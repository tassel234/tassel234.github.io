[{"content":"数组的定义和使用 （1）一维数组的定义、初始化、引用 使用数组，可以方便地定义一个名字（数组名）来表示大批量数据，并能够通过循环批处理大量数据。\n一维数组是由元素类型、数组名和长度组成的构造类型。例如：\nint A[10], B[20]; // 元素是整型 常量表达式表示数组中元素的个数，称为数组长度。常量表达式的值必须为正整数且大于等于1。数组一经定义，数组长度就始终不变。定义中数组的值不能是变量。\n初值列表提供的元素个数不能超过数组长度，但可以小于数组长度。如果初值个数小于数组长度，则只初始化前面的数组元素，剩余元素初始化为0。\n可以用下面的表达式计算出数组A的长度：\nint A[]={1,8,9}; sizeof(A) / sizeof(int) 下标表达式可以是常量、变量、表达式，但必须是正整数，不允许为负。下标由0开始。整个数组不允许进行赋值运算、算术运算等操作，只有元素才可以。\n（2）二维数组的定义、初始化、引用 本质上，C++的多维数组都是一维数组。\nint A[2][3]={ {1,2,3},{4,5,6}};//初值按二维形式 int A[2][3]={ 1,2,3,4,5,6 };//初值按一维形式 初值列表提供的元素个数不能超过数组长度，但可以小于数组长度。如果初值个数小于数组长度，则只初始化前面的数组元素；剩余元素初始化为0。这个规则两种初始化形式都适用。\nint A[3][4]={{1},{1,2},{1,2,3}}; int A[3][4]={1,2,3,4,5}; 多维数组定义时可以不用指定第1维的数组长度，但其余维的长度必须指定，编译器会根据列出的元素个数自动确定第1维的长度。\nint A[][2][3]={1,2,3,4,5,6,7,8,9,10,11,12};//正确 int B[2][][3]={1,2,3,4,5,6,7,8,9,10,11,12};//错误，只能省略第1维 数组与函数 （1）数组作为函数的参数 x=max(c,-10); //使用变量或常数作为函数实参 x=max(A[2],-10); //使用数组元素作为函数实参 a[5]的a就是数组的首地址，可以作为参数传递到数组。如果实参使用数组名调用，本质上是将这个数组的首地址传递到形参中。这就造成了数组即使形式参数又是实际参数，（内存中 两个对象所处位置相同，则它们实为同一个对象）不像变量是生成副本，无法在函数体内修改它的值。\nvoid fun(int A[5],int n) { A[1]=100; //A[1]实质就是实参a[1] n=10; //赋值给形参n，不影响实参x } void caller() { int a[5]={1,2,3,4,5},x=5; fun(a,x); cout\u0026lt;\u0026lt;a[1]\u0026lt;\u0026lt;“,“\u0026lt;\u0026lt;x\u0026lt;\u0026lt;endl; //a[1]=100,x=5 } 数组的定义中可以不写长度，写长或者写短都可以。而且名字可以不同，只有是数组就可以。（对一维数组而言）\n（2）数组参数的传递机制 既然形参数组就是实参数组，所以函数调用时不会为形参数组分配存储空间。\n多维数组作为函数的参数，形参数组第1维可以与实参相同，也可以不相同；可以是任意长度，也可以不写长度；但其他维的长度需要相同。\nvoid f(int A[5][10]); //正确 void f(int A[2][10]); //正确 void f(int A[][10]); //正确 void f(int A[][]); //错误，第2维长度必须给出 void f(int A[5][5]); //错误，第2维长度必须相同 void f(int A[50]); //错误，必须是二维数组 字符串的处理 （1）字符数组 char s[20]; //定义字符数组 char s[4]={\u0026#39;J\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;v\u0026#39;,\u0026#39;a\u0026#39;}; //字符数组初始化 C++语言规定字符串是以'\\0'（ASCII值为0）字符作为结束符的字符数组。C++总是在编译时为字符串常量自动在其后增加一个空字符。以定义字符数组时数组的长度至少为字符串长度加1（空字符也要占位）。\nchar c; char s[10]=“hello.”; c=‘a’; //正确 c=“a”; //错误 //因为使用\u0026#34;\u0026#34;会造成自动带一个空字符，数组的长度至少为2 （1）使用标准输入输出流，将整个字符串一次输入或输出\nchar str[80];//数组应该比较大 cin \u0026gt;\u0026gt; str; //输入字符串 cout \u0026lt;\u0026lt; str; //输出字符串 （2）使用字符串输入输出函数\nchar str[80]; gets(str); //输入字符串 char str[80]=\u0026#34;Programming\u0026#34;; puts(str); //输出字符串 （2）字符串处理函数 C++标准库提供了兼容C语言的字符串处理函数，其头文件为string.h。\n►（1）字符串复制函数strcpy char str1[10],str2[]=\u0026#34;Computer\u0026#34;; strcpy(str1,str2); //复制str2到str1 ►（2）字符串复制函数strncpy char str1[10], str2[]=\u0026#34;Computer\u0026#34;; strncpy(str1,str2,4);//复制str2的前4个字符到str1 ►（3）字符串连接函数strcat char str1[10]=\u0026#34;ABC\u0026#34;, str2[]=\u0026#34;123\u0026#34;; strcat(str1,str2);//在str1后面连接str2,str2未变化 ►（4）字符串连接函数strncat char str1[10]=\u0026#34;ABC\u0026#34;,str2[]=\u0026#34;123456\u0026#34;; strncat(str1,str2,4);//将str2前4个字符连接到str1后面 ►（5）字符串比较函数strcmp if (strcmp(str1,str2)==0)...... //比较字符串相等 if (strcmp(str1,str2)\u0026gt;0)......//比较str1大于str2 ►（6）计算字符串长度函数 n=strlen(\u0026#34;Language\u0026#34;); //n=8 char str[20]=\u0026#34;Visual Basic\u0026#34;; n=strlen(str); //n=12 ►（7）字符串转换成数值函数 f=atof(\u0026#34;123.456\u0026#34;); //f=123.456 i=atoi(\u0026#34;-456\u0026#34;); //i=-456 （3）字符串对象 C++特有，使用string类型，比使用C风格字符串更方便、更安全。这样和python非常类似了。\n#include \u0026lt;string\u0026gt; //不能写为string.h char S2[20]=\u0026#34;Java\u0026#34;; //C风格字符串初始化 string str2=\u0026#34;Java\u0026#34;; //string对象复制初始化 string str3(\u0026#34;C++\u0026#34;); //string对象直接初始化 输入输出和上个章节类似。\nstr1=\u0026#34;Java\u0026#34;; //C风格字符串可以直接赋给string str1.c_str(); //string转换为C风格字符串，返回char指针 str1.copy(S1,n,pos); //把str1中从pos开始的n个字符复制到S1字符数组 （4）字符串对象的操作 string对象允许使用运算符进行操作，实现类似C风格字符串的处理。如复制（strcpy）、连接（strcat）、比较（strcmp）等。下面的这些运算和python非常类似了。\n字符串连接运算\nstr1=\u0026#34;12\u0026#34; , str2=\u0026#34;AB\u0026#34; , str3=\u0026#34;CD\u0026#34;; str1 = str2 + str3; //str1结果为ABCD str1 = str1 + \u0026#34;PHP\u0026#34;; //str1结果为12PHP str1 += str3; //str1结果为12CD 字符串关系运算\nstr1=\u0026#34;ABC\u0026#34; , str1=\u0026#34;XYZ\u0026#34;; str1 \u0026gt; str2; //结果为假 str1 == str2; //结果为假 str1 == \u0026#34;ABC\u0026#34;; //结果为真 其他\nstr1=\u0026#34;ABCDEFGHIJK\u0026#34;; //获取字符串的长度 n = str1.size(); //n为11 n = str1.length(); //n为11 //检查字符串是否为空字符串 b = str1.empty(); //b为假 //得到子字符串 str2 = str1.substr(2,4); //从下标2开始的4个字符，str2为CDEF //查找子字符串 n = str1.find(\u0026#34;DEF\u0026#34;,pos); //从pos开始查找字符串\u0026#34;DEF\u0026#34;在str1中的位置，n为3 //删除字符 str1.erase(3,5); //从下标3开始往后删5个字符，str1变为ABCIJK //增加字符 str1.append(\u0026#34;12345\u0026#34;,1,3); //在str1末尾增加\u0026#34;12345\u0026#34;下标从1开始的3个字符，即\u0026#34;234\u0026#34; //字符串替换和插入操作 str1.replace(p0,n0,S1,n); //删除从p0开始的n0个字符，然后在p0处插入字符串S1前n个字符 str1.replace(p0,n0,str2,pos,n); //删除从p0开始的n0个字符，然后在p0处插入字符串str2中pos开始的前n个字符 str1.insert(p0,S1,n); //在p0位置插入字符串S1前n个字符 str1.insert(p0,str2,pos,n); //在p0位置插入字符串str2中pos开始的前n个字符 字符串对象数组\nstring SY[5]={\u0026#34;123\u0026#34;,\u0026#34;12\u0026#34;,\u0026#34;1234\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;12345\u0026#34;}; //长度 3,2,4,1,5 数组的应用 （1）用数组解决排序问题 冒泡排序 冒泡排序法（bubble sort）的基本思想是通过相邻两个记录之间的比较和交换，使关键码较小的记录逐渐从底部移向顶部。\n#include \u0026lt;iostream\u0026gt; using namespace std; #define N 10 //数组元素个数 int main() { int A[N], i, j, t; //注意数组下标从0开始 for (i=0; i\u0026lt;N; i++) cin\u0026gt;\u0026gt;A[i]; //输入N个数 for(j=0 ; j\u0026lt;N-1 ; j++) //冒泡排序法 for(i=0 ; i\u0026lt;N-1-j; i++) //一趟冒泡排序 if(A[i] \u0026gt; A[i+1]) //A[i]与A[i+1]比较 \u0026lt;升序 \u0026gt;降序 t=A[i], A[i]=A[i+1], A[i+1]=t; //交换 for (i=0; i\u0026lt;N; i++) cout\u0026lt;\u0026lt;A[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; //输出排序结果 return 0; } 选择排序法 选择排序法（selection sort）的基本思想是第i趟选择排序通过n-i次关键码的比较，从n-i+1个记录中选出关键码最小的记录，并和第i个记录进行交换。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;ctime\u0026gt; using namespace std; void SelectionSort(int A[],int n) //选择排序 n为数组元素个数 { int i,j,k,t; for(i=0; i\u0026lt;n-1; i++) { //选择排序法 k=i; for(j=i+1; j\u0026lt;n; j++) //一趟选择排序 if (A[j] \u0026lt; A[k]) k=j; //\u0026lt;升序 \u0026gt;降序 if(i!=k) t=A[i], A[i]=A[k], A[k]=t; } } #define N 10 int main() { int A[N],i; srand((unsigned int)time(0)); //设置随机数种子 for(i=0; i\u0026lt;N; i++) { //随机产生N个数 A[i] = rand()%100; cout\u0026lt;\u0026lt;A[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; SelectionSort(A,N); for(i=0; i\u0026lt;N; i++) cout\u0026lt;\u0026lt;A[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; //输出排序结果 return 0; （2）用数组解决查找问题 顺序查找法 就是这个比较，返回数组下标。\n#include \u0026lt;iostream\u0026gt; using namespace std; int Search(int A[],int n,int find) { //顺序查找 n=序列元素个数 find=欲查找数据 int i; for (i=0; i\u0026lt;n ; i++) if (A[i]==find) return i; return -1; //未找到 } #define N 10 int main() { int A[N]={18,-3,-12,34,101,211,12,90,77,45}, i,find; cin\u0026gt;\u0026gt;find; i=Search(A,N,find); if(i\u0026gt;=0) cout\u0026lt;\u0026lt;\u0026#34;A[\u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34;]=\u0026#34;\u0026lt;\u0026lt;find\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;\u0026#34;not found\u0026#34;\u0026lt;\u0026lt;endl; return 0; } 二分查找法 先排序，后查找\n#include \u0026lt;iostream\u0026gt; using namespace std; int BinarySearch(int A[],int n,int find) { //二分查找 n=序列元素个数 find=欲查找数据 int low,upper,mid; low=0 , upper=n-1; //左右两部分 while(low\u0026lt;=upper) { mid = low + (upper-low)/2; //不用(upper+low)/2，避免upper+low溢出 if( A[mid] \u0026lt; find) low = mid+1; //右半部分 else if (A[mid] \u0026gt; find) upper = mid - 1; //左半部分 else return mid; //找到 } return -1; //未找到 } #define N 10 int main() { int A[N]={8,24,30,47,62,68,83,90,92,95},i,find; cin\u0026gt;\u0026gt;find; i=BinarySearch(A,N,find); if(i \u0026gt;= 0) cout\u0026lt;\u0026lt;\u0026#34;A[\u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34;]=\u0026#34;\u0026lt;\u0026lt;find\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;\u0026#34;not found\u0026#34;\u0026lt;\u0026lt;endl; return 0; } 指针的定义与使用 （1）指针的定义 return语句只能返回一个值，即使有多个return也只还回第一个。加上数组也是只针对多个相同类型的数据，如果使用指针就可以想返回多少就返回多少。指针是两个函数进行数据交换必不可少的工具。\n 指针记录某一变量的地址，指针本身也有地址，存于特定的区域 int *pa=pb的写法正确，* 是间接寻址符或者叫取值符,可以理解为从pa指针取出的值是整形。但如果在声明中赋值也是可以的，因为pa在声明中也确实是指针，可以理解为把 *分配给了int，可以理解定义了一个指向int的指针，所以应该使用地址赋值，而不是数值赋值。 *pa单独出现代表了从pa指向的地址中取出来的值，前面要是加上int,char等声明，* pa就只是代表pa指针了。 int *pa;pa=\u0026amp;a这样声明也可以 \u0026amp; 是取地址运算符  由于指针数据的特殊性，其初始化和赋值运算是有约束条件的，只能使用以下四种值： （1）0值常量表达式\np1=null; //正确，指针允许0值常量表达式 p1=0; //正确，指针允许0值常量表达式 （2）相同指向类型的对象的地址。 （3）相同指向类型的另一个有效指针。例如：\nint x, *px=\u0026amp;x; //正确 int *py=px; //正确，相同指向类型的另一个指针 （4）对象存储空间后面下一个有效地址，如数组下一个元素的地址。\nint a[10], *px=\u0026amp;a[2]; //正确 int *py=\u0026amp;a[++i]; //正确，相同指向类型的另一个指针 （2）指针的有效性和运算 无效的情况 如果指针的值为0，称为0值指针，又称空指针（null pointer），空指针是无效的。\n如果指针未经初始化，或者没有赋值，或者指针运算后指向未知对象，那么该指针是无效的。\n一个指针曾经指向一个已知对象，在对象的内存空间释放后，虽然该指针仍是原来的内存地址，但指针所指已是未知对象，称为“迷途指针”\n如果指针的位置停留在未知的位置，那么修改指针的值有可能造成重要的数据被修改。\n指针的运算 （1）指针加减整数运算\nint x[10], n=3 , *p=\u0026amp;x[5]; p+1 //指向存储空间中x[5]后面的第1个int型存储单元 p+n //指向存储空间中x[5]后面的第n(3)个int型存储单元 p-1 //指向存储空间中x[5]前面的第1个int型存储单元 p-n //指向存储空间中x[5]前面的第n(3)个int型存储单元 （2）指针变量自增自减运算\nint x[10], *p=\u0026amp;x[5]; p++ //p指向x[5]后面的第1个int型内存单元 ++p //p指向x[5]后面的第1个int型内存单元 p-- //p指向x[5]前面的第1个int型内存单元 --p //p指向x[5]前面的第1个int型内存单元 （3）两个指针相减运算\nint x[5], *p1=\u0026amp;x[0], *p2=\u0026amp;x[4]; int n; n=p2-p1;//n的值为4 （4）指针的关系运算 即比较地址数据的大小，位置的前后。\nconst的三种 主要应用领域是让实参于函数中不可修改 单const\nconst int *p//代表不可以改变变量的值，但是可以改变指针指向， //实际编程中，指向const的指针常用作函数的形参，以此确保传递给函数的实参对象在函数中不被修改。 int *const pc=\u0026amp;a//代表地址不可以改了，但数值可以改 双const\nconst int *const cpc=\u0026amp;b\n指针与数组 一维数组与指针 数组名既代表数组本身，又代表整个数组的地址，还是是数组首元素的地址值.\nint a[10], b[10], c[10]; a=b; //错误，a是常量不能出现在左值的位置 c=a+b; //错误，a、b是地址值，不允许加法运算 a++; //错误，a是常量不能使用++运算 int a[]; int *p p=a//数组的名称就代表了地址 pb=\u0026amp;a[0]//a[0]就是变量了，要用取地址运算符 *(a+i) *(p+i) 上述代码都是成立的\n区别  指针并不能被赋予常量的值int *p,p=2//是错的 指针所存储的是变量的地址值，指针可以进行数加减，自增，自减；相减时值得注意，间隔几个元素取决他的类型。也可以进行关系运算 数组的数组名不可以进行这些操作  （1）使用下标法访问数组元素，程序写法比较直观，能直接知道访问的是第几个元素。\n（2）而使用指针引用法，指针变量直接指向元素，不必每次都重新计算地址，能提高运行效率。\n（3）将自增和自减运算用于指针变量十分有效，可以使指针变量自动向前或向后指向数组的下一个或前一个元素。\n指针写起来更简捷一些\n（2）指针与字符串 char *p=\u0026#34;C Language\u0026#34;; //或者 char *p; p=\u0026#34;C Language\u0026#34;; 访问\nchar str[]=\u0026#34;C Language\u0026#34;, *p=str; //p指向字符串的指针 cout\u0026lt;\u0026lt;p\u0026lt;\u0026lt;endl; //输出：C Language cout\u0026lt;\u0026lt;p+2\u0026lt;\u0026lt;endl; //输出：Language cout\u0026lt;\u0026lt;\u0026amp;str[7]\u0026lt;\u0026lt;endl; //输出：age 遍历\nchar str[]=\u0026#34;C Language\u0026#34; , *p=str; //p指向字符串的指针 while (*p!=\u0026#39;\\0\u0026#39;) cout\u0026lt;\u0026lt;*p++; 指针与函数 （1）指针作为函数的参数 指针是函数参数传递的重要工具。比如swap交换函数要使用指针，直接使用变量会生成副本。通过将指针作为函数参数的方法，既可以返回多个运算结果，又避免了使用全局变量。\n（2）数组作为函数的参数 数组同样是直接使用地址，不使用副本，直接修改原数组数据。将一个字符串传递到函数中，传递的是地址，则函数形参既可以用字符数组，又可以用指针变量，两种形式完全等价。在子函数中可以修改字符串的内容，主调函数得到的是变化后的字符串。\n（3）引用 引用类型是结合了数组和指针的优点，不在C语言中，而属于C++的一个特性。\n 引用类型自带const限定，引用一旦被初始化，就不能改变引用关系，不能再作为其他对象的引用。 初始化是必定要绑定赋值，不能为空 写法是int x;\u0026amp;r=x  int x, \u0026amp;r=x; //定义整型变量x,y int *p1=\u0026amp;x; //p1指向x int *p2=\u0026amp;r; //p2指向r，本质上指向x //程序① 传递对象本身 #include \u0026lt;iostream\u0026gt; using namespace std; //对象作为函数形参 void swap(int a,int b) { int t; t=a, a=b, b=t; } int main() { int x=10, y=20; swap(x,y); 12 cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34;,\u0026#34;\u0026lt;\u0026lt;y; 13 return 0; 14 } //程序② 传递对象的指针 #include \u0026lt;iostream\u0026gt; using namespace std; //指针作为函数形参 void swap(int *a,int *b) { int t; t=*a, *a=*b, *b=t; } int main() { int x=10, y=20; swap(\u0026amp;x,\u0026amp;y); cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34;,\u0026#34;\u0026lt;\u0026lt;y; return 0; } //程序③ 传递对象的引用 #include \u0026lt;iostream\u0026gt; using namespace std; //引用作为函数形参 void swap(int \u0026amp;a,int \u0026amp;b) { int t; t=a, a=b, b=t; } int main() { int x=10, y=20; swap(x,y); cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34;,\u0026#34;\u0026lt;\u0026lt;y; return 0; （4）指向函数的指针 函数代码在内存中也要占据一段存储空间（代码区内），这段存储空间的起始地址称为函数入口地址。C++规定函数入口地址为函数的指针，即函数名既代表函数，又是函数的指针（或地址）。\nC++允许定义指向函数的指针变量，定义形式为：\nint (*p)(int a, int b); //定义函数指针变量 int max(int a, int b); //max函数原型 int min(int a, int b); //min函数原型 int (*p)(int a, int b); //定义函数指针变量 p=max; c=p(a,b); //等价于c=max(a,b); 变为动态方式调用。熟练掌握函数指针的应用，有利于程序的模块化设计，提高程序的可扩展性。\n动态分配内存 （1）new与delete运算符 数据类型* 指针名称 = new 数据类型 int* p = new int delete p; 可以拓展到结构体或类\n动态分配是根据程序的需要适时分配，且分配的大小就是程序要求的大小。分配的空间可以根据程序的需要扩大或缩小；\nnew 动态分配\nnew [] 动态分配数组\ndelete 释放空间\ndelete [] 释放数组空间\n（2）动态内存的应用 ►（1）静态内存管理由编译器进行，而动态内存管理按程序员人为的指令进行。\n►（2）动态内存分配和释放必须对应，即有分配就必须有释放，后果是随着程序运行多次，可以使用的内存空间越来越少.\n► （3）动态分配内存的生命期由程序员决定，即从分配时开始，至释放时结束。特别地，动态分配内存的生命期允许跨多个函数。\n►（4）避免释放内存后出现“迷途指针”，应及时设置为空指针。\n#include \u0026lt;iostream\u0026gt; using namespace std; int *f1(int n) //分配n个整型内存，返回首地址 { int *p, i; p = new int[n]; //分配 for (i=0; i\u0026lt;n; i++) p[i]=i; //赋初始值 return p; //动态分配的指针返回是有意义的 } void f2(int *p,int n) //输出动态内存中的n个数据 { while (n--\u0026gt;0) cout\u0026lt;\u0026lt;*p++\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } void f3(int *p) { delete [] p; } //释放内存 int main() { int *pi; pi=f1(5); //分配 f2(pi,5); //输出 f3(pi); //释放 return 0; } int *f1(int n)返回指针的函数\n（3）动态分配数组 #include \u0026lt;iostream\u0026gt; using namespace std; double AVE(double *A,int N) //计算N*N二维数组元素的平均值 { int i,j,sum=0; for(i=0;i\u0026lt;N;i++) for(j=0;j\u0026lt;N;j++) sum=sum+*(A+i*N+j); return sum/(N*N); } int main() { int i,j,n=4; cin\u0026gt;\u0026gt;n; double *A=new double[n*n]; //分配“数组”A[n][n] for (i=0;i\u0026lt;n;i++) for (j=0;j\u0026lt;n;j++) cin\u0026gt;\u0026gt;*(A+i*n+j); //输入数据到A[i][j] cout\u0026lt;\u0026lt;\u0026#34;detA=\u0026#34;\u0026lt;\u0026lt;AVE(A,n)\u0026lt;\u0026lt;endl; delete [] A; //释放“数组” return 0; } （4）动态分配字符串 char *p=new char[1000]; //分配字符串空间 cin\u0026gt;\u0026gt;p; //输入字符串 cout\u0026lt;\u0026lt;p; //输出字符串 delete [] p; //释放字符串空间 结构体 基本知识 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { cout\u0026lt;\u0026lt;\u0026#34;hello\\n\u0026#34;; struct DATA{ int year; int mouth; int day; }; struct staff{ int no; char name[21]; char sex; DATA birthday; double salary; }; staff s1={1001,\u0026#34;archer\u0026#34;,\u0026#39;m\u0026#39;,{1980,1,1},2900.0};//s1是一个结构体对象， cout\u0026lt;\u0026lt;s1.birthday.year;//成员引用使用. //成员只可以逐个输入和输出 }  结构体声明一般放在开头，也可以放在main的外面。大概等价于数据类型的定义和声明，也不会在声明中分配存储空间，实例化才会分配存储空间，空间是连续按顺序的。 可以放在函数内部，但此时这个声明是局部的，而不是全局的。 结构体对象可以赋值，但不可以算数和比较运算。  结构体和指针的关系 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { cout\u0026lt;\u0026lt;\u0026#34;hello\\n\u0026#34;; struct DATA{ int year; int mouth; int day; }; DATA d={1980,1,1};//一个奇怪的devc++规则，即用即声明，但反正也不麻烦 //更新，可以在结构体后声明成员，但前提是要把结构体的创建写到main函数外部 struct staff{ int no; char name[21]; char sex; DATA *pbirthday; double salary; }; staff *p;//指针可以提前声明然后赋值，这里声明s1会报错 staff s1={1001,\u0026#34;archer\u0026#34;,\u0026#39;m\u0026#39;,\u0026amp;d,2900.0}; p=\u0026amp;s1;//赋地址值，没有*，下方编译成功 cout\u0026lt;\u0026lt;p-\u0026gt;sex\u0026lt;\u0026lt;endl;//这是字母l不是一数字1，/用于除法和注释 p-\u0026gt;pbirthday-\u0026gt;year=2008; p-\u0026gt;sex=\u0026#39;w\u0026#39;; cout\u0026lt;\u0026lt;s1.sex\u0026lt;\u0026lt;endl; } 结构体和数组的关系 如同声明int,char数组，可以用结构体进行声明。用这个方法可以表示几何的点。\n#include\u0026lt;iostream\u0026gt; using namespace std; struct staff{ int no; char name[21]; double salary; }a[3],t; int main() { cout\u0026lt;\u0026lt;\u0026#34;hello\\n\u0026#34;; int i,j; for (i=0;i\u0026lt;3;i++) cin\u0026gt;\u0026gt;a[i].name \u0026gt;\u0026gt;a[i].no \u0026gt;\u0026gt;a[i].salary; for (i=0;i\u0026lt;3;i++) cout\u0026lt;\u0026lt;a[i].name \u0026lt;\u0026lt;a[i].no \u0026lt;\u0026lt;a[i].salary\u0026lt;\u0026lt;endl; }; 结构体和函数的关系 就像传int类型等，直接传递进去，在函数内部进行各种操作。 对结构体数组进行传递，是对首地址进行传入。\n共用体  对于实体对象，分配的存储空间是成员内存的最大值。 定义和结构体的定义和引用相似。使用union定义，   修改一个成员的值会让其他值都改变 成员的首地址相同，所有成员的值相同，不同成员所用到的内存长度有差异  枚举类型(enum)  定义都是相似的 必须是指定值 枚举常量是右值不是左值  没有给定值时从0往后排\nenum COLORS {RED=10,GREEN=8,BLUE,BLACK,WHITE}; //RED为10、GREEN为8、BLUE为9、BLACK为10、WHITE为11。 RED=10; //错误，RED不是左值，不能被赋值 GREEN++; //错误，GREEN不是左值，不能自增自减 enum DIRECTION {LEFT,UP,RIGHT,DOWN,BEFORE,BACK} dir=LEFT; typedef 就是把一个结构的名字进行更改\n自定义数据类型的应用——链表 基础知识 链表主要用于两个目的：一是建立不定长度的数组。二是链表可以 在不重新安排整个存储结构的情况下，方便且迅速地插入和删除数 据元素。\nstruct NODE { //结点数据类型 ElemType data; //数据域 NODE *link; //指针域 }; 首先设计一种称为结点（node）的数据类型： 这个结构体类型中，data成员表示数据域，代表结点的数据信息。\nElemType可以是简单的内置数据类型，也可以是复杂的数据类型， 如\ntypedef struct tagElemType { //复杂的数据元素类型 ...... //任意数目、任意组合、任意类型的数据成员 } ElemType; 数据域是链表中的信息对象（元素），实际应用中结合具体要求设 计其数据类型。为方便介绍，将ElemType简单设定为int型，即\ntypedef int ElemType; //简单的数据元素类型 link成员表示指针域，存放另一个结点的地址，是链表中的组织者。 假定有一个NODE类型的对象指针L，将一个新结点的地址赋给L的 link成员，则L可以通过它的link成员“链接”到新结点上，重复这 个过程可以得到链表结构。\n链表的类型 struct LNode { //单链表结点类型 ElemType data; //数据域\nLNode *next; //指针域：指向直接后继结点 }; typedef LNode* LinkList; //LNode为单链表结构体类型， LinkList为单链表指针类型\n此外还有双链表和循环链表\n创建单链表 创建链表常用两种方法：头插法和尾插法。\n头插法 #include \u0026lt;iostream\u0026gt; using namespace std; typedef int ElemType; //简单的数据元素类型 struct LNode { //单链表结点类型 ElemType data; //数据域 LNode *next; //指针域：指向直接后继结点 }; typedef LNode* LinkList; //LNode为单链表结构体类型，LinkList为单链表指针类型 void input(ElemType *ep) //实现数据域元素输入的定制函数 { //在函数中可以写更加复杂、任意形式、任意数目的输入 cin\u0026gt;\u0026gt;*ep; } void CreateLinkF(LinkList *L,int n,void(*input)(ElemType*)) { //头插法创建单链表，调用input输入函数输入数据 LinkList s; *L=new LNode;//创建头结点 (*L)-\u0026gt;next=NULL; //初始时为空表 for (; n\u0026gt;0; n--) { //创建n个结点链表 s=new LNode; //创建新结点 input(\u0026amp;s-\u0026gt;data); //调用input输入数据域 s-\u0026gt;next=(*L)-\u0026gt;next; //将s增加到开始结点之前 (*L)-\u0026gt;next=s; //头结点之后 } } int main() { LinkList L; int n; cin\u0026gt;\u0026gt;n; CreateLinkF(\u0026amp;L,n,input); } 尾插法 #include \u0026lt;iostream\u0026gt; using namespace std; typedef int ElemType; //简单的数据元素类型 struct LNode { //单链表结点类型 ElemType data; //数据域 LNode *next; //指针域：指向直接后继结点 }; typedef LNode* LinkList; //LNode为单链表结构体类型，LinkList为单链表指针类型 void input(ElemType *ep) //实现数据域元素输入的定制函数 { //在函数中可以写更加复杂、任意形式、任意数目的输入 cin\u0026gt;\u0026gt;*ep; } void CreateLinkR(LinkList *L,int n,void(*input)(ElemType*)) { //尾插法创建单链表，调用input输入函数输入数据 LinkList p,s; p=*L=new LNode; //创建头结点 for (; n\u0026gt;0; n--) { //创建n个结点链表 s=new LNode; //创建新结点 input(\u0026amp;s-\u0026gt;data); //调用input输入数据域 p-\u0026gt;next=s, p=s; //将s插入到当前链表末尾 } p-\u0026gt;next=NULL; //尾结点 } int main() { LinkList L; int n; cin\u0026gt;\u0026gt;n; CreateLinkR(\u0026amp;L,n,input); } 链表的撤销 void DestroyList(LinkList *L) //销毁单链表L { LinkList q,p=*L; //p指向头结点 while(p!=NULL) { //若不是链尾继续 q=p-\u0026gt;next; //指向直接后继结点 delete p; //释放结点存储空间 p=q; //直接后继结点 } *L=NULL; //置为空表 链表的运算 链表的遍历 即p=p-\u0026gt;next\n查找节点 int compare(ElemType *ep1,ElemType *ep2) //实现两个数据元素关系比较的定制函数 {//在函数中对数据元素进行定制的关系比较，如相等，大于或小于 if (*ep1==*ep2) return 1; //满足相等关系返回真（1） return 0; //不满足关系返回假（0） int LocateElem(LinkList L,ElemType e, int(*compare)(ElemType*,ElemType*)) {//返回L中第1个与e满足关系compare()的元素的位序 int i=0; LinkList p=L-\u0026gt;next; //p指向开始结点 while(p!=NULL) { //若不是链尾继续 i++; //记录结点的位序 if(compare(\u0026amp;(p-\u0026gt;data),\u0026amp;e)) return i; p=p-\u0026gt;next; //指向直接后继结点 } return 0; //关系不存在返回0 插入节点 int ListInsert(LinkList *L,int i,ElemType e) { //在第i个位置之前插入元素e LinkList s,p=*L; //p指向头结点 while(p!=NULL \u0026amp;\u0026amp; i\u0026gt;1) { //寻找第i-1个结点 p=p-\u0026gt;next; //p指向直接后继结点 i--; } if(p==NULL||i\u0026lt;1) return 0; //i值不合法返回假（0） s=new LNode; //创建新结点 s-\u0026gt;data=e; //插入L中 s-\u0026gt;next=p-\u0026gt;next, p-\u0026gt;next=s; //结点插入算法 return 1; //操作成功返回真（1） 删除节点 int ListDelete(LinkList *L,int i,ElemType *ep) { //删除第i个结点,并由*ep返回其值 LinkList p=NULL,q=*L; //q指向头结点 while(q!=NULL \u0026amp;\u0026amp; i\u0026gt;=1) { //直到第i个结点 p=q; //p是q的前驱 q=q-\u0026gt;next; //q指向直接后继结点 i--; } if(p==NULL||q==NULL) return 0;//i值不合法返回假（0） p-\u0026gt;next=q-\u0026gt;next; //结点删除算法 if(ep!=NULL) *ep=q-\u0026gt;data; //删除结点由*ep返回其值 delete q; //释放结点 return 1; //操作成功返回真（1） ","permalink":"https://tassel234.github.io/posts/note/%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/","summary":"数组的定义和使用 （1）一维数组的定义、初始化、引用 使用数组，可以方便地定义一个名字（数组名）来表示大批量数据，并能够通过循环批处理大量数据。 一维数组是由元素类型、数组名和长度组成的构造类型。例如： int A[10], B[20]; // 元素是整型 常量表达式表示数组中元素的个数，称为数组长度。常量表达式的值必须为","title":"C++入门学习笔记-2(数组，指针，结构体)"},{"content":"图论入门_2 图着色 图着色可以应用于调度问题，平面图的点着色也和著名的四色问题也有很深的联系。\n点着色 即一条边上两点的颜色均不相同。顶点着色可以应用于调度问题，即日程安排或工作安排问题。对不同的人执行两种或以上的操作构成图，对着色相同的各个事件，在同一段时间平行的去做，节约时间成本。\n任意图都是最大度加一可顶点着色的。\n布鲁克斯定理 对于连通图G，如果G不是完全图，又不是奇数长的圈，则G是可顶点着色的  可以知道，除了上述给出的两种情况，其他图都是可以（最大度加一）减 可着色的。\n非正则的连通图都是最大度-可以顶点着色的。 G是2-可顶点着色，G是二部图，G中不含奇数长的圈这三个命题等价。  3-顶点可着色问题是np完全问题。\n4-顶点也是np完全问题，等价于四色问题。\n任意平面图都存在度不超过5的顶点。 五色定理：任意平面图都是5-可着色的。  边着色 如果图中用5中颜色进行了边着色，因为任意平面图都存在度不超过5的顶点，所以不能使用颜色更少的方案。\n维京定理：任意图可边着色数都小于或等于最大度加一。  而由定义可知，图可边着色数要大于等于最大度数。\n克里希定理：对任意二部图，边着色就是最大度数。  最大流问题 什么是最大流问题 最大流问题是一种组合优化问题，讨论如何充分利用装置的能力，使得运输的流量最大以取得最好的效果的问题。有容量限制原则和流量守恒原则。\ns表示网络的源点. t表示网络的汇点.\n福特- 富尔克森算法 残留网络，给出某路径和流量后反向生成新的路径和对应的流量，生成的路径可以视为新的路（增广路），增广路相当于可以把流量流回去，然后进行查找，重复几次，同向的流可以合并，没有流量的路可以擦掉。当找不到通往终点的路径了，就可以认为程序完成了。\n最大流最小割定理 穿过某些路径进行分割，一个部分含s,一个部分含t,将节点分为两个部分称为割。\n割选中的路径流量累计，也称作容量（特别注意，流量的计算是针对对含起点的部分指向外部的割边，反向的路不计算）最小的割叫做图的最小割。\n最小割定理：最大流等于最小割的容量。\n匹配问题 什么是匹配 就是把点和点通过线做一一对应，一个点只能被一个点匹配和一个点只能匹配一个点。 主要应用于二部图，在二部图里像一一映射。\n二向图中的匹配 极大匹配的定义是不能再添加其他边了。\n最大匹配的就是指边数最多的情况。\n最大匹配一定是极大匹配，但极大匹配不一定是最大匹配。\n如四点三段直线图。\n霍尔定理刻画了二部图完美匹配的存在性。\n匈牙利算法 和福特- 富尔克森算法很类似\n先随意确定几个路径，然后利用增广路进行反悔，如搜索5a1d这条路，然后修改。\n用求解最大流问题的算法求解匹配问题 甚至可以直接转化为最大流问题，使用对应的算法求解。\n","permalink":"https://tassel234.github.io/posts/note/%E5%9B%BE%E8%AE%BA%E5%85%A5%E9%97%A8_2/","summary":"图论入门_2 图着色 图着色可以应用于调度问题，平面图的点着色也和著名的四色问题也有很深的联系。 点着色 即一条边上两点的颜色均不相同。顶点着色可以应用于调度问题，即日程安排或工作安排问题。对不同的人执行两种或以上的操作构成图，对着色相同的各个事件，在同一段时间平行的去做，节约时间成本。","title":"图论入门_2"},{"content":"资源 (主)算法图解动画软件\n我的第一本算法书\n图解算法使用c++\n传输数据的四个问题及其解决方法 B从A那里收到了消息,但作为消息发送者的A可能对卫抱有恶意,并在事后声称“这不是我发送的消息“。这种情况会导致互联网上的商业交易或合同签罪无法成立。这种行为便是事后否认。\n哈希函数 哈希值简介和特征 哈 希 函 数 可 以 把 给 定 的 数 据 转 换 成 固 定 长 度 的 无 规 律 数 值 。 转 换 后 的 无 规 律 数 值 可 以 作 为 数 据 摘 要 应 用 于 各 种 各 样 的 场 景 。哈希值多用16进制表示。\n 第 一 个 特 征 是 输 出 的 哈 希值 数 据 长 度 不 变 。 如果输入的数据相同，那么输出的哈希值也必然相同。 输入的数据相似，哪怕只有一比特的差别，也会导致输出的哈希值大不相同。 如果两个数据完全不同，输出的哈希值也可能是相同的，叫做哈希冲突。 不可能从哈希值反向推出原本的数据。 求哈希值的计算相对容易  哈 希 函 数 的 算 法 中 具 有 代 表 性 的 是 MD5、SHA-1 和 SHA-2 等 。 其 中 SHA-2是 现 在 应 用 较 为 广 泛 的 一 个 , 而 MD5 和 SHA-1 存 在 安 全 隐 患 , 不 推 荐 使 用 。\n哈希算法 哈希算法是使用哈希函数计算出一个键值对应的地址，然后建立哈希表。查找的速度和数据大小无关，在没有碰撞好溢出的情况下，一次即可查找成功。\n除留余数法 h（key）= key mod B //B最好选一个质数。 算出来的数当索引，索引对应地址。\n平方取中法 把数组平方后区中间的两个数字，也要分配100个地址。\n折叠法 把数据拆成几个部分，然后相加，即得到索引值。\n不过哈希值的设计原则之一是减小碰撞的产生（虽然前面几个例子碰的可厉害了），可以对拆分后的数据进行奇数或者偶数的反转，改进后的做法称为边界折叠法。\n数字分析法 适用于数据不会更改，且为数字类型的静态表。\n然后观察分析，排除重复率高的存在。\n碰撞和溢出处理 线型探测法 如果发生了碰撞，就以线型的方式往后查找空的位置。\n线性探测法通常视为环状结构，当后面满了，数据也可以加在前面。\n平方探测法 相当类似的键值聚集在一起后，线性探测法就不太适用了。\n可以使用平方探测法，把数先平方，然后加或者减某数字i，然后用质数b取模。\nb必须是4j+3的质数，i大于等于1，小于等于(b-1)/2\n再哈希法 第一种哈希函数溢出，就用第二种，再溢出，就是第三种，第四种等。\n链表法 让哈希表所在空间建立对应数目的链表，如果溢出直接加到后面。\n应 用 示 例 哈希函数也常用于数据的压缩。\n将 用 户 输 入 的 密 码 保 存 到 服 务 器 时 也 需 要 用 到 哈 希 函 数 。\n如 果 把 密 码 直 接 保 存 到 服 务 器 , 可 能 会 被 第 三 者 窃 听 , 因 此 需 要 算 出 密 码 的哈 希 值 , 并 只 存 储 哈 希 值 。 当 用 户 输 入 密 码 时 , 先 算 出 该 输 入 密 码 的 哈 希 值 , 再把 它 和 服 务 器 中 的 哈 希 值 进 行 比 对 。 这 样 一 来 , 就 算 保 存 的 晗 希 值 暴 露 了 , 鉴 于上 文 中 提 到 的 哈 希 函 数 的 第 五 个 特 征 ( 输 入 输 出 不 可 逆 ) , 第 三 者 也 无 法 得 知 原本 的 密 码 。\n共享密钥加密 就是加密方式和解密方式两者都知道，可以理解为实际上给的是一把钥匙和完全一样的副本，传输的是加密的数据，就不怕被窃听了。\n实 现 共 享 密 钥 加 密 的 算 法 有 凯 撤 密 码 、AES、DES、 动 态 口 令 等 , 其中 AES 的 应 用 最 为 广 泛 。\n但是因为加密的密钥也应该会通过互联网发送，密匙也有可能被窃听者盗取，于是信息又不安全了。\n既 然 密 钥 有 被 第 三 者 窃 听 的 风 险 , 那 也 可 以 先 加 密 密 钢 再 发 送 。用 这 种 方 式 , 又 会 产 生 如 何 把 加 密 密 钥 的 密 钢 发 送 给 对 方 的 问 题 , 还 是 回 到 了 一开 始 的 问 题 。因 此 需 要 找 到 可 以 把 密 钢 安 全 送 出 的 方 法 , 这 就 是 “ 密 钥 分 配 问 题 “。\n要 想 解 决 这 个 问 题 , 可 以 使 用 “ 宿 钥 交 换 协 议 “ 和 “ 公 开 密 钢 加 密 “ 两 种 方 法 。\n公开密匙加密 首先先由B生成共开密匙和私有密匙（开锁和上锁的钥匙不同），然后公开密匙发给A，或者发给很多人，或者直接公布在互联网，其他人用公开密匙进行加密，然后发给B，只有B可以用私有密匙对数据进行解密。\n提 示 实 现 公 开 密 钥 加 密 的 算 法 有 RAS 算 法 、 椭 圆 曲 线 加 密 算 法 等 , 其 中 使用 最 为 广 泛 的 是 RSA 算 法 。RSA 算 法 由 其 开 发 者 Rivest、Shamir、Adleman 的首 字 母 命 名 而 来 , 三 人 在 2002 年 获 得 了 图灵 奖 。\n这样做的安全性很高，因为只有B知道怎么解密。而且可以让其他很多人都可以发送数据给B，而不用一一传递密匙。 缺点是一般这种加密算法的实现速度很慢，比共享密钥法慢的多。 但即使这样监听者用一些方法也可以盗取，比如上图。因为公开密匙并不会显示是谁创建的，窃听者把 密 文 发 送 给 B, 这 个 密 文 由 B 发 出 的 公 开 密 钢 B 来 解 密 。 从 收 到 密文 到 解 密 密 文 都 没 发 生 任 何 问 题 , 因 此 B 也 意 识 不 到 数 据 己 经 被 穸 听 。 这 种通 过 中 途 替 换 公 开 密匙来 窃 听 数 据 的 攻 击 方 法 叫 作 \u0026quot; 中 间 人 攻 击 \u0026ldquo;。\n公 开 密 钥 的 可 靠 性 会 出 现 问 题 , 就 是 因 为 A 无 法 判 断 收 到 的 公 开 密 钢 是 否 来自 B。 要 想 解 决 这 个 问 题 , 就 要 用 到 之 后 会 讲 到 的 “ 数 字 证 书 “。\n公 开 密 钥 加 密 还 有 一 个 问 题 , 那 就 是 加 密 和 解 密 都 比 较 耗 时 , 所 以 这 种 方 法不 适 用 于 持 续 发 送 零 碎 数 据 的 情 况 。 要 想 解 决 这 个 问 题 , 就 要 用 到 “ 混 合 加 密 “。\n混合加密 对数据量较小的共享密匙进行公开加密，保证安全性。\n用加密和解密速度快的共享密匙进行主要数据的加密，保证速度。\n迪菲-赫尔曼密钥交换 这 种 合 成 方 法 有 三 个 特 征 。\n第 一 ,即使 持 有 P 和 合 成 的 密 钥 P-S, 也 无 法 把 密 钥 S 单 独 取 出 来 。\n第 二 , 不 管 是 怎 样 合 成 而 来 的 密匙 , 都 可 以 把 它 作 为 新 的 元 素 , 继 续 与别 的 密 钥 进 行 合 成 。 使 用 密 钥 卫 和 密 锏 P-S, 还 能合 成 出 新 的 密 钥 P-P-S。\n第三：合成的结果和顺序无关。\n双方分别创建自己的私有密匙并且妥善保管，然后使用一个公开密匙，反复加密。 得到相同的加密方式，相同的密匙。\n具体实现可以使用非常大的素数。\n消息认证码 我是真的感觉下面这三个兄弟，是真的兵来将挡水来土掩，反复套娃。\n首先是消息认证码，为了解决密文被篡改的情况。 必要条件是制作一个用于消息认证码的密钥，然后用安全的方法发送为B。消息认证码简称mac, 但还是有缺陷。 加密和解密是双向的，消息的来源A可能是恶意的，A可能在发送信息后矢口否认。\n数字签名 数字加密使用的公开密匙，但和一般的公开密匙不同，私有的是用来加密的，共有的是用来解密的，这在加密通信层面毫无意义，但却可以肯定是A发送的。\n补 充 说 明\n公 开 密 钥 加 密 的 加 密 和 解 密 都 比 较 耗 时 。 为 了 节 约 运 算 时 间 , 实 际 上 不 会 对消 息 直 接 进 行 加 密 , 而 是 先 求 得 消 息 的 哈 希 值 , 再 对 哈 希 值 进 行 加 密 , 然 后 将 其作 为 签 名 来 使 用 ( 请 参 考 下 图 ）\n但这样就完美了吗，不，还没有。\n因为公开密匙加密好数字签名 无法保证是信息的发送者。公开密匙可能会被第三方恶意替换，中转破译发送，接受者甚至无法注意到。\n数字证书 A应该向一个非常权威的认证中心去申请认证证书。\n将 公 开 密 钥 A 和 包 含 邮 箱 信 息 的 个 人 资 料 发 送 给 认 证 中 心 。\n认 证 中 心 对 收 到 的 资 料 进 行 确 认 , 判 断 其 是 否 为 A 本 人 的 资 料 。 确 认 完毕 后 , 认 证 中 心 使 用 自 己 的 私 有 密匙， 根 据 A 的 资 料 生 成 数 字 签 名 。\n认 证 中 心 将 生 成 的 数 字 签 名 和 资 料 放 进 同 一 个 文 件 中 。然后交给A，B确认邮箱地址，使用认证中心的密匙确认是否为认证中心给出的数字签名。\n但这是完美的了吗，其实还没有，因为窃听者也可以假冒认证公司发布证书。\n认 证 中 心 是 管 理 数 字 证 书 的 组 织 机 构 。 原 则 上 谁 都 可 以 成 为 认 证 中 心 ,所 以 认 证 中 心 的 数 量 也 比 较 多 , 但 建 议 在 经 过 政 府 审 查 的 大 型 企 业 机 构 进 行 申请 , 这 些 机 构 更 令 人 放 心 。\n所以套娃到最后信任的是权威。\n拓展资源 图解密码技术\n信息安全数学基础网课\n应用密码学 协议、算法与C源程序_protocols, algorithms, and source code in C\n密码学C_C++语言实现 原书第2版\n信息论、编码与密码学\n","permalink":"https://tassel234.github.io/posts/note/%E7%AE%97%E6%B3%95%E9%A2%84%E8%A7%88%E5%AE%89%E5%85%A8%E7%AF%87/","summary":"资源 (主)算法图解动画软件 我的第一本算法书 图解算法使用c++ 传输数据的四个问题及其解决方法 B从A那里收到了消息,但作为消息发送者的A可能对卫抱有恶意,并在事后声称“这不是我发送的消息“。这种情况会导致互联网上的商业交易或合同签罪无法成立。这种行为便是事后否认。 哈希函数 哈希值简介和","title":"算法预览（安全篇）"},{"content":"使用资源 图解数据结构，使用C++ 吴灿明 （源代码来自这里）\n递归法详解 斐波那契数列 /* [示范]：斐波那契数列的递归程序 */ #include\u0026lt;iostream\u0026gt; using namespace std; int fib(int);\t//fib()函数的原型声明 int main() { int i,n; cout\u0026lt;\u0026lt;\u0026#34;请输入要计算到第几项斐波那契数列：\u0026#34;;//如果输入的数字太大会导致算到负数 ，后面会越来越慢 cin\u0026gt;\u0026gt;n; for(i=0;i\u0026lt;=n;i++) //计算前n项斐波那契数列 cout\u0026lt;\u0026lt;\u0026#34;fib(\u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34;)=\u0026#34;\u0026lt;\u0026lt;fib(i)\u0026lt;\u0026lt;endl; return 0; } int fib(int n) // 定义函数fib() { if (n==0) return 0; // 如果n=0，则返回0 else if(n==1 || n==2)\t//如果n=1或n=2，则返回1 return 1; else\t// 否则返回 fib(n-1)+fib(n-2) return (fib(n-1)+fib(n-2)); } 汉诺塔问题 /* [示范]:利用汉诺塔函数求出不同圆盘数时圆盘的移动步骤 */ #include \u0026lt;iostream\u0026gt; using namespace std; void hanoi(int, int, int, int); // 函数原型 int main(void) { int j; cout\u0026lt;\u0026lt;\u0026#34;请输入圆盘数量：\u0026#34;; cin\u0026gt;\u0026gt;j; hanoi(j,1, 2, 3); return 0; } void hanoi(int n, int p1, int p2, int p3) { if (n==1) cout\u0026lt;\u0026lt;\u0026#34;圆盘从 \u0026#34;\u0026lt;\u0026lt;p1\u0026lt;\u0026lt;\u0026#34; 号木桩移到 \u0026#34;\u0026lt;\u0026lt;p3\u0026lt;\u0026lt;\u0026#34; 号木桩\u0026#34;\u0026lt;\u0026lt;endl; else { hanoi(n-1, p1, p3, p2); cout\u0026lt;\u0026lt;\u0026#34;圆盘从 \u0026#34;\u0026lt;\u0026lt;p1\u0026lt;\u0026lt;\u0026#34; 号木桩移到 \u0026#34;\u0026lt;\u0026lt;p3\u0026lt;\u0026lt;\u0026#34; 号木桩\u0026#34;\u0026lt;\u0026lt;endl; hanoi(n-1, p2, p1, p3); } } 由一些数学公式可得汉诺塔的执行步骤最小为$2^{n} -1$,n代表圆盘的个数\n动态规划法（DPA） 动态规划法（Dynamic Programming Aigorithm）是一种优化算法策略，主要应用于求解具有重叠子问题和最优子结构性质的问题。动态规划法的核心思想是将问题分解为更小的子问题(和分治法类似)，并将子问题的解存储在一个表中（分治法没有的），从而避免了对相同子问题的重复计算。\n动态规划法的基本步骤如下：\n 定义子问题：将原问题分解为若干个子问题。 定义状态：用数学表示子问题的解。 定义状态转移方程：描述子问题之间的关系，如何通过子问题的解计算原问题的解。 初始化边界条件：确定状态转移方程的初始值。 自底向上或自顶向下计算：根据状态转移方程逐步计算子问题的解，最终得到原问题的解。  动态规划法可以应用于各种问题，如最短路径问题、背包问题、字符串匹配问题等。动态规划法的一个重要应用场景是求解最优化问题，例如最大（最小）问题。通过动态规划，可以在多项式时间内求解这些问题，而其他方法（如穷举法）可能需要指数级时间。\n例如使用递归法进行斐波那契数列的Fib(9)计算时，需要反复计算Fib(4),Fib(5)等值，浪费了时间，使用动态规划算法将计算过的结果储存起来，在后续的计算中只需要判断数值的存在与否，若存在就直接调用。\nDijkstra 算法 Dijkstra算法,中文名音译作迪杰斯特拉算法或戴克斯特拉算法。\n回溯法—老鼠走迷宫 回溯法（Backtracking）是一种用于搜索解空间的算法，通常在组合问题、优化问题和约束满足问题等领域中使用。回溯法通过对解空间的节点进行深度优先搜索，尝试找到问题的解。当搜索到某个节点时，如果该节点不能继续搜索下去，就回溯到该节点的父节点并尝试其他分支。回溯法的基本思想是：先广搜索，后深入搜索。\n以下是回溯法的一般步骤：\n 定义问题的解空间：首先需要明确问题的解空间，即所有可能的解的集合。 确定解空间的组织结构：将解空间组织成树形结构，每个节点表示一个部分解。 设计回溯算法的递归函数：递归函数需要完成以下功能： a. 判断当前节点是否包含问题的解，如果是，则保存解并返回。 b. 如果当前节点不能包含问题的解，则回溯到父节点并尝试其他分支。  回溯法是枚举法的一种。\n老鼠走迷宫就是一种回溯法的应用。老鼠走迷宫问题的描述是:假设把一只老鼠放在一个没有盖子的大迷宫盒的入口处，盒中有许多墙，使得大部分路径都被挡住而无法前进。老鼠可以采用尝试错误的方法找到出口。不过，这只老鼠必须在走错路时就退回来并把走过的路记下来，避免下次走重复的路，就这样直到找到出口为止。简单来说，老鼠行进时必须遵守以下3 个原则:\n(1)一次只能走一格。\n(2) 遇到墙无法往前走时，则退回一步找找看是否有其他的路可以走。\n(3)走过的路不会再走第二次。\n人们对这个问题感兴趣的原因是它可以提供一种典型堆栈应用的思考方法。\n/*题目：设计一个 C++程序，使用链表堆栈来找出老鼠走迷宫的路线，1 表示该处有墙无法通过， 0表示[i][i]处无墙可通行，并且将走过的位置对应的数组元素内容标记为 2。*/ #include \u0026lt;iostream\u0026gt; #define EAST MAZE[x][y+1] //定义东方的相对位置 #define WEST MAZE[x][y-1] //定义西方的相对位置 #define SOUTH MAZE[x+1][y]\t//定义南方的相对位置 #define NORTH MAZE[x-1][y]\t//定义北方的相对位置 using namespace std; const int ExitX = 8; //定义出口的X坐标在第8列 const int ExitY = 10; //定义出口的Y坐标在第10行 struct list { int x,y; struct list* next; }; typedef struct list node; typedef node* link; int MAZE[10][12] = {1,1,1,1,1,1,1,1,1,1,1,1, //声明迷宫数组 1,0,0,0,1,1,1,1,1,1,1,1, 1,1,1,0,1,1,0,0,0,0,1,1, 1,1,1,0,1,1,0,1,1,0,1,1, 1,1,1,0,0,0,0,1,1,0,1,1,//1是墙，0是可走的路 1,1,1,0,1,1,0,1,1,0,1,1, 1,1,1,0,1,1,0,1,1,0,1,1, 1,1,1,1,1,1,0,1,1,0,1,1, 1,1,0,0,0,0,0,0,1,0,0,1,//最右下角的0代表出口 1,1,1,1,1,1,1,1,1,1,1,1}; link push(link stack,int x,int y); link pop(link stack,int* x,int* y); int chkExit(int ,int ,int,int); int main(void) { int i,j; link path = NULL; int x=1;\t//入口的X坐标 int y=1; //入口的Y坐标 cout\u0026lt;\u0026lt;\u0026#34;[迷宫的路径(0的部分)]\\n\u0026#34;\u0026lt;\u0026lt;endl; //打印出迷宫的路径图 for(i=0;i\u0026lt;10;i++) { for(j=0;j\u0026lt;12;j++) cout\u0026lt;\u0026lt;MAZE[i][j]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;endl; } while(x\u0026lt;=ExitX\u0026amp;\u0026amp;y\u0026lt;=ExitY) { MAZE[x][y]=2; if(NORTH==0) { x -= 1; path=push(path,x,y); } else if(SOUTH==0) { x+=1; path=push(path,x,y); } else if(WEST==0) { y-=1; path=push(path,x,y); } else if(EAST==0) { y+=1; path=push(path,x,y); } else if(chkExit(x,y,ExitX,ExitY)==1) // 检查是否走到出口了 break; else { MAZE[x][y]=2; path=pop(path,\u0026amp;x,\u0026amp;y); } } cout\u0026lt;\u0026lt;\u0026#34;[老鼠走过的路径(2的部分)]\u0026#34;\u0026lt;\u0026lt;endl; // 打印出老鼠走完迷宫后的路径图 for(i=0;i\u0026lt;10;i++) { for(j=0;j\u0026lt;12;j++) cout\u0026lt;\u0026lt;MAZE[i][j]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;endl; } return 0; } link push(link stack,int x,int y) { link newnode; newnode = new node; if(!newnode) { cout\u0026lt;\u0026lt;\u0026#34;Error！内存分配失败！\u0026#34;\u0026lt;\u0026lt;endl; return NULL; } newnode-\u0026gt;x=x; newnode-\u0026gt;y=y; newnode-\u0026gt;next=stack; stack=newnode; return stack; } link pop(link stack,int* x,int* y) { link top; if(stack!=NULL) { top=stack; stack=stack-\u0026gt;next; *x=top-\u0026gt;x; *y=top-\u0026gt;y; delete top; return stack; } else *x=-1; return stack; } int chkExit(int x,int y,int ex,int ey) { if(x==ex\u0026amp;\u0026amp;y==ey) { if(NORTH==1||SOUTH==1||WEST==1||EAST==2) return 1; if(NORTH==1||SOUTH==1||WEST==2||EAST==1) return 1; if(NORTH==1||SOUTH==2||WEST==1||EAST==1) return 1; if(NORTH==2||SOUTH==1||WEST==1||EAST==1) return 1; } return 0; } 八皇后问题 八皇后问题也是一种常见的堆栈应用实例。在国际象棋中的皇后可以对棋盘中的其他棋子直吃、横吃和对角斜吃(左斜吃或右斜吃都可)。现在要放入多个皇后到棋盘上，后放入的新皇后，放入前必须考虑所放位置的直线方向、横线方向或对角线方向是否已被放置了旧皇后，否则就会被先放入的旧皇后吃掉。这个问题难倒了高斯，但如果使用计算机思维和计算机的算力可以比较轻松的求得结果。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;cmath\u0026gt; #define EIGHT 8 //定义堆栈的最大容量 #define TRUE 1 #define FALSE 0 using namespace std; int queen[EIGHT]; //存放8个皇后的行位置 int number=0; //计算总共有几组解 //决定皇后存放的位置 //输出所需要的结果 int attack(int ,int); void print_table() { int x=0,y=0; number+=1; cout\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;八皇后问题的第\u0026#34;\u0026lt;\u0026lt;setw(2)\u0026lt;\u0026lt;number\u0026lt;\u0026lt;\u0026#34;组解\u0026#34;\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;\u0026#34;\\t\u0026#34;; for(x=0;x\u0026lt;EIGHT;x++) { for(y=0;y\u0026lt;EIGHT;y++) if(x==queen[y]) cout\u0026lt;\u0026lt;\u0026#34;\u0026lt;q\u0026gt;\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;\u0026lt;-\u0026gt;\u0026#34;; cout\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;\u0026#34;\\t\u0026#34;; } system(\u0026#34;pause\u0026#34;); } void decide_position(int value) { int i=0; while(i\u0026lt;EIGHT) { //是否受到攻击的判断式 if(attack(i,value)!=1) { queen[value]=i; if(value==7) print_table(); else decide_position(value+1); } i++; } } //测试在(row,col)上的皇后是否遭受攻击 //若遭受攻击则返回值为1,否则返回0 int attack(int row,int col) { int i=0,atk=FALSE; int offset_row=0,offset_col=0; while((atk!=1)\u0026amp;\u0026amp;i\u0026lt;col) { offset_col=abs(i-col); offset_row=abs(queen[i]-row); //判断两皇后是否在同一行或同一对角线上 if((queen[i]==row)||(offset_row==offset_col)) atk=TRUE; i++; } return atk; } //主程序 int main(void) { decide_position(0); return 0; } 算术表达式的表示法 我们正常的算数公式书写是中序法，而对于计算机来说处理较为复杂，解决方法就是使用前序法与后序法（后序法只使用一个堆栈缓冲区，前序法两个）。\n中序法转为前序法与后序法 可以使用括号法，值得注意的是每两个数进行一次运算就要一次括号。\n也可以使用堆栈法。\n(1)从右到左读进中序法表达式的每个字符\n(2)如果读进的字符为操作数，则直接输出到前序法表达式中。\n(3) 如果遇到“(”，则弹出堆内的运算符，直到弹出到一个“)”，两者互相抵消。\n(4)“)”的优先级在堆内比任何运算符都小，任何运算符的优先级都高过它，不过在堆栈外却是优先级最高者。\n(5)当运算符准备进入堆栈内时，必须和堆顶端的运算符比较，如果外面的运算符优先级高于或等于堆栈顶端的运算符则压入堆栈，如果优先级低于堆栈顶端的运算符就把堆栈顶端的运算符弹出直到堆栈顶端的运算符优先级低于外面的运算符或堆栈为空时，就再把外面这个运算符压入堆栈\n(6) 中序法表达式读完后，如果运算符堆栈不是空的，则将其内的运算符逐一弹出，输出到前序法表达式中即可。 前序法与后序法表达式转为中序法表达式 也可以使用括号法或堆栈法。\n 括号法的乘法除法运算符在前序法向后括一个，加减法括两个。符号向右取代 括号法的乘法除法运算符在后序法向前括一个，加减法括两个。符号向左取代  中序法求值 需要两个堆栈，一个用于存储运算符，一个存放操作数。 但计算方法和人算大同小异。\n前序法求值 需要两个堆栈，一个用于存储表达式，一个存放操作数。不需要比较操作符的优先级。\n后序法求值 只需要一个堆栈。不需要比较操作符的优先级，计算非常直观简单\n","permalink":"https://tassel234.github.io/posts/note/%E7%AE%97%E6%B3%95%E9%A2%84%E8%A7%88%E9%80%92%E5%BD%92%E6%B3%95%E5%92%8C%E7%AE%97%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/","summary":"使用资源 图解数据结构，使用C++ 吴灿明 （源代码来自这里） 递归法详解 斐波那契数列 /* [示范]：斐波那契数列的递归程序 */ #include\u0026lt;iostream\u0026gt; using namespace std; int fib(int); //fib()函数的原型声明 int main() { int i,n; cout\u0026lt;\u0026lt;\u0026#34;请输入要计算到第几项斐波那契数列：\u0026#34;;//如果输入的数字太大会导致算到负数","title":"算法预览（递归法和算数表达式）"},{"content":"堆栈简介 基本知识 也可以简写为栈，具有后进先出的特性（LIFO）\n与链表和数组一样，栈的数据也是线性排列，但在栈中，添加和删除数据的操作只能在一端进行，访问数据也只能访问到顶端的数据。想要访问中间的数据时，就必须通过出栈操作将目标数据移到栈顶才行。\n放入栈的顶端，称为压入PUSH,从顶端取出，称为弹出pop\n栈只能在一端操作，这一点看起来似乎十分不便，但在只需要访问最新数据时，使用它就比较方便了。另外，我们将要在接下来学习深度优先搜索算法，通常会选择最新的数据作为候补顶点。在候补顶点的管理上就可以使用栈。\n代码实现 使用数组实现堆栈 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; #define MAXSTACK 100\t//定义堆栈的最大容量 using namespace std; int stack[MAXSTACK];\t//声明用于堆栈操作的数组 int top=-1;\t//堆栈的顶端 //判断是否为空堆栈 int isEmpty() { if(top==-1) return 1; else return 0; } //将指定的数据压入堆栈 int push(int data) { if(top\u0026gt;=MAXSTACK) { cout\u0026lt;\u0026lt;\u0026#34;堆栈已满,无法再压入\u0026#34;\u0026lt;\u0026lt;endl; return 0; } else { stack[++top]=data;\t//top的值一直在变化，将数据压入堆栈 return 1; } } //从堆栈弹出数据 int pop() { if(isEmpty())\t//判断堆栈是否为空,如果是则返回-1 return -1; else return stack[top--];\t//将数据弹出后,再将堆栈指针往下移 //先输出，再自减 } //主程序 int main(void) { int value; int i; cout\u0026lt;\u0026lt;\u0026#34;请按序输入10个数据:\u0026#34;\u0026lt;\u0026lt;endl; for(i=0;i\u0026lt;10;i++) { cin\u0026gt;\u0026gt;value; push(value); } cout\u0026lt;\u0026lt;\u0026#34;====================\u0026#34;\u0026lt;\u0026lt;endl; while(!isEmpty())\t//将数据陆续从顶端弹出 cout\u0026lt;\u0026lt;\u0026#34;堆栈弹出的顺序为:\u0026#34;\u0026lt;\u0026lt;setw(4)\u0026lt;\u0026lt;pop()\u0026lt;\u0026lt;endl; //C++ setw() 函数用于设置字段的宽度, //语法格式如下setw(n)n 表示宽度,用数字表示。setw() 函数只对紧接着的输出产生作用。 //当后面紧跟着的输出字段长度小于 n 的时候，在该字段前面用空格补齐，当输出字段长度大于 n 时，全部整体输出。 cout\u0026lt;\u0026lt;\u0026#34;====================\u0026#34;\u0026lt;\u0026lt;endl; return 0; } //发牌程序 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;ctime\u0026gt; #include \u0026lt;cstdlib\u0026gt; using namespace std; void Swap(int*,int*); void push(int statck[],int MAX,int val); int pop(int stack[]); int top=-1; int main(void) { int card[52],stack[52]={0}; int i,j,k=0, ascVal; char suit[4][10]={\u0026#34;草花\u0026#34;,\u0026#34;方块\u0026#34;,\u0026#34;红桃\u0026#34;,\u0026#34;黑桃\u0026#34;}; int style; srand((unsigned)time(NULL));//srand函数是C语言中的种子函数,它的功能是生成一个随机数。 //srand(1); 直接使用1来初始化种子。不过为了防止随机数每次重复，常常使用系统时间来初始化， //即使用 time函数来获得系统时间，它的返回值为从 00:00:00 GMT, January 1, 1970 到现在所持续的秒数， //然后将time_t型数据转化为(unsigned)型再传给srand函数，即: srand((unsigned) time(\u0026amp;t)); //还有一个经常用法，不需要定义time_t型t变量,即: srand((unsigned) time(NULL)); //直接传入一个空指针，因为你的程序中往往并不需要经过参数获得的数据。 //若去掉这段语句，会造成接下来的数据一直保持在同一个值 for (i=0;i\u0026lt;52;i++) card[i]=i+1; cout\u0026lt;\u0026lt;\u0026#34;[洗牌中...请稍后!]\u0026#34;\u0026lt;\u0026lt;endl; while(k\u0026lt;30) { for(i=0;i\u0026lt;51;i++) for(j=i+1;j\u0026lt;52;j++) if(rand()%52==2)//不是52也可以，为什么是52呢 Swap(\u0026amp;card[i],\u0026amp;card[j]);//洗牌 k++; } i=0; while(i!=52) { push(stack,52,card[i]);//将52张牌压入堆栈 i++; } cout\u0026lt;\u0026lt;\u0026#34;[逆时针发牌]\u0026#34;\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;[显示各家拿到的牌]\u0026#34;\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34; 东家\\t\\t 北家\\t\\t 西家\\t\\t 南家\u0026#34;\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;=========================================================\u0026#34;\u0026lt;\u0026lt;endl; while (top \u0026gt;=0) { style = stack[top]/13;\t//计算扑克牌的花色 switch(style)\t//扑克牌花色对应的图标 { case 0:\t//梅花 ascVal=0; break; case 1:\t//方块 ascVal=1; break; case 2:\t//红心 ascVal=2; break; case 3:\t//黑桃 ascVal=3; break; } cout\u0026lt;\u0026lt;\u0026#34;[\u0026#34;\u0026lt;\u0026lt;suit[ascVal]\u0026lt;\u0026lt;setw(3)\u0026lt;\u0026lt;stack[top]%13+1\u0026lt;\u0026lt;\u0026#34;]\\t\u0026#34;; if(top%4==0) cout\u0026lt;\u0026lt;endl; top--; } return 0; } void push(int stack[],int MAX,int val) { if(top\u0026gt;=MAX-1) cout\u0026lt;\u0026lt;\u0026#34;[堆栈已经满了]\u0026#34;\u0026lt;\u0026lt;endl; else { top++; stack[top]=val; } } int pop(int stack[]) { if(top\u0026lt;0) cout\u0026lt;\u0026lt;\u0026#34;[堆栈已经空了]\u0026#34;\u0026lt;\u0026lt;endl; else top--; return stack[top]; } void Swap(int* a,int* b) { int temp; temp=*a; *a=*b; *b=temp; } 使用链表实现堆栈 使用链表设计堆栈的好处是链表的大小是可以变动的，不会造成内存空间的浪费 缺点是设计复杂\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; class Node\t//声明堆栈链表节点 { public: int data;\t//声明存放堆栈数据的变量 class Node *next;\t//堆栈中用来指向下一个节点的指针 }; typedef class Node Stack_Node;\t//定义堆栈中节点的新类型 typedef Stack_Node *Linked_Stack;\t//定义链表堆栈的新类型 Linked_Stack top=NULL;\t//指向堆栈顶端的指针 //判断是否为空堆栈 int isEmpty() { if(top==NULL) return 1; else return 0; } //将指定的数据压入堆栈 void push(int data) { Linked_Stack new_add_node;\t//新加入节点的指针 new_add_node=new Stack_Node;//分配内存给新节点 new_add_node-\u0026gt;data=data;\t//将传入的值赋值给节点的数据变量 new_add_node-\u0026gt;next=top;\t//将新节点指向堆栈的顶端 top=new_add_node;\t//新节点成为堆栈的顶端 } //从堆栈弹出数据 int pop() { Linked_Stack ptr;\t//指向堆栈顶端的指针 int temp; if(isEmpty())\t//判断堆栈是否为空,如果是则返回-1 { cout\u0026lt;\u0026lt;\u0026#34;===目前为空堆栈===\u0026#34;\u0026lt;\u0026lt;endl; return -1; } else { ptr=top;\t//指向堆栈的顶端 top=top-\u0026gt;next;\t//将堆栈顶端的指针指向下一个节点 temp=ptr-\u0026gt;data;\t//取出堆栈的数据 free(ptr);\t//将节点占用的内存释放 return temp;\t//将从堆栈取出的数据返回给主程序 } } //主程序 int main(void) { int value; int i; cout\u0026lt;\u0026lt;\u0026#34;请按序输入10个数据:\u0026#34;\u0026lt;\u0026lt;endl; for(i=0;i\u0026lt;10;i++) { cin\u0026gt;\u0026gt;value; push(value); } cout\u0026lt;\u0026lt;\u0026#34;====================\u0026#34;\u0026lt;\u0026lt;endl; while(!isEmpty()) //将数据陆续从顶端弹出 cout\u0026lt;\u0026lt;\u0026#34;堆栈弹出的顺序为:\u0026#34;\u0026lt;\u0026lt;setw(2)\u0026lt;\u0026lt;pop()\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;====================\u0026#34;\u0026lt;\u0026lt;endl; return 0; } 堆栈类模板的实现 样板的设计概念也被称为泛型编程，通过对模板输入特定的数据类型可以形成对应的函数或类。 C++有stl模板库，但本书并没有使用。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; using namespace std; template \u0026lt;class Type\u0026gt;\t// 定义链表中的节点 struct Node { Type data;\t// 记录数据 Node* next;\t// 记录下一笔节点的地址 }; template \u0026lt;class Type\u0026gt; class LinkedList\t// 链表类型 { private: Node\u0026lt;Type\u0026gt;* first;\t// 指到第一个节点的指针 public: LinkedList()\t// 构造函数 { first = NULL; } void addNode(Type data);\t// 加入节点 void display();\t// 显示所有的节点 }; template\u0026lt;class Type\u0026gt; void LinkedList\u0026lt;Type\u0026gt;::addNode(Type data) { Node\u0026lt;Type\u0026gt;* newNode = new Node\u0026lt;Type\u0026gt;;\t// 新增一个节点 newNode-\u0026gt;data = data;\t// 记录数据 newNode-\u0026gt;next = first;\t// 指向前一个节点 first = newNode;\t// 指向新的节点 } template\u0026lt;class Type\u0026gt; void LinkedList\u0026lt;Type\u0026gt;::display() { Node\u0026lt;Type\u0026gt;* currentNode = first; // 从第一个节点开始显示 while( currentNode != NULL ) { cout \u0026lt;\u0026lt; currentNode-\u0026gt;data \u0026lt;\u0026lt; \u0026#34; -\u0026gt; \u0026#34;; currentNode = currentNode-\u0026gt;next; } } int main() { LinkedList\u0026lt;double\u0026gt; dblList;\t// 建立一个存储double类型数据的链表 double num;\t// 记录输入的数据 char ch;\t// 记录用户的选择 do{ cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt;\u0026#34;请输入一个数字 : \u0026#34;; cin \u0026gt;\u0026gt; num; dblList.addNode( num ); cout \u0026lt;\u0026lt; \u0026#34;继续输入(y / n)?\u0026#34;; cin \u0026gt;\u0026gt; ch; }while( ch != \u0026#39;n\u0026#39; ); cout \u0026lt;\u0026lt; endl; dblList.display();\t// 显示所有的数据 cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; return 0; } #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; using namespace std; // 设置类样版的类型参数Type的默认值为整数int,非类型参数的类型为整数int,默认值为5 template \u0026lt;class Type = int, int size = 5\u0026gt;\t// 声明类样板 class Stack { private: Type st[size];\t// 声明一数组作为堆栈的存储空间 int top;\t// 堆栈数据顶端的索引 public: Stack() { top = -1; } void push(Type data);\t// 将数据压入堆栈 Type pop();\t// 将数据从堆栈中弹出 }; template \u0026lt; class Type, int size \u0026gt; void Stack\u0026lt; Type, size \u0026gt; :: push ( Type data ) { st[ ++top ] = data; } template \u0026lt; class Type, int size \u0026gt; Type Stack\u0026lt;Type, size\u0026gt; :: pop() { return st[ top-- ]; } int main() { Stack\u0026lt;\u0026gt; stk_1;\t// 声明一个堆栈对象, 并使用其默认值 Stack\u0026lt;char*, 4\u0026gt; stk_2;\t// 声明堆栈对象, 其类型为字符串, 大小为4 stk_1.push( 11 ); stk_1.push( 22 ); stk_1.push( 33 ); cout \u0026lt;\u0026lt; \u0026#34;stack_1 [1] = \u0026#34; \u0026lt;\u0026lt; stk_1.pop() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;stack_1 [2] = \u0026#34; \u0026lt;\u0026lt; stk_1.pop() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;stack_1 [3] = \u0026#34; \u0026lt;\u0026lt; stk_1.pop() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; endl; stk_2.push( \u0026#34;第一名\u0026#34; ); stk_2.push( \u0026#34;第二名\u0026#34; ); stk_2.push( \u0026#34;第三名\u0026#34; ); cout \u0026lt;\u0026lt; \u0026#34;stack_2 [1] = \u0026#34; \u0026lt;\u0026lt; stk_2.pop() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;stack_2 [2] = \u0026#34; \u0026lt;\u0026lt; stk_2.pop() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;stack_2 [3] = \u0026#34; \u0026lt;\u0026lt; stk_2.pop() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; endl; return 0; } 队列 (1)图遍历的广度优先搜索法 (BFS) 就是使用队列。 (2)可用于计算机的模拟，在模拟过程中，由于各种事件 的输入时间不一定，可以使用队列来反映真实的情况。 (3)可用于 CPU 的作业调度 ，利用队列来处理，可实现作业先到先执行的要求。 (4)外围设备联机并发处理系统的应用，也就是让输入/输出的数据先在高速磁驱动器中完成，把磁盘当成一个大型的工作缓冲区，如此可让输入/输出操作快速完成，因而缩短了系统响应的时间，接下来由系统软件负责将磁盘数据输出到打印机，其中就应用了队列的工作原理。\n认识队列 队列的基本操作 create,add,delete,front,empty\n用数组来实现队列 好处是算法简单，只需要front和rear来指队首和队尾，初始值都赋上-1，add,delete时对数据增加。 rear指向最后的元素，front指向最前面的元素的前一个位置，刚开始就是-1。 坏处是只能声明固定长度。\n/* [示范]：实现往队列中加入数据和从队列中取出数据 */ #include \u0026lt;iostream\u0026gt; using namespace std; const int MAX=20; //定义队列的大小 int main(void) { int front,rear,val,queue[MAX]={0}; char ch; front=rear=-1; while(rear\u0026lt;MAX-1\u0026amp;\u0026amp;ch!=\u0026#39;E\u0026#39;) { cout\u0026lt;\u0026lt;\u0026#34;输入I：往队列加入一个数据 输入G：从队列中取出一个数据\\n输入E：结束程序\\n请输入：\u0026#34;; cin\u0026gt;\u0026gt;ch; switch(ch) { case \u0026#39;I\u0026#39;: cout\u0026lt;\u0026lt;\u0026#34;[请输入数据]：\u0026#34;; cin\u0026gt;\u0026gt;val; rear++; queue[rear]=val; break; case \u0026#39;G\u0026#39;: if(rear\u0026gt;front) { front++; cout\u0026lt;\u0026lt;\u0026#34;[从队列中取出的数据为]: [\u0026#34;\u0026lt;\u0026lt;queue[front]\u0026lt;\u0026lt;\u0026#34;]\u0026#34;; cout\u0026lt;\u0026lt;endl; queue[front]=0; } else { cout\u0026lt;\u0026lt;\u0026#34;[队列已经空了]\u0026#34;\u0026lt;\u0026lt;endl; exit(0); } break; default: cout\u0026lt;\u0026lt;endl; break; } } if(rear==MAX-1) cout\u0026lt;\u0026lt;\u0026#34;[队列已经满了]\u0026#34;\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;[目前队列中的数据]:\u0026#34;; if (front\u0026gt;=rear) { cout\u0026lt;\u0026lt;\u0026#34;没有\u0026#34;\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;[队列已经空了]\u0026#34;\u0026lt;\u0026lt;endl; } else { while (rear\u0026gt;front) { front++; cout\u0026lt;\u0026lt;\u0026#34;[\u0026#34;\u0026lt;\u0026lt;queue[front]\u0026lt;\u0026lt;\u0026#34;]\\t\u0026#34;; } cout\u0026lt;\u0026lt;endl; } return 0; } 用链表实现队列 /* [示范]：以链表来实现队列 */ #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; class Node { public: int data; class Node *next; }; typedef class Node QueueNode; typedef QueueNode *QueueByLinkedList; QueueByLinkedList front=NULL; QueueByLinkedList rear=NULL; //方法enqueue：把数据加入队列 void enqueue(int value) { QueueByLinkedList node; //建立节点 node=new QueueNode; node-\u0026gt;data=value; node-\u0026gt;next=NULL; //检查是否为空队列 if (rear==NULL) front=node; //如果rear为NULL，表示这是队列的第一个元素（节点） else rear-\u0026gt;next=node; //将新元素（新节点）连接至队列末尾 rear=node; //将队列的末尾指针指向新加入的节点 } //方法dequeue：从队列中取出数据 int dequeue() { int value; //检查队列是否为空队列 if (!(front==NULL)) { if(front==rear) rear=NULL; value=front-\u0026gt;data; //从队列中取出数据 front=front-\u0026gt;next; //将队列的前端指针指向下一个 return value; } else return -1; } int main(void) { int temp; cout\u0026lt;\u0026lt;\u0026#34;用链表来实现队列\u0026#34;\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;====================================\u0026#34;\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;在队列前端加入第1个数据，此数据为1\u0026#34;\u0026lt;\u0026lt;endl; enqueue(1); cout\u0026lt;\u0026lt;\u0026#34;在队列前端加入第2个数据，此数据为3\u0026#34;\u0026lt;\u0026lt;endl; enqueue(3); cout\u0026lt;\u0026lt;\u0026#34;在队列前端加入第3个数据，此数据为5\u0026#34;\u0026lt;\u0026lt;endl; enqueue(5); cout\u0026lt;\u0026lt;\u0026#34;在队列前端加入第4个数据，此数据为7\u0026#34;\u0026lt;\u0026lt;endl; enqueue(7); cout\u0026lt;\u0026lt;\u0026#34;在队列前端加入第5个数据，此数据为9\u0026#34;\u0026lt;\u0026lt;endl; enqueue(9); cout\u0026lt;\u0026lt;\u0026#34;====================================\u0026#34;\u0026lt;\u0026lt;endl; while (1) { if (!(front==NULL)) { temp=dequeue(); cout\u0026lt;\u0026lt;\u0026#34;从队列前端按序取出的数据为：\u0026#34;\u0026lt;\u0026lt;setw(1)\u0026lt;\u0026lt;temp\u0026lt;\u0026lt;endl; } else break; } cout\u0026lt;\u0026lt;endl; return 0; } 环形队列 上述的数组程序可以实现先进先出的排队策略，但没有办法模拟排队的人走了接下来几位向前走的情形，没法加入其他数据。可以利用环形队列解决这个问题。\n当数据满了，把rear的值重写为0. (rear+1)mod n\nfront指向最前面的元素的前一个位置。\nrear指向的下一个是front时判断队列已经满了，队列只可以存放n-1个数据。\n/* [示范]：实现环状队列数据的进队和出队 */ #include \u0026lt;iostream\u0026gt; using namespace std; int main(void) { int front,rear,val=0,queue[5]={0}; front=rear=-1; while(rear\u0026lt;5\u0026amp;\u0026amp;val!=-1) { cout\u0026lt;\u0026lt;\u0026#34;请输入一个值以存入队列，欲取出值请输入-2。(结束输入-1)：\u0026#34;; cin\u0026gt;\u0026gt;val; if(val==-2) { if(front==rear) { cout\u0026lt;\u0026lt;\u0026#34;[队列已经空了]\u0026#34;\u0026lt;\u0026lt;endl; break; } front++; if (front==5) front=0; cout\u0026lt;\u0026lt;\u0026#34;取出队列值 [\u0026#34;\u0026lt;\u0026lt;queue[front]\u0026lt;\u0026lt;\u0026#34;]\u0026#34;\u0026lt;\u0026lt;endl; queue[front]=0; } else if(val!=-1 \u0026amp;\u0026amp; rear\u0026lt;5) { if(rear+1==front || rear==4 \u0026amp;\u0026amp; front\u0026lt;=0) { cout\u0026lt;\u0026lt;\u0026#34;[队列已经满了]\u0026#34;\u0026lt;\u0026lt;endl; break; } rear++; if(rear==5) rear=0; queue[rear]=val; } } cout\u0026lt;\u0026lt;\u0026#34;\\n队列剩余数据：\u0026#34;\u0026lt;\u0026lt;endl; if (front==rear) cout\u0026lt;\u0026lt;\u0026#34;队列已空!!\u0026#34;\u0026lt;\u0026lt;endl; else { while(front!=rear) { front++; if (front==5) front=0; cout\u0026lt;\u0026lt;\u0026#34;[\u0026#34;\u0026lt;\u0026lt;queue[front]\u0026lt;\u0026lt;\u0026#34;]\u0026#34;; queue[front]=0; } } cout\u0026lt;\u0026lt;endl; return 0; } 双向队列 一般双向队列的应用可以分为2种，一种是两端都可以加入数据但只有一段可以取出数据，另一种是两端都可以取出数据但只有一段可以加入数据。\n优先队列 每一个元素都赋给了一个优先级，加入任意，但取出时优先级高的先出，不是FIFO了。\n后记 我是使用devc++打开源代码的，其中可能会用目录寻找错误而导致打不开文件，这是因为编码方式不一样，容易出现汉字乱码，可以试试把文件打开路径的中文改成英文或拼音。\n","permalink":"https://tassel234.github.io/posts/note/%E4%BD%BF%E7%94%A8cpp%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/","summary":"堆栈简介 基本知识 也可以简写为栈，具有后进先出的特性（LIFO） 与链表和数组一样，栈的数据也是线性排列，但在栈中，添加和删除数据的操作只能在一端进行，访问数据也只能访问到顶端的数据。想要访问中间的数据时，就必须通过出栈操作将目标数据移到栈顶才行。 放入栈的顶端，称为压入PUSH,从顶","title":"使用Cpp实现数据结构-2（栈和队列）"},{"content":"资源 （主）图解数据结构，使用C++ 吴灿明 （源代码来自这里）\n使用软件\u0026quot;算法动画图解\u0026quot;\n我的第一本算法书（书中彩色配图来自上面那个软件）\n算法简单介绍 算法加数据结构构成可执行程序。\n算法的五个条件，输入，输出，有效，明确，有穷\n链表 链表主要用于两个目的：一是建立不定长度的数组。二是链表可以 在不重新安排整个存储结构的情况下，方便且迅速地插入和删除数 据元素。\n动态分配内存 3.1.1 C++的动态分配变量\n数据类型* 指针名称 = new 数据类型 int* p = new int delete p; 可以拓展到结构体或类\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; using namespace std; int main() { int *intptr = new int(50); //声明一指向整数的指针,在该内存中存入整数值50 float *floatptr = new float; //声明一指向浮点数的指针,但未指定内存中存储的数据值 cout \u0026lt;\u0026lt; \u0026#34;intptr 指向的数据值：\u0026#34; \u0026lt;\u0026lt; *intptr \u0026lt;\u0026lt; \u0026#34;\\n\\n\u0026#34;; *floatptr = 0.5; cout \u0026lt;\u0026lt; \u0026#34;floatptr 指向的数据值：\u0026#34; \u0026lt;\u0026lt; *floatptr \u0026lt;\u0026lt; \u0026#34;\\n\\n\u0026#34;; delete intptr; delete floatptr; return 0; } 3.1.2 动态分配数组\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; using namespace std; int main(){ int no,count=0, Total=0; // 定义整数变量 count 与 Total cout\u0026lt;\u0026lt;\u0026#34;要输入计算的个数为:\u0026#34;; cin\u0026gt;\u0026gt;no; int *ptr=new int[no]; // 动态分配数组为n个元素 cout\u0026lt;\u0026lt;endl;\tfor (count=0; count \u0026lt; no; count++)\t{\tcout \u0026lt;\u0026lt; \u0026#34;输入ptr[\u0026#34; \u0026lt;\u0026lt; count \u0026lt;\u0026lt; \u0026#34;]:\u0026#34;; cin \u0026gt;\u0026gt; ptr[count]; // 采用数组下标来输入数组元素 } for (count=0; count \u0026lt; no; count++) Total+=*(ptr+count); // 采用指针变量运算来存取数组的元素值 cout\u0026lt;\u0026lt;\u0026#34;---------------------------------------\u0026#34;\u0026lt;\u0026lt;endl; cout \u0026lt;\u0026lt; no\u0026lt;\u0026lt;\u0026#34;个数的总和=\u0026#34; \u0026lt;\u0026lt; Total; // 显示结果 cout \u0026lt;\u0026lt; endl; delete [] ptr; // 释放分配给 ptr 的内存空间 ptr=NULL;\treturn 0; } 单向链表 在C++网课学习期间已经对该部分内容有部分了解，和网课不同的是本书的程序不是由结构体，而是由类写的。\n接下来的笔记主要以程序为主，笔记以标注//形式写出。\n3.2.1 单向链表的创建与遍历\n#include \u0026lt;iostream\u0026gt; using namespace std; class list { public: int num,score; char name[10]; class list *next; }; typedef class list node;//删除class也可以，有class是偏c语言的写法 typedef node *link; int main() { link newnode,ptr,delptr; //声明三个链表结构的指针 cout\u0026lt;\u0026lt;\u0026#34;请输入 5 位学生的数据：\u0026#34;\u0026lt;\u0026lt;endl; delptr=new node; //delptr暂当链表头指针 if (!delptr) { cout\u0026lt;\u0026lt;\u0026#34;[Error!!内存分配失败!]\u0026#34;\u0026lt;\u0026lt;endl; exit(1); } cout\u0026lt;\u0026lt;\u0026#34;请输入学号：\u0026#34;; cin\u0026gt;\u0026gt;delptr-\u0026gt;num; cout\u0026lt;\u0026lt;\u0026#34;请输入姓名：\u0026#34;; cin\u0026gt;\u0026gt;delptr-\u0026gt;name; cout\u0026lt;\u0026lt;\u0026#34;请输入成绩：\u0026#34;; cin\u0026gt;\u0026gt;delptr-\u0026gt;score; ptr=delptr; //保留链表头指针，以ptr为指向当前节点的指针 for (int i=1;i\u0026lt;5;i++) { newnode=new node; //创建新节点 if(!newnode) { cout\u0026lt;\u0026lt;\u0026#34;[Error!!内存分配失败!\u0026#34;\u0026lt;\u0026lt;endl; exit(1); } cout\u0026lt;\u0026lt;\u0026#34;请输入学号：\u0026#34;; cin\u0026gt;\u0026gt;newnode-\u0026gt;num; cout\u0026lt;\u0026lt;\u0026#34;请输入姓名：\u0026#34;; cin\u0026gt;\u0026gt;newnode-\u0026gt;name; cout\u0026lt;\u0026lt;\u0026#34;请输入成绩：\u0026#34;; cin\u0026gt;\u0026gt;newnode-\u0026gt;score; newnode-\u0026gt;next=NULL; ptr-\u0026gt;next=newnode; //把新节点加在链表后面 ptr=ptr-\u0026gt;next; //让ptr保持在链表的最后面 } cout\u0026lt;\u0026lt;\u0026#34;\\n 学 生 成 绩\u0026#34;\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34; 学号\\t姓名\\t成绩\\n=====================\u0026#34;\u0026lt;\u0026lt;endl; ptr=delptr; //让ptr回到链表头 while(ptr!=NULL) { cout\u0026lt;\u0026lt;ptr-\u0026gt;num\u0026lt;\u0026lt;\u0026#34;\\t\u0026#34;\u0026lt;\u0026lt;ptr-\u0026gt;name\u0026lt;\u0026lt;\u0026#34;\\t\u0026#34;\u0026lt;\u0026lt;ptr-\u0026gt;score\u0026lt;\u0026lt;endl; delptr=ptr; ptr=ptr-\u0026gt;next; //ptr按序往后遍历整个链表 delete delptr; //释放内存空间 } } 3.2.2 单向链表中新节点的插入\n方法同网课\n3.2.3 单向链表中节点的删除\ny=ptr-\u0026gt;next; ptr-\u0026gt;next=y-\u0026gt;next; delete y; 也可以采用网课讲的方法。\n3.2.4 单向链表的反转 （指全部数据）\n/* [示范]:将学生成绩按学号反转打印出来 */ #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;ctime\u0026gt; #include \u0026lt;cstdlib\u0026gt; using namespace std; class list { public: int num,score; char name[10]; class list *next; }; typedef class list node; typedef node *link; int main() { link ptr,last,before; int i,j,findword=0,data[12][2]; char namedata[12][10]={{\u0026#34;Allen\u0026#34;},{\u0026#34;Mako\u0026#34;},{\u0026#34;Lean\u0026#34;}, {\u0026#34;Melissa\u0026#34;},{\u0026#34;Angel\u0026#34;},{\u0026#34;Sabrina\u0026#34;},{\u0026#34;Joyce\u0026#34;}, {\u0026#34;Jasica\u0026#34;},{\u0026#34;Hanson\u0026#34;},{\u0026#34;Amy\u0026#34;},{\u0026#34;Bob\u0026#34;},{\u0026#34;Jack\u0026#34;}}; srand((unsigned)time(NULL)); for (i=0;i\u0026lt;12;i++) { data[i][0]=i+1; data[i][1]=rand()%50+51;//随机给成绩 } link head=new node;\t//建立链表头指针 if(!head) { cout\u0026lt;\u0026lt;\u0026#34;Error!! 内存分配失败!!\u0026#34;\u0026lt;\u0026lt;endl; exit(1); } head-\u0026gt;num=data[0][0]; for (j=0;j\u0026lt;10;j++) head-\u0026gt;name[j]=namedata[0][j]; head-\u0026gt;score=data[0][1]; head-\u0026gt;next=NULL; ptr=head; for(i=1;i\u0026lt;12;i++) //建立链表 { link newnode=new node; newnode-\u0026gt;num=data[i][0]; for (j=0;j\u0026lt;10;j++) newnode-\u0026gt;name[j]=namedata[i][j]; newnode-\u0026gt;score=data[i][1]; newnode-\u0026gt;next=NULL; ptr-\u0026gt;next=newnode; ptr=ptr-\u0026gt;next; } ptr=head; i=0; cout\u0026lt;\u0026lt;\u0026#34;原始链表数据：\u0026#34;\u0026lt;\u0026lt;endl; while (ptr!=NULL) { //打印链表数据 cout\u0026lt;\u0026lt;\u0026#34;[\u0026#34;\u0026lt;\u0026lt;setw(2)\u0026lt;\u0026lt;ptr-\u0026gt;num\u0026lt;\u0026lt;setw(8) \u0026lt;\u0026lt;ptr-\u0026gt;name\u0026lt;\u0026lt;setw(3)\u0026lt;\u0026lt;ptr-\u0026gt;score\u0026lt;\u0026lt;\u0026#34;] -\u0026gt; \u0026#34;; i++; if(i\u0026gt;=3) //三个元素为一行 { cout\u0026lt;\u0026lt;endl; i=0; } ptr=ptr-\u0026gt;next; } ptr=head; before=NULL; cout\u0026lt;\u0026lt;\u0026#34;\\n反转后链表数据：\u0026#34;\u0026lt;\u0026lt;endl; while(ptr!=NULL) //链表反转 { last=before; before=ptr; ptr=ptr-\u0026gt;next; before-\u0026gt;next=last; } ptr=before; while(ptr!=NULL) { cout\u0026lt;\u0026lt;\u0026#34;[\u0026#34;\u0026lt;\u0026lt;setw(2)\u0026lt;\u0026lt;ptr-\u0026gt;num\u0026lt;\u0026lt;setw(8) \u0026lt;\u0026lt;ptr-\u0026gt;name\u0026lt;\u0026lt;setw(3)\u0026lt;\u0026lt;ptr-\u0026gt;score\u0026lt;\u0026lt;\u0026#34;] -\u0026gt; \u0026#34;; i++; if(i\u0026gt;=3) { cout\u0026lt;\u0026lt;endl; i=0; } ptr=ptr-\u0026gt;next; } } 3.2.5 多项式链表表示法\n/* [示范]:多项式相加 */ #include \u0026lt;iostream\u0026gt; using namespace std; class list //声明链表结构 { public : int coef,exp; class list *next; }; typedef class list node; typedef node *link; link creat_link(int data[4]); void print_link(link head);//函数定义 link sum_link(link a,link b); int main() { link a,b,c; int data1[4]={3,0,4,2}; //多项式A的系数 int data2[4]={6,8,6,9}; //多项式B的系数 cout\u0026lt;\u0026lt;\u0026#34;原始多项式：\u0026#34;\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;\u0026#34;A=\u0026#34;; a=creat_link(data1); //建立多项式A b=creat_link(data2); //建立多项式B print_link(a); //打印多项式A cout\u0026lt;\u0026lt;\u0026#34;B=\u0026#34;; print_link(b); //打印多项式B cout\u0026lt;\u0026lt;\u0026#34;多项式相加的结果：\\nC=\u0026#34;; c=sum_link(a,b); //C为A、B多项式相加的结果 print_link(c); //打印多项式C } link creat_link(int data[4])//建立多项式子程序 { link head,newnode,ptr; for(int i=0;i\u0026lt;4;i++) { newnode = new node; if(!newnode) { cout\u0026lt;\u0026lt;\u0026#34;Error!! 内存分配失败!!\u0026#34;\u0026lt;\u0026lt;endl; exit(1); } if(i==0) { newnode-\u0026gt;coef=data[i]; newnode-\u0026gt;exp=3-i; newnode-\u0026gt;next=NULL; head=newnode; ptr=head; } else if(data[i]!=0) { newnode-\u0026gt;coef=data[i]; newnode-\u0026gt;exp=3-i; newnode-\u0026gt;next=NULL; ptr-\u0026gt;next=newnode; ptr=newnode; } } return head; } void print_link(link head) //打印多项式子程序 { while(head!=NULL) { if(head-\u0026gt;exp==1 \u0026amp;\u0026amp; head-\u0026gt;coef!=0)\t//X^1时不显示指数 cout\u0026lt;\u0026lt;head-\u0026gt;coef\u0026lt;\u0026lt;\u0026#34;X + \u0026#34;; else if(head-\u0026gt;exp!=0 \u0026amp;\u0026amp; head-\u0026gt;coef!=0) cout\u0026lt;\u0026lt;head-\u0026gt;coef\u0026lt;\u0026lt;\u0026#34;X^\u0026#34;\u0026lt;\u0026lt;head-\u0026gt;exp\u0026lt;\u0026lt;\u0026#34; + \u0026#34;; else if(head-\u0026gt;coef!=0) //X^0时不显示变量 cout\u0026lt;\u0026lt;head-\u0026gt;coef; head=head-\u0026gt;next; } cout\u0026lt;\u0026lt;endl; } link sum_link(link a,link b) //多项式相加子程序 { int sum[4],i=0; link ptr; ptr=b; while(a!=NULL) //判断多项式1 { b=ptr; //重复比较A和B的指数 while(b!=NULL) { if(a-\u0026gt;exp==b-\u0026gt;exp)\t//指数相等，系数相加 { sum[i]=a-\u0026gt;coef+b-\u0026gt;coef; a=a-\u0026gt;next; b=b-\u0026gt;next; i++; } else if(b-\u0026gt;exp \u0026gt; a-\u0026gt;exp)\t//B指数较大，指定系数给C { sum[i]=b-\u0026gt;coef; b=b-\u0026gt;next; i++; } else if(a-\u0026gt;exp \u0026gt; b-\u0026gt;exp)\t//A指数较大，指定系数给C { sum[i]=a-\u0026gt;coef; a=a-\u0026gt;next; i++; } } } return creat_link(sum);\t//建立相加结果的链表C } 环形链表 单链表如果头指针丢失，整个链表就会丢失。\n对单向链表进行了改进，把尾节点本该空着的指针改为指向头节点。这样每一个节点都可以作为头指针。\n环形链表通常应用于内存工作区和IO缓冲区。\n双向链表 把指针增加为2个，一个指向前方，一个指向后方，增加链表的结实长度，让链表不会因为某指针，链接的断裂而失去数据。同时也可以反方向遍历。\n","permalink":"https://tassel234.github.io/posts/note/%E4%BD%BF%E7%94%A8cpp%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1%E9%93%BE%E8%A1%A8/","summary":"资源 （主）图解数据结构，使用C++ 吴灿明 （源代码来自这里） 使用软件\u0026quot;算法动画图解\u0026quot; 我的第一本算法书（书中彩色配图来自上面那个软件） 算法简单介绍 算法加数据结构构成可执行程序。 算法的五个条件，输入，输出，有效，明确，有穷 链表 链表主要用于两个目的：一是建立不定长度的","title":"使用Cpp实现数据结构-1（链表）"},{"content":"类的定义 （1）定义类 面向程序设计更偏向于把每一个细节都做好，从每一个零件开始是制造汽车。面向对象编程偏向于把很多细小的零件已经主装好了，保留集成了很多接口，只需要把部件进行拼接就可以得到产品。\n面向对象编程的意义在于自然界都是由实体组成，面向对象也是软件开发的主流方式。\n面对对象的三大特征，分别是抽象，封装，继承。抽象指的是将成员和成员的行为分别表示为数据成员和成员函数。封装就是把抽象来的对象代码写到类里面，并设计一些接口。继承和派生，指的是可以对一些类进行修改，得到子类，比如把本科学生信息管理系统稍作修改就可以变成研究生学生信息管理系统。\n类的定义和结构体相似，但比结构体多了对共有，私有成员的声明，还有就是类里面可以由函数。公有成员就是所有类的用户都可以使用，私有成员是只有类的成员可以用，被保护的成员基本和私有成员相同，但派生继承的类的成员也可以访问\n函数可以定义先声明在类的里面，然后定义在类外。使用：：符号\nclass Data { //Data类定义 void set(int d); //成员函数原型声明，与 void set(int); 等价 int get() { //成员函数类内部定义 return data; } //get函数定义结束 int data; //数据成员 }; //Data类定义结束 void Data::set(int d) //成员函数类外部定义 { data=d; //访问类的数据成员 } 类定义一般放在程序文件开头，或者放到头文件中被程序文件包含， 此时这个定义是全局的。在全局作用域内，该定义处处可见，因此 同作用域内的所有函数都可以使用它。\n类定义向编译器声明了一种新的数据类型，该数据类型有不同类型 的数据成员和成员函数。因此尽管数据成员类似变量的定义，但类 型声明时并不会产生该成员的实体，即为它分配存储空间。\n（2）成员的访问控制 类的每个成员都有访问控制属性，由以下三种访问标号说明：public（公有的）、private（私有的）和protected（保护的）。\npublic实现了类的外部接口。私有成员用private标号声明，只有类成员可以访问私有成员，类用户的访问是不允许的。显然，private实现了私有成员的隐蔽。保护成员用protected标号声明，在不考虑继承的情况下，protected的性质和private的性质一致，但保护成员可以被派生类的类成员访问。\n实际编程中，为了使程序清晰，每一种成员访问限定符在类体中只出现一次\n（3）类的数据成员 类的数据成员可以是基本类型、数组、指针、引用、共用体、枚举 类型、void指针、const限定等数据类型。\n但不可以是自身，后面会提到构造函数，可以构造同名的函数体。\n（4）类的成员函数 在成员函数中可以访问这个类的任何成员，无论它是公有的 或是私有的，是类内部声明的还是类外部定义的。\n（::）是作用域限定符（field qualifed）。如果在作用域限定符的前面没有类名，或者函数前面既无类名又无作用域限定符，例 如：::set(10) 或 set(10）则表示set函数不属于任何类，这个函数不是成员函数，而是全局的普通函数。此时的（::）不是类作用域限定符的含义，而是命名空间域限定符的含义。\n类的成员函数可以指定为inline，即内联函数。声明在类外或者类内都可以。\n可以对成员函数重载或使用默认参数。需要注意，声明成员函数的多个重载版本或指定成员函数的默认参 数，只能在类内部中进行。\n用类实例化一个对象时，系统会为每一个对象分配存储空问。如果 一个类包括了数据成员和成员函数，则要分别为数据和函数的代码 分配存储空间。 （5）类的声明 类不能具有自身类型的数据成员。然而，只要类名一经出现就可以 认为该类己声明。因此，类的数据成员可以是指向自身类型的指针 或引用。\nclass Point; //Point类声明，非Point类定义，因为没有类体 class Line { Point a; //错误，不能使用仅有类声明而没有类定义的类定义数 据对象 Point *pp, \u0026amp;rp; //正确，只有类声明，即可用它定义该类的指 针或引用 Line b; //错误，类不能具有自身类型的数据成员 Line *pl, \u0026amp;rl; //正确，类可以有指向自身类型的指针或引用 的数据成员 }; 对象的定义和使用 （1）对象的的定义 从现在起，“对象”一词专门表示类的实体。\nPoint a,b; //C++特色定义对象 class Point x,y; //兼容C语言特色定义对象 具体定义方式和结构体类似\n（2）对象的动态建立和释放 利用new运算符可以动态地分配对象空间，delete运算符释放对象空间。 用new运算动态分配得到的对象是无名的，它返回一个指向新对象的指针的值，即分配得到是对象的内存单元的起始地址。程序通过这个地址可以间接访问这个对象，因此需要定义一个指向类的对象的指针变量来存放该地址。显然，用new建立的动态对象是通过指针来引用的。\n在执行new运算时，如果内存不足，无法开辟所需的内存空间，C++编译器会返回一个0值指针。\n#include\u0026lt;iostream\u0026gt; using namespace std; class Box { public: int width, length, height; }; int main() { Box * p=new Box; p-\u0026gt;width=10; p-\u0026gt;length=20; p-\u0026gt;height=30; 1 cout\u0026lt;\u0026lt;p-\u0026gt;width\u0026lt;\u0026lt;\u0026#34;\\t\u0026#34;\u0026lt;\u0026lt;p-\u0026gt;length\u0026lt;\u0026lt;\u0026#34;\\t\u0026#34;\u0026lt;\u0026lt;p-\u0026gt;height\u0026lt;\u0026lt;endl; delete p; return 0; （3）对象成员的引用 访问对象中的成员可以有3种方法：\n①通过对象名和对象成员引用运算符（.）访问对象中的成员；\n②通过指向对象的指针和指针成员引用运算符（-\u0026gt;）访问对象中的成员；\n③通过对象的引用变量和对象成员引用运算符（.）访问对象中的成员；\n需要注意，从类外部只能访问类公有的成员\nvoid caller1() { Data A, *p, *p1; //定义对象指针变量 p1=\u0026amp;A; //p1指向对象A p1-\u0026gt;data=100; //正确，类外部可以访问类的public数据成员 p1-\u0026gt;fun(1,2,3); //正确，类外部可以访问类的public成员函数 p = new Data; //动态分配Data对象 p-\u0026gt;data=100; //正确，类外部可以访问类的public数据成员 p-\u0026gt;fun(1,2,3); //正确，类外部可以访问类的public成员函数 delete p; //撤销p所指向的Data对象 } void caller1() { Data A, \u0026amp;r=A; //定义对象引用变量 r.data=100; //正确，类外部可以访问类的public数据成员 r.fun(1,2,3); //正确，类外部可以访问类的public成员函数 } （4）对象的赋值 如果一个类定义了两个或多个对象，则这些同类的对象之间可以互相赋值。这里所指的对象的“值”是指对象中所有数据成员的值。\n（5）对象、对象指针或对象引用作为函数的参数和返回值 当形参是对象时，实参要求是相同类的对象名，C++不能对类对象进行任何隐式类型转换。此时形参是实参对象的副本。实际编程中，传递对象时需要考虑类的规模带来的调用开销，如果开销很大时建议不用对象作为函数参数。\n当形参是对象指针时，实参要求是同类对象的指针，C++不能对对象指针进行任何隐式类型转换。采用地址传递方式，在函数中若按间接引用方式修改了形参对象本质上就是修改实参对象。因此，使用对象指针作为函数参数可以向主调函数传回变化后的对象。\n当形参是对象引用时，实参要求是同类的对象，其功能与对象指针相似。\n#include \u0026lt;iostream\u0026gt; using namespace std; void func1(Data a,Data *p,Data \u0026amp;r) { a.data=100; p-\u0026gt;data=200; r.data=300; } int main() { Data A, B, C; A.fun(1,2,3); B.fun(4,5,6); C.fun(7,8,9); func1(A,\u0026amp;B,C);//将对象A、B的地址、对象C的引用传递到函数func1 return 0; 如果不希望在函数中修改实参对象的值，函数形参可以作const限定\nvoid func2(Data a,const Data *p,const Data \u0026amp;r) { a.data=100; p-\u0026gt;data=200; //错误，左值是const对象 r.data=300; //错误，左值是const对象 } 函数返回值可以是对象、对象指针或对象引用。函数返回对象指针或引用，本质上返回的是对象的地址而不是它的存储内容，因此不要返回局部对象的指针或引用，因为它在函数返回后是无效的。\nData* func() { Data a; Data *p=\u0026amp;a; return p; //返回局部对象a的指针p } void caller() { Data *p1; p1=func(); p1-\u0026gt;data=100; //a已不存在，引用错误 } 构造函数 （1）什么是构造函数 在类的对象创建之处就会被执行，用来对数据成员（公有还是私有都可以）进行赋值，函数的名字要和类的名字相同。 类的数据成员是不能在类定义时初始化的，因为本身不分配存储空间如果一个类中所有的数据成员是公有的，则可以在定义对象时对数据成员进行初始化，如果类中的数据成员是私有的，如private的或protected的，就不能用这种方法初始化，因为外部不能直接访问私有的数据成员。构造函数不需要人为调用，而是在建立对象时自动被执行。\n（2）构造函数的定义 与其他任何函数一样，构造函数可以声明为内联的。\n#include \u0026lt;iostream\u0026gt; using namespace std; class Cuboid { //Cuboid类表示长方体 public: Cuboid(int l,int h, int d); //构造函数 int volumn() { return length*height*depth; } //计算体积 private: int length,height,depth; //长、高、深 }; Cuboid::Cuboid(int l,int h,int d) //外部定义的构造函数 { length=l, height=h, depth=d; //初始化数据成员 cout\u0026lt;\u0026lt;\u0026#34;Cuboid: \u0026#34;\u0026lt;\u0026lt;\u0026#34;L=\u0026#34;\u0026lt;\u0026lt;l\u0026lt;\u0026lt;\u0026#34; ,H=\u0026#34;\u0026lt;\u0026lt;h\u0026lt;\u0026lt;\u0026#34; ,D=\u0026#34;\u0026lt;\u0026lt;d\u0026lt;\u0026lt;endl; } int main() { Cuboid a(1,2,3); //定义长方体对象a，调用构造函数初始化 cout\u0026lt;\u0026lt;\u0026#34;volumn=\u0026#34;\u0026lt;\u0026lt;a.volumn()\u0026lt;\u0026lt;endl; //输出体积 Cuboid b(10,20,30); //定义长方体对象b，调用构造函数初始化 cout\u0026lt;\u0026lt;\u0026#34;volumn=\u0026#34;\u0026lt;\u0026lt;b.volumn()\u0026lt;\u0026lt;endl; //输出体积 return 0; 构造函数一般声明为公有的（public），因为创建对象通常是在类的外部进行的。如果构造函数声明为保护的（protected）或私有的（protected），那就意味着在类外部创建对象（并调用构造函数）是错误的。\n每个构造函数应该为每个数据成员提供初始化。否则将使那些数据成员处于未定义的状态。而使用一个未定义的成员是错误的。\n构造函数初始化列表 与普通函数一样，构造函数具有函数名、形参列表和函数体。与其他函数不同的是，构造函数可以包含一个构造函数初始化列表。与其他的成员函数一样，构造函数可以定义在类的内部或外部，但构造函数初始化列表只在构造函数的定义中而不是函数原型声明中指定。\n#include \u0026lt;iostream\u0026gt; using namespace std; class Cuboid { //Cuboid类表示长方体 public: Cuboid(int l,int h, int d); //构造函数 int volumn() { return length*height*depth; }; //计算体积 private: int length,height,depth; //长、高、深 }; Cuboid::Cuboid(int l,int h,int d) :length(l),heght(h),depth(d) //带构造函数初始化列表的构造函数 { cout\u0026lt;\u0026lt;\u0026#34;Cuboid: \u0026#34;\u0026lt;\u0026lt;\u0026#34;L=\u0026#34;\u0026lt;\u0026lt;l\u0026lt;\u0026lt;\u0026#34; ,H=\u0026#34;\u0026lt;\u0026lt;h\u0026lt;\u0026lt;\u0026#34; ,D=\u0026#34;\u0026lt;\u0026lt;d\u0026lt;\u0026lt;endl; } 如果没有为类类型的数据成员提供初始化列表，编译器会隐式地使用该成员的默认构造函数。如果那个类没有默认构造函数，则编译器会报告错误。在这种情况下，为了初始化类类型的数据成员，必须提供初始化列表。\n一般地，没有默认构造函数的成员，以及const或引用类型的成员，都必须在构造函数初始化列表中进行初始化。\n（3）构造函数的重载 在一个类中可以定义多个构造函数版本，即构造函数允许被重载，只要每个构造函数的形参列表是唯一的\n尽管在一个类中可以包含多个构造函数，但是对于每一个对象来说，建立对象时只执行其中一个，并非每个构造函数都被执行。\n（4）带默认参数的构造函数 构造函数的参数允许使用默认值。对类的设计者来说，使用默认参数可以减少代码重复；对类的使用者者来说，使用默认参数可以方便地用适当的参数进行初始化。\n必须在类的内部指定构造函数的默认参数，不能在类外部指定默认参数。\n如果构造函数的全部参数都指定了默认值，则在定义对象时可以给一个或几个实参，也可以不给出实参。这时，就与无参数的构造函数有歧义了。\nclass Point { public: Point(){x=y=0;} Point(int a=1,int b=1):x(a),y(b) { }; void display() { cout\u0026lt;\u0026lt;\u0026#34;x=\u0026#34;\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34; ,y=\u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl; } private: int x,y; //坐标值 }; int main() { Point k; //出现歧义，既可以x=0，y=0；也可以x=1，y=1 return 0; } 一般地，不应同时使用构造函数的重载和带默认参数的构造函数。\n默认构造函数和复制构造函数 （1）定义默认构造函数 默认构造函数就是在没有显式提供初始化式时调用的构造函数，它 是一个不带参数的构造函数。如果定义某个类的对象时没有提供初 始化式就会使用默认构造函数。\n它由不带参数的构造函数，或者所有形参均是默认参数的构造函数 定义。\n任何一个类有且只有一个默认构造函数。如果定义的类中没有显式 定义任何构造函数，编译器会自动为该类生成默认构造函数，称为 合成默认构造函数.一个类哪怕只定义了一个构造函数，编译器也不会再生成默认构造 函数。一般地，任何一个类都应定义一个默认构造函数。\n（2）隐式类类型转换 #include \u0026lt;iostream\u0026gt; using namespace std; class Data { //Data类定义 public: Data(const string\u0026amp; str=\u0026#34;\u0026#34;) : s1(str) { } //const限定 引用字符串类型 为str变量设置默认初值 提供初始化列表 void SetString(const Data\u0026amp; r) //期待的是Data类型的对象 { s1=r.s1; } void print() { cout\u0026lt;\u0026lt;s1\u0026lt;\u0026lt;endl; } private: string s1; } int main() { Data a,b,c(\u0026#34;world\u0026#34;); string i=\u0026#34;string\u0026#34;; a.SetString(c); b.SetString(string(\u0026#34;world\u0026#34;)); //隐式转换 a.print(); b.print(); Data d=Data(i); //隐式转换 d.print(); return 0; 类名(const 指定数据类型\u0026amp; obj)\nC++关键字explicit用来修饰类的构造函数，指明该构造函数是显式 的。explicit关键字只能用于类内部的构造函数声明上，在类定义外 部不能重复它。\n可以禁止由构造函数定义的隐式转换，方法是通过将构造函数声明 为explicit，来防止在需要隐式转换的上下文中使用构造函数。\n（3）复制构造函数与合成复制构造函数 ►复制构造函数又称为拷贝构造函数，它是一种特殊的构造函数。它 的作用就是用一个已经生成的对象来初始化另一个同类的对象。\nPoint pt1(10,20); Point pt2=pt1 复制构造函数定义的一般形式为：\n类名(const 类名\u0026amp; obj) { 函数体 } class Point { //Point类 public: Point() : x(0), y(0) { } //默认构造函数 Point(const Point\u0026amp; r) : x(r.x), y(r.y) { } //复制构造函 数 Point(int a,int b) : x(a), y(b) { } //带参数构造函数 private: int x,y; }; ►复制构造函数有且只有一个本类类型对象的引用形参，通常使用const限定。\n每个类必须有一个复制构造函数。如果类没有定义复制构造函数， 编译器就会自动合成一个，称为合成复制构造函数 与合成默认构造函数不同，即使定义了其他构造函数，编译器也会合成复制构造函数。\n►以下3种情况会使用复制构造函数。\n►（1）用一个对象显式或隐式初始化另一个对象。\n►C++支持两种初始化形式：复制初始化和直接初始化。复制初始化 使用等号（=），而直接初始化将初始化式放在圆括号中。\n►复制初始化和直接初始化是有区别的：直接初始化会调用与实参匹 配的构造函数；而复制初始化总是调用复制构造函数。\nPoint pt1(10,20); Point pt2=pt1; //复制初始化 Point pt3(pt1); //直接初始化 （2）函数参数按值传递对象时或函数返回对象时 当函数形参为对象类型，而非指针和引用类型时，函数调用按值传 递对象，即编译器调用复制构造函数产生一个实参对象副本传递到 函数中。\n类似地，以对象类型作为返回值时，编译器调用复制构造函数产生 一个return语句中的值的副本返回到调用函数。\n（3）根据元素初始化式列表初始化数组元素时。\n总的来说，正是有了复制构造函数，函数才可以传递对象和返回对 象，对象数组才能用初值列表的形式初始化。\n（4）深复制与浅复制 是合成复制构造函数和复制构造函数的区别。 若复制对象但未复制资源内容称为浅复制， 如果一个拥有资源（如用new得到的动态内存）的类对象发生复制 的时候，若对象数据与资源内容一起复制，称为深复制。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string.h\u0026gt; using namespace std; class CA { public: CA(int b,char *cstr) //构造函数 { a=b; str=new char[b]; strcpy(str,cstr); } CA(const CA \u0026amp;C) //复制构造函数 { a=C.a; str=new char[a]; //深复制，浅复制则写成str=C.str; if(str!=0) strcpy(str,C.str); } void show() { cout\u0026lt;\u0026lt;str\u0026lt;\u0026lt;endl; } ~CA() //析构函数 { delete str; } private: int a; char *str; }; int main() { CA a(10,\u0026#34;hello\u0026#34;); CA b=a; b.show(); return 0; } 析构函数 （1）析构函数的定义 析构函数：当对象脱离其作用域时（例如对象所在的函数已调用完 毕），系统会自动执行析构函数。析构函数往往用来做“清理善后” 的工作（例如在建立对象时用new开辟了一段内存空间，则在该对 象消亡前应在析构函数中用delete释放这段存储空间）。\n一个类可以有多个构造函数，但是只能有一个析构函数。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string.h\u0026gt; using namespace std; class Point { public: Point(int a,int b):x(a),y(b){} //带参数的构造函数 ~Point() //析构函数 { cout\u0026lt;\u0026lt;\u0026#34;析构函数被调用。\u0026#34;\u0026lt;\u0026lt;endl; } void show() { cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34;,\u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl; } private: int x,y; }; int main() { Point pt1(10,20); pt1.show(); return 0; （2）合成析构函数 与复制构造函数不同，编译器总是会为类生成一个析构函数，称为合成析构函数 需要注意，合成析构函数并不删除指针成员所指向的对象，它需要 程序员显式编写析构函数去处理。\n（3）何时需要编写析构函数 需要注意，合成析构函数并不删除指针成员所指向的对象，它需要 程序员显式编写析构函数去处理。\n如果类需要析构函数，则该类几乎必然需要定义自己的复制构造函 数和赋值运算符重载，这个规则称为析构函数三法则(三个同时出现)\n#include \u0026lt;iostream\u0026gt; using namespace std; class CString { //CString类 public: CString(const char *str); //单个参数构造函数 ~CString(); //析构函数 void show() { cout\u0026lt;\u0026lt;p\u0026lt;\u0026lt;endl; } //显示字符串 private: char *p; //存储字符串动态内存区 CString::CString(const char *str) { p=new char[strlen(str)+1]; //为存储str动态分配内存 strcpy(p,str); //复制str到p cout\u0026lt;\u0026lt;\u0026#34;构造：\u0026#34;\u0026lt;\u0026lt;str\u0026lt;\u0026lt;endl; } CString::~CString() { cout\u0026lt;\u0026lt;\u0026#34;析构：\u0026#34;\u0026lt;\u0026lt;p\u0026lt;\u0026lt;endl; delete [] p; //析构函数必须是否p占用的内存 } int main() { CString s1(\u0026#34;C++\u0026#34;), s2=\u0026#34;JavaScript\u0026#34;; //定义对象 s1.show(); s2.show(); return 0; } （4）构造函数和析构函数的调用次序 构造函数和析构函数的调用很像一个栈的先进后出，调用析构函数 的次序正好与调用构造函数的次序相反。最先被调用的构造函数， 其对应的（同一对象中的）析构函数最后被调用，而最后被调用的 构造函数，其对应的析构函数最先被调用。\n","permalink":"https://tassel234.github.io/posts/note/c++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1-1/","summary":"类的定义 （1）定义类 面向程序设计更偏向于把每一个细节都做好，从每一个零件开始是制造汽车。面向对象编程偏向于把很多细小的零件已经主装好了，保留集成了很多接口，只需要把部件进行拼接就可以得到产品。 面向对象编程的意义在于自然界都是由实体组成，面向对象也是软件开发的主流方式。 面对对象的三","title":"C++学习笔记-1（类和对象-1）"},{"content":"注释语句 /* ......块注释内容 */ //......行注释内容 输入和输出 标准输入输出流库的头文件\ncin输入时，为了分隔多项数据，默认要求在键盘输入数据之间使用空格、Tab键、回车作为分隔符。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; int main() { bool v; int a,m,n; double x,y,z,p,f; float f1;//除了已经定义的变量，下面出现的oct,setw都是关键字 cin\u0026gt;\u0026gt;boolalpha\u0026gt;\u0026gt;v; //输入：true cin\u0026gt;\u0026gt;oct\u0026gt;\u0026gt;a\u0026gt;\u0026gt;hex\u0026gt;\u0026gt;m\u0026gt;\u0026gt;dec\u0026gt;\u0026gt;n;//输入：144 46 -77 cin\u0026gt;\u0026gt;p\u0026gt;\u0026gt;f\u0026gt;\u0026gt;f1\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;z;//输入：3.14 3.14 3.14 3.14159 0.1 0.1e1 cout\u0026lt;\u0026lt;v\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;boolalpha\u0026lt;\u0026lt;v\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;noboolalpha\u0026lt;\u0026lt;v\u0026lt;\u0026lt;endl;//输出：1 true 1 cout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;p\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;a*p\u0026lt;\u0026lt;endl;//输出：100 3.14 314 cout\u0026lt;\u0026lt;hex\u0026lt;\u0026lt;m\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;oct\u0026lt;\u0026lt;m\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;dec\u0026lt;\u0026lt;m\u0026lt;\u0026lt;endl;//输出：46 106 70，分别是16，8，10进制 cout\u0026lt;\u0026lt;showbase\u0026lt;\u0026lt;hex\u0026lt;\u0026lt;m\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;oct\u0026lt;\u0026lt;m\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;dec\u0026lt;\u0026lt;m\u0026lt;\u0026lt;endl; //输出：0x46 0106 70 cout.precision(5); cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;z\u0026lt;\u0026lt;endl;//输出：3.1416 0.1 1 cout\u0026lt;\u0026lt;fixed\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;z\u0026lt;\u0026lt;endl;//输出：3.14159 0.10000 1.00000 cout\u0026lt;\u0026lt;scientific\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;z\u0026lt;\u0026lt;endl; //输出：3.14159e+000 1.00000e-001 1.00000e+000 cout\u0026lt;\u0026lt;left\u0026lt;\u0026lt;setw(6)\u0026lt;\u0026lt;n\u0026lt;\u0026lt;endl; //输出：-77 cout.width(6); cout\u0026lt;\u0026lt;right\u0026lt;\u0026lt;n\u0026lt;\u0026lt;endl; //输出：_ _ _-77 cout\u0026lt;\u0026lt;setw(10)\u0026lt;\u0026lt;77\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;setfill(\u0026#39;0\u0026#39;)\u0026lt;\u0026lt;setw(10)\u0026lt;\u0026lt;77\u0026lt;\u0026lt;endl; //输出：_ _ _ _ _ _ _77 0000000077 cout\u0026lt;\u0026lt;fixed\u0026lt;\u0026lt;setprecision(5)\u0026lt;\u0026lt;f\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;setprecision(9)\u0026lt;\u0026lt;f\u0026lt;\u0026lt;endl; //输出：3.14000 3.140000000 cout\u0026lt;\u0026lt;showpos\u0026lt;\u0026lt;1\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;0\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;endl; //输出：+1 +0 -1 cout\u0026lt;\u0026lt;noshowpos\u0026lt;\u0026lt; 1\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;0\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;endl; //输出：1 0 -1 return 0; } 顺序结构 所谓顺序结构是指：语句以其出现的顺序执行。\n分支 if语句 if (a\u0026gt;b) { x=a+b; y=a-b; } else { x=a-b; y=a+b; } a=5,b=2; if ( a ) x=a*10; //等价于a!=0 switch语句 switch ( 表达式 ) { case 常量表达式1 : … 语句序列1 case 常量表达式2 : … 语句序列2 ┇ case 常量表达式n : … 语句序列n default : … 默认语句序列//其他值都在这，无论表达式的值是什么（特指case没有的值），写在最后的该语句都会被执行 } switch语句中case分支的语句序列可以是一个语句，也可以是任意多的语句序列，也可以没有语句；\nswitch语法中各个case分支和default分支的出现次序在语法上没有规定，但次序的不同安排会影响执行结果。\nswitch (n) { default: cout\u0026lt;\u0026lt;\u0026#34;0\u0026#34;;//输入1或2不执行此语句 case 1 : cout\u0026lt;\u0026lt;\u0026#34;1\u0026#34;; case 2 : cout\u0026lt;\u0026lt;\u0026#34;2\u0026#34;; } switch语法中default分支是可选的，若没有default分支且没有任何case标号的值相等时，switch语句将什么也不做，直接执行后续语句。\nswitch语句的分支表达式可以是C++语言的任意表达式，但其值必须是整数（含字符类型）、枚举类型。\n更常见的switch结构应该如下，它提供了程序多分支选择执行流程。\nswitch ( 表达式 ) { case 常量表达式1: … 语句序列1; break; case 常量表达式2: … 语句序列2; break; ┇ case 常量表达式n: … 语句序列n; break; default : … 默认语句序列 } //成绩分层程序 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; int main() { int g; cin\u0026gt;\u0026gt;g; //输入成绩等级 switch(g) { case \u0026#39;A\u0026#39;:cout\u0026lt;\u0026lt;\u0026#34;85～100\\n\u0026#34;; break; case \u0026#39;B\u0026#39;:cout\u0026lt;\u0026lt;\u0026#34;70～84\\n\u0026#34;; break; case \u0026#39;C\u0026#39;:cout\u0026lt;\u0026lt;\u0026#34;60～69\\n\u0026#34;; break; case \u0026#39;D\u0026#39;:cout\u0026lt;\u0026lt;\u0026#34;\u0026lt;60\\n\u0026#34;; break; default: cout\u0026lt;\u0026lt;\u0026#34;error\\n\u0026#34;; } return 0; } 选择语句的嵌套 if第一种方式\nif ( 表达式1 ) 语句1 else if ( 表达式2 ) 语句2 else if ( 表达式3 ) 语句3 ...... else if ( 表达式n ) 语句n else 语句m if第二种方式\nif ( 表达式1 ) if ( 表达式2 ) 语句1 else 语句2 else if ( 表达式3 ) 语句3 else 语句4 switch的嵌套\n#include \u0026lt;iostream\u0026gt; using namespace std; int main() { int y,m,d,Days; cin\u0026gt;\u0026gt;y\u0026gt;\u0026gt;m\u0026gt;\u0026gt;d; //输入日期 switch(m) { //计算每月的天数 case 2 : Days=28; if((y%4==0\u0026amp;\u0026amp;y%100!=0)|| (y%400==0)) Days++; //闰年天数加1 break; case 4 : case 6 : case 9 : case 11 : Days=30;break; default: Days=31; //其余月份为31天 } d++; if (d\u0026gt;Days) d=1,m++; //判断月末 if (m\u0026gt;12) m=1,y++; //判断年末 cout\u0026lt;\u0026lt;y\u0026lt;\u0026lt;“-”\u0026lt;\u0026lt;m\u0026lt;\u0026lt;“-”\u0026lt;\u0026lt;d\u0026lt;\u0026lt;endl; //输出第二天的日期 return 0; } 循环 基本语法 循环语句大致可以分为下面三种\n1、while语句\n2、do while语句（几乎和while等价，可以相互转化，区别在于do while多少要执行一次）\n3、for语句\nfor语句的说明。\n►（1）整个循环过程中表达式1只求解一次；作用是给循环控制变量赋初值。\n►（2）表达式2相当于是for的循环条件。\n►（3）表达式3是重复执行的内容；通常是改变循环控制变量值的语句。\n//判断质数 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int i,m; cin\u0026gt;\u0026gt;m;//从2到m-1之间逐一检查是否被m整除 for (i=2 ; i\u0026lt;=m-1 ; i++) if (m % i==0) break; //如果整除则结束检查 if (i==m) cout\u0026lt;\u0026lt;\u0026#34;Yes\u0026#34;\u0026lt;\u0026lt;endl; //根据循环结束位置判断是否素数 else cout\u0026lt;\u0026lt;\u0026#34;No\u0026#34;\u0026lt;\u0026lt;endl; return 0;\t} ►break语句的作用是结束switch语句和循环语句的运行，转到后续语句，语法形式为：break；\n►break语句只能用在switch语句和循环语句（while、do、for）中，不得单独使用。\n►continue语句的作用是在循环体中结束本次循环，直接进入下一次循环，语句形式为：continue；（可以用来求解奇书偶数的和） ► continue语句只能用在循环语句（while、do、for）中，不能单独使用。\n循环语句的选用 ►计数型循环常使用for语句\n►计数型循环用于处理已知循环次数的循环过程。\n►控制变量在每次循环时都要发生规律性变化（递增或递减），当控制变量达到预定的循环次数时，循环就结束。\n►条件型循环常使用while语句和do while语句。可以写较为抽象的条件。\n►条件型循环用于处理循环次数未知的循环过程，称为“不定次数循环”。\n►在条件型循环中，由于事先不能准确知道循环的次数，因此循环控制是由条件来判定的。在每次循环时检测这个条件，当条件一旦满足，循环就结束。\n//求π的近似值 π/4≈1-1/3+1/5-1/7+1/9-…，直到最后一项的绝对值小于10-7为止。 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; int main() { double s=1,pi=0,n=1,t=1; while (fabs(t)\u0026gt;1e-7) pi=pi+t, n=n+2, s=-s, t=s/n; cout\u0026lt;\u0026lt;pi*4\u0026lt;\u0026lt;endl; return 0; } 循环语句应用举例 百元买鸡问题\n百钱买百鸡问题：有人有一百块钱，打算买一百只鸡。公鸡一只5元，母鸡一只3元，小鸡3只1元，求应各买多少？\n//百元买鸡问题 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int x,y,z; for (x=0; x\u0026lt;=20; x++) //枚举公鸡的可能数量，最多为20 for (y=0; y\u0026lt;=33; y++) //枚举母鸡的可能数量，最多为33 for (z=0; z\u0026lt;=100; z++)//枚举小鸡的可能数量，最多为100 if(z%3==0\u0026amp;\u0026amp;x+y+z==100\u0026amp;\u0026amp;5*x+3*y+z/3==100)//约束条件 cout\u0026lt;\u0026lt;\u0026#34;公鸡=\u0026#34;\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34;,母鸡=\u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;\u0026#34;,小鸡=\u0026#34;\u0026lt;\u0026lt;z\u0026lt;\u0026lt;endl; return 0; } //百元买鸡问题（二重循环优化） #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int x,y,z; for (x=0; x\u0026lt;=20; x++) //枚举公鸡的可能数量，最多为20 for (y=0; y\u0026lt;=33; y++) { //枚举母鸡的可能数量，最多为33 z=100-x-y; //小鸡的数量根据约束条件求得 if (z%3==0 \u0026amp;\u0026amp; 5*x+3*y+z/3==100) //约束条件 cout\u0026lt;\u0026lt;\u0026#34;公鸡=\u0026#34;\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34;,母鸡=\u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;\u0026#34;,小鸡=\u0026#34;\u0026lt;\u0026lt;z\u0026lt;\u0026lt;endl;} return 0; } //百元买鸡问题（一重循环） #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { int rooster, hen, chick; int count; count = 0; //设公鸡r只,母鸡h只,雏鸡c只 //由计算可得,r = (4 * c - 300) / 3 //但是必须使等式有意义,即r\u0026gt;=0,即可求解出r的范围:c\u0026gt;=75 //此外,因为1钱可买3雏鸡,雏鸡的数量c必须是3的整数倍* //经检验,75是\u0026gt;=75且能被三整除的最小整数 //由*可知,雏鸡增加的数量也必须为3的整数倍,所以变量c每次加3 for(chick = 75; chick \u0026lt;= 300; chick = chick + 3) //这条语句限定了chick的范围 75~300 { count++; if ((4 * chick - 300) % 3 == 0)//rooster表达式递增且大于0,但要保证为整数 { rooster = (4 * chick - 300) / 3; hen = (600 - 7 * chick) / 3;//这里无需检验hen是否为整数,因为hen=100-r-c,且前面保证了r,c为整数 if (hen \u0026gt;= 0)//因为hen的表达式递减,这条语句限定了hen的范围\u0026gt;0 printf(\u0026#34;Rooster: %d, Hen: %d, Chick: %d\\n\u0026#34;, rooster, hen, chick); else break; } } printf(\u0026#34;Total count: %d\u0026#34;, count); return 0; } 函数 函数的定义和使用 （1）函数的定义和函数的参数\n返回类型可以是C++除数组之外的内置数据类型或自定义类型。 函数可以不返回数据，此时返回类型应写成void，表示没有返回值。\n#include \u0026lt;iostream\u0026gt; using namespace std; int IsPrime(int m) //求素数函数 { //枚举法求m是否素数 int i; for (i=2 ; i\u0026lt;=m-1 ; i++) if (m % i==0) return 0; //不是素数返回0 return 1; //是素数返回1 } int main() { int m; cin\u0026gt;\u0026gt;m; if (IsPrime(m)) cout\u0026lt;\u0026lt;\u0026#34;Yes\u0026#34;\u0026lt;\u0026lt;endl; //是素数输出Yes else cout\u0026lt;\u0026lt;\u0026#34;No\u0026#34;\u0026lt;\u0026lt;endl; //不是素数输出No return 0; } 1）函数定义时指定的形参，在未进行函数调用前，并不实际占用 内存中的存储单元。\n2）只有在发生函数调用时，形参才分配实际的内存单元，接受从 主调函数传来的数据。\n3）当函数调用结束后，形参占用的内存单元被自动释放。\n值传递（pass-by-value）过程中，形参作为被调函数的内部变量来处理，即开辟内存空间以存放由主调函数复制过来的实参的值，从而成为实参的一个副本。实参数据传递给形参是单向传递，即只能由实参传递给形参，而不能由形参传回给实参。\n函数调用时提供给被调函数的参数称为实际参数（arguments）， 简称实参。\n实参必须有确定的值，因为调用函数会将它们传递给形参。实参可 以是常量、变量或表达式，还可以是函数的返回值。例如：\nx = max(a,b); //max函数调用，实参为a,b y = max(a+3,128); //max函数调用，实参为a+3,128 z = max(max(a,b),c); //max函数调用，实参为max(a,b),c （2）函数的声明与内联函数\n声明时使用函数原型（function prototype）。其作用是提供函数调用所必须的接口信息，函数原型可以没有形式参数的名字，到后面函数定义可以再写。但为了调用函数原型必须放在调用之前，而函数定义可以放在函数调用之后。\nint gcd(int m, int n) //求最大公约数，gcd函数实现在后 { int r; while (n!=0) { //欧几里德算法，举例是：m=9, n=6 ① r=3, m=6, n=3 ② r=0, m=3, n=0 r = m % n ; //r为m/n的余数 m = n ; //则gcd(m,n)=gcd(n,r)=... n = r ; //r=0时n即是gcd } return m; } C++提供一种提高函数效率的方法，即在编译时将被调函数的代码 直接嵌入到主调函数中，取消调用这个环节。这种嵌入到主调函数 中的函数称为内联函数（inline function）。\ninline 返回类型 函数名(形式参数列表) { 函数体 } 但因为过于复杂的函数内联会导致错误，内联函数中不允许用循环语句和switch语句。\n函数的设计 默认参数\nint add(int x=5,int y=6) 可以这样调用。 add(10,20); //10+20 add(10); //10+6 add(); //5+6\n可以设置多个默认参数，设置的顺序为自右向左，换言之，要为某个参数设置默认值，则它右边的所有参数必须都是默认参数。\n默认值可以是常量、全局变量，甚至是一个函数调用，但不可以是局部变量。 函数重载 就是可以取同名的函数。\n函数重载的使用说明：\n（1）重载函数的形参必须不同（个数不同或类型不同）。\n（2）编译程序将根据实参和形参的类型及个数的最佳匹配来选择调用哪一个函数。\n（3）不要将不同功能的函数声明为重载函数，以免出现调用结果的误解、混淆。\n函数模板与库函数的调用\n函数模板（function template）是一个独立于类型的函数，可作为一种模式，产生函数的特定类型版本。\ntemplate\u0026lt;typename T\u0026gt; T abs(T x) { return x\u0026lt;0?-x:x; } 标准库函数的连接在开发环境中是默认的，一般可以不用特别设置，只需要在文件开头输入#include 声明一下就行。包括stl,c语言库等。\n对于一些特殊的由其他人编写的库，一般提前下载，然后再按配置说明进行安装就行。\n函数的调用 （1）函数的嵌套调用\n在调用一个函数的过程中，又调用另一个函数，称为函数的嵌套调 用，C++允许函数多层嵌套调用，只要在函数调用前有函数声明即 可。\n（2）函数的递归调用\n可以使用递归解决阶乘，汉诺塔问题的求解。\n作用域、生命期和程序的组织结构 （1）作用域和生命期\n局部变量只能在定义它的区域及其子区域中使用。\n在不同区域中允许定义相同名字的变量，但本质上它们是不同的变量\n如果一个变量所处区域的子区域中有同名的变量，则该变量在子区域无效，有效的是子区域的变量，称为定义屏蔽。\n#include \u0026lt;iostream\u0026gt; using namespace std; void swap(int x,int y) { int t; t=x; x=y; y=t; } int main( ) { int a,b; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; swap(a,b); cout\u0026lt;\u0026lt;\u0026#34;a=\u0026#34;\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026#34;,b=\u0026#34;\u0026lt;\u0026lt;b\u0026lt;\u0026lt;endl; return 0;//最后不交换次序 } #include \u0026lt;iostream\u0026gt; using namespace std; int x,y; void swap() { int t; t=x; x=y; y=t; } int main( ) { int a,b; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; swap(a,b); cout\u0026lt;\u0026lt;\u0026#34;a=\u0026#34;\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026#34;,b=\u0026#34;\u0026lt;\u0026lt;b\u0026lt;\u0026lt;endl; return 0;//会交换次序 作用域是程序中的一段区域。在同一个作用域上，C++程序中每个名字都与唯一的实体对应；如果在不同的作用域上，程序中可以多次使用同一个名字，对应不同作用域中的不同实体。\n实体在包含它的作用域内，从定义或声明的位置开始，按文件行的顺序往后（往下）直到该作用域结束均是可见的，包含作用域内的所有子区域及其嵌套。但是往前就看不到了。\n可以使用extern声明将变量或函数实体的可见区域往前延伸，称为前置声明。\n在全局作用域中，变量或函数实体若使用static修饰，则该实体对于其他源文件是屏蔽的，称为私有的（private）。\n动态存储在分配和释放的形式有两种，一种是由函数调用来自动完 成的，称为自动存储（automatic storage）如默认参数，结构体和类的实例化，一种是由程序员通过 指令的方式来人工完成的，称为自由存储（free storage）\n现代程序设计的观点是，除非有必要尽量少地使用静态存储\nC++语言允许用CPU的寄存器来存放局部变量，称为寄存器变量。 在局部变量前加上register存储类别修饰来定义的，其形式为：\nregister 类型 变量名[=初值] 在局部对象的前面加上static存储类别修饰用来指明对象是静态局 部对象（static local ）\n#include \u0026lt;iostream\u0026gt; using namespace std; int fun() { static int cnt=0; //静态局部变量会保持其值 ，可以做计数器 cnt++; return cnt; } int main() { int i,c; for (i=1;i\u0026lt;=10;i++) c=fun(); cout\u0026lt;\u0026lt;c\u0026lt;\u0026lt;endl; return 0; } （2）程序的组织结构\n函数本质上是全局的，在多文件的程序中，在连接时会检查函数在 全局作用域内是否名字唯一，如果不是则出现连接错误。\n在函数定义前加上static修饰，则函数称为内部函数。内部函数仅在包含它的文件中有效。\n在函数定义前加上extern声明，则函数称为外部函数。C++中所有的函数本质上都是外部函数。因此，上面的extern都可以省略。\n头文件与工程文件\n如果是多文件结构程序，欲在文件中调用别的文件中的函数，需要有函数的声明，而且每个文件均是如此。如果是函数声明比较多的情况下，在每个文件中都写上函数声明不是好办法，很难管理。如果某个函数定义有变动，那么所有含有这个函数声明的调用文件都需要找出来，逐一修改。使用头文件可以解决这个问题，其工作原理是通过将每个源文件中外部函数的函数声明等信息集中写到一个文件中，称为头文件（有别于源文件），而别的源文件只需用文件包含命令将这个头文件包含，则编译时编译器自然就有了函数声明。\n多文件结构程序在编译时需要工程文件来管理，不同的编译器有不 同的工程文件格式。\n多文件编译\n头文件a.h和cpp文件a.cpp\n#include \u0026#34;a.h\u0026#34;//\u0026#34;\u0026#34;表示在工程文件夹寻找，\u0026lt;\u0026gt;是只在系统文件夹找 //直接引用.h头文件 ","permalink":"https://tassel234.github.io/posts/note/c++%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%87%BD%E6%95%B0/","summary":"注释语句 /* ......块注释内容 */ //......行注释内容 输入和输出 标准输入输出流库的头文件 cin输入时，为了分隔多项数据，默认要求在键盘输入数据之间使用空格、Tab键、回车作为分隔符。 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; int main() { bool v; int a,m,n; double x,y,z,p,f; float f1;//除了已经定义的变量，下面出现的oct,setw都","title":"C++入门学习笔记-2(语句和函数)"},{"content":"前言 使用资源 （主）程序员的数学4：图论 算法图解动画软件演示 b站视频图解\n目标指向 了解图的基本知识，可以对图论模型进行数学建模和程序求解。\n图的基础知识 什么是图 在数学中，图是描述于一组对象的结构，其中某些对象对在某种意义上是“相关的”。这些对象对应于称为顶点的数学抽象（也称为节点或点），并且每个相关的顶点对都称为边（也称为链接或线）。通常，图形以图解形式描绘为顶点的一组点或环，并通过边的线或曲线连接。 图形是离散数学的研究对象之一。\n图的表示法 在计算机中表示图的方式由邻接矩阵，关联矩阵，邻接表。\n其他图论术语 度（Degree）：一个顶点的度是指与该顶点相关联的边的条数，顶点v的度记作d(v)。\n对任意图，度的个数之和都是偶数，也就是握手定理。\n迹：如果路径P(u,v)中的边各不相同，则该路径称为u到v的一条行迹。 路（轨道）：如果路径P(u,v)中的顶点各不相同，则该路径称为u到v的一条轨道。 闭的行迹称作回路（Circuit），闭的轨称作圈（Cycle）。\n定理1 设图G的邻接矩阵为A，A的K次幂的（i,j元素）等于在图G中由i到j长度为K的路径数  子图（Sub-Graph）：当图G'=(V',E')其中V‘包含于V，E’包含于E，则G\u0026rsquo;称作图G=(V,E)的子图。每个图都是本身的子图。\n生成子图（Spanning Sub-Graph）：指满足条件V(G') = V(G)的G的子图G'。\n导出子图（Induced Subgraph）：以图G的顶点集V的非空子集V1为顶点集，以两端点均在V1中的全体边为边集的G的子图，称为V1导出的导出子图；以图G的边集E的非空子集E1为边集，以E1中边关联的顶点的全体为顶点集的G的子图，称为E1导出的导出子图。\n补图。点不变，完全图的补线构成的图。\n几类特殊的图 树和森林 联通且不含圈的图称为树，多个不相连的树构成森林。 单个树可以看作一个比较特殊的森林。\n二部图（二分图） 二分图：顶集，且每一条边都有一个顶点在X中，而另一个顶点在Y中。 完全二分图：二分图G中若任意两个X和Y中的顶点都有边相连。若，则图G记作Km,n。 如上图，树是二部图。\n可平面图 图可以被画成边各不相交的图，称为可平面图。\n定理2：欧拉公式 不论什么形状的可平面图（凸多面体），其顶点数V、棱数E、面数F之间总有关系V+F-E=2  其他 完全图：每一对不同顶点间都有边相连的的图，记作Kn。\n正则图：如果图中所有顶点的度皆相等，则此图称为正则图\n图的度序列 定理3：通过度判断一个序列是否为可图化序列 首先把各顶点的度按降序排列形成度序列 。 去掉第一个数字k，然后把前k个数字减1，再按降序排列，循环步骤简化图。  最小生成树 什么是最小生成树 在图（包括赋权图）中，可以找到的路径长度之和最小的树。 可以解决电缆安装问题，只要达到每一个地点就行，形成连通图。\n克鲁斯卡尔算法 属于贪心算法的一种。 按找赋权的大小依次查找，让其不构成圈，最后可以产生最小生成树 。\n普里姆算法 也属于贪心算法的一种。 以某个节点开始，查找赋权小的。\n最小斯坦纳树问题 某些节点可以连（作为中继节点），也可以不连。 NP难的问题，不太可能存在高效的算法。\n最短路径问题 什么是最短路径问题 由一点到另一点所用路径的权值总和最小的问题。\n迪杰斯特拉算法 每一个节点初始化为非常大的数，路径上赋权正常的数字，赋值方式是节点的值加上路径的值。 通过查找可行路径给节点赋值，节点的值往小的地方更新。 满足条件因为使用其他路径时，必须经过点C，但AC成本大于AB成本 但也因为这个限制，权值不能为负，否则可能会出错，这一点不如福特算法 但斯拉特算法也有优点，比如他的速度要快上很多 对于单行道和双向通道值不一致时也可以非常好的解决，这是福特算法做不到的\n欧拉回路与哈密顿圈 欧拉回路 就像七桥问题，把每一个边走且只走一遍，就是欧拉回路。\n形成欧拉回路的充分必要条件是顶点的度都是偶数。\n哈密顿圈 把每一个点走且只走一遍，就是哈密顿圈 。\n是NP完全问题，不太可能存在高效算法。\n狄拉克定理 狄拉克定理：如果图是一个具有至少3个顶点的简单图G，并且图中每个顶点的度数至少为节点数的一半，那么图包含哈密顿图。\n奥尔定理\n奥尔定理是图论在1960年由挪威数学家奥斯汀·奥尔证明的结果，它为图成为哈密顿量提供了充分的条件，从本质上说，具有“足够多的边”的图必须包含哈密顿环。 具体来说，该定理考虑非相邻顶点对的度数之和：如果每个这样的对具有至少等于图中顶点总数的和，则该图为哈密顿图。如果一个总点数至少为3的简单图G满足：G的任意两个不相邻的点u和v度数之和至少为n，即d(u)+d(v)≥n，那么G必然有哈密顿回路。\n","permalink":"https://tassel234.github.io/posts/note/%E5%9B%BE%E8%AE%BA%E5%85%A5%E9%97%A8-1/","summary":"前言 使用资源 （主）程序员的数学4：图论 算法图解动画软件演示 b站视频图解 目标指向 了解图的基本知识，可以对图论模型进行数学建模和程序求解。 图的基础知识 什么是图 在数学中，图是描述于一组对象的结构，其中某些对象对在某种意义上是“相关的”。这些对象对应于称为顶点的数学抽象（也称为节点或点）","title":"图论入门-1"},{"content":"参考资源 python数学建模算法与应用\nhttps://blog.csdn.net/weixin_35757704/article/details/117808073\nhttps://blog.csdn.net/chuididehuayiren/article/details/109765279\n图表解释 第一部分左边\nDep. Variable:即dependent variable，因变量 OLS:普通最小二乘法 least squares：最小化残差平方和 No. Observations:个案数，即样本容量 df residuals：残差自由度(观测数No.Observations - (参数数目Df Model+1))，这里的1是常量参数 df model：模型中自变量（即参数）个数 Covariance Type：协方差阵的稳健性  第一部分右边\nR-squared：R方，判定系数，01间越大越吻合，计算方法为SSR/SST，残差（sse）为0. Adj . R-squared：调整后的R方，利用奥卡姆剃刀修正后的R-squared值 （奥卡姆剃刀是一种理论，认为通用的模型倾向于更简单的参数，正所谓大道至简） F-statistic：F统计量，均方误差/残差的均方误差。值越大, H 0​ 越不可能，从而回归系数显著. F检验，这个值越大越能推翻原假设，值越大说明模型是线性模型，原假设是“我们的模型不是线性模型”。f检验（F-test）， 最常用的别名叫做联合假设检验（英语：joint hypotheses test），此外也称方差比率检验、方差齐性检验。 它是一种在零假设之下，统计值服从F-分布的检验。其通常是用来分析用了超过一个参数的统计模型， 以判断该模型中的全部或一部分参数是否适合用来估计母体。 Prob（F-statistic）：当 prob(F−statistic)\u0026lt;α时，表示拒绝原假设，即认为模型是显著的， 为F-statistic的概率，值越小越能拒绝原假设。 Log likelihood ：对数似然比LLR。值越大，模型拟合得越好。 （Davidson 与MacKinnon年说：对于线性回归模型，不管它误差是不是正态分布， 都不需要过问LM，W，LLR，因为这些信息已被F检验所含有） AIC: AIC=2k−2ln(L)。其中：k是参数的数量，L是似然函数。 它衡量拟合优良性,应选择AIC最小的模型,引入了惩罚项,避免参数过多,过拟合. BIC: 贝叶斯信息准则BIC=kln(n)−2ln(L) ,BIC相比AIC在大数据量时对模型参数惩罚得更多， 导致BIC更倾向于选择参数少的简单模型。  第二部分\nintercept：常数 coef：各自变量的估计系数 std err：系数估计的标准差 t : 衡量显著性的指标，就是我们常用的t统计量，这个值越大越能拒绝原假设。 P\u0026gt;|t|，H0​（系数=0）为真的概率。统计检验中的P值，这个值越小越能拒绝原假设。 [0.025,0.975]: 95％置信区间的下限和上限值  第三部分\nOmnibus :基于峰度和偏度进行数据正态性的检验，通常与Jarque-Bera检验共同使用 属于一种统计测验,测试一组数据中已解释方差是否显著大于未解释方差, 但omnibus不显著,模型也可能存在合法的显著影响, 比如两个变量中有一个不显著, 即便另一个显著.通常用于对比 Prob(Omnibus):将上面的统计数据变成概率 Skewness: 偏度 Kurtosis:峰度 Durbin-Watson:德宾-沃森检验（检验残差自相关最常用的方法），它用于检验一阶自相关性。 自相关系数 − 1 \u0026lt; ρ \u0026lt; 1 ⇒ 0 ≤ D W ≤ 4 -1\u0026lt;ρ\u0026lt;1\\Rightarrow0≤DW≤4 −1\u0026lt;ρ\u0026lt;1⇒0≤DW≤4 并且 D W ＝ 0 ⇔ ρ ＝ １ DW＝0 \\Leftrightarrow ρ＝１ DW＝0⇔ρ＝１　即存在正自相关性 D W ＝ ４ ⇔ ρ ＝ － １ DW＝４\\Leftrightarrow ρ＝－１ DW＝４⇔ρ＝－１即存在负自相关性 D W ＝ ２ ⇔ ρ ＝ ０ DW＝２\\Leftrightarrow ρ＝０ DW＝２⇔ρ＝０　即不存在（一阶）自相关性 Jarque-Bera(JB) :同样是基于峰度和偏度进行数据正态性的检验， 通常与Omnibus检验共同使用， Jarque–Bera检验。如果统计量≫0，则表示数据不是正态分布。 Prob(JB): JB统计量的概率形式 Cond. No :条件数。用于诊断多重共线性  一元线性回归模型 import numpy as np import statsmodels.api as sm import pylab as plt def check(d): x0 = d[0]; y0 = d[1]; d ={\u0026#39;x\u0026#39;:x0, \u0026#39;y\u0026#39;:y0} re = sm.formula.ols(\u0026#39;y~x\u0026#39;, d).fit() #拟合线性回归模型 print(re.summary()) print(re.outlier_test()) #输出已知数据的野值检验 print(\u0026#39;残差的方差\u0026#39;, re.mse_resid) pre=re.get_prediction(d) df = pre.summary_frame(alpha=0.05) dfv = df.values; low, upp = dfv[:,4:].T #置信下限上限 r = (upp-low)/2 #置信半径 num = np.arange(1, len(x0)+1) plt.errorbar(num, re.resid, r, fmt=\u0026#39;o\u0026#39;) plt.show() a = np.loadtxt(\u0026#39;data10_1.txt\u0026#39;) plt.rc(\u0026#39;font\u0026#39;, size=15); plt.plot(a[0], a[1], \u0026#39;o\u0026#39;) plt.figure(); check(a) a2 = a; a2 = np.delete(a2, 8, axis=1) #删除第9列 check(a2); a3 = a2 a3 = np.delete(a3, 4, axis=1); check(a3) 注意几个比较重要的值：R方，F，P，s方（残差的方差）\n多元线性回归 一种使用公式构建，一种使用数组构建。\nplot是制图\nfit是利用极大似然估计进行估计未知参数\nppf反函数\npdf概率密度函数\nimport numpy as np import statsmodels.api as sm import pylab as plt a = np.loadtxt(\u0026#39;data10_2.txt\u0026#39;) plt.rc(\u0026#39;text\u0026#39;, usetex=True); plt.rc(\u0026#39;font\u0026#39;, size=16) plt.plot(a[0], a[2], \u0026#39;*\u0026#39;, label=\u0026#39;$x_1$\u0026#39;) plt.plot(a[1], a[2], \u0026#39;o\u0026#39;, label=\u0026#39;$x_2$\u0026#39;) plt.legend(loc=\u0026#39;upper left\u0026#39;) d = {\u0026#39;x1\u0026#39;: a[0], \u0026#39;x2\u0026#39;: a[1], \u0026#39;y\u0026#39;: a[2]} re = sm.formula.ols(\u0026#39;y~x1+x2\u0026#39;, d).fit() print(re.summary()) yh = re.predict({\u0026#39;x1\u0026#39;: [9, 10], \u0026#39;x2\u0026#39;: [10, 9]}) print(\u0026#39;残差的方差:\u0026#39;, re.mse_resid) print(\u0026#39;预测值：\u0026#39;, yh); plt.show() import numpy as np import statsmodels.api as sm import pylab as plt a = np.loadtxt(\u0026#39;data10_2.txt\u0026#39;) plt.rc(\u0026#39;text\u0026#39;, usetex=True); plt.rc(\u0026#39;font\u0026#39;, size=16) plt.plot(a[0], a[2], \u0026#39;*\u0026#39;, label=\u0026#39;$x_1$\u0026#39;) plt.plot(a[1], a[2], \u0026#39;o\u0026#39;, label=\u0026#39;$x_2$\u0026#39;) plt.legend(loc=\u0026#39;upper left\u0026#39;) X = sm.add_constant(a[:2].T) re = sm.OLS(a[2], X).fit() print(re.summary()) yh = re.predict(np.array([[1,9,10],[1,10,9]])) print(\u0026#39;残差的方差:\u0026#39;, re.mse_resid) print(\u0026#39;预测值：\u0026#39;, yh); plt.show() 多项式回归和逐步回归 看图判定几次函数拟合比较好。\n#程序文件ex10_4.py import numpy as np import statsmodels.formula.api as smf import pylab as plt a = np.loadtxt(\u0026#39;data10_4.txt\u0026#39;); x1 = a[0]; x2 = a[1]; y = a[2] plt.rc(\u0026#39;text\u0026#39;, usetex=True); plt.rc(\u0026#39;font\u0026#39;, size=16) plt.plot(x1, y, \u0026#39;*\u0026#39;, label=\u0026#39;$x_1$\u0026#39;); plt.plot(x2, y, \u0026#39;o\u0026#39;, label=\u0026#39;$x_2$\u0026#39;) d = {\u0026#39;y\u0026#39;: y, \u0026#39;x1\u0026#39;: x1, \u0026#39;x2\u0026#39;: x2} re1 = smf.ols(\u0026#39;y~x1+x2\u0026#39;, d).fit() print(\u0026#39;线性回归的残差方差：\u0026#39;, re1.mse_resid) re2 = smf.ols(\u0026#39;y~x1+x2+I(x1**2)+I(x2**2)\u0026#39;, d).fit() #这里注意写法，\u0026#39;是括起来的，最后有一个d print(\u0026#39;纯二次的残差方差：\u0026#39;, re2.mse_resid) re3 = smf.ols(\u0026#39;y~x1*x2\u0026#39;, d).fit() print(\u0026#39;交叉的残差方差：\u0026#39;, re3.mse_resid) re4 = smf.ols(\u0026#39;y~x1*x2+I(x1**2)+I(x2**2)\u0026#39;, d).fit() print(\u0026#39;完全二次的残差方差：\u0026#39;, re4.mse_resid) print(\u0026#39;预测值：\u0026#39;, re2.predict({\u0026#39;x1\u0026#39;: 170, \u0026#39;x2\u0026#39;: 160})) print(re2.summary()); plt.legend(); plt.show() re2 = smf.ols(\u0026#39;y~x1+x2+I(x1 **2) +I(x2 * *2)\u0026#39;, d).fit() 这里注意写法，\u0026lsquo;是括起来的，最后有一个d\n这个模型寻求残差最小的值。\n#程序文件ex10_5.py import numpy as np import pandas as pd from scipy.stats import t, f import statsmodels.api as sm a = pd.read_excel(\u0026#39;data10_5.xlsx\u0026#39;, header=None) b = a.values; Y=np.hstack([b[:,1],b[:-1,6]]) X = np.vstack([b[:,2:5],b[:-1,7:]]) XX = np.hstack([np.ones((25,1)),X]) cs = np.linalg.pinv(XX) @ Y #最小二乘法拟合参数 print(\u0026#39;拟合的参数为：\u0026#39;, np.round(cs,4)) yb = Y.mean() #计算y的观测值的平均值 yh = XX @ cs #计算y的估计值 q = sum((yh-Y)**2) #计算残差平方和 u = sum((yh-yb)**2) #计算回归平方和 m =3; n = len(Y) #变量个数和样本容量 F = u/m/(q/(n-m-1)) #计算F统计量的值 print(\u0026#39;F=\u0026#39;, round(F,4)) fw = f.ppf(0.95, m, n-m-1) #计算上alpha分位数 print(\u0026#39;F分布的上alpha分位数：\u0026#39;, round(fw,4)) c = np.diag(np.linalg.inv(XX.T @ XX)) ts = cs/np.sqrt(c)/np.sqrt(q/(n-m-1)) #计算t统计量的值 tw = t.ppf(0.975, n-m-1) #计算上alpha/2分位数 print(\u0026#39;t统计量值为：\u0026#39;, np.round(ts,4)) print(\u0026#39;t分布的上alpha/2分位数：\u0026#39;, round(tw,4)) XD = np.delete(XX,1,axis=1) #删除x1的观测值 cs2 = np.linalg.pinv(XD) @ Y #重新拟合参数 print(\u0026#39;x2,x3模型的参数值：\u0026#39;,np.round(cs2,4)) d = {\u0026#39;y\u0026#39;:Y,\u0026#39;x1\u0026#39;:X[:,0],\u0026#39;x2\u0026#39;:X[:,1],\u0026#39;x3\u0026#39;:X[:,2]} md = sm.formula.ols(\u0026#39;y~x1*x2+x1*x3+x2*x3+I(x1**2)+I(x2**2)+I(x3**2)\u0026#39;,d).fit() print(\u0026#39;完全二次项的系数为：\u0026#39;, md.params) 上下和左右合并矩阵的方法。\n左取右不取。\n矩阵有一行是是空的，所以切片要-1。\n#程序文件ex10_6.py import numpy as np import statsmodels.api as sm a = np.loadtxt(\u0026#39;data10_6.txt\u0026#39;) d = {\u0026#39;x1\u0026#39;:a[:,0], \u0026#39;x2\u0026#39;:a[:,1], \u0026#39;x3\u0026#39;:a[:,2], \u0026#39;x4\u0026#39;:a[:,3], \u0026#39;y\u0026#39;:a[:,4]} md1 = sm.formula.ols(\u0026#39;y~x1+x2+x3+x4\u0026#39;,d).fit() print(md1.tvalues) #下面删除变量的t值绝对值最小的 md2 = sm.formula.ols(\u0026#39;y~x1+x2+x4\u0026#39;,d).fit() print(md2.tvalues) #下面删除变量的t值绝对值最小的 md3 = sm.formula.ols(\u0026#39;y~x1+x2\u0026#39;, d).fit() print(md3.summary()) print(\u0026#39;残差方差：\u0026#39;, md3.mse_resid) 每次舍去一个。\n广义线性回归模型 分组的logistic回归模型 处理01型因变量产生的问题。回归函数改为分布在01区间。\n可以使用Yi等于1的比例来代替yi本身作为因变量（yi只可以为0或1）\n分组的适用于样本量大的数据，样本小的不宜分组。\n可以使用ols或glm\n未分组的logistic回归模型 #程序文件ex10_8_1.py import numpy as np import statsmodels.api as sm a = np.loadtxt(\u0026#39;data10_8.txt\u0026#39;) x = np.vstack([a[:, 1:4], a[:, 6:-1]]) y = np.hstack([a[:, 4], a[:, 9]]) d={\u0026#39;x1\u0026#39;: x[:,0], \u0026#39;x2\u0026#39;:x[:,1], \u0026#39;x3\u0026#39;:x[:,2], \u0026#39;y\u0026#39;:y} md = sm.formula.logit(\u0026#39;y~x1+x2+x3\u0026#39;, d).fit() print(md.summary()) md2 = sm.formula.logit(\u0026#39;y~x1+x3\u0026#39;, d).fit() print(md2.summary()) 或使用glm函数\n#程序文件ex10_8_2.py import numpy as np import statsmodels.api as sm a = np.loadtxt(\u0026#39;data10_8.txt\u0026#39;) x = np.vstack([a[:, 1:4], a[:, 6:-1]]) y = np.hstack([a[:, 4], a[:, 9]]) d={\u0026#39;x1\u0026#39;: x[:,0], \u0026#39;x2\u0026#39;:x[:,1], \u0026#39;x3\u0026#39;:x[:,2], \u0026#39;y\u0026#39;:y} md1 = sm.formula.glm(\u0026#39;y~x1+x2+x3\u0026#39;, d, family=sm.families.Binomial()).fit() print(md1.summary()) md2 = sm.formula.glm(\u0026#39;y~x1+x3\u0026#39;, d, family=sm.families.Binomial()).fit() print(md2.summary()) probit回归模型 使用到了分布函数的反函数,ppf\n#程序文件ex10_9.py import numpy as np import statsmodels.api as sm from scipy.stats import norm a = np.loadtxt(\u0026#34;data10_7_1.txt\u0026#34;) x = a[:,0]; pi = a[:,2]/a[:,1]; yi = norm.ppf(pi) X = sm.add_constant(x) md = sm.OLS(yi, X).fit() #构建并拟合模型 print(md.summary()) #输出模型的所有结果 p0= norm.cdf(md.predict([1, 9])) print(\u0026#34;所求比例p0=%.4f\u0026#34;%p0) 偏最小二乘回归 多个因变量和自变量\n 数据标准化 求得相关系数矩阵 分别提出自变量组和因变量组的成分 求回归方程 模型的解释和检验，交叉有效性检验  建议的成分个数，使均方差最小。\n#程序文件ex13_2.py import numpy as np from sklearn.cross_decomposition import PLSRegression from scipy.stats import zscore from sklearn.model_selection import cross_val_predict from sklearn.metrics import mean_squared_error d0 = np.loadtxt(\u0026#39;data13_2.txt\u0026#39;) mu = d0.mean(axis=0) #求均值 s =d0.std(axis=0, ddof=1) #求标准差 r = np.corrcoef(d0.T) #求相关系数矩阵 d = zscore(d0, ddof=1) #数据标准化 a = d[:, :7]; b = d[:, 7:] n = a.shape[1]; m = b.shape[1] #自变量和因变量个数 mse = [] #均方误差初始化 for i in range(1, n+1): #以下确定成分的个数 pls = PLSRegression(i) y_cv = cross_val_predict(pls, a, b) mse.append(mean_squared_error(b, y_cv)) nmin = np.argmin(mse); print(\u0026#39;均方误差：\\n\u0026#39;, mse) print(\u0026#39;建议的成分个数: \u0026#39;, nmin+1) md = PLSRegression(2).fit(a, b) b = md.coef_ #每一列是y对x的回归系数 print(\u0026#39;标准化数据的回归系数(列)：\\n\u0026#39;, b) b0 = np.zeros((n+1, m)) b0[0, :] = mu[n:] - mu[:n]/s[:n] @ b * s[n:] for i in range(m): b0[1:, i] = s[n+i]/s[:n] * b[:,i] print(\u0026#39;(原始数据)y关于x回归系数(列):\\n\u0026#39;, b0) ","permalink":"https://tassel234.github.io/posts/note/python%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AE%97%E6%B3%95-2%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90/","summary":"参考资源 python数学建模算法与应用 https://blog.csdn.net/weixin_35757704/article/details/117808073 https://blog.csdn.net/chuididehuayiren/article/details/109765279 图表解释 第一部分左边 Dep. Variable:即dependent variable，因变量 OLS:普通最小二乘法 least squares：最小化残差平方和 No. Observations:个案数，即样本容量 df residuals：残差自由度(观测数No.Obs","title":"Python数学建模算法-2（回归分析）"},{"content":"python数模算法-1（库的基本使用和绘图基础） 前言 使用学习资源 python数学建模算法与应用（司守奎） 比较全面的建模算法视频（但编程语言是matlab）\n目标指向 只需要会看那些代码并运行实现一次代码和理解用途就可以了，需要使用的时候查阅复制粘贴就可以了。\n算法具体实现的逻辑步骤要搞清楚，锻炼一些编程思想，可以对程序进行合理的修改。\n编程环境配置 conda-python3.10.9\nlatex（可无）\n库的使用 numpy对数组 数组生成\nimport numpy as np a1 = np.array([1, 2, 3, 4]) #生成整型数组 a2 = a1.astype(float) a3 = np.array([1, 2, 3, 4], dtype=float) #浮点数 print(a1.dtype); print(a2.dtype); print(a3.dtype) b = np.array([[1, 2, 3], [4, 5, 6]]) c = np.arange(1,5) #生成数组[1, 2, 3, 4] d = np.linspace(1, 4, 4) #前面是范围，后面是分割数，生成数组[1, 2, 3, 4] e = np.logspace(1, 3, 3, base=2) #生成等比数列数组[2, 4, 8] import numpy as np a = np.ones(4, dtype=int) #输出[1, 1, 1, 1] b = np.ones((4,), dtype=int) #逗号加在前面会报错，输出同a c= np.ones((4,1)) #输出4行1列的数组 d = np.zeros(4) #输出[0, 0, 0, 0] e = np.empty(3) #生成3个元素的空数组行向量 f = np.eye(3) #生成3阶单位阵 g = np.eye(3, k=-1) #主对角线是0，生成第k对角线的元素为1，其他元素为0的3阶方阵 h = np.zeros_like(a) #生成与a同维数的全0数组 print(g) print(c) 数组元素的索引\nimport numpy as np a = np.arange(16).reshape(4,4) #生成4行4列的数组 b = a[1][2] #输出6 c = a[1, 2] #同b d = a[1:2, 2:3] #输出[[6]] x = np.array([0, 1, 2, 1]) print(a[x==1]) #输出a的第2、4行元素 print(a) numpy对矩阵 矩阵的合并 np.vstack([a, b]) #上下合并矩阵 np.hstack([a, c]) #左右合并矩阵\n矩阵的分割 b = np.vsplit(a, 2) #行分割 c = np.hsplit(a, 4) #列分割\n矩阵的乘法\n使用符号@，前面的相当于行向量\n范数计算\nimport numpy as np a = np.array([[0, 3, 4], [1, 6, 4]]) b = np.linalg.norm(a, axis=1) #求行向量2范数 c = np.linalg.norm(a, axis=0) #求列向量2范数 d = np.linalg.norm(a) #求矩阵2范数 print(\u0026#39;行向量2范数为：\u0026#39;, np.round(b, 4)) print(\u0026#39;列向量2范数为：\u0026#39;, np.round(c, 4)) print(\u0026#39;矩阵2范数为：\u0026#39;, round(d, 4)) 求线性方程的唯一解\nimport numpy as np a = np.array([[3, 1], [1, 2]]) b = np.array([9, 8]) x1 = np.linalg.inv(a) @ b #第一种解法 #上面语句中@表示矩阵乘法 x2 = np.linalg.solve(a, b) #第二种解法 print(x1); print(x2) 求超定线性方程组的唯一解\nimport numpy as np a = np.array([[3, 1], [1, 2], [1, 1]]) b = np.array([9, 8, 6]) x = np.linalg.pinv(a) @ b print(np.round(x, 4)) 特征值和特征向量\nimport numpy as np a = np.eye(4) b = np.rot90(a) #好像代表转 c, d = np.linalg.eig(b) print(\u0026#39;特征值为：\u0026#39;, c) print(\u0026#39;特征向量为：\\n\u0026#39;, d) pandas 生成二维数组\nimport pandas as pd import numpy as np dates=pd.date_range(start=\u0026#39;20191101\u0026#39;,end=\u0026#39;20191124\u0026#39;,freq=\u0026#39;D\u0026#39;) a1=pd.DataFrame(np.random.randn(24,4), index=dates, columns=list(\u0026#39;ABCD\u0026#39;)) a2=pd.DataFrame(np.random.rand(24,4)) 读写文件\nimport pandas as pd import numpy as np dates=pd.date_range(start=\u0026#39;20191101\u0026#39;, end=\u0026#39;20191124\u0026#39;, freq=\u0026#39;D\u0026#39;) a1=pd.DataFrame(np.random.randn(24,4), index=dates, columns=list(\u0026#39;ABCD\u0026#39;)) a2=pd.DataFrame(np.random.randn(24,4)) a1.to_excel(\u0026#39;data2_38_1.xlsx\u0026#39;) #可以修改此行让其不带索引 a2.to_csv(\u0026#39;data2_38_2.csv\u0026#39;) f=pd.ExcelWriter(\u0026#39;data2_38_3.xlsx\u0026#39;) #创建文件对象 a1.to_excel(f,\u0026#34;Sheet1\u0026#34;) #把a1写入Excel文件 a2.to_excel(f,\u0026#34;Sheet2\u0026#34;) #把a2写入另一个表单中 f.save() 数据预处理\nimport pandas as pd import numpy as np d=pd.DataFrame(np.random.randint(1,6,(10,4)), columns=list(\u0026#34;ABCD\u0026#34;)) d1=d[:4] #获取前4行数据 d2=d[4:] #获取第5行以后的数据 dd=pd.concat([d1,d2]) #数据行合并 s1=d.groupby(\u0026#39;A\u0026#39;).mean() #数据分组求均值 s2=d.groupby(\u0026#39;A\u0026#39;).apply(sum) #数据分组求和 import pandas as pd import numpy as np a = pd.DataFrame(np.random.randint(1,6,(5,3)), index=[\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;], columns=[\u0026#39;one\u0026#39;, \u0026#39;two\u0026#39;, \u0026#39;three\u0026#39;]) a.loc[\u0026#39;a\u0026#39;, \u0026#39;one\u0026#39;] = np.nan #修改第1行第1列的数据 b = a.iloc[1:3, 0:2].values #提取第2、3行，第1、2列数据 a[\u0026#39;four\u0026#39;] = \u0026#39;bar\u0026#39; #增加第4列数据 a2 = a.reindex([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;]) a3 = a2.dropna() #删除有不确定值的行 scipy 求解非线性方程\nfrom scipy.optimize import fsolve, root fx = lambda x: x**980-5.01*x**979+7.398*x**978\\ -3.388*x**977-x**3+5.01*x**2-7.398*x+3.388 x1 = fsolve(fx, 1.5, maxfev=4000) #函数调用4000次 x2 = root(fx, 1.5) print(x1,\u0026#39;\\n\u0026#39;,\u0026#39;-------------\u0026#39;); print(x2) 最小二乘法\nfrom scipy.optimize import least_squares import numpy as np a=np.loadtxt(\u0026#39;data2_47.txt\u0026#39;) x0=a[0]; y0=a[1]; d=a[2] fx=lambda x: np.sqrt((x0-x[0])**2+(y0-x[1])**2)-d s=least_squares(fx, np.random.rand(2)) print(s, \u0026#39;\\n\u0026#39;, \u0026#39;------------\u0026#39;, \u0026#39;\\n\u0026#39;, s.x) 求最大模特征值和对应的特征向量\nfrom scipy.sparse.linalg import eigs import numpy as np a = np.array([[1, 2, 3], [2, 1, 3], [3, 3, 6]], dtype=float) #必须加float,否则出错 b, c = np.linalg.eig(a) d, e = eigs(a, 1) print(\u0026#39;最大模特征值为：\u0026#39;, d) print(\u0026#39;对应的特征向量为：\\n\u0026#39;, e) 此外，还可以求解积分，傅里叶变换，插值，信号处理等。\nsympy 可以用计算机推导表达式，可以对符号运算。\nimport sympy as sp a, b, c, x=sp.symbols(\u0026#39;a,b,c,x\u0026#39;) x0=sp.solve(a*x**2+b*x+c, x) print(x0) import sympy as sp sp.var(\u0026#39;x1,x2\u0026#39;) s=sp.solve([x1**2+x2**2-1,x1-x2],[x1,x2]) print(s) import numpy as np import sympy as sp a = np.identity(4) #单位矩阵的另一种写法 b = np.rot90(a) c = sp.Matrix(b) print(\u0026#39;特征值为：\u0026#39;, c.eigenvals()) print(\u0026#39;特征向量为：\\n\u0026#39;, c.eigenvects()) matplotlib绘图介绍 二维绘图 绘制折线图\nimport pandas as pd import pylab as plt plt.rc(\u0026#39;font\u0026#39;,family=\u0026#39;SimHei\u0026#39;) #用来正常显示中文标签，还有一个正常显示符号的语句 plt.rc(\u0026#39;font\u0026#39;,size=16) #设置显示字体大小 a=pd.read_excel(\u0026#34;data2_52.xlsx\u0026#34;, header=None) #和py文件保存在同一级目录 b=a.values #提取其中的数据 x=b[0]; y=b[1:] plt.plot(x,y[0],\u0026#39;-*b\u0026#39;,label=\u0026#39;铂金\u0026#39;) plt.plot(x,y[1],\u0026#39;--dr\u0026#39;,label=\u0026#39;铂金\u0026#39;) plt.xlabel(\u0026#39;月份\u0026#39;); plt.ylabel(\u0026#39;每月销量\u0026#39;) plt.legend(loc=\u0026#39;upper left\u0026#39;); plt.grid(); plt.show() ()使用pandas的Dateframe绘图 绘制柱状图\nimport pandas as pd import pylab as plt plt.rc(\u0026#39;font\u0026#39;,family=\u0026#39;SimHei\u0026#39;) #用来正常显示中文标签 plt.rc(\u0026#39;font\u0026#39;,size=16) #设置显示字体大小 a=pd.read_excel(\u0026#34;data2_52.xlsx\u0026#34;,header=None) b=a.T; b.plot(kind=\u0026#39;bar\u0026#39;); plt.legend([\u0026#39;钻石\u0026#39;, \u0026#39;铂金\u0026#39;]) plt.xticks(range(6), b[0], rotation=0); plt.show() 子图\nimport pylab as plt import numpy as np plt.rc(\u0026#39;text\u0026#39;, usetex=True) #调用tex字库 y1=np.random.randint(2, 5, 6); y1=y1/sum(y1); plt.subplot(2, 2, 1); str=[\u0026#39;Apple\u0026#39;, \u0026#39;grape\u0026#39;, \u0026#39;peach\u0026#39;, \u0026#39;pear\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;pineapple\u0026#39;] plt.barh(str,y1) #水平条形图 plt.subplot(222); plt.pie(y1, labels=str) #饼图 plt.subplot(212) x2=np.linspace(0.01, 10, 100); y2=np.sin(10*x2)/x2 plt.plot(x2,y2); plt.xlabel(\u0026#39;$x$\u0026#39;) plt.ylabel(\u0026#39;$\\\\mathrm{sin}(50x)/x$\u0026#39;); plt.show()#latex表示数学公式 linspace(a,b,c)表示的是把a-b平均分成c分, 三维绘图 三维曲线\nimport pylab as plt import numpy as np ax=plt.axes(projection=\u0026#39;3d\u0026#39;) #设置三维图形模式 z=np.linspace(-50, 50, 1000) x=z**2*np.sin(z); y=z**2*np.cos(z) plt.plot(x, y, z, \u0026#39;k\u0026#39;); plt.show() 三维表面图\nimport pylab as plt import numpy as np x=np.linspace(-4,4,100); x,y=np.meshgrid(x,x) z=50*np.sin(x+y); ax=plt.axes(projection=\u0026#39;3d\u0026#39;) ax.plot_surface(x, y, z, color=\u0026#39;y\u0026#39;) plt.show() import pylab as plt import numpy as np ax=plt.axes(projection=\u0026#39;3d\u0026#39;) X = np.arange(-6, 6, 0.25) Y = np.arange(-6, 6, 0.25) X, Y = np.meshgrid(X, Y) Z = np.sin(np.sqrt(X**2 + Y**2)) surf = ax.plot_surface(X, Y, Z, cmap=\u0026#39;coolwarm\u0026#39;) plt.colorbar(surf); plt.show() 概率统计模型专题绘图 直方图 也称频数图\nimport pandas as pd import pylab as plt df = pd.read_csv(\u0026#39;data9_5.txt\u0026#39;, header=None) df = df.T #转置 plt.subplot(121); h1 = plt.hist(df[0], 5); print(h1) plt.subplot(122); plt.hist(df[1], 5) df.hist(bins=5) #另一种方法画直方图 plt.show() 箱线图\n几个点分别是最小值，1/4值，中位数，3/4点，最大值。 用来观察离散程度。\nimport pandas as pd import pylab as plt df = pd.read_csv(\u0026#39;data9_5.txt\u0026#39;, header=None).T plt.rc(\u0026#39;font\u0026#39;, family=\u0026#39;SimHei\u0026#39;); plt.rc(\u0026#39;font\u0026#39;, size=16); plt.boxplot(df, labels=[\u0026#39;甲班\u0026#39;, \u0026#39;乙班\u0026#39;]); plt.show() QQ图\n可以检验拟合优度。同时不建议直接使用库函数绘制QQ图\nimport pandas as pd import pylab as plt from scipy.stats import norm, probplot df = pd.read_csv(\u0026#39;data9_5.txt\u0026#39;, header=None) d = df.values[0] #提取甲班成绩 mu = d.mean(); s = d.std(); sd = sorted(d); n = len(d) x = (plt.arange(n)+1/2)/n; yi = norm.ppf(x, mu, s) plt.rc(\u0026#39;font\u0026#39;, size=16); plt.rc(\u0026#39;font\u0026#39;, family=\u0026#39;SimHei\u0026#39;) plt.rc(\u0026#39;axes\u0026#39;, unicode_minus=False) plt.subplot(121); plt.plot(yi, sd, \u0026#39;o\u0026#39;, label=\u0026#39;QQ图\u0026#39;) plt.plot(sd, sd, label=\u0026#39;参照直线\u0026#39;); plt.legend() plt.subplot(122); probplot(d, plot=plt); plt.show() ","permalink":"https://tassel234.github.io/posts/note/python%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AE%97%E6%B3%95-1%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%92%8C%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80/","summary":"python数模算法-1（库的基本使用和绘图基础） 前言 使用学习资源 python数学建模算法与应用（司守奎） 比较全面的建模算法视频（但编程语言是matlab） 目标指向 只需要会看那些代码并运行实现一次代码和理解用途就可以了，需要使用的时候查阅复制粘贴就可以了。 算法具体实现的逻辑步骤要","title":"Python数学建模算法-1（库的基本使用和绘图基础）"},{"content":"github和git的基础知识（可跳过不看）  Github 代码上边的Raw、Blame是什么意思？\n  Raw：文件内容。 blame：按行显示最新提交的信息。\n Pin，该词可被译为：钉住、按住。被Pin的仓库会显示在个人主页中，类似于仓库置顶。 Watch，默认是Unwatch，如果你想关注某个仓库，当这个库有新的通知时就会提醒你。 star,表示喜爱。\nFork代表从别人的代码仓库中复制一份到自己的代码库，包含了别人库中的提交历史记录。经过fork后的代码库是完全独立的，由自己维护，可以进行任何魔改。改完之后自己可以通过Pull Request向原来的库提交合并请求。 1. Fork别人的仓库：复制别人仓库（代码、文件、提交历史记录、issue等），复制后的仓库在自己的github账号中存着。 2. Clone远程仓库：将这个复制后的远程仓库克隆到本地。 3. 在工作区对代码进行CRUD操作（增删改查） 4. 将代码的更改提交暂存区（git add .） 5. 将暂存区的文件提交到本地仓库（git commit -m \u0026lsquo;小修一下\u0026rsquo;） 6. 将本地仓库的代码推送到远程仓库（git push） 7. 给别人的仓库发送Pull Request：如果原作者认为你的修改版本不错，就会将你代码中的修改合并到自己的库中。\n可以在写编写markdown文件于github网站\nGit是一款分布式源代码管理工具(版本控制工具) ，可以对我们写的代码进行托管和版本记录（每上传一次形成一个版本，可以找回）。github和git的关系非常紧密，hub在百度翻译有如下解释：\n n. 轮毂; (某地或活动的)中心; [例句]The island\u0026rsquo;s social hub is the Cafe Sport 该岛的社交中心是“体育咖啡馆”。 可以理解为github以git为传输路径，把程序员上传过的代码集中,迭代，存放在github的仓库中，方便和其他程序员的合作或交流。\n git的进一步学习\n前言 本文介绍如何使用Github+Hugo+PaperMod主题搭建一个人博客。\n此文章也记录了我搭建博客较为详细的步骤和一些在博客搭建过程中出现的问题和解决方案。\n参考资料 23年的hugo博客搭建视频\nsulv的博客\n333rd的博客\nrosefinch-midsummer的博客\n前置工作 需要一个github账号,可以在网页打开github,推荐使用fastgithub软件，翻墙也行。\n下载hugo,推荐安装比较原始的版本，后面会解释为什么。\n下载地址\n下载和安装git，见视频\n安装github desktop，使用该软件可以从本地库克隆到github仓库，并可以完成较为方便的上传更新。\n安装fastgithub，可以获得非常快的github访问速度，而且不用翻墙。\n下载fastgithub\n搭建博客  先下载好hugo,推荐下载hugo v0.85.0版本，之前我下载了最新版本，死活不能把配置文件改成yaml格式，也就没办法直接调用别人写好的漂亮的网站结构。接下来的文字是对视频的总结，更直观的步骤请查阅hugo博客搭建视频 把下载好后把hugo.exe所在的文件夹地址放置在环境变量的系统变量中。 在cmd窗口输入hugo version查看版本和确认安装成功。  生成新站点，hugo new site \u0026lt;想要存储到的位置\u0026gt;/\u0026lt;站点名字\u0026gt; -f yml ， 实例hugo new site D:/path/to/newst -f yml ，  -f yml是把toml文件格式改成yaml格式，最新版这个指令修改不了配置文件（config）格式。\n然后就可以在文件夹找到生成的站点   在路径栏目输入cmd,打开，\n  输入hugo new posts/tech/文章名称.md生成第一篇博客文章。应该在tech目录下写一个_index.md文件用于索引。\n  安装主题，使用命令行git clone https://github.com/adityatelange/hugo-PaperMod.git\n  下载最新版本，实际上后面cmd提示hugo版本和papermod版本不完全匹配，但最后还是可以生成不错的博客页面，然后对config.yaml进行重写，赋值代码和粘贴config.yml此外写入的md文本应该在github复制最新版，旧版会报错。\n写好了开始生成静态页面，站点目录的cmd输入hugo version在本地查看\n 站点目录的cmd输入hugo生成文件夹public\n  在public的文件夹的cmd进行git 导入，输入git init,一个文件夹导入一次就够了\n  博客上传 配置FastGithub(可以跳过不看) 双击打开FastGithub.UI.exe应用程序,程序会在后台运行。\nfirefox提示连接有潜在的安全问题 设置-\u0026gt;隐私与安全-\u0026gt;证书-\u0026gt;查看证书-\u0026gt;证书颁发机构，导入cacert/fastgithub.cer，勾选“信任由此证书颁发机构来标识网站”\n安全性说明\nFastGithub为每台不同的主机生成自颁发CA证书，保存在cacert文件夹下。客户端设备需要安装和无条件信任自颁发的CA证书，请不要将证书私钥泄露给他人，以免造成损失。\n合法性说明\n《国际联网暂行规定》第六条规定：“计算机信息网络直接进行国际联网，必须使用邮电部国家公用电信网提供的国际出入口信道。任何单位和个人不得自行建立或者使用其他信道进行国际联网。” FastGithub本地代理使用的都是“公用电信网提供的国际出入口信道”，从国外Github服务器到国内用户电脑上FastGithub程序的流量，使用的是正常流量通道，其间未对流量进行任何额外加密（仅有网页原有的TLS加密，区别于VPN的流量加密），而FastGithub获取到网页数据之后发生的整个代理过程完全在国内，不再适用国际互联网相关之规定。\n通过git和github desktop将博客上传到github 输入上述两串代码，然后在github desktop进行上传，浏览器的github就可以更新了。\n上传点击fetch origin按钮.\n网页显示 在GitHub网页端，点击hugo博客代码存放库，点击settings,点击pages,修改Branch的none为master,等待一会，就可以生成网页了。\n更新 hugo -F \u0026ndash;cleanDestinationDir完成public文件夹的更新, 然后再重复上传步骤即可.\n添加图片 笔者使用的是vnote，记markdown笔记。 图片引用代码如下： ![](vx_images/ex.png =481x)\n首先应该在static文件夹下创建vx_images文件夹，再把要用的图片导入，但有两个问题。\n 不能加图片大小，也就是把 =481x去掉 前面应该加一个/  如何改进博客 创建拥有美观界面的博客 sulv大佬已经写好了一个优美的yaml配置文件,我们只需要复制粘贴到config配置文件就可以了。 但博客网页的yaml代码不能成功执行，因为sulv的博客和333rd的博客的博客都是创作于几年前，hugo和papermod的版本更新导致了各种问题，所以应该直接在github中复制，config.yml\n至于配置头像，联系方式等，也请参照上面两个博客。\n改进指南 插件\n建站\n统计部署\n为什么要写博客  通过强迫自己记笔记，对知识进行整理，对日常和灵感进行记录 可以促进知识的输出，检验自己的掌握程度，类似费曼学习法 博客本身可以促进学习，并且有助于和别人交流自己的想法  ","permalink":"https://tassel234.github.io/posts/tech/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","summary":"github和git的基础知识（可跳过不看） Github 代码上边的Raw、Blame是什么意思？ Raw：文件内容。 blame：按行显示最新提交的信息。 Pin，该词可被译为：钉住、按住。被Pin的仓库会显示在个人主页中，类似于仓库置顶。 Watch，默认是Unwatch，如果你想关注某个仓库，","title":"Hugo搭建个人博客"},{"content":"故事梗概 《外婆的道歉信》是瑞典作家弗雷德里克·巴克曼创作的一部长篇小说，讲述了一个关于爱，原谅与守护的温馨故事。这部作品以其幽默、独特的叙事风格和深入浅出的人物描绘，受到了广泛关注。\n小说以小女孩爱莎的视角，展示了一个独特、充满想象力的世界。爱莎是一个聪明、机智的小女孩，她与外婆共同生活，度过了许多难忘的时光。外婆是一个疯狂古怪，打破世俗，四处惹麻烦的存在，却是小女孩爱莎心中的英雄和唯一的朋友。为了安抚爱莎不幸的童年，给与爱莎爱的守护，外婆创作了一个又一个童话故事。然而，外婆去世后，爱莎发现自己陷入了一场冒险——把外婆的道歉信分发给曾经受到外婆恶作剧的邻居们，于是爱莎在外婆留下的一系列谜团和线索中寻找真相并逐渐理解了外婆的良苦用心。这一趟送信之旅让爱莎发现：外婆和邻居的故事，比她听过的任何童话故事都更加精彩。\n爱莎与外婆之间的深厚感情贯穿始终，让人动容。虽然外婆在故事中并不完美，但她对爱莎的关爱和付出是无法替代的。无论发生什么情况，外婆都会站在爱莎这边，为了她和世界拼命。爱莎在寻找真相的过程中，逐渐理解了外婆的期待，理解了外婆所讲故事的隐含意义，最终学会了勇气和坚强，也原谅了外婆的离去。\n文章既有童话的温馨浪漫，也有现实的残酷黑暗。爱莎从小父母离异，在学校遭受霸凌，唯一的朋友外婆也在爱莎八岁时也因为癌症死去，但爱莎并未因此消极堕落，因为童话，外婆，父母，邻居们的共同守护与治愈，爱莎得以更加坚强，温柔的成长。\n读后感 文中我最喜欢的人毫无疑问是外婆。外婆独立，不拘世俗，经常打破常规，四处惹麻烦。“要大笑，要做梦，要与众不同”是外婆的口头禅，她甚至用她的敢打敢拼赢下过一座楼。外婆也是一个温柔善良的人，是一个不怕危险，到处救死扶伤的医生（外婆那个年代学医比较打破常规），奔赴过海啸受灾城市，战场前线救人，她还把一些无家可归的人安置在自己的楼里。外婆在行医的过程中结交过很多形形色色的人，锻炼了各种各样的技能（不过狂妄大胆像是天生的）。所以在爱莎眼里，外婆是一个无所不能的超级英雄。外婆为爱莎构建了一个童话世界，这个世界可以让她克服恐惧和不安，成为内心的支柱，可以为她疲惫之时提供栖息的港湾。\n文中第二个值得讨论的角度是故事。读过全文后就可以发现，外婆创作的故事中的人物其实就是以她帮助过的人为蓝本制作的，诞生的故事进一步去安抚，帮助那些受伤的心灵（有孩子也有大人）。事实上这里可以发现外婆的故事并不是单单为了爱莎而创作，而是诞生在更早之前，为了那些流离失所的孩子而创作，故事的力量可以在爱莎的经历中窥得一斑。\n故事的力量让我想起来了人类简史(这本书是犹左作品，在构建主义上有一些争议，之后也会在读后感讨论)中提到的故事概念，简单来说，我们人类所创造的一切可以被传递和认同的思维思想造物都可以被称为故事，小至童话，寓言，大至各类主义，意识形态，人类的社会就是由无数的故事构成的，我们以相同的故事彼此认同，进而拼接成为文化，民族，国家，文明。故事的诞生之初，承担着教育启蒙的作用，后来故事开始发展为以讴歌赞颂为主，人们迫切的寻求最浪漫完美，可以被奉为涅槃的故事集。随着人们建设自己精神的力量和欲望日渐强大，也开始催生出无数亚文化。\n对那些经历过战争或自然灾害，在绝望的死土上生活的那些孩子，对那些未来无限迷茫，没有光明，希望，呆滞着的那些孩子，一把火，一段围着火堆不成章法的随情热舞，就足以让他们忘记身前身后的一切烦恼，让他们快乐于此刻，不再为生命的寂寥而担忧。如果有人愿意为他们讲上一个精彩的关于爱，勇气和希望的故事，那么他们就可以在幻想的世界里安静安宁的休息片刻，然后好好的长大。这也是故事的意义之一。和外婆的道歉信相似的故事形式，我能联想到的是东方的幻想乡和海猫的黄金乡（前者是车万越共，后者是在故事中讨论故事）。\n第三个角度是关于守护。俗话说的好：大人的职责就是保卫孩子们的健康成长，简称大保健。孩子身上承担着关于未来无限个可能性的力量，或许会引导他们去实现那缈不可及的理想世界和走向最终的故事。大人的意义就是 大保健 为孩子铺上一些路，种上一些花，留下一些种子。\n登场人物 血缘（6人）：爱莎，外婆，爱莎的妈妈，爱莎的爸爸，继父乔治，爱莎的同母异父弟弟小半\n邻居（9人2狗）：三楼 布里特.玛丽，肯特 黑裙女人\n二楼 莫纳特，莫德，莎曼萨（比熊犬） 阿尔法\n一楼 生病男孩，其母亲 怪物（狼心），呜斯（大狗）\n其他（1人）：山姆（狼心曾经的朋友）\n","permalink":"https://tassel234.github.io/posts/read/%E5%A4%96%E5%A9%86%E7%9A%84%E9%81%93%E6%AD%89%E4%BF%A1%E8%AF%BB%E5%90%8E%E6%84%9F/","summary":"故事梗概 《外婆的道歉信》是瑞典作家弗雷德里克·巴克曼创作的一部长篇小说，讲述了一个关于爱，原谅与守护的温馨故事。这部作品以其幽默、独特的叙事风格和深入浅出的人物描绘，受到了广泛关注。 小说以小女孩爱莎的视角，展示了一个独特、充满想象力的世界。爱莎是一个聪明、机智的小女孩，她与外婆共","title":"《外婆的道歉信》读后感"},{"content":"前言 使用资源 西工大网课(在慕课和b站都可以找到资源)\nBjarne Stroustrup《C++程序设计语言》\n洛谷的一些编程题\n主要以网课为主.\n引言 计算机系统由硬件和软件共同组成。硬件主体为输入输出设备，存储器，运算器，控制器。软件又分为系统软件和应用软件。应用软件就是用户下载的音乐播放器，聊天软件，浏览器的软件。而系统软件是一个计算机系统系统必备的，需要提前安装的软件，比如操作系统，数据库系统和网络系统，此外程序设计语言和语言执行程序也应该属于系统软件，其实应该说以语言编写的代码才是软件的基石。\n计算机编程语言其实和汉语，英语等我们口头表达，纸笔书写的语言没有本质的区别，编程语言其实也是把我们的想法转化为特定的词汇和语法，让我们可以和计算机交流。如果我们想书写美妙的编程诗篇，扎实的语言功底，表达力，逻辑力，想象力，创造力缺一不可。\n数据在计算机内部的样子 计算机只能够理解0和1，所以我们编写的程序最后都会转化为计算机可以理解的01代码，同样我们日常使用十进制数据也要变为二进制。\n进制之间的转化。十进制如何转化为二进制，对于整数部分是除以2取余数，对于小数部分是乘2取整数部分，是0就取0。二进制和八，十六进制的转化，整数高位补0，小数低位补0。\n对于数字类型，一般第一位代表±，以-1的次方计数，0正1负。\n二进制的计算。原码可以比较有效的对正数计算，反码指负数的负号位不变，其他位01互换，补码是在反码的基础上进行加1，利用溢出计算。\n浮点数二进制。先表示为科学计数法，对有效数字进行二进制化，分别塞上符号位，二进制的表示数，二的次方数。\n数据类型 基本数据类型。一个字节八位。\n int4,long int 4,unsigned int 4 ,第一位是符号位，而对于无符号的unsigned代表的正数范围多二倍。 char 1,也代表asc||码，为128个，‘1‘49，A65，a97。   float 4,double 8，一般小数都是double,一般计算有效数字为16位，如果是四字节的浮点数，就要在数字后加f，只可以计算7位有效数字。此外还由布尔类型，空类型。 构造数据类型。包括数组，struct,union,enum枚举,class(类)。  特殊的数据类型，有指针类型和引用类型。 int i,j; char c1,c2; c1=\u0026#39;a\u0026#39;; c2=98; i=\u0026#39;A\u0026#39;; j=66; 字符型还可以进行减法运算。cout\u0026laquo;\u0026lsquo;A\u0026rsquo;-32结果是33;\n常量和变量 字面常量  八进制，十六进制表示，0,0x 浮点型也可以用e表示，即科学计数法f e n,f可以是整数或小数，但n必须是整数。 字符串常量和字符常量  \\ooo和\\xhh称为通用转义字符，其中\\ooo表示可以用1至3位八进制数作为码值表示一个ASCII字符，hh表示可以用1至2位十六进制数作为码值表示ASCII字符。\n如:“\\1234”一“123和4”，”\\128”一\\12和8”，19\u0026quot;一”\\1和9\u0026quot;\n\\9错误，\\0xFE 错误\n由于字符型数据在内存中只占用1个字节，即使按无符号处理其最大值也仅是255(八进制为377)，因此ooo的数值范围为0~377 (八进制)，其他值使得字符型数据溢出。同理，hh的数值范围为0~FF\n字符常量 就是使用宏#define进行定义\n变量 变量需要先声明\nint d=a ，e=a+b; //错误，初值不能是变量或表达式 int m=n=z=5: //错误，不能对变量连续初始化 const int a; 一般在函数中应用比较广，避免因为误操作导致数值改变。\n运算符    int m=4，n; n = ++m; //m先增1，m为5，然后表达式使用m的值，赋值给n，n为5 n = --m; //m先减1，m为4，然后表达式使用m的值，赋值给n，n为4 n = m++; //表达式先使用m的值，赋值给n，n为4，然后m增1，m为5 n = m--;//表达式先使用m的值，赋值给n，n为5，然后m减1，m为4   C++在逻辑表达式求解时，并不一定是所有的运算都被执行，当刚开始求解或求解的中途就可以确定整个逻辑表达式的值时，其余的运算将不再进行。\nint a=1 ，b=2,c=3,d=4,m=n=1，k; k=(m=a\u0026gt;b)\u0026amp;\u0026amp;(n=c\u0026gt;d); //m的值为0，n的值为1，k的值为0 3.三目运算符   int i=3,j=5;k=i++,i+1,j++,j+1;//k为3 (i++的值)k=(i++,i+1j++,j+1); //k为7 (j+1的值) 逗号运算符是双目运算符。\n类型转换 手动类型转化\n(int)x+y //将x转换成整型 (int)(x+y) //将x+y转换成整型 (int)x%3 //x的类型和数据值不变，表达式引用转换成int后的x值 隐式类型转换 (implicit type conversion) 又称自动类型转换，它是由编译器自动进行的。\n(1)将浮点型数据赋给整型变量时，舍弃浮点数的小数部分。 如:int n=6.18;n的值为6。\n(2)将整型数据赋给浮点型变量时，数值不变，但以浮点数形式存 诸到变量中。如:double f=78;将78按78.0处理\n(3)将double型数据赋给float变量时，截取前面7位有效数字存储到float变量。将float型数据赋给double变量时，数值不变，有效数字扩展到16位。\n预处理 文件包含 #include 分为相对路径（.h）和绝对路径（C：/） 用户路径\u0026quot;\u0026quot; 系统路径\u0026lt;\u0026gt;\n条件编译 可以避免重复包含头文件，避免错误 1.\n#ifdef #else #endif   #if #elseif #else #endif 宏  #define 进行替换任意文本 但文本替换带有运算是要用（）括起来，不然可能出现错误 #x转化为字符，作用？ ##连接字符文本，ang  ","permalink":"https://tassel234.github.io/posts/note/c++%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1%E5%BC%95%E8%A8%80%E5%92%8C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","summary":"前言 使用资源 西工大网课(在慕课和b站都可以找到资源) Bjarne Stroustrup《C++程序设计语言》 洛谷的一些编程题 主要以网课为主. 引言 计算机系统由硬件和软件共同组成。硬件主体为输入输出设备，存储器，运算器，控制器。软件又分为系统软件和应用软件。应用软件就是用户下载的音乐播放器，聊天","title":"C++入门学习笔记-1（引言和基础知识）"},{"content":"正值暑假，又热又闷。\n学校的图书馆周日不开放，学习任务也没有完成。\n我今天本该在宿舍在宿舍睡觉吃饭学习，但因为前几周的经历，我意识到宿舍学习的效率是有一点惨不忍睹的。\n考虑之下，我决定去青浦图书馆学习和旅行。\n青浦图书馆坐落于青浦新城区夏阳湖上，有水上博物馆的美称，夏阳湖旁边是就是青浦博物馆。\n哈罗单车覆盖了上海的大部分地方，但是没有青浦图书馆这一片，青浦似乎是有自己的共享单车，但我骑不了。\n青浦图书馆的开放时间是周二至周日9:00-20:30(20:00以后停止入馆)\n百度地图显示青浦博物馆的夜景很好，但因为现在正值暑假，宿管阿姨关门关的早，所以很遗憾的我不能欣赏了。\n早上七点半起床，吃了一碗咖啡燕麦粥和一点苏打饼干，收拾行李，关闭电源。\n八点半出发，经过自行车，公交车，地铁，步行，加上吃午饭的时间终于在十二点抵达青浦图书馆。\n上海的地铁站有一个不成文的规定，坐阶梯式电梯时不赶时间，在电梯停留的人统一靠在电梯右侧，左边的空间留给赶时间，在电梯上走动的人。\n地铁上我看日语发音入门课程消磨时间。\n青浦图书馆不需要预约入场更不需要预约座位，上海图书馆东馆就要提前六天抢座位了。 图书馆不算大，也不算小。我能探索的就只有三层结构。\n图书馆下方有一个图咖，我看到有两个女孩在吃冰淇淋。\n图书馆内部的人真是太多了，我转了半天才在一个杂志阅览室的角落找到可以自习的地方。\n自习的人有很多，不只是考研的大学生，还有很多的工作的青年人和看书的老年人。\n书籍也有很多，宗教学，科学，欧美文学，古典文学等面面俱到，还有影像收藏。\n窗外的景色也很不错，南边的座位可以看到一条青绿色的河，北边的座位可以看到夏阳湖。\n学习时我看吴军博士写的 计算之魂，休息时我看保罗.约翰逊写的 所谓知识分子（书挺升血压的）。\n下午的时候天就阴了。\n五点多，我离开了图书馆，吃了一碗拉面。 因为博物馆那时已经闭馆了（我5点多才知道），所以我也就直接回去了。\n我沿着河畔转了一圈，看到了唱戏的大爷大妈，看到了父亲和女儿，看到男男女女，熙熙攘攘。 然后我就回去了，本来想走到地铁站，结果走一小段发现太累了，就停下来等公交。\n值得一提的是，我早上因为大意穿的是睡衣出门，走到一半才意识到，已经来不及回去换了。\n刚开始在地铁上感觉有点尴尬和不自在，但后来渐渐释怀了。\n我意识到上海是一座很大的城市，他很排外也很包容。\n上海的人都很忙，他们压根没精力去在意你，我怀疑我直接cos星野爱也没多少人在意我，更不用提一件睡衣。\n即使有人多看了你一眼，比起在内心折磨自己，不如直接微笑（恶心他人）来的从容。\n","permalink":"https://tassel234.github.io/posts/life/%E9%9D%92%E6%B5%A6%E5%9B%BE%E4%B9%A6%E9%A6%86%E6%B8%B8%E8%AE%B0/","summary":"正值暑假，又热又闷。 学校的图书馆周日不开放，学习任务也没有完成。 我今天本该在宿舍在宿舍睡觉吃饭学习，但因为前几周的经历，我意识到宿舍学习的效率是有一点惨不忍睹的。 考虑之下，我决定去青浦图书馆学习和旅行。 青浦图书馆坐落于青浦新城区夏阳湖上，有水上博物馆的美称，夏阳湖旁边是就是青浦博","title":"青浦图书馆游记"}]