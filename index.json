[{"content":"类的定义 （1）定义类 面向程序设计更偏向于把每一个细节都做好，从每一个零件开始是制造汽车。面向对象编程偏向于把很多细小的零件已经主装好了，保留集成了很多接口，只需要把部件进行拼接就可以得到产品。\n面向对象编程的意义在于自然界都是由实体组成，面向对象也是软件开发的主流方式。\n面对对象的三大特征，分别是抽象，封装，继承。抽象指的是将成员和成员的行为分别表示为数据成员和成员函数。封装就是把抽象来的对象代码写到类里面，并设计一些接口。继承和派生，指的是可以对一些类进行修改，得到子类，比如把本科学生信息管理系统稍作修改就可以变成研究生学生信息管理系统。\n类的定义和结构体相似，但比结构体多了对共有，私有成员的声明，还有就是类里面可以由函数。公有成员就是所有类的用户都可以使用，私有成员是只有类的成员可以用，被保护的成员基本和私有成员相同，但派生继承的类的成员也可以访问\n函数可以定义先声明在类的里面，然后定义在类外。使用：：符号\nclass Data { //Data类定义 void set(int d); //成员函数原型声明，与 void set(int); 等价 int get() { //成员函数类内部定义 return data; } //get函数定义结束 int data; //数据成员 }; //Data类定义结束 void Data::set(int d) //成员函数类外部定义 { data=d; //访问类的数据成员 } 类定义一般放在程序文件开头，或者放到头文件中被程序文件包含， 此时这个定义是全局的。在全局作用域内，该定义处处可见，因此 同作用域内的所有函数都可以使用它。\n类定义向编译器声明了一种新的数据类型，该数据类型有不同类型 的数据成员和成员函数。因此尽管数据成员类似变量的定义，但类 型声明时并不会产生该成员的实体，即为它分配存储空间。\n（2）成员的访问控制 类的每个成员都有访问控制属性，由以下三种访问标号说明：public（公有的）、private（私有的）和protected（保护的）。\npublic实现了类的外部接口。私有成员用private标号声明，只有类成员可以访问私有成员，类用户的访问是不允许的。显然，private实现了私有成员的隐蔽。保护成员用protected标号声明，在不考虑继承的情况下，protected的性质和private的性质一致，但保护成员可以被派生类的类成员访问。\n实际编程中，为了使程序清晰，每一种成员访问限定符在类体中只出现一次\n（3）类的数据成员 类的数据成员可以是基本类型、数组、指针、引用、共用体、枚举 类型、void指针、const限定等数据类型。\n但不可以是自身，后面会提到构造函数，可以构造同名的函数体。\n（4）类的成员函数 在成员函数中可以访问这个类的任何成员，无论它是公有的 或是私有的，是类内部声明的还是类外部定义的。\n（::）是作用域限定符（field qualifed）。如果在作用域限定符的前面没有类名，或者函数前面既无类名又无作用域限定符，例 如：::set(10) 或 set(10）则表示set函数不属于任何类，这个函数不是成员函数，而是全局的普通函数。此时的（::）不是类作用域限定符的含义，而是命名空间域限定符的含义。\n类的成员函数可以指定为inline，即内联函数。声明在类外或者类内都可以。\n可以对成员函数重载或使用默认参数。需要注意，声明成员函数的多个重载版本或指定成员函数的默认参 数，只能在类内部中进行。\n用类实例化一个对象时，系统会为每一个对象分配存储空问。如果 一个类包括了数据成员和成员函数，则要分别为数据和函数的代码 分配存储空间。 （5）类的声明 类不能具有自身类型的数据成员。然而，只要类名一经出现就可以 认为该类己声明。因此，类的数据成员可以是指向自身类型的指针 或引用。\nclass Point; //Point类声明，非Point类定义，因为没有类体 class Line { Point a; //错误，不能使用仅有类声明而没有类定义的类定义数 据对象 Point *pp, \u0026amp;rp; //正确，只有类声明，即可用它定义该类的指 针或引用 Line b; //错误，类不能具有自身类型的数据成员 Line *pl, \u0026amp;rl; //正确，类可以有指向自身类型的指针或引用 的数据成员 }; 对象的定义和使用 （1）对象的的定义 从现在起，“对象”一词专门表示类的实体。\nPoint a,b; //C++特色定义对象 class Point x,y; //兼容C语言特色定义对象 具体定义方式和结构体类似\n（2）对象的动态建立和释放 利用new运算符可以动态地分配对象空间，delete运算符释放对象空间。 用new运算动态分配得到的对象是无名的，它返回一个指向新对象的指针的值，即分配得到是对象的内存单元的起始地址。程序通过这个地址可以间接访问这个对象，因此需要定义一个指向类的对象的指针变量来存放该地址。显然，用new建立的动态对象是通过指针来引用的。\n在执行new运算时，如果内存不足，无法开辟所需的内存空间，C++编译器会返回一个0值指针。\n#include\u0026lt;iostream\u0026gt; using namespace std; class Box { public: int width, length, height; }; int main() { Box * p=new Box; p-\u0026gt;width=10; p-\u0026gt;length=20; p-\u0026gt;height=30; 1 cout\u0026lt;\u0026lt;p-\u0026gt;width\u0026lt;\u0026lt;\u0026#34;\\t\u0026#34;\u0026lt;\u0026lt;p-\u0026gt;length\u0026lt;\u0026lt;\u0026#34;\\t\u0026#34;\u0026lt;\u0026lt;p-\u0026gt;height\u0026lt;\u0026lt;endl; delete p; return 0; （3）对象成员的引用 访问对象中的成员可以有3种方法：\n①通过对象名和对象成员引用运算符（.）访问对象中的成员；\n②通过指向对象的指针和指针成员引用运算符（-\u0026gt;）访问对象中的成员；\n③通过对象的引用变量和对象成员引用运算符（.）访问对象中的成员；\n需要注意，从类外部只能访问类公有的成员\nvoid caller1() { Data A, *p, *p1; //定义对象指针变量 p1=\u0026amp;A; //p1指向对象A p1-\u0026gt;data=100; //正确，类外部可以访问类的public数据成员 p1-\u0026gt;fun(1,2,3); //正确，类外部可以访问类的public成员函数 p = new Data; //动态分配Data对象 p-\u0026gt;data=100; //正确，类外部可以访问类的public数据成员 p-\u0026gt;fun(1,2,3); //正确，类外部可以访问类的public成员函数 delete p; //撤销p所指向的Data对象 } void caller1() { Data A, \u0026amp;r=A; //定义对象引用变量 r.data=100; //正确，类外部可以访问类的public数据成员 r.fun(1,2,3); //正确，类外部可以访问类的public成员函数 } （4）对象的赋值 如果一个类定义了两个或多个对象，则这些同类的对象之间可以互相赋值。这里所指的对象的“值”是指对象中所有数据成员的值。\n（5）对象、对象指针或对象引用作为函数的参数和返回值 当形参是对象时，实参要求是相同类的对象名，C++不能对类对象进行任何隐式类型转换。此时形参是实参对象的副本。实际编程中，传递对象时需要考虑类的规模带来的调用开销，如果开销很大时建议不用对象作为函数参数。\n当形参是对象指针时，实参要求是同类对象的指针，C++不能对对象指针进行任何隐式类型转换。采用地址传递方式，在函数中若按间接引用方式修改了形参对象本质上就是修改实参对象。因此，使用对象指针作为函数参数可以向主调函数传回变化后的对象。\n当形参是对象引用时，实参要求是同类的对象，其功能与对象指针相似。\n#include \u0026lt;iostream\u0026gt; using namespace std; void func1(Data a,Data *p,Data \u0026amp;r) { a.data=100; p-\u0026gt;data=200; r.data=300; } int main() { Data A, B, C; A.fun(1,2,3); B.fun(4,5,6); C.fun(7,8,9); func1(A,\u0026amp;B,C);//将对象A、B的地址、对象C的引用传递到函数func1 return 0; 如果不希望在函数中修改实参对象的值，函数形参可以作const限定\nvoid func2(Data a,const Data *p,const Data \u0026amp;r) { a.data=100; p-\u0026gt;data=200; //错误，左值是const对象 r.data=300; //错误，左值是const对象 } 函数返回值可以是对象、对象指针或对象引用。函数返回对象指针或引用，本质上返回的是对象的地址而不是它的存储内容，因此不要返回局部对象的指针或引用，因为它在函数返回后是无效的。\nData* func() { Data a; Data *p=\u0026amp;a; return p; //返回局部对象a的指针p } void caller() { Data *p1; p1=func(); p1-\u0026gt;data=100; //a已不存在，引用错误 } 构造函数 （1）什么是构造函数 在类的对象创建之处就会被执行，用来对数据成员（公有还是私有都可以）进行赋值，函数的名字要和类的名字相同。 类的数据成员是不能在类定义时初始化的，因为本身不分配存储空间如果一个类中所有的数据成员是公有的，则可以在定义对象时对数据成员进行初始化，如果类中的数据成员是私有的，如private的或protected的，就不能用这种方法初始化，因为外部不能直接访问私有的数据成员。构造函数不需要人为调用，而是在建立对象时自动被执行。\n（2）构造函数的定义 与其他任何函数一样，构造函数可以声明为内联的。\n#include \u0026lt;iostream\u0026gt; using namespace std; class Cuboid { //Cuboid类表示长方体 public: Cuboid(int l,int h, int d); //构造函数 int volumn() { return length*height*depth; } //计算体积 private: int length,height,depth; //长、高、深 }; Cuboid::Cuboid(int l,int h,int d) //外部定义的构造函数 { length=l, height=h, depth=d; //初始化数据成员 cout\u0026lt;\u0026lt;\u0026#34;Cuboid: \u0026#34;\u0026lt;\u0026lt;\u0026#34;L=\u0026#34;\u0026lt;\u0026lt;l\u0026lt;\u0026lt;\u0026#34; ,H=\u0026#34;\u0026lt;\u0026lt;h\u0026lt;\u0026lt;\u0026#34; ,D=\u0026#34;\u0026lt;\u0026lt;d\u0026lt;\u0026lt;endl; } int main() { Cuboid a(1,2,3); //定义长方体对象a，调用构造函数初始化 cout\u0026lt;\u0026lt;\u0026#34;volumn=\u0026#34;\u0026lt;\u0026lt;a.volumn()\u0026lt;\u0026lt;endl; //输出体积 Cuboid b(10,20,30); //定义长方体对象b，调用构造函数初始化 cout\u0026lt;\u0026lt;\u0026#34;volumn=\u0026#34;\u0026lt;\u0026lt;b.volumn()\u0026lt;\u0026lt;endl; //输出体积 return 0; 构造函数一般声明为公有的（public），因为创建对象通常是在类的外部进行的。如果构造函数声明为保护的（protected）或私有的（protected），那就意味着在类外部创建对象（并调用构造函数）是错误的。\n每个构造函数应该为每个数据成员提供初始化。否则将使那些数据成员处于未定义的状态。而使用一个未定义的成员是错误的。\n构造函数初始化列表 与普通函数一样，构造函数具有函数名、形参列表和函数体。与其他函数不同的是，构造函数可以包含一个构造函数初始化列表。与其他的成员函数一样，构造函数可以定义在类的内部或外部，但构造函数初始化列表只在构造函数的定义中而不是函数原型声明中指定。\n#include \u0026lt;iostream\u0026gt; using namespace std; class Cuboid { //Cuboid类表示长方体 public: Cuboid(int l,int h, int d); //构造函数 int volumn() { return length*height*depth; }; //计算体积 private: int length,height,depth; //长、高、深 }; Cuboid::Cuboid(int l,int h,int d) :length(l),heght(h),depth(d) //带构造函数初始化列表的构造函数 { cout\u0026lt;\u0026lt;\u0026#34;Cuboid: \u0026#34;\u0026lt;\u0026lt;\u0026#34;L=\u0026#34;\u0026lt;\u0026lt;l\u0026lt;\u0026lt;\u0026#34; ,H=\u0026#34;\u0026lt;\u0026lt;h\u0026lt;\u0026lt;\u0026#34; ,D=\u0026#34;\u0026lt;\u0026lt;d\u0026lt;\u0026lt;endl; } 如果没有为类类型的数据成员提供初始化列表，编译器会隐式地使用该成员的默认构造函数。如果那个类没有默认构造函数，则编译器会报告错误。在这种情况下，为了初始化类类型的数据成员，必须提供初始化列表。\n一般地，没有默认构造函数的成员，以及const或引用类型的成员，都必须在构造函数初始化列表中进行初始化。\n（3）构造函数的重载 在一个类中可以定义多个构造函数版本，即构造函数允许被重载，只要每个构造函数的形参列表是唯一的\n尽管在一个类中可以包含多个构造函数，但是对于每一个对象来说，建立对象时只执行其中一个，并非每个构造函数都被执行。\n（4）带默认参数的构造函数 构造函数的参数允许使用默认值。对类的设计者来说，使用默认参数可以减少代码重复；对类的使用者者来说，使用默认参数可以方便地用适当的参数进行初始化。\n必须在类的内部指定构造函数的默认参数，不能在类外部指定默认参数。\n如果构造函数的全部参数都指定了默认值，则在定义对象时可以给一个或几个实参，也可以不给出实参。这时，就与无参数的构造函数有歧义了。\nclass Point { public: Point(){x=y=0;} Point(int a=1,int b=1):x(a),y(b) { }; void display() { cout\u0026lt;\u0026lt;\u0026#34;x=\u0026#34;\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34; ,y=\u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl; } private: int x,y; //坐标值 }; int main() { Point k; //出现歧义，既可以x=0，y=0；也可以x=1，y=1 return 0; } 一般地，不应同时使用构造函数的重载和带默认参数的构造函数。\n默认构造函数和复制构造函数 （1）定义默认构造函数 默认构造函数就是在没有显式提供初始化式时调用的构造函数，它 是一个不带参数的构造函数。如果定义某个类的对象时没有提供初 始化式就会使用默认构造函数。\n它由不带参数的构造函数，或者所有形参均是默认参数的构造函数 定义。\n任何一个类有且只有一个默认构造函数。如果定义的类中没有显式 定义任何构造函数，编译器会自动为该类生成默认构造函数，称为 合成默认构造函数.一个类哪怕只定义了一个构造函数，编译器也不会再生成默认构造 函数。一般地，任何一个类都应定义一个默认构造函数。\n（2）隐式类类型转换 #include \u0026lt;iostream\u0026gt; using namespace std; class Data { //Data类定义 public: Data(const string\u0026amp; str=\u0026#34;\u0026#34;) : s1(str) { } //const限定 引用字符串类型 为str变量设置默认初值 提供初始化列表 void SetString(const Data\u0026amp; r) //期待的是Data类型的对象 { s1=r.s1; } void print() { cout\u0026lt;\u0026lt;s1\u0026lt;\u0026lt;endl; } private: string s1; } int main() { Data a,b,c(\u0026#34;world\u0026#34;); string i=\u0026#34;string\u0026#34;; a.SetString(c); b.SetString(string(\u0026#34;world\u0026#34;)); //隐式转换 a.print(); b.print(); Data d=Data(i); //隐式转换 d.print(); return 0; 类名(const 指定数据类型\u0026amp; obj)\nC++关键字explicit用来修饰类的构造函数，指明该构造函数是显式 的。explicit关键字只能用于类内部的构造函数声明上，在类定义外 部不能重复它。\n可以禁止由构造函数定义的隐式转换，方法是通过将构造函数声明 为explicit，来防止在需要隐式转换的上下文中使用构造函数。\n（3）复制构造函数与合成复制构造函数 ►复制构造函数又称为拷贝构造函数，它是一种特殊的构造函数。它 的作用就是用一个已经生成的对象来初始化另一个同类的对象。\nPoint pt1(10,20); Point pt2=pt1 复制构造函数定义的一般形式为：\n类名(const 类名\u0026amp; obj) { 函数体 } class Point { //Point类 public: Point() : x(0), y(0) { } //默认构造函数 Point(const Point\u0026amp; r) : x(r.x), y(r.y) { } //复制构造函 数 Point(int a,int b) : x(a), y(b) { } //带参数构造函数 private: int x,y; }; ►复制构造函数有且只有一个本类类型对象的引用形参，通常使用const限定。\n每个类必须有一个复制构造函数。如果类没有定义复制构造函数， 编译器就会自动合成一个，称为合成复制构造函数 与合成默认构造函数不同，即使定义了其他构造函数，编译器也会合成复制构造函数。\n►以下3种情况会使用复制构造函数。\n►（1）用一个对象显式或隐式初始化另一个对象。\n►C++支持两种初始化形式：复制初始化和直接初始化。复制初始化 使用等号（=），而直接初始化将初始化式放在圆括号中。\n►复制初始化和直接初始化是有区别的：直接初始化会调用与实参匹 配的构造函数；而复制初始化总是调用复制构造函数。\nPoint pt1(10,20); Point pt2=pt1; //复制初始化 Point pt3(pt1); //直接初始化 （2）函数参数按值传递对象时或函数返回对象时 当函数形参为对象类型，而非指针和引用类型时，函数调用按值传 递对象，即编译器调用复制构造函数产生一个实参对象副本传递到 函数中。\n类似地，以对象类型作为返回值时，编译器调用复制构造函数产生 一个return语句中的值的副本返回到调用函数。\n（3）根据元素初始化式列表初始化数组元素时。\n总的来说，正是有了复制构造函数，函数才可以传递对象和返回对 象，对象数组才能用初值列表的形式初始化。\n（4）深复制与浅复制 是合成复制构造函数和复制构造函数的区别。 若复制对象但未复制资源内容称为浅复制， 如果一个拥有资源（如用new得到的动态内存）的类对象发生复制 的时候，若对象数据与资源内容一起复制，称为深复制。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string.h\u0026gt; using namespace std; class CA { public: CA(int b,char *cstr) //构造函数 { a=b; str=new char[b]; strcpy(str,cstr); } CA(const CA \u0026amp;C) //复制构造函数 { a=C.a; str=new char[a]; //深复制，浅复制则写成str=C.str; if(str!=0) strcpy(str,C.str); } void show() { cout\u0026lt;\u0026lt;str\u0026lt;\u0026lt;endl; } ~CA() //析构函数 { delete str; } private: int a; char *str; }; int main() { CA a(10,\u0026#34;hello\u0026#34;); CA b=a; b.show(); return 0; } 析构函数 （1）析构函数的定义 析构函数：当对象脱离其作用域时（例如对象所在的函数已调用完 毕），系统会自动执行析构函数。析构函数往往用来做“清理善后” 的工作（例如在建立对象时用new开辟了一段内存空间，则在该对 象消亡前应在析构函数中用delete释放这段存储空间）。\n一个类可以有多个构造函数，但是只能有一个析构函数。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string.h\u0026gt; using namespace std; class Point { public: Point(int a,int b):x(a),y(b){} //带参数的构造函数 ~Point() //析构函数 { cout\u0026lt;\u0026lt;\u0026#34;析构函数被调用。\u0026#34;\u0026lt;\u0026lt;endl; } void show() { cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34;,\u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl; } private: int x,y; }; int main() { Point pt1(10,20); pt1.show(); return 0; （2）合成析构函数 与复制构造函数不同，编译器总是会为类生成一个析构函数，称为合成析构函数 需要注意，合成析构函数并不删除指针成员所指向的对象，它需要 程序员显式编写析构函数去处理。\n（3）何时需要编写析构函数 需要注意，合成析构函数并不删除指针成员所指向的对象，它需要 程序员显式编写析构函数去处理。\n如果类需要析构函数，则该类几乎必然需要定义自己的复制构造函 数和赋值运算符重载，这个规则称为析构函数三法则(三个同时出现)\n#include \u0026lt;iostream\u0026gt; using namespace std; class CString { //CString类 public: CString(const char *str); //单个参数构造函数 ~CString(); //析构函数 void show() { cout\u0026lt;\u0026lt;p\u0026lt;\u0026lt;endl; } //显示字符串 private: char *p; //存储字符串动态内存区 CString::CString(const char *str) { p=new char[strlen(str)+1]; //为存储str动态分配内存 strcpy(p,str); //复制str到p cout\u0026lt;\u0026lt;\u0026#34;构造：\u0026#34;\u0026lt;\u0026lt;str\u0026lt;\u0026lt;endl; } CString::~CString() { cout\u0026lt;\u0026lt;\u0026#34;析构：\u0026#34;\u0026lt;\u0026lt;p\u0026lt;\u0026lt;endl; delete [] p; //析构函数必须是否p占用的内存 } int main() { CString s1(\u0026#34;C++\u0026#34;), s2=\u0026#34;JavaScript\u0026#34;; //定义对象 s1.show(); s2.show(); return 0; } （4）构造函数和析构函数的调用次序 构造函数和析构函数的调用很像一个栈的先进后出，调用析构函数 的次序正好与调用构造函数的次序相反。最先被调用的构造函数， 其对应的（同一对象中的）析构函数最后被调用，而最后被调用的 构造函数，其对应的析构函数最先被调用。\n","permalink":"https://tassel234.github.io/posts/note/c++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1-1/","summary":"类的定义 （1）定义类 面向程序设计更偏向于把每一个细节都做好，从每一个零件开始是制造汽车。面向对象编程偏向于把很多细小的零件已经主装好了，保留集成了很多接口，只需要把部件进行拼接就可以得到产品。 面向对象编程的意义在于自然界都是由实体组成，面向对象也是软件开发的主流方式。 面对对象的三","title":"C++学习笔记-1（类和对象-1）"},{"content":"注释语句 /* ......块注释内容 */ //......行注释内容 输入和输出 标准输入输出流库的头文件\ncin输入时，为了分隔多项数据，默认要求在键盘输入数据之间使用空格、Tab键、回车作为分隔符。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; int main() { bool v; int a,m,n; double x,y,z,p,f; float f1;//除了已经定义的变量，下面出现的oct,setw都是关键字 cin\u0026gt;\u0026gt;boolalpha\u0026gt;\u0026gt;v; //输入：true cin\u0026gt;\u0026gt;oct\u0026gt;\u0026gt;a\u0026gt;\u0026gt;hex\u0026gt;\u0026gt;m\u0026gt;\u0026gt;dec\u0026gt;\u0026gt;n;//输入：144 46 -77 cin\u0026gt;\u0026gt;p\u0026gt;\u0026gt;f\u0026gt;\u0026gt;f1\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;z;//输入：3.14 3.14 3.14 3.14159 0.1 0.1e1 cout\u0026lt;\u0026lt;v\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;boolalpha\u0026lt;\u0026lt;v\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;noboolalpha\u0026lt;\u0026lt;v\u0026lt;\u0026lt;endl;//输出：1 true 1 cout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;p\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;a*p\u0026lt;\u0026lt;endl;//输出：100 3.14 314 cout\u0026lt;\u0026lt;hex\u0026lt;\u0026lt;m\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;oct\u0026lt;\u0026lt;m\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;dec\u0026lt;\u0026lt;m\u0026lt;\u0026lt;endl;//输出：46 106 70，分别是16，8，10进制 cout\u0026lt;\u0026lt;showbase\u0026lt;\u0026lt;hex\u0026lt;\u0026lt;m\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;oct\u0026lt;\u0026lt;m\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;dec\u0026lt;\u0026lt;m\u0026lt;\u0026lt;endl; //输出：0x46 0106 70 cout.precision(5); cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;z\u0026lt;\u0026lt;endl;//输出：3.1416 0.1 1 cout\u0026lt;\u0026lt;fixed\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;z\u0026lt;\u0026lt;endl;//输出：3.14159 0.10000 1.00000 cout\u0026lt;\u0026lt;scientific\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;z\u0026lt;\u0026lt;endl; //输出：3.14159e+000 1.00000e-001 1.00000e+000 cout\u0026lt;\u0026lt;left\u0026lt;\u0026lt;setw(6)\u0026lt;\u0026lt;n\u0026lt;\u0026lt;endl; //输出：-77 cout.width(6); cout\u0026lt;\u0026lt;right\u0026lt;\u0026lt;n\u0026lt;\u0026lt;endl; //输出：_ _ _-77 cout\u0026lt;\u0026lt;setw(10)\u0026lt;\u0026lt;77\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;setfill(\u0026#39;0\u0026#39;)\u0026lt;\u0026lt;setw(10)\u0026lt;\u0026lt;77\u0026lt;\u0026lt;endl; //输出：_ _ _ _ _ _ _77 0000000077 cout\u0026lt;\u0026lt;fixed\u0026lt;\u0026lt;setprecision(5)\u0026lt;\u0026lt;f\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;setprecision(9)\u0026lt;\u0026lt;f\u0026lt;\u0026lt;endl; //输出：3.14000 3.140000000 cout\u0026lt;\u0026lt;showpos\u0026lt;\u0026lt;1\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;0\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;endl; //输出：+1 +0 -1 cout\u0026lt;\u0026lt;noshowpos\u0026lt;\u0026lt; 1\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;0\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;endl; //输出：1 0 -1 return 0; } 顺序结构 所谓顺序结构是指：语句以其出现的顺序执行。\n分支 if语句 if (a\u0026gt;b) { x=a+b; y=a-b; } else { x=a-b; y=a+b; } a=5,b=2; if ( a ) x=a*10; //等价于a!=0 switch语句 switch ( 表达式 ) { case 常量表达式1 : … 语句序列1 case 常量表达式2 : … 语句序列2 ┇ case 常量表达式n : … 语句序列n default : … 默认语句序列//其他值都在这，无论表达式的值是什么（特指case没有的值），写在最后的该语句都会被执行 } switch语句中case分支的语句序列可以是一个语句，也可以是任意多的语句序列，也可以没有语句；\nswitch语法中各个case分支和default分支的出现次序在语法上没有规定，但次序的不同安排会影响执行结果。\nswitch (n) { default: cout\u0026lt;\u0026lt;\u0026#34;0\u0026#34;;//输入1或2不执行此语句 case 1 : cout\u0026lt;\u0026lt;\u0026#34;1\u0026#34;; case 2 : cout\u0026lt;\u0026lt;\u0026#34;2\u0026#34;; } switch语法中default分支是可选的，若没有default分支且没有任何case标号的值相等时，switch语句将什么也不做，直接执行后续语句。\nswitch语句的分支表达式可以是C++语言的任意表达式，但其值必须是整数（含字符类型）、枚举类型。\n更常见的switch结构应该如下，它提供了程序多分支选择执行流程。\nswitch ( 表达式 ) { case 常量表达式1: … 语句序列1; break; case 常量表达式2: … 语句序列2; break; ┇ case 常量表达式n: … 语句序列n; break; default : … 默认语句序列 } //成绩分层程序 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; int main() { int g; cin\u0026gt;\u0026gt;g; //输入成绩等级 switch(g) { case \u0026#39;A\u0026#39;:cout\u0026lt;\u0026lt;\u0026#34;85～100\\n\u0026#34;; break; case \u0026#39;B\u0026#39;:cout\u0026lt;\u0026lt;\u0026#34;70～84\\n\u0026#34;; break; case \u0026#39;C\u0026#39;:cout\u0026lt;\u0026lt;\u0026#34;60～69\\n\u0026#34;; break; case \u0026#39;D\u0026#39;:cout\u0026lt;\u0026lt;\u0026#34;\u0026lt;60\\n\u0026#34;; break; default: cout\u0026lt;\u0026lt;\u0026#34;error\\n\u0026#34;; } return 0; } 选择语句的嵌套 if第一种方式\nif ( 表达式1 ) 语句1 else if ( 表达式2 ) 语句2 else if ( 表达式3 ) 语句3 ...... else if ( 表达式n ) 语句n else 语句m if第二种方式\nif ( 表达式1 ) if ( 表达式2 ) 语句1 else 语句2 else if ( 表达式3 ) 语句3 else 语句4 switch的嵌套\n#include \u0026lt;iostream\u0026gt; using namespace std; int main() { int y,m,d,Days; cin\u0026gt;\u0026gt;y\u0026gt;\u0026gt;m\u0026gt;\u0026gt;d; //输入日期 switch(m) { //计算每月的天数 case 2 : Days=28; if((y%4==0\u0026amp;\u0026amp;y%100!=0)|| (y%400==0)) Days++; //闰年天数加1 break; case 4 : case 6 : case 9 : case 11 : Days=30;break; default: Days=31; //其余月份为31天 } d++; if (d\u0026gt;Days) d=1,m++; //判断月末 if (m\u0026gt;12) m=1,y++; //判断年末 cout\u0026lt;\u0026lt;y\u0026lt;\u0026lt;“-”\u0026lt;\u0026lt;m\u0026lt;\u0026lt;“-”\u0026lt;\u0026lt;d\u0026lt;\u0026lt;endl; //输出第二天的日期 return 0; } 循环 基本语法 循环语句大致可以分为下面三种\n1、while语句\n2、do while语句（几乎和while等价，可以相互转化，区别在于do while多少要执行一次）\n3、for语句\nfor语句的说明。\n►（1）整个循环过程中表达式1只求解一次；作用是给循环控制变量赋初值。\n►（2）表达式2相当于是for的循环条件。\n►（3）表达式3是重复执行的内容；通常是改变循环控制变量值的语句。\n//判断质数 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int i,m; cin\u0026gt;\u0026gt;m;//从2到m-1之间逐一检查是否被m整除 for (i=2 ; i\u0026lt;=m-1 ; i++) if (m % i==0) break; //如果整除则结束检查 if (i==m) cout\u0026lt;\u0026lt;\u0026#34;Yes\u0026#34;\u0026lt;\u0026lt;endl; //根据循环结束位置判断是否素数 else cout\u0026lt;\u0026lt;\u0026#34;No\u0026#34;\u0026lt;\u0026lt;endl; return 0;\t} ►break语句的作用是结束switch语句和循环语句的运行，转到后续语句，语法形式为：break；\n►break语句只能用在switch语句和循环语句（while、do、for）中，不得单独使用。\n►continue语句的作用是在循环体中结束本次循环，直接进入下一次循环，语句形式为：continue；（可以用来求解奇书偶数的和） ► continue语句只能用在循环语句（while、do、for）中，不能单独使用。\n循环语句的选用 ►计数型循环常使用for语句\n►计数型循环用于处理已知循环次数的循环过程。\n►控制变量在每次循环时都要发生规律性变化（递增或递减），当控制变量达到预定的循环次数时，循环就结束。\n►条件型循环常使用while语句和do while语句。可以写较为抽象的条件。\n►条件型循环用于处理循环次数未知的循环过程，称为“不定次数循环”。\n►在条件型循环中，由于事先不能准确知道循环的次数，因此循环控制是由条件来判定的。在每次循环时检测这个条件，当条件一旦满足，循环就结束。\n//求π的近似值 π/4≈1-1/3+1/5-1/7+1/9-…，直到最后一项的绝对值小于10-7为止。 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; int main() { double s=1,pi=0,n=1,t=1; while (fabs(t)\u0026gt;1e-7) pi=pi+t, n=n+2, s=-s, t=s/n; cout\u0026lt;\u0026lt;pi*4\u0026lt;\u0026lt;endl; return 0; } 循环语句应用举例 百元买鸡问题\n百钱买百鸡问题：有人有一百块钱，打算买一百只鸡。公鸡一只5元，母鸡一只3元，小鸡3只1元，求应各买多少？\n//百元买鸡问题 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int x,y,z; for (x=0; x\u0026lt;=20; x++) //枚举公鸡的可能数量，最多为20 for (y=0; y\u0026lt;=33; y++) //枚举母鸡的可能数量，最多为33 for (z=0; z\u0026lt;=100; z++)//枚举小鸡的可能数量，最多为100 if(z%3==0\u0026amp;\u0026amp;x+y+z==100\u0026amp;\u0026amp;5*x+3*y+z/3==100)//约束条件 cout\u0026lt;\u0026lt;\u0026#34;公鸡=\u0026#34;\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34;,母鸡=\u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;\u0026#34;,小鸡=\u0026#34;\u0026lt;\u0026lt;z\u0026lt;\u0026lt;endl; return 0; } //百元买鸡问题（二重循环优化） #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int x,y,z; for (x=0; x\u0026lt;=20; x++) //枚举公鸡的可能数量，最多为20 for (y=0; y\u0026lt;=33; y++) { //枚举母鸡的可能数量，最多为33 z=100-x-y; //小鸡的数量根据约束条件求得 if (z%3==0 \u0026amp;\u0026amp; 5*x+3*y+z/3==100) //约束条件 cout\u0026lt;\u0026lt;\u0026#34;公鸡=\u0026#34;\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34;,母鸡=\u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;\u0026#34;,小鸡=\u0026#34;\u0026lt;\u0026lt;z\u0026lt;\u0026lt;endl;} return 0; } //百元买鸡问题（一重循环） #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { int rooster, hen, chick; int count; count = 0; //设公鸡r只,母鸡h只,雏鸡c只 //由计算可得,r = (4 * c - 300) / 3 //但是必须使等式有意义,即r\u0026gt;=0,即可求解出r的范围:c\u0026gt;=75 //此外,因为1钱可买3雏鸡,雏鸡的数量c必须是3的整数倍* //经检验,75是\u0026gt;=75且能被三整除的最小整数 //由*可知,雏鸡增加的数量也必须为3的整数倍,所以变量c每次加3 for(chick = 75; chick \u0026lt;= 300; chick = chick + 3) //这条语句限定了chick的范围 75~300 { count++; if ((4 * chick - 300) % 3 == 0)//rooster表达式递增且大于0,但要保证为整数 { rooster = (4 * chick - 300) / 3; hen = (600 - 7 * chick) / 3;//这里无需检验hen是否为整数,因为hen=100-r-c,且前面保证了r,c为整数 if (hen \u0026gt;= 0)//因为hen的表达式递减,这条语句限定了hen的范围\u0026gt;0 printf(\u0026#34;Rooster: %d, Hen: %d, Chick: %d\\n\u0026#34;, rooster, hen, chick); else break; } } printf(\u0026#34;Total count: %d\u0026#34;, count); return 0; } 函数 函数的定义和使用 （1）函数的定义和函数的参数\n返回类型可以是C++除数组之外的内置数据类型或自定义类型。 函数可以不返回数据，此时返回类型应写成void，表示没有返回值。\n#include \u0026lt;iostream\u0026gt; using namespace std; int IsPrime(int m) //求素数函数 { //枚举法求m是否素数 int i; for (i=2 ; i\u0026lt;=m-1 ; i++) if (m % i==0) return 0; //不是素数返回0 return 1; //是素数返回1 } int main() { int m; cin\u0026gt;\u0026gt;m; if (IsPrime(m)) cout\u0026lt;\u0026lt;\u0026#34;Yes\u0026#34;\u0026lt;\u0026lt;endl; //是素数输出Yes else cout\u0026lt;\u0026lt;\u0026#34;No\u0026#34;\u0026lt;\u0026lt;endl; //不是素数输出No return 0; } 1）函数定义时指定的形参，在未进行函数调用前，并不实际占用 内存中的存储单元。\n2）只有在发生函数调用时，形参才分配实际的内存单元，接受从 主调函数传来的数据。\n3）当函数调用结束后，形参占用的内存单元被自动释放。\n值传递（pass-by-value）过程中，形参作为被调函数的内部变量来处理，即开辟内存空间以存放由主调函数复制过来的实参的值，从而成为实参的一个副本。实参数据传递给形参是单向传递，即只能由实参传递给形参，而不能由形参传回给实参。\n函数调用时提供给被调函数的参数称为实际参数（arguments）， 简称实参。\n实参必须有确定的值，因为调用函数会将它们传递给形参。实参可 以是常量、变量或表达式，还可以是函数的返回值。例如：\nx = max(a,b); //max函数调用，实参为a,b y = max(a+3,128); //max函数调用，实参为a+3,128 z = max(max(a,b),c); //max函数调用，实参为max(a,b),c （2）函数的声明与内联函数\n声明时使用函数原型（function prototype）。其作用是提供函数调用所必须的接口信息，函数原型可以没有形式参数的名字，到后面函数定义可以再写。但为了调用函数原型必须放在调用之前，而函数定义可以放在函数调用之后。\nint gcd(int m, int n) //求最大公约数，gcd函数实现在后 { int r; while (n!=0) { //欧几里德算法，举例是：m=9, n=6 ① r=3, m=6, n=3 ② r=0, m=3, n=0 r = m % n ; //r为m/n的余数 m = n ; //则gcd(m,n)=gcd(n,r)=... n = r ; //r=0时n即是gcd } return m; } C++提供一种提高函数效率的方法，即在编译时将被调函数的代码 直接嵌入到主调函数中，取消调用这个环节。这种嵌入到主调函数 中的函数称为内联函数（inline function）。\ninline 返回类型 函数名(形式参数列表) { 函数体 } 但因为过于复杂的函数内联会导致错误，内联函数中不允许用循环语句和switch语句。\n函数的设计 默认参数\nint add(int x=5,int y=6) 可以这样调用。 add(10,20); //10+20 add(10); //10+6 add(); //5+6\n可以设置多个默认参数，设置的顺序为自右向左，换言之，要为某个参数设置默认值，则它右边的所有参数必须都是默认参数。\n默认值可以是常量、全局变量，甚至是一个函数调用，但不可以是局部变量。 函数重载 就是可以取同名的函数。\n函数重载的使用说明：\n（1）重载函数的形参必须不同（个数不同或类型不同）。\n（2）编译程序将根据实参和形参的类型及个数的最佳匹配来选择调用哪一个函数。\n（3）不要将不同功能的函数声明为重载函数，以免出现调用结果的误解、混淆。\n函数模板与库函数的调用\n函数模板（function template）是一个独立于类型的函数，可作为一种模式，产生函数的特定类型版本。\ntemplate\u0026lt;typename T\u0026gt; T abs(T x) { return x\u0026lt;0?-x:x; } 标准库函数的连接在开发环境中是默认的，一般可以不用特别设置，只需要在文件开头输入#include 声明一下就行。包括stl,c语言库等。\n对于一些特殊的由其他人编写的库，一般提前下载，然后再按配置说明进行安装就行。\n函数的调用 （1）函数的嵌套调用\n在调用一个函数的过程中，又调用另一个函数，称为函数的嵌套调 用，C++允许函数多层嵌套调用，只要在函数调用前有函数声明即 可。\n（2）函数的递归调用\n可以使用递归解决阶乘，汉诺塔问题的求解。\n作用域、生命期和程序的组织结构 （1）作用域和生命期\n局部变量只能在定义它的区域及其子区域中使用。\n在不同区域中允许定义相同名字的变量，但本质上它们是不同的变量\n如果一个变量所处区域的子区域中有同名的变量，则该变量在子区域无效，有效的是子区域的变量，称为定义屏蔽。\n#include \u0026lt;iostream\u0026gt; using namespace std; void swap(int x,int y) { int t; t=x; x=y; y=t; } int main( ) { int a,b; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; swap(a,b); cout\u0026lt;\u0026lt;\u0026#34;a=\u0026#34;\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026#34;,b=\u0026#34;\u0026lt;\u0026lt;b\u0026lt;\u0026lt;endl; return 0;//最后不交换次序 } #include \u0026lt;iostream\u0026gt; using namespace std; int x,y; void swap() { int t; t=x; x=y; y=t; } int main( ) { int a,b; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; swap(a,b); cout\u0026lt;\u0026lt;\u0026#34;a=\u0026#34;\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026#34;,b=\u0026#34;\u0026lt;\u0026lt;b\u0026lt;\u0026lt;endl; return 0;//会交换次序 作用域是程序中的一段区域。在同一个作用域上，C++程序中每个名字都与唯一的实体对应；如果在不同的作用域上，程序中可以多次使用同一个名字，对应不同作用域中的不同实体。\n实体在包含它的作用域内，从定义或声明的位置开始，按文件行的顺序往后（往下）直到该作用域结束均是可见的，包含作用域内的所有子区域及其嵌套。但是往前就看不到了。\n可以使用extern声明将变量或函数实体的可见区域往前延伸，称为前置声明。\n在全局作用域中，变量或函数实体若使用static修饰，则该实体对于其他源文件是屏蔽的，称为私有的（private）。\n动态存储在分配和释放的形式有两种，一种是由函数调用来自动完 成的，称为自动存储（automatic storage）如默认参数，结构体和类的实例化，一种是由程序员通过 指令的方式来人工完成的，称为自由存储（free storage）\n现代程序设计的观点是，除非有必要尽量少地使用静态存储\nC++语言允许用CPU的寄存器来存放局部变量，称为寄存器变量。 在局部变量前加上register存储类别修饰来定义的，其形式为：\nregister 类型 变量名[=初值] 在局部对象的前面加上static存储类别修饰用来指明对象是静态局 部对象（static local ）\n#include \u0026lt;iostream\u0026gt; using namespace std; int fun() { static int cnt=0; //静态局部变量会保持其值 ，可以做计数器 cnt++; return cnt; } int main() { int i,c; for (i=1;i\u0026lt;=10;i++) c=fun(); cout\u0026lt;\u0026lt;c\u0026lt;\u0026lt;endl; return 0; } （2）程序的组织结构\n函数本质上是全局的，在多文件的程序中，在连接时会检查函数在 全局作用域内是否名字唯一，如果不是则出现连接错误。\n在函数定义前加上static修饰，则函数称为内部函数。内部函数仅在包含它的文件中有效。\n在函数定义前加上extern声明，则函数称为外部函数。C++中所有的函数本质上都是外部函数。因此，上面的extern都可以省略。\n头文件与工程文件\n如果是多文件结构程序，欲在文件中调用别的文件中的函数，需要有函数的声明，而且每个文件均是如此。如果是函数声明比较多的情况下，在每个文件中都写上函数声明不是好办法，很难管理。如果某个函数定义有变动，那么所有含有这个函数声明的调用文件都需要找出来，逐一修改。使用头文件可以解决这个问题，其工作原理是通过将每个源文件中外部函数的函数声明等信息集中写到一个文件中，称为头文件（有别于源文件），而别的源文件只需用文件包含命令将这个头文件包含，则编译时编译器自然就有了函数声明。\n多文件结构程序在编译时需要工程文件来管理，不同的编译器有不 同的工程文件格式。\n多文件编译\n头文件a.h和cpp文件a.cpp\n#include \u0026#34;a.h\u0026#34;//\u0026#34;\u0026#34;表示在工程文件夹寻找，\u0026lt;\u0026gt;是只在系统文件夹找 //直接引用.h头文件 ","permalink":"https://tassel234.github.io/posts/note/c++%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%87%BD%E6%95%B0/","summary":"注释语句 /* ......块注释内容 */ //......行注释内容 输入和输出 标准输入输出流库的头文件 cin输入时，为了分隔多项数据，默认要求在键盘输入数据之间使用空格、Tab键、回车作为分隔符。 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; int main() { bool v; int a,m,n; double x,y,z,p,f; float f1;//除了已经定义的变量，下面出现的oct,setw都","title":"C++入门学习笔记 2(语句和函数)"},{"content":"前言 使用资源 （主）程序员的数学4：图论 算法图解动画软件演示 计算之魂\n目标指向 了解图的基本知识，可以对图论模型进行数学建模和程序求解。\n图的基础知识 什么是图 在数学中，图是描述于一组对象的结构，其中某些对象对在某种意义上是“相关的”。这些对象对应于称为顶点的数学抽象（也称为节点或点），并且每个相关的顶点对都称为边（也称为链接或线）。通常，图形以图解形式描绘为顶点的一组点或环，并通过边的线或曲线连接。 图形是离散数学的研究对象之一。\n图的表示法 在计算机中表示图的方式由邻接矩阵，关联矩阵，邻接表。\n其他图论术语 度（Degree）：一个顶点的度是指与该顶点相关联的边的条数，顶点v的度记作d(v)。\n对任意图，度的个数之和都是偶数，也就是握手定理。\n迹：如果路径P(u,v)中的边各不相同，则该路径称为u到v的一条行迹。 路（轨道）：如果路径P(u,v)中的顶点各不相同，则该路径称为u到v的一条轨道。 闭的行迹称作回路（Circuit），闭的轨称作圈（Cycle）。\n定理1 设图G的邻接矩阵为A，A的K次幂的（i,j元素）等于在图G中由i到j长度为K的路径数  子图（Sub-Graph）：当图G'=(V',E')其中V‘包含于V，E’包含于E，则G\u0026rsquo;称作图G=(V,E)的子图。每个图都是本身的子图。\n生成子图（Spanning Sub-Graph）：指满足条件V(G') = V(G)的G的子图G'。\n导出子图（Induced Subgraph）：以图G的顶点集V的非空子集V1为顶点集，以两端点均在V1中的全体边为边集的G的子图，称为V1导出的导出子图；以图G的边集E的非空子集E1为边集，以E1中边关联的顶点的全体为顶点集的G的子图，称为E1导出的导出子图。\n补图。点不变，完全图的补线构成的图。\n几类特殊的图 树和森林 联通且不含圈的图称为树，多个不相连的树构成森林。 单个树可以看作一个比较特殊的森林。\n二部图（二分图） 二分图：顶集，且每一条边都有一个顶点在X中，而另一个顶点在Y中。 完全二分图：二分图G中若任意两个X和Y中的顶点都有边相连。若，则图G记作Km,n。 如上图，树是二部图。\n可平面图 图可以被画成边各不相交的图，称为可平面图。\n定理2：欧拉公式 不论什么形状的可平面图（凸多面体），其顶点数V、棱数E、面数F之间总有关系V+F-E=2  其他 完全图：每一对不同顶点间都有边相连的的图，记作Kn。\n正则图：如果图中所有顶点的度皆相等，则此图称为正则图\n图的度序列 定理3：通过度判断一个序列是否为可图化序列 首先把各顶点的度按降序排列形成度序列 。 去掉第一个数字k，然后把前k个数字减1，再按降序排列，循环步骤简化图。  最小生成树 什么是最小生成树 在图（包括赋权图）中，可以找到的路径长度之和最小的树。 可以解决电缆安装问题，只要达到每一个地点就行，形成连通图。\n克鲁斯卡尔算法 属于贪心算法的一种。 按找赋权的大小依次查找，让其不构成圈，最后可以产生最小生成树 。\n普里姆算法 也属于贪心算法的一种。 以某个节点开始，查找赋权小的。\n最小斯坦纳树问题 某些节点可以连（作为中继节点），也可以不连。 NP难的问题，不太可能存在高效的算法。\n最短路径问题 什么是最短路径问题 由一点到另一点所用路径的权值总和最小的问题。\n迪杰斯特拉算法 每一个节点初始化为非常大的数，路径上赋权正常的数字，赋值方式是节点的值加上路径的值。 通过查找可行路径给节点赋值，节点的值往小的地方更新。 满足条件因为使用其他路径时，必须经过点C，但AC成本大于AB成本 但也因为这个限制，权值不能为负，否则可能会出错，这一点不如福特算法 但斯拉特算法也有优点，比如他的速度要快上很多 对于单行道和双向通道值不一致时也可以非常好的解决，这是福特算法做不到的\n欧拉回路与哈密顿圈 欧拉回路 就像七桥问题，把每一个边走且只走一遍，就是欧拉回路。\n形成欧拉回路的充分必要条件是顶点的度都是偶数。\n哈密顿圈 把每一个点走且只走一遍，就是哈密顿圈 。\n是NP完全问题，不太可能存在高效算法。\n狄拉克定理 狄拉克定理：如果图是一个具有至少3个顶点的简单图G，并且图中每个顶点的度数至少为节点数的一半，那么图包含哈密顿图。\n奥尔定理\n奥尔定理是图论在1960年由挪威数学家奥斯汀·奥尔证明的结果，它为图成为哈密顿量提供了充分的条件，从本质上说，具有“足够多的边”的图必须包含哈密顿环。 具体来说，该定理考虑非相邻顶点对的度数之和：如果每个这样的对具有至少等于图中顶点总数的和，则该图为哈密顿图。如果一个总点数至少为3的简单图G满足：G的任意两个不相邻的点u和v度数之和至少为n，即d(u)+d(v)≥n，那么G必然有哈密顿回路。\n","permalink":"https://tassel234.github.io/posts/note/%E5%9B%BE%E8%AE%BA%E5%85%A5%E9%97%A8-1/","summary":"前言 使用资源 （主）程序员的数学4：图论 算法图解动画软件演示 计算之魂 目标指向 了解图的基本知识，可以对图论模型进行数学建模和程序求解。 图的基础知识 什么是图 在数学中，图是描述于一组对象的结构，其中某些对象对在某种意义上是“相关的”。这些对象对应于称为顶点的数学抽象（也称为节点或点），并","title":"图论入门-1"},{"content":"python数模算法-1（库的基本使用和绘图基础） 前言 使用学习资源 python数学建模算法与应用（司守奎） 比较全面的建模算法视频（但编程语言是matlab）\n目标指向 只需要会看那些代码并运行实现一次代码和理解用途就可以了，需要使用的时候查阅复制粘贴就可以了。\n算法具体实现的逻辑步骤要搞清楚，锻炼一些编程思想，可以对程序进行合理的修改。\n编程环境配置 conda-python3.10.9\nlatex（可无）\n库的使用 numpy对数组 数组生成\nimport numpy as np a1 = np.array([1, 2, 3, 4]) #生成整型数组 a2 = a1.astype(float) a3 = np.array([1, 2, 3, 4], dtype=float) #浮点数 print(a1.dtype); print(a2.dtype); print(a3.dtype) b = np.array([[1, 2, 3], [4, 5, 6]]) c = np.arange(1,5) #生成数组[1, 2, 3, 4] d = np.linspace(1, 4, 4) #前面是范围，后面是分割数，生成数组[1, 2, 3, 4] e = np.logspace(1, 3, 3, base=2) #生成等比数列数组[2, 4, 8] import numpy as np a = np.ones(4, dtype=int) #输出[1, 1, 1, 1] b = np.ones((4,), dtype=int) #逗号加在前面会报错，输出同a c= np.ones((4,1)) #输出4行1列的数组 d = np.zeros(4) #输出[0, 0, 0, 0] e = np.empty(3) #生成3个元素的空数组行向量 f = np.eye(3) #生成3阶单位阵 g = np.eye(3, k=-1) #主对角线是0，生成第k对角线的元素为1，其他元素为0的3阶方阵 h = np.zeros_like(a) #生成与a同维数的全0数组 print(g) print(c) 数组元素的索引\nimport numpy as np a = np.arange(16).reshape(4,4) #生成4行4列的数组 b = a[1][2] #输出6 c = a[1, 2] #同b d = a[1:2, 2:3] #输出[[6]] x = np.array([0, 1, 2, 1]) print(a[x==1]) #输出a的第2、4行元素 print(a) numpy对矩阵 矩阵的合并 np.vstack([a, b]) #上下合并矩阵 np.hstack([a, c]) #左右合并矩阵\n矩阵的分割 b = np.vsplit(a, 2) #行分割 c = np.hsplit(a, 4) #列分割\n矩阵的乘法\n使用符号@，前面的相当于行向量\n范数计算\nimport numpy as np a = np.array([[0, 3, 4], [1, 6, 4]]) b = np.linalg.norm(a, axis=1) #求行向量2范数 c = np.linalg.norm(a, axis=0) #求列向量2范数 d = np.linalg.norm(a) #求矩阵2范数 print(\u0026#39;行向量2范数为：\u0026#39;, np.round(b, 4)) print(\u0026#39;列向量2范数为：\u0026#39;, np.round(c, 4)) print(\u0026#39;矩阵2范数为：\u0026#39;, round(d, 4)) 求线性方程的唯一解\nimport numpy as np a = np.array([[3, 1], [1, 2]]) b = np.array([9, 8]) x1 = np.linalg.inv(a) @ b #第一种解法 #上面语句中@表示矩阵乘法 x2 = np.linalg.solve(a, b) #第二种解法 print(x1); print(x2) 求超定线性方程组的唯一解\nimport numpy as np a = np.array([[3, 1], [1, 2], [1, 1]]) b = np.array([9, 8, 6]) x = np.linalg.pinv(a) @ b print(np.round(x, 4)) 特征值和特征向量\nimport numpy as np a = np.eye(4) b = np.rot90(a) #好像代表转 c, d = np.linalg.eig(b) print(\u0026#39;特征值为：\u0026#39;, c) print(\u0026#39;特征向量为：\\n\u0026#39;, d) pandas 生成二维数组\nimport pandas as pd import numpy as np dates=pd.date_range(start=\u0026#39;20191101\u0026#39;,end=\u0026#39;20191124\u0026#39;,freq=\u0026#39;D\u0026#39;) a1=pd.DataFrame(np.random.randn(24,4), index=dates, columns=list(\u0026#39;ABCD\u0026#39;)) a2=pd.DataFrame(np.random.rand(24,4)) 读写文件\nimport pandas as pd import numpy as np dates=pd.date_range(start=\u0026#39;20191101\u0026#39;, end=\u0026#39;20191124\u0026#39;, freq=\u0026#39;D\u0026#39;) a1=pd.DataFrame(np.random.randn(24,4), index=dates, columns=list(\u0026#39;ABCD\u0026#39;)) a2=pd.DataFrame(np.random.randn(24,4)) a1.to_excel(\u0026#39;data2_38_1.xlsx\u0026#39;) #可以修改此行让其不带索引 a2.to_csv(\u0026#39;data2_38_2.csv\u0026#39;) f=pd.ExcelWriter(\u0026#39;data2_38_3.xlsx\u0026#39;) #创建文件对象 a1.to_excel(f,\u0026#34;Sheet1\u0026#34;) #把a1写入Excel文件 a2.to_excel(f,\u0026#34;Sheet2\u0026#34;) #把a2写入另一个表单中 f.save() 数据预处理\nimport pandas as pd import numpy as np d=pd.DataFrame(np.random.randint(1,6,(10,4)), columns=list(\u0026#34;ABCD\u0026#34;)) d1=d[:4] #获取前4行数据 d2=d[4:] #获取第5行以后的数据 dd=pd.concat([d1,d2]) #数据行合并 s1=d.groupby(\u0026#39;A\u0026#39;).mean() #数据分组求均值 s2=d.groupby(\u0026#39;A\u0026#39;).apply(sum) #数据分组求和 import pandas as pd import numpy as np a = pd.DataFrame(np.random.randint(1,6,(5,3)), index=[\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;], columns=[\u0026#39;one\u0026#39;, \u0026#39;two\u0026#39;, \u0026#39;three\u0026#39;]) a.loc[\u0026#39;a\u0026#39;, \u0026#39;one\u0026#39;] = np.nan #修改第1行第1列的数据 b = a.iloc[1:3, 0:2].values #提取第2、3行，第1、2列数据 a[\u0026#39;four\u0026#39;] = \u0026#39;bar\u0026#39; #增加第4列数据 a2 = a.reindex([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;]) a3 = a2.dropna() #删除有不确定值的行 scipy 求解非线性方程\nfrom scipy.optimize import fsolve, root fx = lambda x: x**980-5.01*x**979+7.398*x**978\\ -3.388*x**977-x**3+5.01*x**2-7.398*x+3.388 x1 = fsolve(fx, 1.5, maxfev=4000) #函数调用4000次 x2 = root(fx, 1.5) print(x1,\u0026#39;\\n\u0026#39;,\u0026#39;-------------\u0026#39;); print(x2) 最小二乘法\nfrom scipy.optimize import least_squares import numpy as np a=np.loadtxt(\u0026#39;data2_47.txt\u0026#39;) x0=a[0]; y0=a[1]; d=a[2] fx=lambda x: np.sqrt((x0-x[0])**2+(y0-x[1])**2)-d s=least_squares(fx, np.random.rand(2)) print(s, \u0026#39;\\n\u0026#39;, \u0026#39;------------\u0026#39;, \u0026#39;\\n\u0026#39;, s.x) 求最大模特征值和对应的特征向量\nfrom scipy.sparse.linalg import eigs import numpy as np a = np.array([[1, 2, 3], [2, 1, 3], [3, 3, 6]], dtype=float) #必须加float,否则出错 b, c = np.linalg.eig(a) d, e = eigs(a, 1) print(\u0026#39;最大模特征值为：\u0026#39;, d) print(\u0026#39;对应的特征向量为：\\n\u0026#39;, e) 此外，还可以求解积分，傅里叶变换，插值，信号处理等。\nsympy 可以用计算机推导表达式，可以对符号运算。\nimport sympy as sp a, b, c, x=sp.symbols(\u0026#39;a,b,c,x\u0026#39;) x0=sp.solve(a*x**2+b*x+c, x) print(x0) import sympy as sp sp.var(\u0026#39;x1,x2\u0026#39;) s=sp.solve([x1**2+x2**2-1,x1-x2],[x1,x2]) print(s) import numpy as np import sympy as sp a = np.identity(4) #单位矩阵的另一种写法 b = np.rot90(a) c = sp.Matrix(b) print(\u0026#39;特征值为：\u0026#39;, c.eigenvals()) print(\u0026#39;特征向量为：\\n\u0026#39;, c.eigenvects()) matplotlib绘图介绍 二维绘图 绘制折线图\nimport pandas as pd import pylab as plt plt.rc(\u0026#39;font\u0026#39;,family=\u0026#39;SimHei\u0026#39;) #用来正常显示中文标签，还有一个正常显示符号的语句 plt.rc(\u0026#39;font\u0026#39;,size=16) #设置显示字体大小 a=pd.read_excel(\u0026#34;data2_52.xlsx\u0026#34;, header=None) #和py文件保存在同一级目录 b=a.values #提取其中的数据 x=b[0]; y=b[1:] plt.plot(x,y[0],\u0026#39;-*b\u0026#39;,label=\u0026#39;铂金\u0026#39;) plt.plot(x,y[1],\u0026#39;--dr\u0026#39;,label=\u0026#39;铂金\u0026#39;) plt.xlabel(\u0026#39;月份\u0026#39;); plt.ylabel(\u0026#39;每月销量\u0026#39;) plt.legend(loc=\u0026#39;upper left\u0026#39;); plt.grid(); plt.show() ()使用pandas的Dateframe绘图 绘制柱状图\nimport pandas as pd import pylab as plt plt.rc(\u0026#39;font\u0026#39;,family=\u0026#39;SimHei\u0026#39;) #用来正常显示中文标签 plt.rc(\u0026#39;font\u0026#39;,size=16) #设置显示字体大小 a=pd.read_excel(\u0026#34;data2_52.xlsx\u0026#34;,header=None) b=a.T; b.plot(kind=\u0026#39;bar\u0026#39;); plt.legend([\u0026#39;钻石\u0026#39;, \u0026#39;铂金\u0026#39;]) plt.xticks(range(6), b[0], rotation=0); plt.show() 子图\nimport pylab as plt import numpy as np plt.rc(\u0026#39;text\u0026#39;, usetex=True) #调用tex字库 y1=np.random.randint(2, 5, 6); y1=y1/sum(y1); plt.subplot(2, 2, 1); str=[\u0026#39;Apple\u0026#39;, \u0026#39;grape\u0026#39;, \u0026#39;peach\u0026#39;, \u0026#39;pear\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;pineapple\u0026#39;] plt.barh(str,y1) #水平条形图 plt.subplot(222); plt.pie(y1, labels=str) #饼图 plt.subplot(212) x2=np.linspace(0.01, 10, 100); y2=np.sin(10*x2)/x2 plt.plot(x2,y2); plt.xlabel(\u0026#39;$x$\u0026#39;) plt.ylabel(\u0026#39;$\\\\mathrm{sin}(50x)/x$\u0026#39;); plt.show()#latex表示数学公式 linspace(a,b,c)表示的是把a-b平均分成c分, 三维绘图 三维曲线\nimport pylab as plt import numpy as np ax=plt.axes(projection=\u0026#39;3d\u0026#39;) #设置三维图形模式 z=np.linspace(-50, 50, 1000) x=z**2*np.sin(z); y=z**2*np.cos(z) plt.plot(x, y, z, \u0026#39;k\u0026#39;); plt.show() 三维表面图\nimport pylab as plt import numpy as np x=np.linspace(-4,4,100); x,y=np.meshgrid(x,x) z=50*np.sin(x+y); ax=plt.axes(projection=\u0026#39;3d\u0026#39;) ax.plot_surface(x, y, z, color=\u0026#39;y\u0026#39;) plt.show() import pylab as plt import numpy as np ax=plt.axes(projection=\u0026#39;3d\u0026#39;) X = np.arange(-6, 6, 0.25) Y = np.arange(-6, 6, 0.25) X, Y = np.meshgrid(X, Y) Z = np.sin(np.sqrt(X**2 + Y**2)) surf = ax.plot_surface(X, Y, Z, cmap=\u0026#39;coolwarm\u0026#39;) plt.colorbar(surf); plt.show() 概率统计模型专题绘图 直方图 也称频数图\nimport pandas as pd import pylab as plt df = pd.read_csv(\u0026#39;data9_5.txt\u0026#39;, header=None) df = df.T #转置 plt.subplot(121); h1 = plt.hist(df[0], 5); print(h1) plt.subplot(122); plt.hist(df[1], 5) df.hist(bins=5) #另一种方法画直方图 plt.show() 箱线图\n几个点分别是最小值，1/4值，中位数，3/4点，最大值。 用来观察离散程度。\nimport pandas as pd import pylab as plt df = pd.read_csv(\u0026#39;data9_5.txt\u0026#39;, header=None).T plt.rc(\u0026#39;font\u0026#39;, family=\u0026#39;SimHei\u0026#39;); plt.rc(\u0026#39;font\u0026#39;, size=16); plt.boxplot(df, labels=[\u0026#39;甲班\u0026#39;, \u0026#39;乙班\u0026#39;]); plt.show() QQ图\n可以检验拟合优度。同时不建议直接使用库函数绘制QQ图\nimport pandas as pd import pylab as plt from scipy.stats import norm, probplot df = pd.read_csv(\u0026#39;data9_5.txt\u0026#39;, header=None) d = df.values[0] #提取甲班成绩 mu = d.mean(); s = d.std(); sd = sorted(d); n = len(d) x = (plt.arange(n)+1/2)/n; yi = norm.ppf(x, mu, s) plt.rc(\u0026#39;font\u0026#39;, size=16); plt.rc(\u0026#39;font\u0026#39;, family=\u0026#39;SimHei\u0026#39;) plt.rc(\u0026#39;axes\u0026#39;, unicode_minus=False) plt.subplot(121); plt.plot(yi, sd, \u0026#39;o\u0026#39;, label=\u0026#39;QQ图\u0026#39;) plt.plot(sd, sd, label=\u0026#39;参照直线\u0026#39;); plt.legend() plt.subplot(122); probplot(d, plot=plt); plt.show() ","permalink":"https://tassel234.github.io/posts/note/python%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AE%97%E6%B3%95-1%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%92%8C%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80/","summary":"python数模算法-1（库的基本使用和绘图基础） 前言 使用学习资源 python数学建模算法与应用（司守奎） 比较全面的建模算法视频（但编程语言是matlab） 目标指向 只需要会看那些代码并运行实现一次代码和理解用途就可以了，需要使用的时候查阅复制粘贴就可以了。 算法具体实现的逻辑步骤要","title":"Python数学建模算法-1（库的基本使用和绘图基础）"},{"content":"github和git的基础知识（可跳过不看）  Github 代码上边的Raw、Blame是什么意思？\n  Raw：文件内容。 blame：按行显示最新提交的信息。\n Pin，该词可被译为：钉住、按住。被Pin的仓库会显示在个人主页中，类似于仓库置顶。 Watch，默认是Unwatch，如果你想关注某个仓库，当这个库有新的通知时就会提醒你。 star,表示喜爱。\nFork代表从别人的代码仓库中复制一份到自己的代码库，包含了别人库中的提交历史记录。经过fork后的代码库是完全独立的，由自己维护，可以进行任何魔改。改完之后自己可以通过Pull Request向原来的库提交合并请求。 1. Fork别人的仓库：复制别人仓库（代码、文件、提交历史记录、issue等），复制后的仓库在自己的github账号中存着。 2. Clone远程仓库：将这个复制后的远程仓库克隆到本地。 3. 在工作区对代码进行CRUD操作（增删改查） 4. 将代码的更改提交暂存区（git add .） 5. 将暂存区的文件提交到本地仓库（git commit -m \u0026lsquo;小修一下\u0026rsquo;） 6. 将本地仓库的代码推送到远程仓库（git push） 7. 给别人的仓库发送Pull Request：如果原作者认为你的修改版本不错，就会将你代码中的修改合并到自己的库中。\n可以在写编写markdown文件于github网站\nGit是一款分布式源代码管理工具(版本控制工具) ，可以对我们写的代码进行托管和版本记录（每上传一次形成一个版本，可以找回）。github和git的关系非常紧密，hub在百度翻译有如下解释：\n n. 轮毂; (某地或活动的)中心; [例句]The island\u0026rsquo;s social hub is the Cafe Sport 该岛的社交中心是“体育咖啡馆”。 可以理解为github以git为传输路径，把程序员上传过的代码集中,迭代，存放在github的仓库中，方便和其他程序员的合作或交流。\n git的进一步学习\n前言 本文介绍如何使用Github+Hugo+PaperMod主题搭建一个人博客。\n此文章也记录了我搭建博客较为详细的步骤和一些在博客搭建过程中出现的问题和解决方案。\n参考资料 23年的hugo博客搭建视频\nsulv的博客\n333rd的博客\nrosefinch-midsummer的博客\n前置工作 需要一个github账号,可以在网页打开github,推荐使用fastgithub软件，翻墙也行。\n下载hugo,推荐安装比较原始的版本，后面会解释为什么。\n下载地址\n下载和安装git，见视频\n安装github desktop，使用该软件可以从本地库克隆到github仓库，并可以完成较为方便的上传更新。\n安装fastgithub，可以获得非常快的github访问速度，而且不用翻墙。\n下载fastgithub\n搭建博客  先下载好hugo,推荐下载hugo v0.85.0版本，之前我下载了最新版本，死活不能把配置文件改成yaml格式，也就没办法直接调用别人写好的漂亮的网站结构。接下来的文字是对视频的总结，更直观的步骤请查阅hugo博客搭建视频 把下载好后把hugo.exe所在的文件夹地址放置在环境变量的系统变量中。 在cmd窗口输入hugo version查看版本和确认安装成功。  生成新站点，hugo new site \u0026lt;想要存储到的位置\u0026gt;/\u0026lt;站点名字\u0026gt; -f yml ， 实例hugo new site D:/path/to/newst -f yml ，  -f yml是把toml文件格式改成yaml格式，最新版这个指令修改不了配置文件（config）格式。\n然后就可以在文件夹找到生成的站点   在路径栏目输入cmd,打开，\n  输入hugo new posts/tech/文章名称.md生成第一篇博客文章。应该在tech目录下写一个_index.md文件用于索引。\n  安装主题，使用命令行git clone https://github.com/adityatelange/hugo-PaperMod.git\n  下载最新版本，实际上后面cmd提示hugo版本和papermod版本不完全匹配，但最后还是可以生成不错的博客页面，然后对config.yaml进行重写，赋值代码和粘贴config.yml此外写入的md文本应该在github复制最新版，旧版会报错。\n写好了开始生成静态页面，站点目录的cmd输入hugo version在本地查看\n 站点目录的cmd输入hugo生成文件夹public\n  在public的文件夹的cmd进行git 导入，输入git init,一个文件夹导入一次就够了\n  博客上传 配置FastGithub(可以跳过不看) 双击打开FastGithub.UI.exe应用程序,程序会在后台运行。\nfirefox提示连接有潜在的安全问题 设置-\u0026gt;隐私与安全-\u0026gt;证书-\u0026gt;查看证书-\u0026gt;证书颁发机构，导入cacert/fastgithub.cer，勾选“信任由此证书颁发机构来标识网站”\n安全性说明\nFastGithub为每台不同的主机生成自颁发CA证书，保存在cacert文件夹下。客户端设备需要安装和无条件信任自颁发的CA证书，请不要将证书私钥泄露给他人，以免造成损失。\n合法性说明\n《国际联网暂行规定》第六条规定：“计算机信息网络直接进行国际联网，必须使用邮电部国家公用电信网提供的国际出入口信道。任何单位和个人不得自行建立或者使用其他信道进行国际联网。” FastGithub本地代理使用的都是“公用电信网提供的国际出入口信道”，从国外Github服务器到国内用户电脑上FastGithub程序的流量，使用的是正常流量通道，其间未对流量进行任何额外加密（仅有网页原有的TLS加密，区别于VPN的流量加密），而FastGithub获取到网页数据之后发生的整个代理过程完全在国内，不再适用国际互联网相关之规定。\n通过git和github desktop将博客上传到github 输入上述两串代码，然后在github desktop进行上传，浏览器的github就可以更新了。\n上传点击fetch origin按钮.\n网页显示 在GitHub网页端，点击hugo博客代码存放库，点击settings,点击pages,修改Branch的none为master,等待一会，就可以生成网页了。\n更新 hugo -F \u0026ndash;cleanDestinationDir完成public文件夹的更新, 然后再重复上传步骤即可.\n添加图片 笔者使用的是vnote，记markdown笔记。 图片引用代码如下： ![](vx_images/ex.png =481x)\n首先应该在static文件夹下创建vx_images文件夹，再把要用的图片导入，但有两个问题。\n 不能加图片大小，也就是把 =481x去掉 前面应该加一个/  如何改进博客 创建拥有美观界面的博客 sulv大佬已经写好了一个优美的yaml配置文件,我们只需要复制粘贴到config配置文件就可以了。 但博客网页的yaml代码不能成功执行，因为sulv的博客和333rd的博客的博客都是创作于几年前，hugo和papermod的版本更新导致了各种问题，所以应该直接在github中复制，config.yml\n至于配置头像，联系方式等，也请参照上面两个博客。\n改进指南 插件\n建站\n统计部署\n为什么要写博客  通过强迫自己记笔记，对知识进行整理，对日常和灵感进行记录 可以促进知识的输出，检验自己的掌握程度，类似费曼学习法 博客本身可以促进学习，并且有助于和别人交流自己的想法  ","permalink":"https://tassel234.github.io/posts/tech/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","summary":"github和git的基础知识（可跳过不看） Github 代码上边的Raw、Blame是什么意思？ Raw：文件内容。 blame：按行显示最新提交的信息。 Pin，该词可被译为：钉住、按住。被Pin的仓库会显示在个人主页中，类似于仓库置顶。 Watch，默认是Unwatch，如果你想关注某个仓库，","title":"Hugo搭建个人博客"},{"content":"故事梗概 《外婆的道歉信》是瑞典作家弗雷德里克·巴克曼创作的一部长篇小说，讲述了一个关于爱，原谅与守护的温馨故事。这部作品以其幽默、独特的叙事风格和深入浅出的人物描绘，受到了广泛关注。\n小说以小女孩爱莎的视角，展示了一个独特、充满想象力的世界。爱莎是一个聪明、机智的小女孩，她与外婆共同生活，度过了许多难忘的时光。外婆是一个疯狂古怪，打破世俗，四处惹麻烦的存在，却是小女孩爱莎心中的英雄和唯一的朋友。为了安抚爱莎不幸的童年，给与爱莎爱的守护，外婆创作了一个又一个童话故事。然而，外婆去世后，爱莎发现自己陷入了一场冒险——把外婆的道歉信分发给曾经受到外婆恶作剧的邻居们，于是爱莎在外婆留下的一系列谜团和线索中寻找真相并逐渐理解了外婆的良苦用心。这一趟送信之旅让爱莎发现：外婆和邻居的故事，比她听过的任何童话故事都更加精彩。\n爱莎与外婆之间的深厚感情贯穿始终，让人动容。虽然外婆在故事中并不完美，但她对爱莎的关爱和付出是无法替代的。无论发生什么情况，外婆都会站在爱莎这边，为了她和世界拼命。爱莎在寻找真相的过程中，逐渐理解了外婆的期待，理解了外婆所讲故事的隐含意义，最终学会了勇气和坚强，也原谅了外婆的离去。\n文章既有童话的温馨浪漫，也有现实的残酷黑暗。爱莎从小父母离异，在学校遭受霸凌，唯一的朋友外婆也在爱莎八岁时也因为癌症死去，但爱莎并未因此消极堕落，因为童话，外婆，父母，邻居们的共同守护与治愈，爱莎得以更加坚强，温柔的成长。\n读后感 文中我最喜欢的人毫无疑问是外婆。外婆独立，不拘世俗，经常打破常规，四处惹麻烦。“要大笑，要做梦，要与众不同”是外婆的口头禅，她甚至用她的敢打敢拼赢下过一座楼。外婆也是一个温柔善良的人，是一个不怕危险，到处救死扶伤的医生（外婆那个年代学医比较打破常规），奔赴过海啸受灾城市，战场前线救人，她还把一些无家可归的人安置在自己的楼里。外婆在行医的过程中结交过很多形形色色的人，锻炼了各种各样的技能（不过狂妄大胆像是天生的）。所以在爱莎眼里，外婆是一个无所不能的超级英雄。外婆为爱莎构建了一个童话世界，这个世界可以让她克服恐惧和不安，成为内心的支柱，可以为她疲惫之时提供栖息的港湾。\n文中第二个值得讨论的角度是故事。读过全文后就可以发现，外婆创作的故事中的人物其实就是以她帮助过的人为蓝本制作的，诞生的故事进一步去安抚，帮助那些受伤的心灵（有孩子也有大人）。事实上这里可以发现外婆的故事并不是单单为了爱莎而创作，而是诞生在更早之前，为了那些流离失所的孩子而创作，故事的力量可以在爱莎的经历中窥得一斑。\n故事的力量让我想起来了人类简史(这本书是犹左作品，在构建主义上有一些争议，之后也会在读后感讨论)中提到的故事概念，简单来说，我们人类所创造的一切可以被传递和认同的思维思想造物都可以被称为故事，小至童话，寓言，大至各类主义，意识形态，人类的社会就是由无数的故事构成的，我们以相同的故事彼此认同，进而拼接成为文化，民族，国家，文明。故事的诞生之初，承担着教育启蒙的作用，后来故事开始发展为以讴歌赞颂为主，人们迫切的寻求最浪漫完美，可以被奉为涅槃的故事集。随着人们建设自己精神的力量和欲望日渐强大，也开始催生出无数亚文化。\n对那些经历过战争或自然灾害，在绝望的死土上生活的那些孩子，对那些未来无限迷茫，没有光明，希望，呆滞着的那些孩子，一把火，一段围着火堆不成章法的随情热舞，就足以让他们忘记身前身后的一切烦恼，让他们快乐于此刻，不再为生命的寂寥而担忧。如果有人愿意为他们讲上一个精彩的关于爱，勇气和希望的故事，那么他们就可以在幻想的世界里安静安宁的休息片刻，然后好好的长大。这也是故事的意义之一。和外婆的道歉信相似的故事形式，我能联想到的是东方的幻想乡和海猫的黄金乡（前者是车万越共，后者是在故事中讨论故事）。\n第三个角度是关于守护。俗话说的好：大人的职责就是保卫孩子们的健康成长，简称大保健。孩子身上承担着关于未来无限个可能性的力量，或许会引导他们去实现那缈不可及的理想世界和走向最终的故事。大人的意义就是 大保健 为孩子铺上一些路，种上一些花，留下一些种子。\n登场人物 血缘（6人）：爱莎，外婆，爱莎的妈妈，爱莎的爸爸，继父乔治，爱莎的同母异父弟弟小半\n邻居（9人2狗）：三楼 布里特.玛丽，肯特 黑裙女人\n二楼 莫纳特，莫德，莎曼萨（比熊犬） 阿尔法\n一楼 生病男孩，其母亲 怪物（狼心），呜斯（大狗）\n其他（1人）：山姆（狼心曾经的朋友）\n","permalink":"https://tassel234.github.io/posts/read/%E5%A4%96%E5%A9%86%E7%9A%84%E9%81%93%E6%AD%89%E4%BF%A1%E8%AF%BB%E5%90%8E%E6%84%9F/","summary":"故事梗概 《外婆的道歉信》是瑞典作家弗雷德里克·巴克曼创作的一部长篇小说，讲述了一个关于爱，原谅与守护的温馨故事。这部作品以其幽默、独特的叙事风格和深入浅出的人物描绘，受到了广泛关注。 小说以小女孩爱莎的视角，展示了一个独特、充满想象力的世界。爱莎是一个聪明、机智的小女孩，她与外婆共","title":"《外婆的道歉信》读后感"},{"content":"前言 使用资源 西工大网课(在慕课和b站都可以找到资源)\nBjarne Stroustrup《C++程序设计语言》\n洛谷的一些编程题\n主要以网课为主.\n引言 计算机系统由硬件和软件共同组成。硬件主体为输入输出设备，存储器，运算器，控制器。软件又分为系统软件和应用软件。应用软件就是用户下载的音乐播放器，聊天软件，浏览器的软件。而系统软件是一个计算机系统系统必备的，需要提前安装的软件，比如操作系统，数据库系统和网络系统，此外程序设计语言和语言执行程序也应该属于系统软件，其实应该说以语言编写的代码才是软件的基石。\n计算机编程语言其实和汉语，英语等我们口头表达，纸笔书写的语言没有本质的区别，编程语言其实也是把我们的想法转化为特定的词汇和语法，让我们可以和计算机交流。如果我们想书写美妙的编程诗篇，扎实的语言功底，表达力，逻辑力，想象力，创造力缺一不可。\n数据在计算机内部的样子 计算机只能够理解0和1，所以我们编写的程序最后都会转化为计算机可以理解的01代码，同样我们日常使用十进制数据也要变为二进制。\n进制之间的转化。十进制如何转化为二进制，对于整数部分是除以2取余数，对于小数部分是乘2取整数部分，是0就取0。二进制和八，十六进制的转化，整数高位补0，小数低位补0。\n对于数字类型，一般第一位代表±，以-1的次方计数，0正1负。\n二进制的计算。原码可以比较有效的对正数计算，反码指负数的负号位不变，其他位01互换，补码是在反码的基础上进行加1，利用溢出计算。\n浮点数二进制。先表示为科学计数法，对有效数字进行二进制化，分别塞上符号位，二进制的表示数，二的次方数。\n数据类型 基本数据类型。一个字节八位。\n int4,long int 4,unsigned int 4 ,第一位是符号位，而对于无符号的unsigned代表的正数范围多二倍。 char 1,也代表asc||码，为128个，‘1‘49，A65，a97。   float 4,double 8，一般小数都是double,一般计算有效数字为16位，如果是四字节的浮点数，就要在数字后加f，只可以计算7位有效数字。此外还由布尔类型，空类型。 构造数据类型。包括数组，struct,union,enum枚举,class(类)。  特殊的数据类型，有指针类型和引用类型。 int i,j; char c1,c2; c1=\u0026#39;a\u0026#39;; c2=98; i=\u0026#39;A\u0026#39;; j=66; 字符型还可以进行减法运算。cout\u0026laquo;\u0026lsquo;A\u0026rsquo;-32结果是33;\n常量和变量 字面常量  八进制，十六进制表示，0,0x 浮点型也可以用e表示，即科学计数法f e n,f可以是整数或小数，但n必须是整数。 字符串常量和字符常量  \\ooo和\\xhh称为通用转义字符，其中\\ooo表示可以用1至3位八进制数作为码值表示一个ASCII字符，hh表示可以用1至2位十六进制数作为码值表示ASCII字符。\n如:“\\1234”一“123和4”，”\\128”一\\12和8”，19\u0026quot;一”\\1和9\u0026quot;\n\\9错误，\\0xFE 错误\n由于字符型数据在内存中只占用1个字节，即使按无符号处理其最大值也仅是255(八进制为377)，因此ooo的数值范围为0~377 (八进制)，其他值使得字符型数据溢出。同理，hh的数值范围为0~FF\n字符常量 就是使用宏#define进行定义\n变量 变量需要先声明\nint d=a ，e=a+b; //错误，初值不能是变量或表达式 int m=n=z=5: //错误，不能对变量连续初始化 const int a; 一般在函数中应用比较广，避免因为误操作导致数值改变。\n运算符    int m=4，n; n = ++m; //m先增1，m为5，然后表达式使用m的值，赋值给n，n为5 n = --m; //m先减1，m为4，然后表达式使用m的值，赋值给n，n为4 n = m++; //表达式先使用m的值，赋值给n，n为4，然后m增1，m为5 n = m--;//表达式先使用m的值，赋值给n，n为5，然后m减1，m为4   C++在逻辑表达式求解时，并不一定是所有的运算都被执行，当刚开始求解或求解的中途就可以确定整个逻辑表达式的值时，其余的运算将不再进行。\nint a=1 ，b=2,c=3,d=4,m=n=1，k; k=(m=a\u0026gt;b)\u0026amp;\u0026amp;(n=c\u0026gt;d); //m的值为0，n的值为1，k的值为0 3.三目运算符   int i=3,j=5;k=i++,i+1,j++,j+1;//k为3 (i++的值)k=(i++,i+1j++,j+1); //k为7 (j+1的值) 逗号运算符是双目运算符。\n类型转换 手动类型转化\n(int)x+y //将x转换成整型 (int)(x+y) //将x+y转换成整型 (int)x%3 //x的类型和数据值不变，表达式引用转换成int后的x值 隐式类型转换 (implicit type conversion) 又称自动类型转换，它是由编译器自动进行的。\n(1)将浮点型数据赋给整型变量时，舍弃浮点数的小数部分。 如:int n=6.18;n的值为6。\n(2)将整型数据赋给浮点型变量时，数值不变，但以浮点数形式存 诸到变量中。如:double f=78;将78按78.0处理\n(3)将double型数据赋给float变量时，截取前面7位有效数字存储到float变量。将float型数据赋给double变量时，数值不变，有效数字扩展到16位。\n预处理 文件包含 #include 分为相对路径（.h）和绝对路径（C：/） 用户路径\u0026quot;\u0026quot; 系统路径\u0026lt;\u0026gt;\n条件编译 可以避免重复包含头文件，避免错误 1.\n#ifdef #else #endif   #if #elseif #else #endif 宏  #define 进行替换任意文本 但文本替换带有运算是要用（）括起来，不然可能出现错误 #x转化为字符，作用？ ##连接字符文本，ang  ","permalink":"https://tassel234.github.io/posts/note/c++%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1%E5%BC%95%E8%A8%80%E5%92%8C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","summary":"前言 使用资源 西工大网课(在慕课和b站都可以找到资源) Bjarne Stroustrup《C++程序设计语言》 洛谷的一些编程题 主要以网课为主. 引言 计算机系统由硬件和软件共同组成。硬件主体为输入输出设备，存储器，运算器，控制器。软件又分为系统软件和应用软件。应用软件就是用户下载的音乐播放器，聊天","title":"C++入门学习笔记-1（引言和基础知识）"},{"content":"正值暑假，又热又闷。\n学校的图书馆周日不开放，学习任务也没有完成。\n我今天本该在宿舍在宿舍睡觉吃饭学习，但因为前几周的经历，我意识到宿舍学习的效率是有一点惨不忍睹的。\n考虑之下，我决定去青浦图书馆学习和旅行。\n青浦图书馆坐落于青浦新城区夏阳湖上，有水上博物馆的美称，夏阳湖旁边是就是青浦博物馆。\n哈罗单车覆盖了上海的大部分地方，但是没有青浦图书馆这一片，青浦似乎是有自己的共享单车，但我骑不了。\n青浦图书馆的开放时间是周二至周日9:00-20:30(20:00以后停止入馆)\n百度地图显示青浦博物馆的夜景很好，但因为现在正值暑假，宿管阿姨关门关的早，所以很遗憾的我不能欣赏了。\n早上七点半起床，吃了一碗咖啡燕麦粥和一点苏打饼干，收拾行李，关闭电源。\n八点半出发，经过自行车，公交车，地铁，步行，加上吃午饭的时间终于在十二点抵达青浦图书馆。\n上海的地铁站有一个不成文的规定，坐阶梯式电梯时不赶时间，在电梯停留的人统一靠在电梯右侧，左边的空间留给赶时间，在电梯上走动的人。\n地铁上我看日语发音入门课程消磨时间。\n青浦图书馆不需要预约入场更不需要预约座位，上海图书馆东馆就要提前六天抢座位了。 图书馆不算大，也不算小。我能探索的就只有三层结构。\n图书馆下方有一个图咖，我看到有两个女孩在吃冰淇淋。\n图书馆内部的人真是太多了，我转了半天才在一个杂志阅览室的角落找到可以自习的地方。\n自习的人有很多，不只是考研的大学生，还有很多的工作的青年人和看书的老年人。\n书籍也有很多，宗教学，科学，欧美文学，古典文学等面面俱到，还有影像收藏。\n窗外的景色也很不错，南边的座位可以看到一条青绿色的河，北边的座位可以看到夏阳湖。\n学习时我看吴军博士写的 计算之魂，休息时我看保罗.约翰逊写的 所谓知识分子（书挺升血压的）。\n下午的时候天就阴了。\n五点多，我离开了图书馆，吃了一碗拉面。 因为博物馆那时已经闭馆了（我5点多才知道），所以我也就直接回去了。\n我沿着河畔转了一圈，看到了唱戏的大爷大妈，看到了父亲和女儿，看到男男女女，熙熙攘攘。 然后我就回去了，本来想走到地铁站，结果走一小段发现太累了，就停下来等公交。\n值得一提的是，我早上因为大意穿的是睡衣出门，走到一半才意识到，已经来不及回去换了。\n刚开始在地铁上感觉有点尴尬和不自在，但后来渐渐释怀了。\n我意识到上海是一座很大的城市，他很排外也很包容。\n上海的人都很忙，他们压根没精力去在意你，我怀疑我直接cos星野爱也没多少人在意我，更不用提一件睡衣。\n即使有人多看了你一眼，比起在内心折磨自己，不如直接微笑（恶心他人）来的从容。\n","permalink":"https://tassel234.github.io/posts/life/%E9%9D%92%E6%B5%A6%E5%9B%BE%E4%B9%A6%E9%A6%86%E6%B8%B8%E8%AE%B0/","summary":"正值暑假，又热又闷。 学校的图书馆周日不开放，学习任务也没有完成。 我今天本该在宿舍在宿舍睡觉吃饭学习，但因为前几周的经历，我意识到宿舍学习的效率是有一点惨不忍睹的。 考虑之下，我决定去青浦图书馆学习和旅行。 青浦图书馆坐落于青浦新城区夏阳湖上，有水上博物馆的美称，夏阳湖旁边是就是青浦博","title":"青浦图书馆游记"}]