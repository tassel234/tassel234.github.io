[{"content":"《艾迪芬奇的记忆》体验 前言 使用资源：百度百科\n艾迪芬奇的记忆被称为游戏版的百年孤独，芬奇家族在四百年以来（甚至更久）都受到的死亡命运的诅咒，这个诅咒最终夺取了这个家族几乎所有人的姓名，只留下一个小女孩还活着，她就是玩家操作的主角，艾迪芬奇。多年之后，为了揭露这个萦绕在芬奇家族头上关于死亡的诅咒，多年之后我们的主角艾迪芬奇回到了发生了诸多不幸的故居，以此见证了非常多离奇的死亡方式。\n到底什么样的家族会在建造房子之前先建造墓地 我们习惯了死亡 欣然接受所有这奇怪而短暂的一切 游戏体验 1st 刚才使用了一个半小时体验了几个芬奇家族人员的奇妙死法。\n出现幻觉变成各种奇妙动物的非常饥饿的吃鸟，吃兔，吃海豹的Molly。有美漫故事模式的被怪物粉丝吃掉而死的Barbara（故事中是这样），实际上应该是被杀人犯杀死的。荡秋千，飞起来死的Calvin，被恐惧吓倒，最后决心对抗命运，面对诅咒的时候被命运火车创死。\n一个猜测，死亡的命运无可避免，曾祖母Edie修饰了孩子们的死法，让这些死亡的命运对于活着的人不再是残酷，而是荒诞,以此维持这个家族的延续。也不妨是一个奇迹。\n而按照这个趋势来说，我们的主角艾迪芬奇最后恐怕难逃一劫，不过这个被命运诅咒四百年甚至更久的家族还能活到现代简直是不可思议，可能最后有奇迹发生，但却只是短暂的挣脱，命运的诅咒还会笼罩在这个不幸的家族上，当然如果最后是百年孤独式的“赐予这个被诅咒的家族永恒的孤独”的结局，我也没话说。总之故事确实很奇幻和吸引人，不过还有作业要写，之后再玩。\n冬青的特点是其叶子具有刺，这些刺通常呈现为锐利的尖端，有些物种的刺甚至可以带有毒性。冬青的叶子一般呈现为暗绿色，有些品种的叶子也可能具备其他颜色，如红色或黄色。另外，冬青在秋季和冬季通常会结出醒目的浆果，这些浆果是红色或黑色的。\n需要注意的是，有些冬青的浆果或其他部分可能对人体有一定的毒性，造成恶心,腹泻,呕吐甚至死亡。不过没有说出现幻觉，关于Molly的死亡仍然存疑，比如她是怎么在后来把故事写下来的，怪异程度相当于你知道某个人是在梦中被杀死的。我个人感觉应该是曾祖母Edie修饰了孩子们的死法，创造了一个又一个的故事。\n还有一种植物，叫颠茄，是我在另外的一本书了解到的，是一种剧毒的植物，可以让人产生幻觉和造成人的死亡。\n颠茄有毒，颠茄的根和根茎毒性是最强的，其中毒症状和解毒方法如下：\n1、颠茄中毒后极度口渴，咽喉干燥、充血，瞳孔放大，皮肤发干、发红，有时可出现红疹、黏膜出血点。鼻出血，偶尔有出血性胃炎。\n2、重度中毒可出现脉搏加速而微弱，体温可增高至40℃以上，以后可出现幻觉、谵妄、不安、强直性或阵挛性惊厥。随着进展，可出现昏迷、呼吸浅表等危重征象。\n3、瞳孔扩大、偶有发生黄视、复视、眼球结膜充血、视物模糊、斜视、青光眼、视力和听力障碍。\n查了一下，原来这东西就是颠茄，我老家一抓一大把，小时候还把他当成一种染色剂，不过还好没因为好奇误食。\n不过我对植物学的了解很少，是其他相似无毒的物种也是有可能的，此外冬青浆果和颠茄貌似在中医里都可以药用（本草纲目的神奇），似乎某些成分还可以合成一些西医药品。\n2 nd 刚才又使用了一个半小时通关了艾迪芬奇的记忆。\n通过照相的模式进行了Sam被鹿创死的过程。操作青蛙玩具导致了Gregory的溺水死亡。Gus放台风里面风筝被卷起来物品创死，Milton，天赋横溢的画家，他似乎是了解到了家中的诅咒，在2003年的某一天离家出走，生死不明，也就是说并不一定死去了，如果有第二部揭露诅咒的主线应该会有milton的故事。房子落灰的情况并不严重，怀疑可能和milton，当然落灰的情况可能压根是制作组懒得或不想加。\nLewis，Dawn的长子、Edith的大哥。他是一个关心家人的人，告诉Edith很多家中的秘密通道。他在一家鱼罐头厂工作，最后似乎是被切鱼的到砍掉头颅而死（路易16模拟器）。在Lewis的幻想中，芬奇家族的诅咒似乎可以具象，或者说来自于一个巨大的怪物，杀鱼的大哥的想象中窥得这个怪物的骨头像。这个游戏的扮演左手操作幻想绚丽的世界，右手机械单调的杀鱼。\n最后edie享年93岁，死亡。母亲dawn因为疾病，死亡。\n最后只剩下Edith，的儿子还明确活着。因为Edith似乎最后也死亡了，原因似乎是难产而死。\n果然像我猜的那样，艾迪芬奇最后恐怕难逃一劫，不过最后没有百年孤独，家族消亡，芬奇家族还是有后裔的，400年的诅咒恐怕故意留给这个家族一口气，真是恶趣味的恶魔呀。\n出场人物 Molly（1937-1947） Edie的长女。\n喜欢动物，养了一只仓鼠和一条金鱼，还喜欢观察蚂蚁。\n在她十岁的某一天晚上，Molly没吃晚饭就被母亲要求上床睡觉。十分饥饿的她吃了仓鼠的食物、牙膏和窗台上的冬青树浆果，这可能导致她食物中毒并产生了幻觉，感觉自己变成猫、猫头鹰、鲨鱼和怪物进行捕食。最终可能为食物中毒而死。\nBarbara（1944-1960） Edie的次女。\n电影童星，曾以其尖叫声而出名，然随着长大后声音逐渐变化而过气。\n在16岁生日时，由于父母前往医院，家中只有她、男朋友Rick、弟弟Walter，当地杀人魔潜入家中杀害了Barbara和他的男朋友。还有可能确实如同故事那样，Barbara是被簇拥着她的狂热粉丝杀死的，不过可能性很低，因为Barbara已经过气了，但是即使如此祖母仍然希望Barbara是在簇拥下是在在粉丝的喜爱下死去的。\nCalvin（1950-1961） Edie 的双胞胎儿子之一。\n他喜欢宇宙、飞船，想成为宇航员。在姐姐Barbara死去后，他愈发觉得自己的理想无法实现。\n在某一天午后，他在房子外荡秋千，妈妈喊他回家吃饭他也不管不顾，秋千越荡越高，最终他被甩飞了出去，掉入了海中死去。\nOdin（1880-1937） 芬奇家族原本定居于挪威，500年来因其财富及不幸而闻名。\nOdin在埋葬了他的妻子和儿子后，为摆脱诅咒而带着女儿Edie、女婿Sven、外孙女Molly以及房子启航出海，但在遭遇海浪后Odin与房子共同坠入海中，Odin不幸溺亡。\nWalter（1952-2005） Edie的小儿子。\n在8岁时，由于目睹姐姐Barbara遇害而留下了极深的心理阴影。后又因父亲Sven在他12岁生日不幸死去而十分内疚，并由此惧怕“诅咒”。\n16岁后搬进了家宅的地下室生活，并开始了长达30余年的生活，每日以桃子罐头为生及火车驶过的声响而活。2005年，由于火车连续一周没有经过，心怀不安的他克服恐惧离开地下室，在铁轨仰望阳光时火车驶过而去世。\nEdith（1999-2017） Dawn的女儿、故事开始时Finch家族中唯一可能活着的人。\n在母亲去世后，她回到家中的探索家族的秘密，她将家族各成员的死亡故事写进她的笔记本并留给了她的儿子Christopher。\n在她18岁生日前的一个月，她可能因早产或早产引发的并发症而去世。\nEdie（1917-2010） Edith的曾祖母、Odin的女儿。\n1937年，20岁的她跟随父亲Odin乘船来到美国，途中她的父亲死去，她和她的丈夫Sven将Odin葬在岸边，也将她们的房子建在此处，除了 Molly 外他们又生下了四个孩子（Barbara、Calvin、Sam、Walter）。\n之后家族成员们陆续死亡，她为了纪念死去的家人，保留他们各自房间的样子。并在房子上面建造新的房间给新出生的孩子们居住。当整个 Finch 家族只剩下她、她的孙女Dawn、曾孙女Edith三人时，她也不避讳诅咒的事情，反而将这些故事讲给Edith听。\n在Lewis丧礼结束的第二天，Dawn为了不让Edith被“诅咒”牵连，带着Edith离开了祖宅，并准备将Edie送往养老院。当第二天养老院的工作人员来接Edie之时发现她已经去世了，享年93岁。\n在Dawn和Edith离开的前一天晚上Edie喝了一些酒，Dawn说这会影响Edie药物的效果，Edie可能因此而病逝。\nSam（1950-1983） Edie 的双胞胎儿子之一，Edith 的祖父。\n军人，曾参加过多次军事行动，喜欢摄影与狩猎。与第一任妻子Kay育有 Dawn、Gus、Gregory 三个孩子。在Gregory去世后，Kay因内疚与Sam协议离婚，Sam 迎娶了他的第二任妻子，与第二任妻子之间未有子嗣。\n在一个周末，他和女儿Dwan外出打猎，Dawn 打中了一头鹿，可那只鹿没有完全断气，当Sam想要和鹿合影时，鹿将他顶下了悬崖，而这一瞬间也被相机拍了下来。\nDawn（1968-2016） Sam的长女、Edith的母亲。\n她离开家与印度人Sanjay结婚生下了 Lewis、Milton、Edith。在他的丈夫不幸去世后带着她的三个孩子回到家中生活。\n她亲眼见证了家族中许多人死去，包括她的父亲 Sam、她的孩子Lewis。而她的另一个儿子Milton也神秘失踪，直至家中只剩下她和她的女儿Edith、她的祖母Edie，可Edie还不断给Edith讲家族中有关“诅咒”的故事，这让她十分愤怒又不安。\n在Lewis葬礼结束的第二天，她决定所有的Finch家族成员都必须离开这所房子。她将Edie托付给养老院，带着Edith离开了房子，之后她的病情不断反复，最终不幸病逝。\n在她去世之前，她将祖宅的钥匙留给Edith想让Edith自己调查家族的秘密。\nGus（1969-1982） Sam的儿子。 Gus对父亲离婚与其他女人结婚的行为十分不满，在父亲的结婚典礼上，他也只自顾自地放风筝。\n这一天天气不好，狂风不止，将户外的帐篷吹起砸死了Gus。\nGregory（1976-1977） Sam最小的儿子。\n只有一岁大的Gregory中在浴缸中边洗澡边玩着各种小玩具，他的母亲将浴池中的水放完了之后接到了Sam打来的电话便离开了。Gregory自己却打开了水龙头，而他的小玩具正好堵住了出水口，他因此不幸溺死。\n因为这件事，他的母亲Kay十分内疚，选择和Sam协议离婚。\nLewis（1988-2010） Dawn的长子、Edith的大哥。\n他是一个关心家人的人，告诉Edith很多家中的秘密通道。\n他在一家鱼罐头厂工作，每天只完成一些切掉鱼头、把剩下的鱼肉放上流水线的重复性劳动。\n他在工作时会一边工作一边幻想自己在冒险，起初他是能够意识到自己在幻想的，但因为他滥用药物，他逐渐沉浸在自己的幻想中无法自拔，被切鱼头的机器所伤而死亡。\nMilton（1992-2003） Dawn的次子、Edith的二哥。\n天赋横溢的画家，他似乎是了解到了家中的诅咒，在2003年的某一天离家出走，生死不明。\n他的母亲Dawn找了他三个月也没有找到，她因此把家中所有房间都封了起来，但Edie还是在每个房间上留了一个探视孔。\n感悟 《活着》是把生命的死亡和苦难写成了悲哀震撼的文学作品。\n而《艾迪芬奇的记忆》是把生命的脆弱写成了忧伤奇幻的第九艺术作品。\n我之前听说过那个男作者的创作灵感似乎来自于生活，啊。。。\n最后滚动的真人头像我也感觉到事情开始有一点不对劲，然后滚出来似乎是死亡名单的30来人，我就已经开始感叹作者的命运多舛了，不过后来转念一想，那些人的姓都不一样，果然作者应该是参考了很多人离奇的自然死亡，然后汇总到故事中的这个家族。不过能把死亡写的这么小清新的作者，我还是觉得照片的某些人确实是作者认识的，他的家族可能也经历过一些离奇死亡，而他的妈妈修饰了那些残酷的故事，变成了离奇奇幻甚至有趣的故事，来安抚作者的心灵。母亲就是Edie和Edith，最后的故事中活下来的男孩子就是作者（我猜的）。\n我看了作者的背景故事，上面的很多猜测都不对。我为我的猜测忏悔，但还是保留了它。\n针对这些故事，网上还有一些关于游戏的猜测，比如Edie是变态杀人狂，神经疾病（梦回雏见泽）之类的。。。我觉得这些猜想有点类似于海猫的黑山羊了。虽然我们很多时候只相信自己愿意相信的事情，但这并不一定是一件坏事。\n八大艺术，主要指用形象来反映现实但比现实有典型性的社会意识形态，包括文学、音乐、舞蹈、绘画、雕塑、戏剧、建筑、电影八大类别。~~笑死，科学什么时候才能站起来。~~而游戏就被称为第九艺术，从现在的发展上来看，确实是。在有记录的历史上，公认世界最早的一部电影是于1888年由法国导演普林斯所拍摄的《朗德海花园场景》。最早有记录的电子游戏诞生于1952年，为井字棋游戏（Tic-Tac-Toe），运行于真空管计算机上。可以说电子游戏是非常年轻的了。电子游戏主体和文学，戏剧、电影，音乐很类似，都是创作故事然后让人们欣赏故事，而游戏是是让人们实际参与进来的一种很高级的叙事方式，再加上vr的发展，游戏确实成为了现代人们消遣的重要方式。\n","permalink":"https://tassel234.github.io/posts/note/%E8%89%BE%E8%BF%AA%E8%8A%AC%E5%A5%87%E7%9A%84%E8%AE%B0%E5%BF%86%E4%BD%93%E9%AA%8C/","summary":"《艾迪芬奇的记忆》体验 前言 使用资源：百度百科 艾迪芬奇的记忆被称为游戏版的百年孤独，芬奇家族在四百年以来（甚至更久）都受到的死亡命运的诅咒，这个诅咒最终夺取了这个家族几乎所有人的姓名，只留下一个小女孩还活着，她就是玩家操作的主角，艾迪芬奇。多年之后，为了揭露这个萦绕在芬奇家族头上关","title":"《艾迪芬奇的记忆》体验"},{"content":"《深度学习的数学》读书笔记-2 前言 额外使用资源：\n卷积神经网络介绍\n卷积神经网络 卷积的概念 不稳定输入 稳定输出，求系统存量。可以使用吃东西消化和例子进行理解。\n卷积神经网络中的卷积 感觉上像是推广到二维的数据了。\n通过3x3的数字方格（卷积核），把中心的点扣在待处理图像的每一个像素点上（边缘处可以添加数值为0的像素点以完成3x3的卷积处理，不加也行，减少要卷积的个数），完成卷积操作。简而言之了解周围像素点如何产生影响。\ng是卷积核，f是在变化的像素点。\n3x3的方格如果数字都是1/9，相当于把像素点求平均，把这个操作称为平滑卷积操作，可以让图像变得更朦胧。\n而对于不同数字的卷积核，卷积的神奇之处开始展现出来，比如下面的图像经过处理可以提取横向和纵向的特征。\n使用excel体验神经网络 excel的文件也可以在书中找到。\n普通的神经网络excel也求解不了，下面的例子都是非常简单神经网络的例子，使用excel可以非常直观的观察变化情形，算是优点之一吧。还有两个比较邪门的例子：excel最新版本微软把python嵌入到里面了，从前有一个美赛队伍只用excel就拿了o奖。\n梯度下降法 学习率，也就是步长，通过乘以偏导数的值进行函数向极值点的移动，最终位移向量趋近于0.\n神经网络求解器 初始权重和偏置的设定是通过正态分布随机数进行的。\n然后计算隐藏层的输入，使用sigmod函数输出值。\n盘了半天，好像是这本书数据出现了问题，数据直接给出最后的结果而没有给学习的过程。似乎初始权重和偏置和最终的权重和偏置位置搞反了，导致使用计算出来的结果非常接近0或者1，sigmod函数出现截断，最后的值要么是0要么是1，也可以对数据鼠标右键，设置单元格格式，修改精度，下面是改为了15位的结果。\n把数据的顺序改一下就可以实现和书中写的一致的结果。\n规划求解器的加入可以参考下面的文章。\nhttps://jingyan.baidu.com/article/64d05a0269c01c9f55f73bbd.html\n最后执行成功果然改成了最优解的值，就是只显示01的那个情况。\n误差反向传播法 这个例子的长度和宽度都太吓人了，只截取第一次的学习作为例子。\n梯度\t∂CT/∂w\t∂CT/∂b 隐藏层\t1\t0.040 0.068 -0.022 0.082 -0.015 0.103 -0.013 -0.014 0.093 -0.022 0.000 0.080 -0.011 2\t-0.019 0.193 -0.295 0.121 -0.481 0.589 -0.394 -0.534 0.645 -0.413 -0.287 0.187 -0.396 3\t-0.491 -0.794 0.037 -0.932 0.016 -0.959 -0.086 0.016 -0.922 -0.129 -0.117 -0.889 -0.163 输出层\t1\t0.542 -1.939 -0.135 -2.491 2\t-1.158 -2.106 -1.028 -3.263 1次\tCT\t20.255 上面的结果是处理完64副图片得到的汇总（相加）值。以这些值对第二次的数据进行梯度下降处理。\n不断更新，让误差变小。\n","permalink":"https://tassel234.github.io/posts/note/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-2/","summary":"《深度学习的数学》读书笔记-2 前言 额外使用资源： 卷积神经网络介绍 卷积神经网络 卷积的概念 不稳定输入 稳定输出，求系统存量。可以使用吃东西消化和例子进行理解。 卷积神经网络中的卷积 感觉上像是推广到二维的数据了。 通过3x3的数字方格（卷积核），把中心的点扣在待处理图像的每一个像素点上（边缘","title":"《深度学习的数学》读书笔记-2"},{"content":"excel操作入门-1 前言 使用资源：官方excel教学文档\n添加 键入 =SUM(D4:D7)， 然后按 Enter。\n按alt和=，然后按“Enter”，可以快捷求和。\n在本工作表顶部，我们还向你展示了 SUMIF 函数。SUMIF 函数根据条件求和。如果 SUMIF 函数进行解释，应会是： 自动填充单元格以节省时间 将光标置于单元格的右下角，直到它变为十字形，拖拽或者双击（双击代表自动）。\n或者直接选择框，然后control+D (向下)，加R代表向右填充。\nExcel 可基于序列自动填充一些单元格。例如，可在某单元格键入 1 月，然后在其他单元格中填充 2 月、3 月等。\n拆分数据 Ctrl+E 是“快速填充”的快捷方式。 似乎excel会自动识别模式帮助我们填充。\n基于分隔符拆分列\n快速填充非常方便。但是如果想要将数据一次拆分到多个列，则它不是此作业的最佳工具。在此情况下，尝试使用”分列”\n单击并拖动，选择从”Nancy“到“Yvonne”的单元格 在“数据”选项卡上，单击”分列”。请确保选择了”分隔符号”，然后单击”下一步”\n在“分隔符”下方，确保只选中“逗号”复选框，然后单击”下一步”\n单击”常规”选项\n最后，单击”目标区域”框，键入$D$32。然后单击”完成”\n通过转置来变换数据位置 先选中复制，然后粘贴，在“开始”选项卡上，单击“粘贴”按钮下的箭头。单击“选择性粘贴”，然后在底部，单击“转置”复选框。单击“确定”。\n快捷一点是control直接点T。\n排序和筛选 可以单点一个，对其同列的相同类型的数据进行按照大小排序。“开始” \u0026gt; “排序和筛选” \u0026gt; “降序”。\n同时单点一个可以右键选择筛选，选择相同的内容。现在清除筛选，单击“部门”的筛选按钮 ，然后单击“清除筛选”。\n同时还可以根据颜色进行筛选和排序。\n同时一些表格还提供筛选按钮，可以在这个中进行高于平均值等属性的筛选。\n表格 单击右侧的数据，然后单击上面的“插入” \u0026gt; “表格” \u0026gt; “确定”。\n也可以轻松创建新行。在最下列下方的空单元格中，键入一些文本，然后按 Enter。表格将出现一个新行。创建新列也是同理。\n表格为你提供方便的一个示例：计算列。输入公式，表格将会自动填充。alt加=\n单击表格内部，然后按 Ctrl+Shift+T。汇总行。不同于键入 SUM 公式，Excel 可轻松进行总计。在 Excel 窗口顶部将出现“表设计”选项卡。 在该选项卡上，单击“汇总行”。最后生成的统计数据也有一个向下箭头符号，可以进行平均值的求解。\n下拉列表 在“数据”选项卡上，单击数据工具的“数据验证”。在“允许”下，单击“序列”。\n在“来源”框中，键入“农产品, 肉类, 烘焙品”。请确保在它们之间输入逗号。完成后，单击“确定”而且这个逗号是英语的逗号，中文的逗号会让下拉菜单连成一坨。\n在“数据”选项卡上，单击“数据验证”。在“允许”下，单击“序列”。\n在“来源”框中单击，然后单击向上箭头按钮。单击并拖动，仅选择 F 列中的“农产品”、“肉类”和“烘焙品”单元格。然后单击向下箭头按钮 。单击“确定”。现在，单击下拉箭头。只显示三个部门：农产品、肉类和烘焙品。但如果在“烘焙品”下方的 F 列内添加新部门，新部门将会更新在下拉菜单中。\n分析和图表 在出现的面板上，单击右下角的“数据条”。control加q是快捷键，可以直接选择和打开面板，选择“簇状柱形图”进行图的绘制。\n点击上方的插入也可以进行绘图，选择推荐使用的图表可以直观的看到想要使用的图表效果，而且还有组合图。\n也可以创建数据透视表，点击数据透视表的各个选项可以进行筛选。\n","permalink":"https://tassel234.github.io/posts/note/excel%E6%93%8D%E4%BD%9C%E5%85%A5%E9%97%A8-1/","summary":"excel操作入门-1 前言 使用资源：官方excel教学文档 添加 键入 =SUM(D4:D7)， 然后按 Enter。 按alt和=，然后按“Enter”，可以快捷求和。 在本工作表顶部，我们还向你展示了 SUMIF 函数。SUMIF 函数根据条件求和。如果 SUMIF 函数进行解释，应会是： 自动填充单元格以节省时间 将","title":"Excel操作入门-1"},{"content":"更新中\n前言 使用资源：\n工业4.0(6.1w)\n中国制造2025蓝皮书(主要看领域篇)\n图解中国制造2025（国家和地区）\n百度百科\n工业4.0 工业4.0是基于工业发展的不同阶段作出的划分。按照共识，工业1.0是蒸汽机时代，工业2.0是电气化时代，工业3.0是信息化时代，工业4.0则是利用信息化技术促进产业变革的时代，也就是智能化时代。\n2013年的汉诺威工业博览会上正式推出，其核心目的是为了提高德国工业的竞争力，在新一轮工业革命中占领先机。随后由德国政府列入《德国2020高技术战略》中所提出的十大未来项目之一。该项目由德国联邦教育局及研究部和联邦经济技术部联合资助，投资预计达2亿欧元。旨在提升制造业的智能化水平，建立具有适应性、资源效率及基因工程学的智慧工厂，在商业流程及价值流程中整合客户及商业伙伴。其技术基础是网络实体系统及物联网。\n德国所谓的工业4.0是指利用物联信息系统（Cyber—Physical System简称CPS）将生产中的供应，制造，销售信息数据化、智慧化，最后达到快速，有效，个人化的产品供应。\n“中国制造2025”与德国“工业4.0”的合作对接渊源已久。2015年5月，国务院正式印发《中国制造2025》，部署全面推进实施制造强国战略。\n第一章 为何是4．0？ 智能制造中的生产设备具有感知、分析、决策、控制等功能，是先进的制造技术、信息技术的集成和深度融合。在智能生产过程中，传感器、智能诊断和管理系统通过网络互联，使得由单一、分散的程序控制上升到综合智能控制，从而制造工艺能够根据制造环境和制造过程的变化，进行实时优化，提升产品的质量和生产效率。\n德国“工业4.0”与美国第三次工业革命的共同点是都基于互联网，互联网技术带给我们许多创新和意想不到。\n美国提出的第三次工业革命实质上是将互联网技术应用到新能源领域，将新能源资源的分散化、分布式配置，结合互联网技术实现能源的按需供给和双向买卖，产生智能电网，带动第三次工业革命。它本质上是推动互联网技术在新能源领域的深度应用，是新能源与互联网相融合的新一次工业革命。\n在德国，“工业4.0”的概念被认为是以智能制造为主导的第四次工业革命，旨在通过深度应用信息技术和网络物理系统等技术手段，将制造业向智能化转型。\n自动化只是单纯的控制，智能化则是在控制的基础上，通过物联网的传感器采集海量生产数据，通过互联网汇集到云计算数据中心，然后经过信息管理系统对大数据进行分析、挖掘，从而制定出正确的决策。\n在传统制造业时代，材料、能源和信息是工厂生产的三个要素。\n工业4.0实现的是生产智能化，设备智能化，能源智能化，供应链管理智能化。\n第二篇 “工业4．0”的科学发展观 “工业4.0”是一个发展的概念，体现出科学的发展观。工业4.0本质是基于“信息物理系统”实现“智能工厂”，是以动态配置的生产方式为核心的智能制造，也是未来信息技术与工业融合发展到新的深度而产生的工业发展模式。通过“工业4.0”可以实现生产率大幅提高，产品创新速度加快，满足个性化定制需求，减少生产能耗，提高资源配置效率，解决能源消费等社会问题。从最终用意来看，“工业4.0”将全面推动标准化体系建设，进一步巩固德国制造业优势，抢占新一轮产业竞争的制高点。\n第三篇 “工业4．0”背后的秘密 “工业4．0” 最开始源于德国，德国是一个以机械行业为支柱的制造业大国。工业4.0一定上反映了德国在制造业上对美国的竞争意识。\n第四篇 中国版“工业4．0”畅想 我国制造业“大而不强”，与制造业强国仍有较大差距。我们最欠缺的是高端制造业。\n第五篇 对未来制造业的探讨 工业软件充斥整个制造业\n一种是植入类用于达到自动化、智能化的控制、监测、管理各种设备和系统运行的目的。分为操作系统、嵌入式数据库，开发工具，应用软件等。还有一类是如辅助设计（CAD）、辅助制造（CAM）、辅助分析（CAE）、辅助工艺（CAPP）、产品数据管理（PDM）等实现生产和管理过程的智能化、网络化管理和控制等工程软件。\n大数据驱动制造业迈向智能化\n网络信息安全同样影响工厂\n对控制系统进行网络攻击的最著名案例是，2010年9月伊朗纳坦兹的铀燃料浓缩施设被称为“Stuxnet”的超级工厂的病毒进行了网络攻击。Stuxnet是一个强大的、旨在攻击西门子制造的工业控制系统的计算机病毒。该病毒会传播到插入电脑USB接口的设备中，并从中窃取数据机密。这是黑客首次尝试入侵大型工业控制系统的电脑病毒攻击\n该攻击中，Stuxnet利用了德国西门子开发的Step 7控制系统软件中的漏洞，进行干扰控制浓缩铀的离心分离机的运行速度以及状态，妨碍铀浓缩过程。事件破坏了伊朗核设施，震惊了全球。\n制造业将成为信息产业的一部分\n中国制造2025 中国制造2025上海所承担的任务： ","permalink":"https://tassel234.github.io/posts/note/%E4%B8%AD%E5%9B%BD%E5%88%B6%E9%80%A02025%E5%92%8C%E5%B7%A5%E4%B8%9A4.0/","summary":"更新中 前言 使用资源： 工业4.0(6.1w) 中国制造2025蓝皮书(主要看领域篇) 图解中国制造2025（国家和地区） 百度百科 工业4.0 工业4.0是基于工业发展的不同阶段作出的划分。按照共识，工业1.0是蒸汽机时代，工业2.0是电气化时代，工业3.0是信息化时代，工业4.0则是利用信","title":"中国制造2025和工业4.0"},{"content":"工业大数据建模理论和案例-2 更新中\n前言 使用资源：\n工业大数据分析实例（21w）这本书的内容很全面，广度很大，深度也不小。目前只针对这本书大致了解工业大数据的理论应用。\n智能制造标准案例集(20w)\n工业大数据技术与应用实践（5.5w）\nchatgpt\n平台技术 基本介绍 工业大数据平台的特点由工业大数据的数据负荷特性、分析和应用的特点共同决定。工业大数据平台不能只是一个灵活扩展、成本可控的大数据存储系统，还应是以业务主题为中心的数据服务提供者、支持知识沉淀和快速迭代的分析支撑平台、消除技能壁垒的协同应用平台。\n数据负载特性是指在不同的数据分布和查询条件下，数据库或数据系统的性能表现。不同的数据负载特性可能会导致完全不同的性能表现。因此，在评估一个数据系统的性能时，需要考虑到不同的数据负载特性。以下是一些常见的数据负载特性：\n  数据分布均匀度：数据分布均匀度是指数据在数据库中的分布是否均匀。如果数据分布不均匀，可能导致某些部分的数据访问速度明显慢于其他部分。\n  数据访问频率：数据访问频率是指不同数据项被访问的频率。高频访问的数据项可能需要采用不同的缓存策略来提高性能。\n  数据查询模式：数据查询模式是指常见的数据查询类型，包括点查询、范围查询、聚合查询等。不同的查询模式可能会导致不同的性能问题。\n  数据更新模式：数据更新模式包括插入、更新和删除等操作。不同的更新模式可能会对数据系统的性能产生不同的影响。\n  并发访问：并发访问是指多个用户或进程同时访问数据库。并发访问可能导致锁争用、资源竞争等问题，从而影响性能。\n  数据量：数据量是指数据库存储的数据量。数据量越大，通常意味着检索和更新数据所需的时间越长。\n  在设计和优化数据系统时，需要考虑到这些不同的数据负载特性，以确保数据系统能够在各种场景下提供高性能和稳定性能。\n关系数据需要解决的问题：面向工业大数据分析场景，工业大数据存储组件需要支持关系数据与时序数据、非结构化数据的关联读取和处理。同时工业大数据的存储组件要达到TB单位的内存，支持100个节点以上的分布式管理架构，支持年级别时间的运行。\n模型研发工具 可视化技术：平台在数据准备阶段需要提供可视化算子，帮助数据分析师完成面向业务逻辑的数据准备工作。提供可视化建模和编辑功能，能够屏蔽底层执行引擎内容，加快模型开发。\n平台架构 基本的功能组件包括大数据存储组件、计算引擎组件、可视化建模组件、安全组件和数据可视化组件。\n数据管理的层次感觉是计算机数据库的那些知识。比如TSDB,TSDW,OBJ.\n工业大数据分析案例 实际上《工业大数据分析实例》给出的六个例子都非常好，之后有机会再深究，这里只选取其中三个，而另外三个从《智能制造标准案例集》这本书选择的。\n风电大数据分析 透平设备智能运维 冲压排产优化 “动态性是运筹优化存在的前提，也是挑战。”\n基于工业互联网的新型 生 物 能 源 制取系统 直升机旋翼系统制造智能工厂 数控机床信息安全 ","permalink":"https://tassel234.github.io/posts/note/%E5%B7%A5%E4%B8%9A%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1%E7%90%86%E8%AE%BA%E5%92%8C%E6%A1%88%E4%BE%8B-2/","summary":"工业大数据建模理论和案例-2 更新中 前言 使用资源： 工业大数据分析实例（21w）这本书的内容很全面，广度很大，深度也不小。目前只针对这本书大致了解工业大数据的理论应用。 智能制造标准案例集(20w) 工业大数据技术与应用实践（5.5w） chatgpt 平台技术 基本介绍 工业大数据平台的特点由工业大数据的","title":"工业大数据建模理论和案例-2"},{"content":"《奥本海默》观后感 现代盗火的普罗米修斯，通过毁灭人类的威慑，阻止了可能爆发的超大规模的战争。\n古巴导弹危机，导弹都快在美国头上爆炸了，眼瞅着核战争就要爆发力，不过最后还是谈判解决了。在那个时候美国总统的口号是为了我们下一代的孩子都可以在和平的世界里面生活。我不知道最后苏联为什么会解体，但就结果而言确实极大降低了第三次世界大战的风险，凭借后人不负责任的以教育为意义的从善意和爱的角度出发的，我也比较喜欢给苏联的解体安上一个为了战争的不再发生，人们不再受苦，孩子不再哭泣的名号。所以才让苏联退出了历史舞台。苏联本身的竞争力和早年和晚年的一些暴行污点也是苏联输掉的重要理由。\n“愚者才选择光明正大，权力只存在于阴影之中” “他们拍拍你的肩膀，说道一切既往不咎，看似是为了你，其实是为了他们自己” “到底有谁可以说出真相” 主线有两个，一个是奥本海默研究原子弹的过程，一个是官员施特劳斯诬陷奥本海默的故事线。\n电影最后的一幕有些讽刺，爱因斯坦和奥本海默谈论科学和人类存亡的大事，却被某个心胸狭窄的人认为是针对自己政治生涯的密谋。最后否定施特劳斯的有一个美国新秀，精神小伙：肯尼迪。长的帅，笑口常开，脑洞大开，江湖人称美乐宗。\n感觉从科学（原子弹）的角度，整个二战（西部）是犹太人大战德国人（希特勒）的过程。因为科学家感觉很多都是犹太人，也只有德国人那边海森堡他们能压犹太科学家一头。为什么德国没有先研制出原子弹，有一些原因是希特勒不喜欢量子力学，认为这是犹太人的科学，必须加以抵制。这也是科学的威力之一，他强制的让所有人不同信仰的人存在在同一个世界下，从此西方不再活在以太里面，东方也不活在金木水火土里面，从此世界的所以活着的人都生活在原子之间，因为如果不遵守这一点，就赶不上科学技术的发展，无法发展核武器，世界开始存在保真度极高的真理。奥本海默连接了美国所有不同语言，宗教的人，调度所有的力量，承认科学技术，最终赶上了德国制造原子弹的进程。\n我个人还是比较喜欢前两个小时的研究原子弹的拍摄，因为出现了非常多的科学大佬。\n比如费米，波尔，海森堡，泰勒。\n以前听说过爱因斯坦晚年经常和哥德尔一起散步，本来只是听说，没想到电影看到活着的了。哥德尔是逻辑学的宗师级人物，哥德尔不完备定理让人们知道我们对真理的认知有多么匮乏。\n比较遗憾的是我一直留意的费曼并没有详细介绍，没有太多出场镜头，不过一出场就十分搞笑。看原子弹爆炸时费曼露天坐在小椅子上敷防晒霜。一个把物理变成生活的浪子，一个敢于质疑权威，提出路径积分，费曼图的古灵精怪的科学家。不过原子弹爆炸的时候对应 的时间线是费曼的妻子阿琳患肺结核生命所剩无几的时间线，最后原子弹爆炸后费曼是握着妻子的手激动的流泪的，阿琳不久就死了。阿琳离开的后劲来的比较慢，但是后劲比较大，大到我们可以把浪子费曼形容为一个痴情的男人。\n感觉诺兰要么看过刘慈欣的球状闪电，要么刘慈欣看过奥本海默的传记。因为里面对奥本海默在造出原子弹然后抵制的说辞几乎如出一辙，因为科学家就是疯子，虽然现在抵制，但是如果重新来一次，奥本海默还是会去造原子弹。\n一些神秘学的观点。 原子核可能连接着另一个宇宙，ufo经常目击到在核电站附近。宇宙星系的发光交错就像是人类的大脑。\n","permalink":"https://tassel234.github.io/posts/read/%E5%A5%A5%E6%9C%AC%E6%B5%B7%E9%BB%98%E8%A7%82%E5%90%8E%E6%84%9F/","summary":"《奥本海默》观后感 现代盗火的普罗米修斯，通过毁灭人类的威慑，阻止了可能爆发的超大规模的战争。 古巴导弹危机，导弹都快在美国头上爆炸了，眼瞅着核战争就要爆发力，不过最后还是谈判解决了。在那个时候美国总统的口号是为了我们下一代的孩子都可以在和平的世界里面生活。我不知道最后苏联为什么会解","title":"《奥本海默》观后感"},{"content":"工业大数据应用模型 生产安全分析 海因里希法则（Heinrich’s Law）。该法则指出，当一个企业有300个隐患或违章时，非常有可能发生29起轻伤或故障，以及1起重伤、死亡或重大事故。海因里希提出的事故因果连锁论，阐明了发生伤亡事故的各种原因及这些原因与伤亡事故之间的关系。该理论认为，伤亡事故的发生不是孤立事件，尽管可能在某瞬间突然发生，但实际上它是一系列事件相继发生的结果。\n生产安全分析是一种关注生产过程中安全状况的分析方法，旨在识别潜在的安全风险，评估安全水平，并制定相应的预防和控制措施。这种分析方法涉及多个领域，包括安全生产、风险管理、质量控制和工业工程等。通过对生产过程中的人员、设备、物料、环境和管理制度等方面进行全面、深入的分析，可以减少事故发生率，提高生产效率，保障员工的生命财产安全。\n生产安全分析通常包括以下步骤：\n  识别危险源：通过检查生产设备和环境，分析可能出现的安全隐患，例如机械设备的故障、有毒有害物质的泄露等。\n  评估风险程度：根据危险源的性质和可能导致的事故后果，评估风险等级，确定风险优先级。\n  制定预防措施：针对 identified危险源，制定相应的预防和控制措施，包括改进设备、加强人员培训、优化生产流程等。\n  实施安全监控：通过实时监控生产过程中的关键参数和安全指标，确保安全措施的有效实施。\n  持续改进：根据生产安全分析的结果，持续改进生产工艺和设备，提高安全生产水平。\n  在进行生产安全分析时，还可利用一些分析工具和技术，如事故树分析（FTA）、失效模式和效应分析（FMEA）、危险与可操作性分析（HAZOP）等。这些方法可以帮助分析人员更好地识别风险，制定针对性的预防措施，从而达到提高生产安全的目的。\n7.1.1 微观管理 视频分析技术。随着计算处理能力、计算机视觉，传感器和机器人技术的突破，全自动安全程序随之产生。\n音频分析技术。根据设备的声纹信息判断旋转设备的运行工况是否安全，根据次声波分析密闭压力\n特定装备或重点装备的关键参数进行监控和分析。\n7.1.2 宏观管理 基于多维数据， 从 管 理 领 域 需 求 出 发 , 借 助 数 据 分 析 技 术 , 从 管 理 优 化 、 实时 监 管 和 趋 势 预 警 3 个 方 面 进 行 安 监 大 数 据 分 析 应 用 建 设 。 为 保 证 分 析 应 用 可 灵 活。\n在此过程中可以依托物联网，社交媒体数据以及历史管理数据。\n这一方面和数学建模竞赛的习题有很多的相似了。\n营销优化分析 营销优化分析是一种提高营销效果的数据分析方法。这种方法通过深入研究市场数据、客户行为、竞争环境等多方面因素，发现营销活动中存在的问题，并提出优化方案。通过实施营销优化分析，企业能够提高营销效率，降低成本，提高客户满意度和忠诚度，从而实现更好的营销业绩。\n营销优化分析通常包括以下几个步骤：\n  明确目标：首先需要明确营销优化的目标，例如提高销售额、增加潜在客户、提高品牌知名度等。\n  数据收集与整理：收集与营销活动相关的各种数据，包括销售数据、客户行为数据、市场趋势数据等。整理数据，确保数据的准确性和完整性。\n  分析与诊断：对收集到的数据进行详细分析，识别出营销活动中存在的问题和瓶颈。例如，分析客户转化率、活动效果、渠道效率等指标，找出薄弱环节。\n  制定优化方案：根据分析结果，制定针对性的优化方案。这可能包括调整营销策略、修改营销素材、优化渠道组合等。\n  实施优化措施：将优化方案付诸实践，并进行持续跟踪和调整，以确保优化措施的有效性。\n  评估优化效果：经过一定时期的实施后，重新评估营销效果，以检验优化措施的实际效果。根据评估结果，决定是否需要进一步优化。\n  营销优化分析过程中，可以运用多种数据分析方法和工具，如数据挖掘、统计分析、A/B测试等。通过这些方法和工具，可以帮助分析人员更深入地了解市场需求和客户行为，从而做出更明智的营销决策。\n研发数据分析 研发数据分析（R\u0026amp;D Analytics）是一种收集、整理、处理和分析研发数据，以改进产品开发、优化研发流程和降低成本的方法。研发数据分析可以帮助企业更好地了解其研发活动的效率和效果，以便在竞争中保持领先地位。\n研发数据分析的主要步骤包括：\n  数据收集：收集研发过程中的所有相关数据，包括项目计划、需求分析、设计文档、测试结果、缺陷报告、成本数据等。\n  数据整理：对收集到的数据进行整理，包括数据清洗、数据规范化、数据整合等，以确保数据的准确性和一致性。\n  数据分析：运用适当的数据分析方法和技术，对整理后的数据进行深入分析，以挖掘有价值的信息和规律。\n  结果可视化：将分析结果用图表、报告等形式进行可视化，以便进行有效的沟通和决策。\n  研发数据分析的方法和技术包括：\n  描述性统计分析：用于总结研发数据的分布、中心趋势和离散程度，如均值、中位数、标准差、最小值、最大值等。\n  推论统计分析：用于通过样本数据来推断总体特征，如假设检验、T检验、方差分析等。\n  数据挖掘：用于发现数据中的隐藏模式和趋势，如聚类分析、分类分析、关联规则等。\n  可视化分析：用于将数据用图表、图形等形式进行可视化，以便进行有效的沟通和决策，如柱状图、饼图、散点图、箱线图等。\n  研发数据分析可以帮助企业更好地了解研发活动的效率和效果，例如：\n  项目进度分析：通过分析项目进度数据，了解项目是否按计划进行，以便及时采取措施调整进度。\n  成本分析：通过分析项目成本数据，了解项目的成本构成和成本趋势，以便优化成本控制。\n  缺陷分析：通过分析缺陷报告数据，了解缺陷的类型、原因和分布，以便改进产品质量和开发流程。\n  技术趋势分析：通过分析技术文档和数据，了解技术发展趋势和市场需求，以便优化产品规划和研发方向。\n  研发人员效率分析：通过分析研发人员的工作数据，了解研发人员的效率和能力，以便优化研发团队的结构和人力资源配置。\n  研发是一个高度创新的过程，人工智能有时候可以看到我们看不到的东西。比如通过大数据对某些异常情况的分析，我们可以了解那些“意料之外，情理之中”的小发现，不断对工业系统进行改进。\n有限元仿真（Finite Element Simulation，FEM）是一种广泛应用于工程和科学研究的的计算方法，通过将复杂的物理问题分解为较小的、 简单的问题，来近似求解偏微分方程（PDE）。\nFEM将求解域离散化为有限个互不重叠的单元，用简单函数（如线性函数）逼近单元中的解，通过求解单元之间的连接方程（如平衡方程、兼容性方程等），最终获得整个求解域上的数值解。\n有限元仿真在多个领域都有广泛的应用，如：\n 结构分析：评估结构在不同负载和条件下的响应，如应力、应变、位移等。 流体力学：模拟流体流动、热传导和化学反应等问题。 电磁学：分析电磁场和波在复杂结构中的传播和行为。 传热分析：研究热传递现象，如热传导、对流和辐射。  有限元仿真的优势在于可以处理复杂几何形状和载荷条件，考虑材料的非线性行为，并具有较高的计算效率。这使得它们在工程和科学研究中成为了一种不可或缺的工具。\n有限元仿真的时间比较长，而且需要一定的数据支持，基 于 有 限 元 仿 真 结 果 库 , 利 用 统 计 学 习 的 回 归 分 析 算 法 ( 如 神 经 网 络 、 随 机 森 林 等 ) 训 练 得 到 回 归 预 测 模 型。\n在数据上，研发数据分析需要将研发数据（PLM）、管理数据（ERP）、制造数据（MES）、服务数据（MRO）、监测数据（SCADA）等有机融合\n在研发大数据的基础层面，大数据平台应该融合既有的研发数据管理体系，还应该有相对灵活的对象存储模式，以支持数据的不断扩展。\n工业大数据的分析算法 数据和特征决定了机器学习的上限，而模型和算法只是逼近这个上限而已\n时序数据常常呈现自相关（时间维度）、互相关（多个变量间）、多尺度（时间颗粒度）等特性，因而有不少针对这些时序数据特征的领域算法。\n在工业大数据分析实践中，领域理解和特征加工比算法本身更重要，因此，要最大限度地从原始数据中提取特征，以供算法和模型使用。\n8.1 统计分析算法 8.2 机器学习算法 这两个章节的知识和前面博客写过的算法有诸多相似之处，或者应该说这些算法和数学建模竞赛的算法是基本一致的（比如聚类分析，pca,神经网络，决策树，启发算法），因此不再赘述。\n不过这本书介绍的机器学习算法仍然有非常多的可取之处，虽然内容的深度没有拓展多少，但是广度极佳，有大量图表，分类辅助理解，而且还出现了一些我闻所未闻的算法。比专门的建模算法书介绍的都更有条理和全面。\n后续可以针对这两章专门写几篇博客。\n8.3 时序数据挖掘算法 这部分的算法感觉如果应用到23年国赛的C题会比较好，但是当时我们并没有学到时序算法。\n8.3.1 时序分割 不同时间，不同工况之间的数据差异非常大，所以要应用时序分割。而且时序分割也可以达到降维的效果。\n Changepoint（统计量的变化点）  一个最简单的时序分割假设是：时间序列的基础统计量（均值、方差）是分段稳定的。此类算法的重点是寻找统计量的变化点。主要有3种算法：AMOC（At Most One Change）、PELT（Pruned Exact Linear Time）、BinSeg（Binary Segementation）。 AMOC根据均值或方差的变化进行研判，但其最多只能找到1个分割点。AM\nTreeSplit  梯度直方图（Histogram of Oriented Gradients，HOG）是图像识别中流行的特征提取方法，具有旋转不变性、位移不变性等良好性质，形状表达能力非常好\nAutoplait  Autoplait算法使用隐马尔可夫模型（HMM）和最小描述长度准则（MDL）自动决定分割的段数和每段的起始点。\nMDL是基于信息理论的模型选择标准之一，此外值得一提的是，Autoplait算法的鲁棒性不好，容易受到干扰。\n8.3.2 时序分解 时序分解（Temporal decomposition）是一种将复杂问题分解为更小的、可管理的子问题的方法，这些子问题可以在不同的时间点上分别解决，以实现更有效的问题解决。这种方法在人工智能、规划和调度等领域有着广泛的应用。\n时序分解通常包括以下几个步骤：\n  问题识别：确定需要解决的问题，例如任务调度、规划等。\n  子问题生成：将原始问题分解为更小的子问题，这些子问题可以在不同的时间点上解决。\n  子问题求解：对每个子问题进行求解，这可能涉及到使用其他算法或策略。\n  结果合并：将各个子问题的解决方案合并成一个完整的解决方案。\n  评估与优化：评估所得解决方案的质量，并在必要时进行优化。\n  时序分解可以帮助我们更好地理解问题的复杂性，并在解决复杂问题时提供一种系统化的方法。通过将问题分解为更小的子问题，我们可以更容易地找到合适的解决方案，并提高问题的可解性。\n常见的时序分解算法有STL、奇异谱分析（SSA）、经验模态分解（EMD）、小波变换、SuperSmooth、传统线性滤波等。\nSTL的优点是适用于任何周期的数据（X12ARIMA周期只能是季度或月份），且可以控制季节性成分随时间的变化率。stl的鲁棒性很强。\n对经过EMD处理的信号进行希尔伯特变换，就组成了“希尔伯特—黄变换”。EMD是一种信号分解方法，与傅里叶变换、小波变换的核心思想一致，都是将信号分解为相互独立的成分的叠加。\n奇异谱分析是近年来兴起的一种研究非线性时序数据的方法。可以估计混沌系统，比如气候吸引子的维数，这是是SSA在气象学中的最早应用。\n8.3.3 时序再表征 时序再表征（Temporal re-representation）是指在时序数据中，通过一定的方法将原始数据变换为新的表示形式，以便更好地捕获数据中的时间模式、趋势和规律。这种技术在时序预测、金融分析、语音识别等领域有着广泛的应用。\n时序再表征通常包括以下几个步骤：\n  数据预处理：对原始时序数据进行清洗、去噪、填补缺失值等处理，以确保数据质量。\n  特征提取：从原始数据中提取具有预测能力的特征，如时间序列的统计特征、变化率等。\n  特征选择：选择对预测目标最具预测能力的特征，以减少特征向量的维度，提高模型的效率。\n  特征变换：将特征向量从原始空间映射到一个新的空间，以便更好地展现数据中的时间模式。这可能涉及到使用一些非线性映射方法，如傅里叶变换、小波变换、离散余弦变换等。\n  模型构建：根据变换后的特征向量，运用机器学习或深度学习方法建立预测模型。\n  评估与优化：对预测模型的性能进行评估，并在必要时进行优化，以提高预测精度。\n  通过时序再表征，我们可以更好地捕捉时序数据中的时间动态性，从而为预测、分类等任务提供更有效的特征表示。\n8.3.4 序列模式 序列模式（Sequential Pattern）的主要任务是挖掘时间序列中的频繁模式，即时间序列中经常出现的模式。\n8.3.5 异常检测 异常检测有规则驱动、数据驱动两条技术路线。\n8.3.6 时序聚类 时序聚类（Temporal Clustering）是一种将时间序列数据划分为不同簇（或分组）的统计分析技术。这种技术可以帮助我们更好地理解数据，发现潜在的模式和趋势，以及识别异常值。时序聚类有多种方法，以下是一些常见的方法：\n  动态时间折纸（Dynamic Time Warping, DTW）：这是一种常见的时序聚类方法，它通过计算两个时间序列之间的相似度，然后将相似的时间序列聚类在一起。DTW 可以处理时间序列之间的时间不对齐和变形问题。\n  基于距离的聚类方法：如欧式距离、 Pearson 相关系数等，将这些距离或相似性度量作为聚类算法的输入，将相似的时间序列聚在一起。\n  隐马尔可夫模型（Hidden Markov Model, HMM）：HMM 是一种基于概率模型的聚类方法，它假设观测序列是由一个隐藏的马尔可夫链生成的。通过估计模型的参数，可以将相似的时间序列聚类在一起。\n  条件随机场（Conditional Random Fields, CRF）：CRF 是一种基于概率图的聚类方法，它也假设观测序列是由一个隐藏的马尔可夫链生成的。与 HMM 不同，CRF 考虑了观测序列之间复杂的依赖关系。\n  深度学习方法：如循环神经网络（Recurrent Neural Network, RNN）和卷积神经网络（Convolutional Neural Network, CNN），它们可以将时间序列数据作为输入，自动学习输入数据的特征表示，从而实现时间序列的聚类。\n  时序聚类在许多领域都有广泛的应用，如金融（股票市场分析）、物联网（传感器数据聚类）、医疗保健（心电图分析）等。\n8.3.7 时序分类 时序分类常常用于设备异常类型识别、工况状态识别等场景。例如，医学中的心电图类型识别。\n8.3.8 时序预测 处理稳态时间序列的经典方法是采用ARIMA、状态方程（在线Kalman滤波）等。在考虑多种因素的非线性交互作用时，采用ARIMA等解析模型进行处理较为困难。在工程实践中，常利用ARIMA了解变量的时序相关阶数，将其加工为特征变量，再利用通用的回归方法建模。\n8.3.9 可视化 可视化是提高数据可消费性。\n8.3.10 工具与应用 在实际应用中，常常灵活地交叉使用各种时序算法和经典机器学习算法，没有固定模式。例如，对于存在多尺度（Multi-scale）特征量的时序数据，可以用小波变换等方法提前将多尺度分开，在每个尺度上采用机器学习算法，\n8.4 工业知识图谱 在工业生产过程中会积累大量日志文本，如产品手册、维修工单、工艺流程文件、故障记录等，在这些非结构化数据中蕴含着丰富的专家经验，利用文本分析技术能够实现事件实体和类型提取（故障类型抽取）、事件线索抽取（故障现象、征兆、排查路线、结果分析），通过专家知识的沉淀形成专家知识库。这些沉淀的知识可以指导工业企业的产品研发设计、设备运行检修，甚至营销采购等多个方面。\n工业知识图谱是一种重要的知识沉淀工具，它的本质是语义网络，是一种基于图的数据结构，由节点（实体）和边（关系）组成，知识图谱是把所有类型的工业数据连接在一起得到的关系网络，因此具备从“关系”的角度分析问题的能力。\n知识融合：分为数据层知识融合与概念层知识融合。\n把经验和大数据进行融合，或者说把机理和大数据进行融合。\n8.5 其他算法 8.5.1 系统辨识算法 系统辨识算法面向控制和优化系统建模。\n8.5.2 运筹优化算法 运筹学主要研究人类对各种资源的合理使用，在满足外界各类约束的情况下，最大化资源效益，达到总体最优的目标。已经和建模非常相似了\n8.5.3 规则推理算法 Rete算法是规则引擎常用的前向规则快速匹配算法，通过缓存条件结果和触发关系，避免了相同条件的多次计算（即用空间换时间），提高规则引擎的处理效率。\n8.5.4 基于遗传算法的特征提取算法 在数据分析中，特征提取通常花费60%的时间。为了加速这一个过程，可以进行遗传算法和特征提取的结合算法。在遗传算法中，文法树的每条推导路径（即衍生特征变量）对应一个基因。\n","permalink":"https://tassel234.github.io/posts/note/%E5%B7%A5%E4%B8%9A%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1%E7%90%86%E8%AE%BA%E5%92%8C%E6%A1%88%E4%BE%8B-3/","summary":"工业大数据应用模型 生产安全分析 海因里希法则（Heinrich’s Law）。该法则指出，当一个企业有300个隐患或违章时，非常有可能发生29起轻伤或故障，以及1起重伤、死亡或重大事故。海因里希提出的事故因果连锁论，阐明了发生伤亡事故的各种原因及这些原因与伤亡事故之间的关系。该理论认","title":"工业大数据建模理论和案例-3"},{"content":"ps入门 前言 使用资源：\nhttps://www.bilibili.com/video/BV1Q5411P7k4\n简介：\nAdobe Photoshop，简称“PS”，是由Adobe Systems开发和发行的图像处理软件。Photoshop主要处理以像素所构成的数字图像。使用其众多的编修与绘图工具，可以有效地进行图片编辑和创造工作。PS 有很多功能，在图像、图形、文字、视频、出版等各方面都有涉及。可以PS还可以制作表情包，抠图，制造gif。\n我一般绘画采用的是procreate在平板上进行（因为纸质的画笔各种颜色太贵了），ps也可以接入数位板进行绘画，但手眼分离算是比较难受的了。可以使用比较复杂的步骤：通过procreate进行图画的绘制，然后导入到ps进行优化。现在ps完成抠图，procreate进行临摹。\n快捷键 Ps快捷键应用到的常用四个键：Ctrl，Shift，Alt，空格键。\nCtrl键：相当于你命令行，控制的意思。\nShift键：相当于是切换/换挡的意思。按住shift键还可以选择正方形选区，正圆\n选区，或者等比例放大缩小\nAlt”键：“Alter”的缩写，它的中文意思是“更改、改变、修改”\nEsc键：取消操作\nEnter 键：执行操作\n放缩大小：alt+鼠标的轮滑 或者 ctrl+ \u0026ldquo;+或者-\u0026rdquo;\n选择：全部选取 【Ctrl】+【A】、取消选择 【Ctrl】+【D】、重新选择 【Ctrl】+【Shift】+【D】、羽化选择 【Ctrl】+【Alt】+【D】。\n拖动画布: 按住空格，出现抓手即可拖动 撤回: Ctrl+Z 重做: Ctrl+Shift+Z\n界面介绍 左边是最重要的工具，点击工具后上面会出现一些操作属性。\n右边可以方便的修改颜色选取和图层。\n历史记录: 记录PS操作中的每一步，可在其中找到之前的修改操作。\n字符、段落:可以对文字工具进行编辑调整\n颜色、色板、渐变:结合画笔、油漆桶、形状、文字工具使用。图形、字体的色彩调整可以在这几个面板中进行管理。\n属性:针对不同的工具，有不同的内容可以进行调整。\n调整:里面包含多种图片调整工具，例如亮度、色彩平衡、曲线等等。\n图层:显示图层之间的堆叠顺序，以及图层的属性，可以进行的操作有新建图层、删除图层、编组、建立蒙版、混合选项等等。\n通道:根据色彩模式的设置，通道会显示出该色彩模式下的几种颜色通道图层。可建立精确选区、存储选区、载入选区备用\n路径:使用绘图工具创建的任意形状的曲线会显示在路径栏当中，可以创建矢量蒙版、转换为选区、颜色填充、描边。\n图层基本知识 通过对图层的研究可以进行海报 的制作，包括层次感 的显示，大量重复图像的放缩叠加。\n国层混合模式包括下面四种：\n 变暗模式 变亮模式 中性模式 差集模式 颜色模式  ps工具探索 魔棒工具组 -快捷键W\n魔棒工具:选择色彩类似的图像区域\n快速选择工具: 通过查找和追踪图像边缘来创建选区\n裁剪工具组 - 快捷键C\n裁剪工具:裁切或者拓展图像的边缘\n透视裁剪工具:裁剪图像以矫正透视导致的扭曲\n吸管工具 - 快捷键I 吸管工具:从图像中取样颜色\n画笔工具组-快捷键B\n画笔工具:绘制自定义画笔描边\n铅笔工具:绘制硬边缘画笔描边\n颜色替换工具:将选定颜色绘制在现有颜色之上\n混合器画笔工具:模拟真实的绘画技巧，例如混合颜色和变化涂料湿度\n实例1：镂空图像 打开“磨砂纸”素材，使用椭圆工具按住Shf键绘制正圆，并在属性中给圆填充灰色，增加镂空的真实感\n对圆形图层使用图层混合选项，添加内阴影效果\nCtrl+J复制圆形图层，Ctrl+T并按住Alt键以中心为缩放点，缩小圆形\n加入音符素材，调整音符大小与位置，让音符位于圆心\n锁定音符图层不透明像素，用画笔工具为音符涂上灰色\n对音符图层使用图层混合选项，同样添加内阴影效果\n使用椭圆工具绘制正圆，略大于镂空外圆一圈，填充使用预设内的渐变预设进行填充\n丰富画面\n给渐变圆添加图层混合模式，选择叠加模式\n栅格化渐变圆图层，使用滤镜\u0026gt;模糊\u0026gt;高斯模糊，对渐变圆边缘进行过渡，让色彩与背景融合\n在图像正中间下方，使用文字工具输入文字\n实例2：重影海报制作 打开拳击照片，点击照片图层Ctrl+]复制图层\n右键复制的图层对图层使用混合选项，关闭通道R(红色通道)\n轻移关闭通道R的图层，制作出红蓝重影\n使用矩形选框工具，布尔运算选用添加模式，在图片中围绕人物随机框选出一些长条矩形\n点击滤镜\u0026gt;风格化\u0026gt;风，选择大风执行滤镜，效果不明显使用快捷键Alt+Ctrl+F多执行几次滤镜6不要取消选区，点击下方没有关闭通道R的照片图层，同样使用快捷键At+Ctl+F执行几次滤镜，制作故障效果\n使用文字工具输入PUGILIST，在文字面板中更改文字字体大小等\n使用同样的方法，用选框工具结合滤镜给文字制作故障效果\nctrl+J复制文字图层，执行图层混合选项，运用同样的方法制作重影效果\n实例3：灯笼 新建文件，在预设中选择A4尺寸画布建立文件\n拖入纸背景素材并调整图像位置与大小\n拖入灯笼素材，按住Alt键使用移动工具，拖移复制出四个灯笼\nCtrl+T自由变换调整灯笼的大小以及位置，交错摆放在画面上方\n使用文字工具输入Chinese New Year Celebration，并在文字面板对文字进行字体、大小以及间距的更改\n移动文字至画面左下角对文件进行排版\n实例4：抠图和修图 打开熊宝宝素材和草地素材\n在熊宝宝素材中使用快速选择工具或是磁性套索工具对熊宝宝进行抠图\n将扣好的熊宝宝图片复制粘贴到草地素材中\nCtrl+T自由变换调整熊宝宝位置及大小\n使用套索工具绘制熊宝宝在草地上的阴影区域并填充黑色\n使用滤镜\u0026gt;模糊\u0026gt;高斯模糊对绘制的阴影形状进行模糊\n","permalink":"https://tassel234.github.io/posts/note/ps%E5%85%A5%E9%97%A8-1/","summary":"ps入门 前言 使用资源： https://www.bilibili.com/video/BV1Q5411P7k4 简介： Adobe Photoshop，简称“PS”，是由Adobe Systems开发和发行的图像处理软件。Photoshop主要处理以像素所构成的数字图像。使用其众多的编修与绘图工具，可以有效地进行图片编辑和创造工作。PS 有很多功能，在图像、图形、文字、视频、出版等","title":"Ps入门-1"},{"content":"数学建模和算法应用举例-2(智能RGV的动态调度策略) 前言 更新中\n使用资源 2018年高教社杯全国大学生数学建模竞赛题目 B题 智能RGV的动态调度策略\n即其相应的优秀论文：B203,225，334.\nchatgpt\naim 考虑不一样的因素。不同的视角，看到不一样的东西。\n学会建立模型和求解解决实际问题。\n问题重述 问题描述 有一个智能加工系统的示意图，由8台计算机数控机床（Computer Number Controller，CNC）、1辆轨道式自动引导车（Rail Guide Vehicle，RGV）、1条RGV直线轨道、1条上料传送带、1条下料传送带等附属设备组成。RGV是一种无人驾驶、能在固定轨道上自由运行的智能车。它根据指令能自动控制移动方向和距离，并自带一个机械手臂、两只机械手爪和物料清洗槽，能够完成上下料及清洗物料等作业任务。\n针对下面的三种具体情况：\n（1）一道工序的物料加工作业情况，每台CNC安装同样的刀具，物料可以在任一台CNC上加工完成；\n（2）两道工序的物料加工作业情况，每个物料的第一和第二道工序分别由两台不同的CNC依次加工完成；\n（3）CNC在加工过程中可能发生故障（据统计：故障的发生概率约为1%）的情况，每次故障排除（人工处理，未完成的物料报废）时间介于10~20分钟之间，故障排除后即刻加入作业序列。要求分别考虑一道工序和两道工序的物料加工作业情况。\n请你们团队完成下列两项任务：\n任务1：对一般问题进行研究，给出RGV动态调度模型和相应的求解算法；\n任务2：利用表1中系统作业参数的3组数据分别检验模型的实用性和算法的有效性，给出RGV的调度策略和系统的作业效率，并将具体的结果分别填入附件2的EXCEL表中。\n表1：智能加工系统作业参数的3组数据表\n系统的构成及说明 智能加工系统由8台CNC、1台带机械手和清洗槽的RGV、1条RGV直线轨道、1条上料传送带和1条下料传送带等附属设备构成。\n（1）CNC：在上料传送带和下料传送带的两侧各安装4台CNC，等距排列，每台CNC同一时间只能安装1种刀具加工1个物料。 如果物料的加工过程需要两道工序，则需要有不同的CNC安装不同的刀具分别加工完成，在加工过程中不能更换刀具。第一和第二道工序需要在不同的CNC上依次加工完成，完成时间也不同，每台CNC只能完成其中的一道工序。\n（2）RGV：RGV带有智能控制功能，能够接收和发送指令信号。根据指令能在直线轨道上移动和停止等待，可连续移动1个单位（两台相邻CNC间的距离）、2个单位（三台相邻CNC间的距离）和3个单位（四台相邻CNC间的距离）。RGV同一时间只能执行移动、停止等待、上下料和清洗作业中的一项。\n（3）上料传送带：上料传送带由4段组成，在奇数编号CNC1#、3#、5#、7#前各有1段。由系统传感器控制，只能向一个方向传动，既能连动，也能独立运动。\n（4）下料传送带：下料传送带由4段组成，在偶数编号CNC2#、4#、6#、8#前各有1段。由传感器控制，只能向同一个方向传动，既能连动，也能独立运动。\n在附图1中，中间设备是自带清洗槽和机械手的轨道式自动引导车RGV，清洗槽每次只能清洗1个物料，机械手臂前端有2个手爪，通过旋转可以先后各抓取1个物料，完成上下料作业。两边排列的是CNC，每台CNC前方各安装有一段物料传送带。右侧为上料传送带，负责为CNC输送生料（未加工的物料）；左边为下料传送带，负责将成料（加工并清洗完成的物料）送出系统。其他为保证系统正常运行的辅助设备。\n在附图3左图中，机械臂前端上方手爪抓有1个生料A，CNC加工台上有1个熟料B。RGV机械臂移动到CNC加工台上方，机械臂下方空置的手爪准备抓取熟料B，在抓取了熟料B后即完成下料作业。\n在附图3右图中，RGV机械臂下方手爪已抓取了CNC加工台上的熟料B抬高手臂，并旋转手爪，将生料A对准加工位置，安放到CNC加工台上，即完成上料作业。\n系统的作业流程 （1）智能加工系统通电启动后，RGV在CNC1#和CNC2#正中间的初始位置，所有CNC都处于空闲状态。\n（2）在工作正常情况下，如果某CNC处于空闲状态，则向RGV发出上料需求信号；否则，CNC处于加工作业状态，在加工作业完成即刻向RGV发出需求信号。\n（3）RGV在收到某CNC的需求信号后，它会自行确定该CNC的上下料作业次序，并依次按顺序为其上下料作业。根据需求指令，RGV运行至需要作业的某CNC处，同时上料传送带将生料送到该CNC正前方，供RGV上料作业。\nRGV为偶数编号CNC一次上下料所需时间要大于为奇数编号CNC一次上下料所需时间。\n（4）在RGV为某CNC完成一次上下料作业后，就会转动机械臂，将一只机械手上的熟料移动到清洗槽上方，进行清洗作业（只清洗加工完成的熟料）。\n具体过程：首先用另一只机械手抓取出清洗槽中的成料、转动手爪、放入熟料到清洗槽中，然后转动机械臂，将成料放到下料传送带上送出系统。这个作业过程所需要的时间称为RGV清洗作业时间，并且在这个过程中RGV不能移动。\n熟料在清洗槽中的实际清洗时间是很短的，远小于机械手将成料放到下料传送带上的时间。\n（5）RGV在完成一项作业任务后，立即判别执行下一个作业指令。此时，如果没有接到其他的作业指令，则RGV就在原地等待直到下一个作业指令。\n某CNC完成一个物料的加工作业任务后，即刻向RGV发出需求信号。如果RGV没能即刻到达为其上下料，该CNC就会出现等待。\n（6）系统周而复始地重复（3）至（5），直到系统停止作业，RGV回到初始位置。\n初步思路 任务1：对一般问题进行研究，给出RGV动态调度模型和相应的求解算法；\n任务2：利用表1中系统作业参数的3组数据分别检验模型的实用性和算法的有效性，给出RGV的调度策略和系统的作业效率，并将具体的结果分别填入附件2的EXCEL表中。\n立即判别执行下一个作业指令，三种具体情况：单个和两个项目以及故障的情况。\n位置的选择。但是没有给数量啊。要求分别考虑一道工序和两道工序的物料加工作业情况。代表不是混合的情况，刀片一开始就设定好了。最后确定的是4种情况。\n在八个小时的时间里面，考虑故障的情况，获得最大的效率。\nRGV动态调度模型，可能和选择先上料哪一个有关，如何处理重叠的信号。\n似乎可以通过初始化上料时间完成重合度最少的选择。\n似乎不是优化问题，而是对机械过程进行抽象进行描述，对三种情况进行分析。但其实也相当于规划优化的问题了。\n考虑故障的情况：泊松分布。故障时间的假设。故障的台式和发生时间。\nRGV移动1个单位所需时间 RGV移动2个单位所需时间 RGV移动3个单位所需时间 CNC加工完成一个一道工序的物料所需时间 CNC加工完成一个两道工序物料的第一道工序所需时间 CNC加工完成一个两道工序物料的第二道工序所需时间 RGV为CNC1#，3#，5#，7#一次上下料所需时间 RGV为CNC2#，4#，6#，8#一次上下料所需时间 RGV完成一个物料的清洗作业所需时间 启发思路 建模 求解 总结 ","permalink":"https://tassel234.github.io/posts/note/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%92%8C%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B-2%E6%99%BA%E8%83%BDrgv%E7%9A%84%E5%8A%A8%E6%80%81%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/","summary":"数学建模和算法应用举例-2(智能RGV的动态调度策略) 前言 更新中 使用资源 2018年高教社杯全国大学生数学建模竞赛题目 B题 智能RGV的动态调度策略 即其相应的优秀论文：B203,225，334. chatgpt aim 考虑不一样的因素。不同的视角，看到不一样的东西。 学会建立模型和求解解决实际问题。 问题重","title":"数学建模和算法应用举例-2(智能RGV的动态调度策略)"},{"content":"概率论入门-2 前言 使用资源：概率论和数理统计（同济课本）\n后续还会针对学校课程的学习对内容进行补充\n随机事件与概率 第一节 随机事件及其运算 样本空间和分割 第二节 概率的定义及其性质 第三节 等可能概型 第四节 条件概率与事件的相互独立性 第五节 全概率公式与贝叶斯公式\n随机变量及其分布 第一节 随机变量及其分布\n 随机变量的定义 随机变量的分布函数  离散型随机变量的分布律 表格 连续性随机变量及其密度函数  第二节 常用的离散型随机变量 二项分布 n重伯努利实验 泊松分布 (1) 某一时段内某网站的点击量; (2) 早高峰时间段内驶入高架道路的车辆 （3）数一本书上的印刷错误数. 超几何分布 几何分布和负二项分布 第三节 常用的连续型随机变量 均匀分布 U 指数分布 E 正态分布N 第四节 随机变量函数的分布 求和与求积分\n二维随机变量及其分布 第一节 二维随机变量及其联合分布\n样本空间，样本点（单事件），随机变量X，（或叫X（w）），即每一个样本点对于的映射。 也叫二维随机变量。\n(1) O\u0026lt;F (x, y) \u0026lt;1; (2) 当固定y值时，F(x，y) 是变量x的单调非减函数，当固定x值时，F(x，y) 是变量y的单调非减函数; (3) (4) 当固定y值时，F(x，y) 是变量x的右连续函数， 当固定x值时，F(x，y) 是变量y的右连续函数;（5)对任意的X1\u0026lt;x2， Y1\u0026lt;y2有矩形公式 P (x1\u0026lt;X\u0026lt;x2, Y1\u0026lt;Y\u0026lt;Y2) =F (x2， Y2) -F (x1， Y2)- F (X2， Y1) +F (X1， Y1) .\n联合分布函数 联合分布律的图表 联合密度函数 第二节 常用的二维随机变量 二维均匀分布 二维正态分布 第三节 边缘分布 如果已知二维随机变量(x，y) 的联合分布，那么其中一个随机变量的分布肯定能够得到，其分布我们称为边缘分布. 边缘分布律\n边缘密度函数 若已知联合密度函数，边缘密度函数可以直接由定义公式计算得到;若已知联合分布函数，首先计算边缘分布函数，再对边缘分布函数求导得到边缘密度函数，第一种方法更简洁，无论使用哪种方法，首先要确定随机变量的值域，在值域上求出密度函数的表达式，值域之外密度函数都为零.\n随机变量的相互独立性\n第四节 条件分布\n在实际工作中，我们经常考虑这样的问题，当一个随机变量的取值确定时，另外一个随机变量的取值规律如何，比如，新生男婴的身高和体重分别用X与Y表示，已知 (X，Y) 的联合分布，新生男婴平均身高为50cm.讨论当男婴身高为5ocm时，男婴体重的分布规律，这需要引入条件分布才能计算，下面给出二维离散型随机变量及二维连续型随机变量的条件分布函数.\n第五节 二维随机变量函数的分布\n当x,y相互独立 这两个公式称为卷积公式\n当x,y相互独立 最大值和最小值分布\n随机变量的数字特征 数学期望\n第二节 方差和标准差 第三节 协方差和相关系数 协方差表示了随机变量间协调变化的关系 协方差有正有负，正的代表正相关，负的代表负相关，一般来说数值越大代表相关性越强，但不同单位下得到的数值有很大的差异，所以经常先对随机变量标准化， 然后求值。 相关系数为0，代表不相关， 第四节 其他数字特征\nk阶矩 变异系数\n分数和中位数\n","permalink":"https://tassel234.github.io/posts/note/%E6%A6%82%E7%8E%87%E8%AE%BA%E5%85%A5%E9%97%A8-2/","summary":"概率论入门-2 前言 使用资源：概率论和数理统计（同济课本） 后续还会针对学校课程的学习对内容进行补充 随机事件与概率 第一节 随机事件及其运算 样本空间和分割 第二节 概率的定义及其性质 第三节 等可能概型 第四节 条件概率与事件的相互独立性 第五节 全概率公式与贝叶斯公式 随机变量及其分布 第一节 随机变量及其","title":"概率论入门-2"},{"content":"前言 使用资源：概率论和数理统计（同济课本）\n大数定律及中心极限定理 超几何分布的极限是二项分布以及泊松定理，即二项分布的极限是泊松分布。 大数定律 得到频率的极限是概率 依概率收敛，稳定.\n在大量相互独立重复试验中可以用某个事件A发生的频率来近似每次试验中事件A发生的概率，这就是伯努利大数定律的直观意义，当n充分大时，频率与其概率能任意接近的概率趋向于1.因此实际中，只要试验次数足够多，可用频率作为概率的估计。同时伯努利大数定律也解释了概率存在的客观意义，为什么“大数次”重复试验下，事件的概率是存在的，正是因为频率的这种稳定性，我们才意识到概率的存在，才有了概率论这门学科。三个大数定律条件是不同的，切比雪夫大数定律不要求随机变量序列同分布，甚至不要求相互独立，只要两两不相关、方差一致有界即可;辛钦大数定律和伯努利大数定律都要求随机变量序列相互独立且同分布，辛钦大数定律不要求方差存在，仅期望存在即可;伯努利大数定律的共同分布限定为两点分布。三个大数定律的条件关系如图所示。\n切比雪夫大数定律不要求随机变量序列相互独立，因而适用面更广。数学的发展从来都是循序渐进的，正因为有了伯努利大数定律，才会有辛钦大数定律进而才有切比雪夫大数定律，大数定律无论在理论还是在实际应用中，都有举足轻重的作用，对概率论和数理统计的发展有着不可替代的作用，是现代概率论、数理统计学、理论科学和社会科学发展的基石。\n中心极限定理 得到正态分布\n统计量和抽样分布 总体与样本 统计量 样本均值和样本方差三大分布 y2分布、t分布、F分布都是从正态总体中衍生出来的，之前介绍的几种常用的统计量的分布在正态总体假定下都与这三大分布有关，所以它们在正态总体的统计推断中起着重要的作用. 正态总体的抽样分布 参数估计 第一节 点估计 在前一章中，我们已经了解总体这个概念，而总体X的分布永远是未知的，通常根据实际情况假定服从某种类型的分布。例如，假定总体X服从正态分布，那么刻画正态分布的均值u和方差C究竟取什么值呢? 在本章中，我们将讨论参数的他计问题。参数估计的形式有两种: 点估计和区间估计。我们从点估计开始\n第二节 点估计的优良性评判标准 无偏性，相合性\n第三节 区间估计 置信区间\n第四节 单正态总体下未知参数的置信区间 第五节 两个正态总体下未知参数的置信区间 假设检验 检验的基本原理 正态总体参数的假设检验 u检验 拟合优度检验 第七章的参数估计是假定总体的分布类型是已知的，需要通过样本来估计亥画总体分布的一个或若千个参数。但是，在实际问题中，经常不知道总体服从1么分布，这时只能假定其为某种分布，那么就需要根据样本数据来检验假设是否合理，即检验假设的总体分布是否可以被接受，又称为分布的拟合检验，常用的方法有x2拟合优度检验\n","permalink":"https://tassel234.github.io/posts/note/%E6%A6%82%E7%8E%87%E8%AE%BA%E5%85%A5%E9%97%A8-1/","summary":"前言 使用资源：概率论和数理统计（同济课本） 大数定律及中心极限定理 超几何分布的极限是二项分布以及泊松定理，即二项分布的极限是泊松分布。 大数定律 得到频率的极限是概率 依概率收敛，稳定. 在大量相互独立重复试验中可以用某个事件A发生的频率来近似每次试验中事件A发生的概率，这就是伯努利大数定","title":"概率论入门-1"},{"content":"《凛冬之刃》读后感 使用资源 《凛冬之刃》电子书\n国产剧《漫长的季节》，共12集，豆瓣9.4分\n木鱼三个小时的功力\n剪影\n时间线\n内容简介 这本书是电视剧遥远的季节的小说原作，电视剧对小说进行了一些改编，小说也补充了电视剧的一些细节。\n小城桦林，此时，出租司机王响做梦也没想到，他还有机会遇到一个他此生最想遇到，又最怕遇到的人。遇到了，就得有交代，给自己，也给儿子。小城桦林，彼时，火车司机王响意气风发，开得了二十挂的钢铁巨兽却管不好鸡毛蒜皮的三口小家，工厂摇摇欲坠，危机处处紧逼。一包身份未明的碎尸像一块石头砸在桦林的水面上，也砸在王响的头脑里，这片涟漪一荡就是20年，荡到秋叶泛黄，从未停歇。迷失的父亲，死亡的恋人、重逢的老友，因一个未解的谜题被困在三个不同的时代里，只为追寻一个跨越了过去、现在、未来的真相，当谜底揭开时，时空融为一体，在漫长的季节里只剩命运的挽歌。\n感想 书影的描写非常接近接近于那个时代，人物的台词也充满了东北特色的豪放气息，而且最难得的一点是人物的对话有一种没有被“文明用语”污染的美感。\n我知道了那个时代的高级招待所，歌舞厅。\n人物 刚开始我比较讨厌龚彪这个角色，因为这个人像一个混子，满嘴脏话，破皮耍赖，擅自动用妻子为了开店攒的的钱，而且还勾搭别的女人。\n但后来我知道龚彪也算是一个比较聪明的人，虽然泼皮，但是比较有能力，可以摆平事情。年轻的龚彪是一个还算比较正经的，长相帅气的大学生，明明前途光明，却在20年后成了混子。龚彪是大学毕业的高材生，一毕业就分配到桦林钢厂做起了厂办科员。相比于一般的工人，也算是个管理层了。\n为什么呢，因为龚彪这个人敢爱敢恨，对于黄丽茹（后来的媳妇）的追求可以说非常热烈和浪漫。在二人还没有确定关系的时候，黄丽茹怀上了厂长的孩子，而厂长因为自己媳妇在工厂里面闹和自己声誉的原因，选择和黄玉茹划清界限，龚彪知道了这个事情后不管之前厂长对自己的提拔，撸起袖子就要把厂长打一顿，后来被王响拉住了（不过之后王响亲手揍了厂长一顿）。黄玉茹因为意外流产，而今后再也没有怀上孩子的能力，龚彪在医院的病床上告诉她自己仍会照顾她爱她一辈子。结婚，一地鸡毛，因为公然反抗厂长，本来没在下岗名单之列的龚彪也被第一个开除了。而开除之后的龚彪只好开起了出租车，好养活他和黄丽茹，让黄丽茹过上幸福的好日子。\n命运 这本书我刚开始看的时候以为是福尔摩斯，后来以为是钱德勒，最后我才明白这部剧是余华的《活着》。\n1998，王响的儿子为了救沈墨被淹死，老婆受不了自杀了。办案的警察队长马德胜也因为压力中风辞职了，王响和马德胜被困在了那个那个季节。王响在失去配偶和孩子后准备卧轨自杀的时候，遇见了一个弃婴，王响为他起名叫王北，为了抚养他，王响活了下去。多年之后，案子终于查清了，自己的朋友龚彪却因为意外死亡，马德胜也因为脑梗而生活不能自理。\n沈墨是桦林杀人碎尸案最核心的人物，她的身上却背负着那么多悲剧的因和果。父母早亡，沈墨被心理变态的亲戚抚养，在猥亵和折磨中长大，如此的一个女孩似乎一辈子都没有不会获得幸福，这个时候王阳像一束光出现在她的生命中，告诉她不要相信命运，命运是可以改变的，这间接导致了沈墨最后决定举起屠刀去进行反抗，杀害那些欺负自己的人。命运从来不会让沈墨获得幸福。\n时代 杀人当然是不对的，这是社会教化给我们的最重要的规训，但即使如此，童年美满，受过教育的王阳还是陪着沈墨一起，杀人，处理尸体，为了救她牺牲了自己的生命。这个事件客观的拿出来绝对会受到很多的批评，但坏就坏在这件事情是有背景的。有种叫爱或者自私的东西，如果犯下大错的是我们的孩子，父母，非常要好的朋友，非常尊敬的人，会让我们在小范围扭曲自己的公平和正义。沈墨从小被恋童的沈栋梁折磨，考上了别地的医学院终于摆脱了他的约束，然后她遇见了不信命，阳光自信的王阳。在王阳的追求下，二人有了暧昧的关系，但接着情况却急转直下，沈墨被沈栋梁公布的裸照破坏了声誉，被一个有钱的老板侵犯，保护自己的弟弟也被黑社会打的半死。王阳，沈墨，傅卫军（弟弟）被逼迫到拿起了屠刀。\n在那个时代下，只是发生了一个非常小的事件，企业发生整改，一群旧的员工需要被裁员。一个企业的厂长利用自己的权利混的风生水起，一个有钱的商人在娱乐场所花天酒地。但这一切却因为人心的黑暗，引发了一系列的悲剧。\n打个响指吧 他说 我们打个共鸣的响指 遥远的事物将被震碎 面前的人们此时尚不知情 吹个口哨吧 我说 你来吹个斜斜的口哨 像一块铁 然后是一枚针 磁极的弧线拂过绿玻璃 喝一杯水吧，也看一看河 在平静时平静 不平静时 我们就错过了一层台阶 一小颗眼泪 滴在石头上 很长时间也不会干涸 整个季节将它结成了琥珀 块状的流淌 具体的光芒 在它背后是些遥远的事物 ","permalink":"https://tassel234.github.io/posts/read/%E5%87%9B%E5%86%AC%E4%B9%8B%E5%88%83%E8%AF%BB%E5%90%8E%E6%84%9F/","summary":"《凛冬之刃》读后感 使用资源 《凛冬之刃》电子书 国产剧《漫长的季节》，共12集，豆瓣9.4分 木鱼三个小时的功力 剪影 时间线 内容简介 这本书是电视剧遥远的季节的小说原作，电视剧对小说进行了一些改编，小说也补充了电视剧的一些细节。 小城桦林，此时，出租司机王响做梦也没想到，他还有机会遇到一个他","title":"《凛冬之刃》读后感"},{"content":"《深度学习的数学》读书笔记-1 前言 目标：\n  稍微了解神经网络和深度学习的数学基础\n  知道如何简单的实现神经网络和深度学习\n  使用资源:\nchatgtp\n深度学习的数学\n基本概念 https://tassel234.github.io/posts/note/%E7%AE%97%E6%B3%95%E9%A2%84%E8%A7%88%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AF%87-3/\n权重的不同才是实现神经网络的基石，比如在图像识别领域，通过不同的特征值附上不同的权重，在识别01时，有非常显著的像素点差异，凭借此附上不同权值的神经网络就可以完成对01的识别。\n数学基础和应用 矩阵的特征向量和特征值 矩阵的特征向量和特征值是线性代数的重要概念，它们在许多领域都有应用，如机器学习、数据分析、优化等。\n  特征向量（Eigenvector）：特征向量是指满足一定条件的向量。在线性代数中，如果一个向量v是一个方阵A的特征向量，那么对于任何非零向量w，有Av = λw，其中λ是一个非零实数，称为特征值。换句话说，特征向量是将方阵A的行空间投影到某个基向量的方向上的向量。更具体地说，特征向量满足 Ax = λx，其中A是一个方阵，x是一个向量，λ是一个实数。\n  特征值（Eigenvalue）：特征值是方阵A的特征向量对应的非零实数，描述了特征向量的大小。特征值可以是负数、零或者正数。一个方阵A的所有特征值之和称为A的谱半径（Spectral Radius）。\n  特征向量和特征值在许多领域都有应用，如：\n 图像处理：可以用特征向量表示图像中的特征，通过特征向量来提取和识别图像中的信息。 机器学习：在机器学习中，特征向量和特征值是将原始数据转换为可以用于机器学习算法的形式的关键步骤。 数据分析：在数据分析中，特征向量和特征值可以帮助我们找到数据中的关键特征，从而更好地理解和解释数据。  总之，特征向量和特征值是线性代数的重要概念，它们在许多领域都有广泛的应用。理解特征向量和特征值的性质和应用，可以帮助我们更好地理解和分析数据。\n在优化问题中，矩阵的特征向量和特征值对解决特定问题有重要作用。它们在许多不同的领域中都有广泛的应用，如线性规划、图论、计算几何等。以下是一些在优化问题中应用特征向量和特征值的例子：\n  线性规划：线性规划是一种特殊的优化问题，其目标是找到一组线性等式和线性不等式，使得一组变量的取值达到最大或最小。在线性规划中，特征向量和特征值非常关键，因为它们可以用来解决约束优化问题。通过找到一组非零特征向量和对应的特征值，我们可以将线性规划问题转化为一个凸优化问题，从而更容易找到全局最优解。\n  图论和网络优化：在图论和网络优化问题中，特征向量和特征值可以用于描述图的特性。例如，在最小生成树问题中，我们可以找到图中的一组特征向量，使得这些向量的线性组合可以描述出图中的最小生成树。\n  计算几何：在计算几何问题中，特征向量和特征值可以用来描述图形的特性。例如，在凸多边形的判定问题中，我们可以找到多边形的一组特征向量，使得这些向量的线性组合可以描述出凸多边形。\n  机器学习和深度学习：在机器学习和深度学习中，特征向量和特征值也有重要作\n  用。在深度学习中，特征提取是一个重要的步骤，通过将原始数据投影到一组特征向量上，可以提高模型的表示能力和泛化能力。\n总的来说，矩阵的特征向量和特征值在优化问题中具有广泛的应用，可以帮助我们更好地理解和解决各种优化问题。\n在数据分析和优化问题中，矩阵的特征向量和特征值具有重要的应用。以下是一些具体的例子：\n  主成分分析（PCA）：主成分分析是一种常用的降维方法，它通过找到一组新的基向量来表示原始数据。这些基向量是原始数据的线性组合，可以最大化数据的方差。在PCA中，特征向量就是这些新的基向量，而特征值则表示对应特征向量的大小，即这些基向量在原始数据中的重要性。通过选择特征值较大的特征向量，可以将原始数据投影到低维空间，同时保留原始数据的大部分方差。\n  线性最小二乘法：线性最小二乘法是一种优化问题的求解方法，它通过最小化残差平方和来找到数据的最优拟合线。在线性最小二乘法中，特征向量和特征值可以用于求解线性方程组，从而找到最优解。这些特征向量和特征值可以将数据投影到基向量上，从而便于线性最小二乘法的求解。\n  正则化和特征选择：在机器学习和数据挖掘中，正则化和特征选择是优化模型泛化能力的重要方法。通过使用正则化方法（如L1正则化或L2正则化），可以在损失函数中添加与特征值相关的惩罚项，从而选择重要的特征。在特征选择方法中，可以通过计算特征的统计量（如互信息、相关性等）来选择具有较高信息量的特征。特征向量和特征值可以用于计算这些统计量，从而帮助我们选择有用的特征。\n  图像压缩：在图像压缩技术中，特征值和特征向量可以用于提取图像的重要特征。例如，可以使用哈尔小波变换提取图像的低频分量和高频分量，将这些特征表示为特征向量和特征值。这些特征向量和特征值可以用于量化图像数据，从而减小图像的数据量，实现图像压缩。\n  总之，矩阵的特征向量和特征值在数据分析和优化问题中具有广泛的应用。通过使用特征向量和特征值，我们可以找到数据的关键特征，从而提高数据处理和分析的效率。\n概率函数和方差 概率函数（probability function）和方差（variance）是概率论和统计学中的两个重要概念。\n  概率函数（probability function）：概率函数是用于描述随机变量取值概率的函数。在离散情况下，概率函数通常被写作P(X=x)，其中x是随机变量X的取值。在连续情况下，概率函数通常被写作P(|X-X_c| \u0026lt; ε)，其中X_c是随机变量X的取值，ε是一个很小的正实数（或0），表示事件的实际界限。\n  方差（variance）：方差是一种衡量随机变量取值分布离散程度的度量。对于离散随机变量X，其方差定义为E[(X - E)^2]，其中E是随机变量X的数学期望。\n  对于连续随机变量X，其方差定义为Var[X] = E[X^2] - (E[X])^2，其中E[X^2]是随机变量X的平方的数学期望。\n概率函数和方差是随机变量分析和推断的重要工具，例如，它们可以用来确定概率分布，以及进行统计推断（如假设检验）。\n梯度下降法 sigmod函数，在梯度下降法中需要对这个函数求导，而他的求导也有一些规律，f'(x) = f(x) * (1 - f(x))，可以配合链式求导使用。对多元函数链式求导计算权重也可以使用。\n梯度下降函数的基础是使用多变量函数的近似值。多元函数的泰勒展开式，以及使用倒数的近似公式，计算向量的内积。两个向量的方向相反时，内积最小，沿着梯度的相反的方向下降最快，使用哈密顿算子可以使表达更简单，符号是倒三角。\nita可以理解为人爬山时的步长，如果步长过大可能跨过最小值点，步长过小会停留在原地，ita在神经网络中被称为学习率，他的确定方法没有明确的标准，只能通过反复的实验去确认。\n梯度下降法也叫最速下降法，是一种优化算法，用于求解损失函数的最小值。在机器学习和人工智能领域，梯度下降法通常用于训练模型中的参数。\n梯度下降法的基本思想是：给定一个损失函数，初始化一个模型参数向量，通过多次迭代，逐步调整模型参数，使得损失函数值逐渐减小，最终接近（或达到）最小值。在每次迭代过程中，梯度下降法会：\n 计算损失函数关于当前参数向量的梯度。 用梯度值与一个预先设定的学习率相乘，得到参数的更新值。 用更新值替代当前参数向量中的对应元素。  重复进行以上步骤，直到满足特定的终止条件（如损失函数值变化很小或达到预设迭代次数）。\n需要注意的是，梯度下降法并不能保证找到全局最优解，只能保证找到局部最优解。在实际应用中，为了更好地寻找全局最优解，通常会使用梯度下降法的变体，如随机梯度下降法（Stochastic Gradient Descent）和小批量梯度下降法（Mini-batch Gradient Descent）。\n神经网络的最优化 神经网络会自己进行学习，这在数学上的含义是指，对权重和偏置进行最优化，使得输出符合学习数据。而对于最优化而言，求导是不可缺少的一种方法。\n神经网络的计算往往会涉及成千上万个变量，这是因为构成神经网络的神经单元的权重和偏置都被作为变量处理。\n代价函数也可以叫目标函数，损失函数，误差函数。\n数据的规模不能小于参数的个数，否则无法确定模型。\n本书使用平方误差作为实际数据和理论值的误差指标。虽然这个指标容易理解，但由于存在计算收敛时间长的情况，所以也有难点为了克服这个缺陷，人们提出了各种各样的误差指标，其中特别有名的一个指标就是交叉熵。\n利用这个交叉熵和 Sigmoid 函数，可以消除Sigmoid函数的冗长性，提高梯度下降法的计算速度。\n此外，交叉熵来源于信息论中熵的思想。\n虽然神经网络和回归分析确定模型的原理相同，但是它们也存在以下差异。\n相比回归分析中使用的模型的参数，神经网络中使用的参数的数目十分巨大。\n线性回归分析中使用的函数为一次式，而神经网络中使用的函数(激活函数)不是一次式。因此，在神经网络的情况下，代价函数变得很复杂。\n代价函数最小化的过程就是最优化的过程，或者也可以说是神经网络学习的过程。通过这个过程不断优化神经网络的参数（偏置和权重），但因为代价函数过于复杂，需要强大的数学武器才可以支持求解。所以需要梯度下降法，但实际上对某些代价函数的求导有时仍然非常困难，所以人们研究出了误差反向传播法。\n误差反向传播 数列和递推可以用来实现误差反向传播（BP）。\n神经单元误差，delta。\n误差反向传播（Error Backpropagation）是一种用于训练人工神经网络的算法。这种算法通过计算损失函数关于模型参数的梯度，然后将梯度反向传播回网络，以调整模型参数，从而最小化损失函数。以下是关于误差反向传播的简要介绍：\n  正向传播：首先，输入数据进入网络，经过各层神经元的计算，最终得到输出。这一过程被称为正向传播（Forward Propagation）。在正向传播过程中，每一层神经元都会计算损失函数关于当前层权重的偏导数。\n  反向传播：反向传播从输出层开始，根据损失函数关于输出层权重的偏导数，使用链式法则依次计算损失函数关于各层权重的偏导数。最后，将这些偏导数用于更新网络权重。\n  更新参数：在得到损失函数关于各层权重的偏导数后，可以使用梯度下降法、随机梯度下降法等优化算法来更新网络参数。更新参数的过程通常会迭代多次，直到模型收敛或达到预设的迭代次数。\n  误差反向传播算法的优势在于，它可以通过梯度计算 guide 参数的更新方向，从而更高效地训练神经网络。然而，误差反向传播也存在一些局限性，如容易受到梯度消失和梯度爆炸等问题的影响。\n","permalink":"https://tassel234.github.io/posts/note/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-1/","summary":"《深度学习的数学》读书笔记-1 前言 目标： 稍微了解神经网络和深度学习的数学基础 知道如何简单的实现神经网络和深度学习 使用资源: chatgtp 深度学习的数学 基本概念 https://tassel234.github.io/posts/note/%E7%AE%97%E6%B3%95%E9%A2%84%E8%A7%88%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AF%87-3/ 权重的不同才是实现神经网络的基石，比如在图像识别领域，通过不同的特征值附上不同的权重，在识别01时，有非常显著的像素点差异，凭借此附","title":"《深度学习的数学》读书笔记-1"},{"content":"数学建模和算法应用举例-1 前言 使用资源 2017年高教社杯全国大学生数学建模竞赛题目 B题 “拍照赚钱”的任务定价B248\n上海市数学建模教学视频（过上一段时间就自动失效）\nhttps://blog.csdn.net/qq_63438888/article/details/127413453\nchatgpt\naim 我无意了解算法的每一个实现细节，理论推导，只求可以将现实的东西转化为数学的结构，然后可以使用别人写好的算法解决即可。\n考虑不一样的因素。不同的视角\n聚类分析获得重要的确立影响因子 数据预处理 绘图分析，分析定价和什么因素有关。\n距离的变换，值得考虑的点，因为地球是圆的。还有一个对百分比的变换。\n这篇文章用到了非常多稀奇古怪的库和软件，技术，方法，值得之后进行学习。\n问题一 思路 和供货商评估模型的建立类似，建模的人在选择，发现或者创造那些重要的变量。采用一种网格化的思路。数据分析整理量化，得到任务数量、会员人数、会员平均完成能力、任务与中心点的距离这四个指标，并进行了流程图的绘制。\n一些可见的推测，这是他们经验累计而来，先对数据进行了观察，分析，觉得应该和什么有关，然后才进行描述。对于一些专业的领域，其实可以搜索到相当相近的论文（见下面的本文参考文献），然后学习和研究机理，不过我倒是觉得自己建模更可以锻炼水平。\n[1]杜剑平，韩中庚，“互联网+”时代的出租车资源配置模型[J]，数学建模及其应用，2015,4(04):40-49+85. [2017\n熵权法确定会员完成能力。对于供货商模型的连续度也采用了这种方式。计算各会员的任务完成能力值，使用了两个指标，\n文章也应用了运用灰色关联矩阵定量分析四个影响因子与定价的相关度，分别为0.9710,0.9671,0.9633,0.9390。\n补充知识 灰度和灰度关联矩阵\n在数学建模中，\u0026ldquo;灰度\u0026quot;通常指的是数据的强度或级别。例如，在图像处理领域，一个图像的每个像素都可以被表示为一个灰度值，该值表示像素的亮度或颜色的明暗程度。例如，灰度值0表示最暗的颜色，灰度值255表示最亮的颜色。\n在灰度数据中，通常有一个单一的数字表示一个像素的颜色强度。例如，在8位图像中，灰度值的范围从0到255，每个值代表一种不同的颜色强度。而在16位或32位图像中，每个像素可以有更多的颜色通道，如红、绿、蓝三个通道，每个通道都有自己的灰度值范围。\n在数学建模中，灰度数据的处理和分析是很重要的一部分。例如，可以用灰度直方图来展示数据的分布，或者用灰度阈值分割法来对图像进行分割。在机器学习和人工智能领域，灰度数据的特征提取和模型训练也是常见的任务。\n在数学中，矩阵是一个二维数组，它可以存储数值信息或其他类型的数据（例如文本）。矩阵是线性代数的核心概念，常用于解决线性方程组、图像处理、机器学习等问题。在机器学习和人工智能领域，矩阵运算是一个关键概念。许多现代算法，如梯度下降法、卷积神经网络等，都依赖于矩阵运算来进行数据处理和优化。\n灰度关联矩阵是一个在图像处理、模式识别和机器学习领域中常用的工具。它用于描述不同特征之间的关联性，特别是在处理多特征数据（如图像）时，可以帮助我们了解各个特征之间的依赖关系。\n灰度关联矩阵是一种矩阵，其中行和列分别表示特征向量和特征值。矩阵中的元素表示特征向量在特征值下的权重。通常，我们会选择不同的特征值，以便每个特征在矩阵中占据一定的比例。这可以帮助我们更好地了解哪些特征对于目标变量具有较高的相关性。\n在图像处理领域，灰度关联矩阵可以用来计算图像的各种特征（如灰度级、边缘、纹理等）之间的关联性。通过分析这些关联性，我们可以更好地理解图像的结构，为图像分类、物体识别等任务提供有价值的信息。\n** K-Means 聚类分析的K值选择**\nK-Means 算法的一个关键问题是如何选择 K 值，这将直接影响聚类结果。一种常用的方法是肘部法则（Elbow Method），它通过观察聚类结果随着 K 值变化而产生的变化趋势来选择合适的 K 值。\n然而，肘部法则并非总是有效的，因为它在处理具有不同密度和形状的数据集时可能产生不同的结果。在这种情况下，可以使用其他方法，如轮廓系数（Silhouette Coefficient）或基于相似度的方法（如余弦相似度或 Jaccard 相似度）来选择合适的 K 值。\n问题二 思路 以各个准则为约束条件，建立了多目标优化模型。\n比如建立了吸引度矩阵的建立，阈值确定\n问题三 双层聚类分析，\n问题三的模型建立在问题二的模型之上，仍然考虑对模型中的约束进行一定简化，并做出适当假设，得到全局最优解的近似解作为模型最优解。问题三模型任务安排采用打包分配模式，首先通过聚类把类似的任务聚成一类，从而降低了任务的维度。新的任务数即打包数量影响着任务阈值、吸引度矩阵等变量，通过聚类打包求得新的任务情况，从而套用问题二的算法，对部分变量和维度进行修改，经过遍历得到更优结果。\n问题四 老实说完成度不高，神经网络预测模型只是把机理讲了一下，然后就出来了。\n补充知识 吸引度矩阵\n吸引度矩阵（attractiveness matrix）是一种用于描述和分析网络结构中节点之间相互作用的数学工具。在图论中，吸引度矩阵通常用于表示无向图的节点之间的连通性，以及节点之间的连接强度。通过吸引度矩阵，我们可以了解网络中不同节点之间的连接强度和关系模式。\n吸引度矩阵是一个N×N的矩阵，其中N表示图的节点数。矩阵中的元素表示节点i和节点j之间的连接强度。每个元素的取值范围通常在[-1, 1]或[0, 1]，分别表示节点i和节点j之间存在连接或不存在连接，以及连接强度。较高的元素值表示较强的连接，较低的元素值表示较弱的连接。\n吸引度矩阵可以通过多种方法计算，例如狄利克雷(Dirichlet)分布、威布尔(Weibull)分布等。这些方法可以根据网络的特点和需求进行选择。\n吸引度矩阵在许多领域都有应用，如社交网络分析、生物网络分析、推荐系统等。通过分析吸引度矩阵，我们可以了解网络中不同节点之间的连接模式、强度和影响力，从而为网络优化、社区发现和推荐策略提供理论支持。\n在图论和网络科学中，吸引力阈值（attraction threshold）是一个关键概念，用于描述网络中节点之间的连接强度。吸引力阈值是一种量化指标，用于衡量节点之间的连接强度。当节点之间的连接强度超过一定阈值时，我们认为这些节点之间存在吸引力；否则，它们之间的连接相对较弱。\n吸引力阈值可以根据具体问题和需求进行选择。在实际应用中，吸引力阈值可以根据以下因素进行选择：\n 节点的重要性：对于关键节点，我们可能需要设置较高的吸引力阈值以确保它们之间的连接具有较强的稳定性。 网络的拓扑结构：对于不同类型的网络，吸引力阈值可能需要调整。例如，在社区发现问题中，较小的社区可能需要较低的吸引力阈值来保持紧密联系；而在随机网络中，较低的吸引力阈值可能更加合理。 网络的环境变化：随着网络环境的变化，吸引力阈值可能需要相应地调整。例如，当新节点加入网络时，吸引力阈值可能需要提高以确保新节点与已有节点之间的连接足够强。  吸引力阈值的计算方法可以根据网络的特点和需求进行选择。常见的方法包括节点重要度、社区发现算法、协同过滤等。在社交网络、生物网络和推荐系统等领域，吸引力阈值都有广泛的应用。通过合理设置吸引力阈值，我们可以更好地了解网络中节点之间的连接强度和关系模式，为网络优化和应用提供支持。\n2022年C题 玻璃检验 问题 1 分析文物样品表面有无风化化学成分含量的 统计规律，并根据风化点检测数据，预测其风化前 的化学成分含量。\n问题 2 分析玻璃的分类规律；对于每个类别选择合 适的化学成分对其进行亚类划分。\n问题 3 对表单 3 中未知类别玻璃文物的化学成分进 行分析，鉴别其所属类型，分析敏感性。\n问题 4 针对不同类别的玻璃，分析其化学成分之间 的关联关系，比较差异性。\n22年的C题，区分度最大其实是在数据预处理上。\n比例累加应该到100% 。 本 题 中 将 成 分 比 例 紧 加 和 介 于 85%~105% 之 间 的 数 据 视 为 有 效 数 据 。\n这句话十分重要，不能遗漏。首先一些在范围内的非100%的比例，应该扩展为100%，然后还应该对成分数据（百分百数据）进行对数比变换（找论文），改变分布。\n数据的共线性问题，去除共线性的方法：\n数据变换（Logit变换（21年B题乙醇的提示），对数比变换）或者pca分析。\n一个非常大比例的数据越大，其他比例自然也就越小，这就是相关。\n这里实际上是在提醒相关度的事情。两个变量非常相关，直接使用回归分析可能导致和现实相比非常大的谬误（如经济学问题），pca然后回带可以比较有效的解决这个问题。PCA 的奇怪用法，带入回去，可以使用新的主成分进行线性回归，然后把原成分带入回去，（可以通过系数判断强度）获得比较好的回归方程。\n对玻璃文物表面风化与其类型、纹饰和颜色的关系进行分析二维列联表的独立性检验（卡方检验）。分别进行判别，看相关性如何。\n统计规律：以高钾类、铅钡类两个总体按风化和未风化4个，绘制正态分布图形。\n","permalink":"https://tassel234.github.io/posts/note/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%92%8C%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B-1/","summary":"数学建模和算法应用举例-1 前言 使用资源 2017年高教社杯全国大学生数学建模竞赛题目 B题 “拍照赚钱”的任务定价B248 上海市数学建模教学视频（过上一段时间就自动失效） https://blog.csdn.net/qq_63438888/article/details/127413453 chatgpt aim 我无意了解算法的每一个实现细节，理论推导，只求可以将现实的东西转化为数学的结构，然后可以使用别人写好的算法解决","title":"数学建模和算法应用举例-1"},{"content":"第一章 1.1包饺子模型，一斤面和一斤馅原本可以包100个饺子，但某次馅做多了，而面不变，请问是应该少用面多包几个饺子，还是应该多用面包较少的饺子。\n分析：以我建模还没入门的思维，以日常的经验。实际操作中好像不管比例多少，只要别太离谱，都可以把饺子包完。我一开始是想不到馅就是体积。\n但看到解析时发现为了把模型简化，应该认为厚度不变，这可以直接把一斤面转化为表面积的形式。而由表面积可以转化为体积，求出这两者的关系就可以表示用馅的多少。此外还有一个特征系数K值得注意，还有就是配合特征系数K ，【次方】 数学在物理上的意义和应用。\n1.2 路障设计\n分析：我很缺乏常识,不理解原理，如果没有读题目我会认为减速带的作用是通过改变速度方向而减少速度和动能，但这不能说不对但根本解不了题目，减速带的作用应该是为了让车到减速带前速度接近0，来防颠。\n剩下的求解就比较简单了。\n1.3椅子平放问题\n模型非常巧妙，只用了一个未知数，让我明白了简化和等效的意义。简化就是抛弃凳子的立体形状而抽象为正方形，等效是直接把凳子腿的长方体形状砍了，最开始我还考虑为什么只有旋转没有平移，答案就是等效，你在其他地方和在这个地方是等效的，他是以自身为参考系，在任何地方都一样。\n我更没有想到微积分的介值定理可以这么用。\n数学建模的思考，书上说建模应该使用非常简单的数学工具，让更多人可以使用，而不是成为专家级别的孤芳自赏。老实说，我更倾向于为了模型的精确性，无论使用什么样的数学工具。\n第二章 第二章用到了很多我不知道的物理定律，让我意识到了能力的局限。对流，传导，辐射\n解决方法 就是学习物理，听课，认真学大学物理，学费恩曼物理学讲义。\n冰箱和凉席为什么凉快，隔热。\n对于那些建模中的特殊数学方法的名词，借助ai是一个不错的选择。\n不管对第一个问题有一个启示，就是合情的推理，比如杯子的塑料壁和空气壁都按一毫米，肯定是塑料壁的导热性能高。\n第三四章\n书中把第三四节都归为可以解决优化问题。规划模型和优化肯定有非常大的联系.\n3.1储存模型\n分为可以缺货的存储方法和不允许缺货的存储方法。\n3.2救火模型\n可以运用类比法，结合vt图像，求面积和积分的方法。\n3.3啤酒瓶的中心\n因为形状完全一致，前后的质心也应该是一致的，所以有先下降后上升的趋势。力矩平衡定理感觉就是加权法，然后解方程用软件。待入有一个巧合，但其实也可以分析。\n3.4\n高度为0时，45°最好，加上身高可以变形为角度和身高有关。\n4.1奶制品的生产和销售\n这是数学规划模型的例题一，用我高中数学的回忆可以想到，作图法来 求解最优化，用斜率和截距来看。\n影子价格的求解方法我确实不知道，但我可以了解他有什么用。\n我可以了解某个算法可以达到什么样的目的以及大概的操作方法。\n还要知道怎么过度到算法，明白用什么算法\n4.2 自来水供应和货机装运\n学到了怎么写求和符号的取值范围和右标的取值范围\n专业数学计算软件果然np,只需要专注范围的取值就可以了，python不是我的事了。\n货运的模型假设可以的。\n","permalink":"https://tassel234.github.io/posts/note/%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B.%E5%A7%9C%E5%90%AF%E6%BA%90-1/","summary":"第一章 1.1包饺子模型，一斤面和一斤馅原本可以包100个饺子，但某次馅做多了，而面不变，请问是应该少用面多包几个饺子，还是应该多用面包较少的饺子。 分析：以我建模还没入门的思维，以日常的经验。实际操作中好像不管比例多少，只要别太离谱，都可以把饺子包完。我一开始是想不到馅就是体积。 但","title":"数学模型.姜启源-1"},{"content":"算法预览-3 决策树 步骤 构建决策树主要分为三个步骤：特征选择、决策树生成和决策树剪枝。以下是一个简单的决策树实现过程：\n 特征选择 特征选择是决策树构建的关键步骤，目的是找到最优的特征来进行划分。常用的特征选择方法有信息增益、增益率、基尼指数等。这里以信息增益为例进行说明：  计算每个特征的信息增益，选择信息增益最大的特征作为划分依据。\n信息增益的计算公式为：\n信息增益 = 熵(父节点) - 条件熵(子节点)\n其中，熵表示数据集的纯度，条件熵表示在给定特征取值条件下的数据集纯度。计算过程如下：\n 熵(父节点) = -∑(p(i) * log2(p(i)))，其中 i 是类别标签，p(i) 是类别 i 的概率。 条件熵(子节点) = ∑(p(v) * 熵(子节点))，其中 v 是特征的某个取值，p(v) 是特征取值 v 的概率，熵(子节点) 是在给定特征取值 v 的条件下的数据集纯度。  决策树生成 决策树生成过程是一个递归过程。从根节点开始，根据特征选择结果进行划分。对于每个子节点，重复特征选择和划分过程，直到满足停止条件。停止条件通常包括：   所有数据属于同一类别； 无法再继续划分（所有特征已经用完，或者达到最大深度）； 节点中的数据集纯度达到一定程度（如熵值低于某个阈值）。  决策树剪枝 为了防止过拟合，需要对生成的决策树进行剪枝。常用的剪枝方法有预剪枝和后剪枝。预剪枝是在生成决策树的过程中，对每个节点在划分前先进行估计，如果当前节点的划分不能带来泛化性能的提升，则停止划分。后剪枝是先生成一颗完整的决策树，然后自底向上地对非叶节点进行考察，若将该节点对应的子节点替换为叶节点能带来泛化性能的提升，则将该非叶节点替换为叶节点。  实现决策树时，可以选择现有的机器学习库，如Python的scikit-learn库，或者使用专门的决策树算法库，如C4.5、CART等。这些库已经实现了决策树的构建、剪枝等功能，可以方便地进行调用和操作。\n基本结构有决策节点，实例节点，问题。通过计算最大增益度进行实例节点的选择。\n最后可以使用混淆矩阵进行检验。\n优缺点 决策树（Decision Tree）是一种常用的分类和回归算法。它是一种树形结构，其中每个内部节点表示一个特征（属性），每个分支代表一个特征取值，每个叶节点表示一个分类（分类树）或数值（回归树）。决策树的构建过程是一个递归过程，基本思想是根据特征的某个阈值（或一些阈值组合）将数据集划分为两个子集，然后继续这个过程，直到满足停止条件为止。\n构建决策树时，通常使用贪心算法，每次选择最优的特征进行划分，以尽可能纯化子集。但在实际应用中，这种贪心策略可能导致过拟合问题，因此需要采取一些措施，如剪枝（pruning），来减少模型复杂度，提高泛化能力。\n决策树的优点包括：\n 易于理解和实现； 能够处理多种数据类型； 可以自动发现特征之间的关系； 对噪声数据具有较好的鲁棒性。  决策树的缺点包括：\n 可能会过拟合，导致泛化能力较差； 处理连续特征的能力较差； 对于样本不均衡的数据集，容易出现类别不平衡问题。  决策树的应用场景广泛，包括金融、医疗、市场营销、生物信息学等领域。例如，在信用卡欺诈检测、病人诊断、客户细分等场景中，决策树都能发挥重要作用。\n应用 决策树（Decision Tree）是一种非参数的监督学习方法，它在分类和回归问题中都有广泛的应用。其主要优势在于模型易于理解和解释，同时具有较好的泛化能力。以下是决策树的一些主要用途：\n  数据分析和探索：决策树能够帮助我们对数据进行深入的探索和分析，通过树形结构展示出数据的内在关系和特征重要性。\n  特征选择：决策树能够自动地选择对目标变量有较大影响的特征，有助于我们发现数据中的关键特征。\n  分类预测：在分类问题中，决策树能够根据训练数据生成一棵树形结构，用于对新的数据进行分类预测。这种基于树形结构的分类方法具有较强的解释性，能够提供易于理解的分类规则。\n  回归预测：在回归问题中，决策树可以用于生成一棵回归树，通过树形结构进行数值预测。\n  异常值检测：决策树可以对特征空间的划分进行观察，从而发现哪些数据点可能属于异常值。\n  总之，决策树是一种实用、高效的机器学习方法，适用于许多不同类型的预测和分析任务。在具体应用中，我们可以根据问题的性质和数据特点选择合适的决策树算法（如ID3、C4.5、CART等），以提高模型的预测效果和泛化能力。\n决策树在各种领域和场景中具有广泛的应用，以下是一些典型的应用场景：\n  医学诊断：在医学领域，决策树可以用于辅助医生进行疾病诊断。例如，根据病人的症状、体征、实验室检查等数据，建立决策树模型，帮助医生确定病人的疾病类型和严重程度。\n  金融风控：在金融领域，决策树可以用于信用评分、贷款风险评估等任务。例如，根据客户的基本信息、收入、负债、信用历史等数据，建立决策树模型，预测客户信用风险。\n  市场营销：在市场营销领域，决策树可以用于客户细分、产品推荐等任务。例如，根据客户的年龄、性别、购买历史、浏览行为等数据，建立决策树模型，为客户提供个性化的产品推荐。\n  生物信息学：在生物信息学领域，决策树可以用于基因表达数据分析、蛋白质结构预测等任务。例如，根据基因序列、表达数据等特征，建立决策树模型，预测基因的功能或疾病的发生风险。\n  环境监测：在环境监测领域，决策树可以用于空气质量预测、水质量评价等任务。例如，根据气象数据、污染源数据等特征，建立决策树模型，预测未来一段时间内的空气质量。\n  客户服务：在客户服务领域，决策树可以用于客户问题分类、投诉处理等任务。例如，根据客户的咨询内容、历史记录等数据，建立决策树模型，自动为客户分配合适的客服人员或解决方案。\n  这些仅仅是决策树在各领域应用的一部分示例，实际上，决策树可以广泛应用于各种需要分类或回归预测的问题。\nBP神经网络 BP神经网络（Backpropagation Neural Network）是一种广泛使用的前馈神经网络。它由三个基本组成部分组成：输入层、隐藏层和输出层。输入层接收外部数据，隐藏层进行信息处理，输出层对隐藏层的输出进行处理并输出结果。BP神经网络的关键在于反向传播算法（Backpropagation Algorithm），用于调整神经网络中权重和偏置的值。\n步骤 BP神经网络的训练过程如下：\n  初始化：为神经网络中的权重和偏置分配随机值。\n  前向传播：输入数据从输入层进入，经过隐藏层处理，最后到达输出层。输出层的结果表示为 $Y$。\n  计算损失：使用损失函数（如均方误差、交叉熵损失等）计算实际输出与期望输出之间的差异。\n  反向传播：从输出层开始，沿着网络反向传播损失值。对于每个权重，计算梯度 $\\nabla_{\\theta} L$，其中 $\\theta$ 是权重。\n  更新权重和偏置：根据梯度下降法（如牛顿法、梯度下降法、Adam等）更新权重和偏置的值，使得神经网络的预测性能得到改善。\n  重复2-5步：直到满足设定的停止准则（如训练误差达到预定阈值、达到预定迭代次数等）。\n  权重的选择实际可以和遗传算法等智能算法进行结合。\n感知器组件的简要说明如下:\n输入一一描述输入值。在神经元中，这些值对应着输入信号\n灰重一一描述输入和隐藏节点之间每个连接的权重。权重影响输入的强度，并产生加权后的输入。在神经元中，这些连接就是突触。\n隐藏节点(求和与激活一一对加权之后的输入值进行求和，然后对求和结果应用激活函数。激活函数决定隐藏节点(神经元)的激活(输出)。激活函数可以进行使用sigmoid函数，\n输出一一描述感知器的最终输出。\n优缺点 BP神经网络的优点：\n 适合处理非线性问题：通过调整隐藏层的神经元数量和激活函数，BP神经网络可以实现对非线性问题的建模。 具有学习能力：BP神经网络可以自动调整权重和偏置的值，以最小化损失函数。 可扩展性：BP神经网络可以通过堆叠多个隐藏层实现复杂模型，从而具有很强的表达能力。  BP神经网络的缺点：\n 训练时间长：由于需要不断迭代调整权重和偏置的值，BP神经网络的训练时间可能较长。 容易陷入局部最优解：BP神经网络的训练过程可能会陷入局部最优解，而非全局最优解。 对初始值敏感：神经网络的权重和偏置的初始值对训练结果有很大影响。如果初始值不佳，可能导致训练过程不收敛或者收敛速度慢。  神经网络预测模型 神经网络预测模型是一种复杂的机器学习方法，它基于人脑神经系统的工作方式，并在过去的几十年里取得了显著的成果。在这篇文章中，我们将讨论神经网络预测模型的基本原理，包括它们的发展历程、结构、训练方法以及在实际应用中的优势和挑战。\n 引言  神经网络预测模型起源于20世纪50年代，当时心理学家和神经科学家开始研究人脑的工作原理。随着计算机技术的发展，科学家们试图将这些原理应用于机器学习领域，从而开发出能够模仿人脑工作方式的人工智能模型。\n神经网络的基本结构(解构和架构，理解就可以创造)  神经网络由许多相互连接的神经元（也称为节点或处理单元）组成。每个神经元接收来自其他神经元的输入信号，并根据一组权重和偏置值进行加权求和，然后通过激活函数进行处理。输出信号可以传递给其他神经元，形成一个层次化的网络结构。\n神经网络的发展历程  神经网络预测模型的发展可以分为以下几个阶段：\n3.1 早期发展（20世纪50-70年代）\n在这个阶段，研究者们开始尝试将神经科学的原理应用于机器学习领域。神经元和突触的概念被引入到模型中，并使用感知机（perceptron）作为基本的单元。尽管感知机在某些简单问题上表现良好，但它们无法解决复杂的分类问题。\n3.2 反向传播算法的提出（20世纪80年代）\n反向传播算法（backpropagation）的提出使得神经网络的训练变得更加高效。通过调整神经元之间的连接权值和偏置值，神经网络能够学习从输入到输出的映射关系。这使得神经网络在图像识别、语音识别等领域取得了显著的成果。\n3.3 多层感知机和卷积神经网络（20世纪90年代-21世纪初）\n多层感知机（multilayer perceptron, MLP）是一种具有多个隐藏层的神经网络，可以处理更复杂的特征和数据。卷积神经网络（convolutional neural networks, CNN）是一种专门用于图像识别的神经网络，它通过卷积层和池化层来提取图像中的局部特征。这些方法在图像识别、语音识别和自然语言处理等领域取得了重要成果。\n3.4 深度学习和大数据时代（21世纪初至今）\n随着计算能力的提升和大数据的普及，神经网络的训练变得更加高效。深度学习（deep learning）是一种基于多层神经网络的机器学习方法，它通过堆叠多个神经网络层来学习更复杂的特征表示。卷积神经网络、循环神经网络（recurrent neural networks, RNN）和长短时记忆网络（long short-term memory, LSTM）等架构在语音识别、自然语言处理、图像识别和生成等领域取得了突破性进展。\n神经网络的训练方法  神经网络预测模型的训练通常采用梯度下降法（gradient descent）。在训练过程中，模型通过最小化损失函数来调整神经元之间的连接权值和偏置值。常用的损失函数包括均方误差（mean squared error, MSE）、交叉熵损失（cross-entropy loss）和逻辑回归损失（logistic regression loss）等。\n神经网络预测模型的优势和挑战  神经网络预测模型在许多领域都取得了显著的成果，例如图像识别、自然语言处理、语音识别和生物信息学等。它们的主要优势包括：\n 能够学习复杂的特征表示 具有很强的泛化能力，能够处理未见过的数据 可以通过大量的数据进行训练，从而提高模型的准确性和鲁棒性 //鲁棒性（Robustness）是指一个系统、模型或者算法在面对不确定性、噪声和干扰等因素时，仍能保持其预期的性能、功能和准确性的能力。在计算机科学、控制理论、信号处理等领域，鲁棒性都是一个重要的概念。 一个具有鲁棒性的系统通常具有以下特点：   抗干扰性：在受到噪声、干扰或不确定性因素影响时，系统仍能保持稳定运行，不发生严重错误。 容错性：在系统部分元件或组件出现故障时，系统能够继续正常运行，不受影响。 适应性：系统能够适应外部环境的变化，具有一定的自适应能力。 鲁棒性的稳定性：系统在受到扰动时，能够恢复到其正常状态，而不是在扰动下逐渐失去稳定性。//  然而，神经网络预测模型也面临一些挑战，如计算资源需求高、训练时间长、过度拟合（overfitting）等。为了解决这些问题，研究者们提出了许多改进方法，如增大网络规模、采用批量归一化（batch normalization）和正则化（regularization）技术等。\n总结\n神经网络预测模型已经成为现代机器学习领域的一个重要分支。它们通过模拟人脑的工作方式，能够学习复杂的特征表示和数据之间的关系。随着计算能力的提升和大数据的普及，神经网络预测模型在图像识别、语音识别、自然语言处理等领域取得了突破性进展。然而，神经网络预测模型仍然面临一些挑战，如计算资源需求高、训练时间长和过度拟合等。为了解决这些问题，研究者们需要继续探索新的方法和技术，以充分发挥神经网络预测模型的潜力。\n梯度下降法 梯度下降法（Gradient Descent，GD）是一种用于优化函数的数值方法。它的基本思想是通过迭代更新参数，以使目标函数（优化问题的目标函数）的值逐步降低，从而找到最优解或次优解。梯度下降法是一种线性搜索方法，适用于解决具有梯度信息的优化问题。\n梯度下降法的一般步骤如下：\n  初始化：选择一个初始参数值，例如随机选择一组初始参数。\n  计算梯度：计算目标函数在当前参数值下的梯度。梯度是一个向量，表示目标函数在当前参数值下的斜率。梯度可以通过求导计算得到。\n  更新参数：使用当前参数值和计算得到的梯度作为参数更新公式的参数。更新公式可能是线性的（如步长为1）、平方的（如步长为0.5）或其他形式。\n参数更新公式：\n参数 = 参数 - 学习率 × 梯度\n  检查停止条件：在每次迭代过程中，你需要检查目标函数的值是否有所改善。如果目标函数的值没有改善，你可以停止迭代。常见的停止条件包括设置一个最大迭代次数、判断目标函数的值是否小于某个阈值，或者判断目标函数的值是否在某个范围内等。\n  返回结果：如果目标函数的值在迭代过程中有所改善，你可以继续迭代，直到达到停止条件。最后，你可以将得到的结果作为优化函数的最小值或最大值。\n  梯度下降法在实际应用中广泛用于解决各种优化问题。然而，梯度下降法可能会陷入局部最优解，而不是全局最优解。为了避免这种情况，你可以尝试使用不同的梯度下降法变种，如批量梯度下降法、随机梯度下降法、小批量梯度下降法等。此外，你还可以使用动量、RMSprop等优化策略来加快梯度下降法的收敛速度。\n蒙特卡洛模拟 蒙特卡洛模拟和穷举法耗时耗力，时间复杂度过高\n蒙特卡罗方法（Monte Carlo method），又称随机抽样或统计模拟方法，是一种以概率统计理论为指导的一类非常重要的数值计算方法。此方法使用随机数（或更常见的伪随机数）来解决很多计算问题的方法。 由于传统的经验方法由于不能逼近真实的物理过程，很难得到满意的结果，而蒙特卡罗方法由于能够真实地模拟实际物理过程，故解决问题与实际非常符合，可以得到很圆满的结果。 原理：当所求解问题是某种随机事件出现的概率，或者是某个随机变量的期望值时，通过某种“实验”的方法，以这种事件出现的频率估计这一随机事件的概率，或者得到这个随机变量的某些数字特征，并将其作为问题的解。\n蒙特卡洛模拟（Monte Carlo Simulation）是一种数值计算方法，它通过从一个概率分布中随机抽样来建立数学模型。这种方法广泛应用于经济学、工程学、物理学、计算机科学等领域，用于解决各种复杂的优化问题和不确定性问题。\n蒙特卡洛模拟的基本思想是：当我们需要解决一个实际问题时，可以通过在一个随机抽样过程中统计抽样数据，从而得到问题的统计性质。通过对这些统计性质的研究，我们可以得到关于问题的概率模型，并据此建立数学模型。\n以下是蒙特卡洛模拟的一般步骤：\n  定义问题：首先，你需要清楚地定义你要解决的问题。这可能涉及到找到一个函数的最小值、最大值、区间、统计结果等。\n  选择随机抽样方法：蒙特卡洛模拟通常需要从一个概率分布中进行随机抽样。你需要选择一个适当的抽样方法，如均匀抽样、几何抽样、高斯抽样等。\n  进行随机抽样：在每个抽样步骤中，你需要从抽样分布中随机选择一个样本。这个过程可以通过随机数发生器来实现。\n  处理抽样结果：一旦你得到了一组抽样数据，你需要对这些数据进行统计分析，以获取问题的统计性质。这可能涉及到计算均值、方差、概率密度函数等。\n  建立数学模型：根据问题的统计性质，你可以建立一个数学模型来描述问题。这个模型可能是一个线性方程、一个微分方程、一个概率分布等。\n  求解数学模型：一旦你建立了数学模型，你可以使用数值方法（如牛顿法、梯度下降法等）来求解模型。\n  评估结果：最后，你需要评估你得到的结果。这可能涉及到比较实际结果和预期结果，或者评估解决方案的可靠性和可行性。\n  蒙特卡洛模拟的一个重要优势是，它可以处理具有不确定性和复杂性的问题。通过从一个随机抽样过程中收集数据，蒙特卡洛模拟可以帮助我们更好地理解问题的本质，并找到更有效的解决方案。\n","permalink":"https://tassel234.github.io/posts/note/%E7%AE%97%E6%B3%95%E9%A2%84%E8%A7%88%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AF%87-3/","summary":"算法预览-3 决策树 步骤 构建决策树主要分为三个步骤：特征选择、决策树生成和决策树剪枝。以下是一个简单的决策树实现过程： 特征选择 特征选择是决策树构建的关键步骤，目的是找到最优的特征来进行划分。常用的特征选择方法有信息增益、增益率、基尼指数等。这里以信息增益为例进行说明： 计算每个特征的","title":"算法预览（数学建模篇-3）"},{"content":"前言 使用资源： 人工智能算法图解\nhttps://github.com/rishal-hurbans/Grokking-Artificial-Intelligence-Algorithms\nhttps://www.zhihu.com/people/MicrostrongAI/posts?page=2\nchatgtp\naim  知道算法可以解决什么问题 对一些重要的算法要知道每行代码代表代码，然后可以进行修改  lightgbm LightGBM（Light Gradient Boosting Machine）是一种基于梯度提升框架的高效机器学习算法，由微软亚洲研究院的研究员提出。LightGBM主要针对GBDT（Gradient Boosting Decision Tree）算法进行了优化，以提高训练速度和精度。\nGBDT不仅在工业界应用广泛，通常被用于多分类、点击率预测、搜索排序等任务；在各种数据挖掘竞赛中也非常实用，LightGBM在许多机器学习竞赛中表现出了优秀的性能，如Kaggle竞赛等。\nLightGBM的主要优势如下：\n  更快的训练速度：LightGBM采用了一种基于梯度的单边采样算法，可以减少样本的使用，降低模型训练时间。此外，LightGBM还使用了一种称为“互斥特征捆绑”的技术，可以减少特征的数量，进一步提高训练速度。\n  更高的精度：通过对决策树算法进行优化，LightGBM可以在相对较少的迭代次数内达到较高的精度。此外，LightGBM引入了一种称为“Gradient-based One-Side Sampling”（GOSS）的策略，可以在一定程度上减小过拟合的风险。\n  更好的处理稀疏数据能力：LightGBM针对稀疏数据进行了优化，可以有效处理高维稀疏数据。此外，LightGBM使用了一种基于直方图的决策树算法，可以降低稀疏数据带来的计算开销。\n  并行化和分布式计算：LightGBM支持并行化和分布式计算，可以充分利用计算资源，提高训练速度。\n  鲁棒性强：LightGBM对异常值和噪声数据具有较好的鲁棒性，能够在一定程度上减小这些数据对模型训练的影响。\n  LightGBM主要应用于回归和分类问题，如点击率预测、图像分类、文本分类等。在实际应用中，LightGBM往往可以通过调整参数和特征工程等方法，取得较好的性能。\nLightGBM作为一种高效的机器学习算法，具有广泛的应用。以下是一些常见的应用领域：\n  推荐系统：LightGBM可以用于构建推荐系统，对用户行为、兴趣和历史数据进行建模，从而实现个性化推荐。例如，在用户点击率预测、购买行为预测等场景中，LightGBM可以提供准确的预测结果。\n  金融风控：在金融风控领域，LightGBM可以用于构建信用评分模型，预测客户的信用风险。此外，LightGBM还可以应用于欺诈检测、交易风险评估等场景。\n  医疗健康：在医疗健康领域，LightGBM可以用于疾病预测、患者分群、药物研发等任务。例如，在预测患者疾病风险、分析疾病与基因之间的关系等方面，LightGBM可以发挥重要作用。\n  图像识别与分类：LightGBM可以用于图像识别和分类任务，如物体检测、场景分类等。通过将图像数据转换为特征向量，LightGBM可以构建高效且准确的分类模型。\n  自然语言处理：在自然语言处理领域，LightGBM可以用于文本分类、情感分析、命名实体识别等任务。通过将文本数据转换为特征向量，LightGBM可以为这些任务提供高性能的解决方案。\n  工业制造与物联网：在工业制造与物联网领域，LightGBM可以用于设备故障预测、生产计划优化、产品质量控制等任务。通过分析设备运行数据、生产流程数据等，LightGBM可以为企业提供有价值的决策支持。\n  交通运输与物流：在交通运输与物流领域，LightGBM可以用于路线规划、货运需求预测、库存管理等任务。通过分析历史数据和实时数据，LightGBM可以为企业提供更高效的运营策略。\n  这些应用领域仅是LightGBM的一部分，随着研究的深入和技术的发展，LightGBM将在更多领域发挥重要作用。\n蚁群算法 蚁群算法（Ant Colony Optimization, ACO）是一种基于自然界蚂蚁行为的启发式搜索算法，它模拟蚂蚁在寻找食物过程中如何通过信息素来引导其他蚂蚁找到最短路径。蚁群算法具有分布式计算、全局搜索和自适应性等优点，广泛应用于组合优化、路径规划、调度问题等领域。\n基本步骤 蚁群算法的基本思想是：\n 初始化：为问题定义解空间，并随机为每个解分配一个信息素值。 构建解：蚂蚁在解空间中搜索最优解，搜索过程中根据信息素浓度和启发式信息来选择下一步移动。 信息素更新：蚂蚁在搜索过程中会留下信息素，当其他蚂蚁经过时，会根据当前信息素浓度和启发式信息来选择下一步移动。 停止条件：达到预设最大迭代次数或者找到满足条件的解。  蚁群算法主要包括以下三个要素：\n  信息素（pheromone）：信息素是蚂蚁之间通信的媒介，模拟了蚂蚁在自然界中留下的化学物质痕迹。信息素会随着时间逐渐挥发，可以通过调整挥发系数来控制信息素的持久性。\n  启发式信息（heuristic information）：启发式信息用于指导蚂蚁在解空间中进行搜索。启发式信息可以是解的估值函数，如贪心策略或随机策略等。\n  信息素更新规则：蚁群算法通过信息素更新规则来平衡全局搜索和局部搜索。常用的信息素更新规则有：Ant-Quantity-Based, Ant-Density-Based 和 Max-Min Ant System 等。\n  以寻找游玩游乐场项目的最短路径实例，项目之间构成完全图。距离由距离矩阵编写。\n初始化信息素印迹应该都赋值相同的数字，比如1。\n蚂蚁会移动到不同的游乐项目处，留下信息蚂蚁还会判断接下来要去哪个游乐项目。最后，蚂蚁会知道它们各自的总移动离。下面列出了蚂蚁的基本属性:\n记忆一一在蚁群优化算法中，这代表着已经访问过的游乐项目列表\n最佳适应度一一这是经过所有项目的最短总距离\n行动一选择下一个目的地，并沿途留下信息素\n可以对这些对象进行抽象，封装，面向对象编程。\n建立蚂蚁种群，从随机分配的项目开始，遍历一遍所有的路，然后回到出发点，蚂蚁走过这条路就会让这条路的信息素强度加一。启发式的值代表我们已经知道 的一些信息，有点类似A*算法，在游乐场路径遍历 的例子中启发式的值就是距离，然后可以通过计算选择路径。\n最后算出的结果仍然是进行轮盘法抽取下一个地点。\n更新信息素，即跑完一轮后对信息素进行蒸发，最后信息素强度代表在上一轮过程中有多少乘以蒸发率加上路程之和之和的倒数，第一轮初始为1。\n达到预定的迭代次数时停止。在这一场景中，我们将终止条件设置为算法需要运行的迭代总数。如果把终止条件定义为 100 次选代，则每只蚁需要在算法终止前完成 100 次旅行。\n在最佳解决方案停滞不前时停止。在这种情况下，我们将每次选代后的最佳解与之前的最佳解进行比较。如果在规定的迭代次数后，最佳解决方案没有变化，则算法终止。譬如，若第 20 次选代产生了一个适应度为100 的最佳解，并且直到第 30 次选代，最佳解依然为这个解，则很可能(但不保证)并不存在更好的解。\n代码实现 import csv import random import math # Ant Colony Optimization (ACO) # The Ant Colony Optimization algorithm is inspired by the behavior of ants moving between destinations, dropping # pheromones and acting on pheromones that they come across. The emergent behavior is ants converging to paths of # least resistance. # Set the number of attractions in the data set # Best total distance for 5 attractions: 19 # Best total distance for 48 attractions: 33523 ATTRACTION_COUNT = 48 # Initialize the 2D matrix for storing distances between attractions attraction_distances = [] # Read attraction distance data set store it in matrix with open(\u0026#39;attractions-\u0026#39; + str(ATTRACTION_COUNT) + \u0026#39;.csv\u0026#39;) as file: reader = csv.reader(file, quoting=csv.QUOTE_NONNUMERIC) for row in reader: attraction_distances.append(row) # Set the probability of ants choosing a random attraction to visit (0.0 - 1.0) RANDOM_ATTRACTION_FACTOR = 0.0 # Set the weight for pheromones on path for selection ALPHA = 4 # Set the weight for heuristic of path for selection BETA = 7 # The Ant class encompasses the idea of an ant in the ACO algorithm. # Ants will move to different attractions and leave pheromones behind. Ants will also make a judgement about which # attraction to visit next. And lastly, ants will have knowledge about their respective total distance travelled. # - Memory: In the ACO algorithm, this is the list of attractions already visited. # - Best fitness: The shortest total distance travelled across all attractions. # - Action: Choose the next destination to visit and drop pheromones along the way. class Ant: # The ant is initialized to a random attraction with no previously visited attractions def __init__(self): self.visited_attractions = [] self.visited_attractions.append(random.randint(0, ATTRACTION_COUNT - 1)) # Select an attraction using a random chance or ACO function def visit_attraction(self, pheromone_trails): if random.random() \u0026lt; RANDOM_ATTRACTION_FACTOR: self.visited_attractions.append(self.visit_random_attraction()) else: self.visited_attractions.append( self.roulette_wheel_selection(self.visit_probabilistic_attraction(pheromone_trails))) # Select an attraction using a random chance def visit_random_attraction(self): all_attractions = set(range(0, ATTRACTION_COUNT)) possible_attractions = all_attractions - set(self.visited_attractions) return random.randint(0, len(possible_attractions) - 1) # Calculate probabilities of visiting adjacent unvisited attractions def visit_probabilistic_attraction(self, pheromone_trails): current_attraction = self.visited_attractions[-1] all_attractions = set(range(0, ATTRACTION_COUNT)) possible_attractions = all_attractions - set(self.visited_attractions) possible_indexes = [] possible_probabilities = [] total_probabilities = 0 for attraction in possible_attractions: possible_indexes.append(attraction) pheromones_on_path = math.pow(pheromone_trails[current_attraction][attraction], ALPHA) heuristic_for_path = math.pow(1 / attraction_distances[current_attraction][attraction], BETA) probability = pheromones_on_path * heuristic_for_path possible_probabilities.append(probability) total_probabilities += probability possible_probabilities = [probability / total_probabilities for probability in possible_probabilities] return [possible_indexes, possible_probabilities, len(possible_attractions)] # Select an attraction using the probabilities of visiting adjacent unvisited attractions @staticmethod def roulette_wheel_selection(probabilities): slices = [] total = 0 possible_indexes = probabilities[0] possible_probabilities = probabilities[1] possible_attractions_count = probabilities[2] for i in range(0, possible_attractions_count): slices.append([possible_indexes[i], total, total + possible_probabilities[i]]) total += possible_probabilities[i] spin = random.random() result = [s[0] for s in slices if s[1] \u0026lt; spin \u0026lt;= s[2]] return result[0] # Get the total distance travelled by this ant def get_distance_travelled(self): total_distance = 0 for a in range(1, len(self.visited_attractions)): total_distance += attraction_distances[self.visited_attractions[a]][self.visited_attractions[a-1]] total_distance += attraction_distances[self.visited_attractions[0]][self.visited_attractions[len(self.visited_attractions) - 1]] return total_distance def print_info(self): print(\u0026#39;Ant \u0026#39;, self.__hash__()) print(\u0026#39;Total attractions: \u0026#39;, len(self.visited_attractions)) print(\u0026#39;Total distance: \u0026#39;, self.get_distance_travelled()) # The ACO class encompasses the functions for the ACO algorithm consisting of many ants and attractions to visit # The general lifecycle of an ant colony optimization algorithm is as follows: # - Initialize the pheromone trails: This involves creating the concept of pheromone trails between attractions # and initializing their intensity values. # - Setup the population of ants: This involves creating a population of ants where each ant starts at a different # attraction. # - Choose the next visit for each ant: This involves choosing the next attraction to visit for each ant. This will # happen until each ant has visited all attractions exactly once. # - Update the pheromone trails: This involves updating the intensity of pheromone trails based on the ants’ movements # on them as well as factoring in evaporation of pheromones. # - Update the best solution: This involves updating the best solution given the total distance covered by each ant. # - Determine stopping criteria: The process of ants visiting attractions repeats for a number of iterations. One # iteration is every ant visiting all attractions exactly once. The stopping criteria determines the total number of # iterations to run. More iterations will allow ants to make better decisions based on the pheromone trails. class ACO: def __init__(self, number_of_ants_factor): self.number_of_ants_factor = number_of_ants_factor # Initialize the array for storing ants self.ant_colony = [] # Initialize the 2D matrix for pheromone trails self.pheromone_trails = [] # Initialize the best distance in swarm self.best_distance = math.inf self.best_ant = None # Initialize ants at random starting locations def setup_ants(self, number_of_ants_factor): number_of_ants = round(ATTRACTION_COUNT * number_of_ants_factor) self.ant_colony.clear() for i in range(0, number_of_ants): self.ant_colony.append(Ant()) # Initialize pheromone trails between attractions def setup_pheromones(self): for r in range(0, len(attraction_distances)): pheromone_list = [] for i in range(0, len(attraction_distances)): pheromone_list.append(1) self.pheromone_trails.append(pheromone_list) # Move all ants to a new attraction def move_ants(self, ant_population): for ant in ant_population: ant.visit_attraction(self.pheromone_trails) # Determine the best ant in the colony - after one tour of all attractions def get_best(self, ant_population): for ant in ant_population: distance_travelled = ant.get_distance_travelled() if distance_travelled \u0026lt; self.best_distance: self.best_distance = distance_travelled self.best_ant = ant return self.best_ant # Update pheromone trails based ant movements - after one tour of all attractions def update_pheromones(self, evaporation_rate): for x in range(0, ATTRACTION_COUNT): for y in range(0, ATTRACTION_COUNT): self.pheromone_trails[x][y] = self.pheromone_trails[x][y] * evaporation_rate for ant in self.ant_colony: self.pheromone_trails[x][y] += 1 / ant.get_distance_travelled() # Tie everything together - this is the main loop def solve(self, total_iterations, evaporation_rate): self.setup_pheromones() for i in range(0, TOTAL_ITERATIONS): self.setup_ants(NUMBER_OF_ANTS_FACTOR) for r in range(0, ATTRACTION_COUNT - 1): self.move_ants(self.ant_colony) self.update_pheromones(evaporation_rate) self.best_ant = self.get_best(self.ant_colony) print(i, \u0026#39; Best distance: \u0026#39;, self.best_ant.get_distance_travelled()) # Set the percentage of ants based on the total number of attractions NUMBER_OF_ANTS_FACTOR = 0.5 # Set the number of tours ants must complete TOTAL_ITERATIONS = 10000 # Set the rate of pheromone evaporation (0.0 - 1.0) EVAPORATION_RATE = 0.4 aco = ACO(NUMBER_OF_ANTS_FACTOR) aco.solve(TOTAL_ITERATIONS, EVAPORATION_RATE) 蚁群算法的优点和缺点 蚁群算法具有以下优点：\n  分布式计算：蚁群算法利用多只蚂蚁同时搜索问题空间，这些蚂蚁可以在不同的解空间中进行独立搜索。这种分布式计算方式有助于提高搜索效率，避免过早陷入局部最优解。\n  自适应性：蚁群算法能够根据问题特征和环境变化动态调整搜索策略。例如，信息素挥发和更新规则可以使算法在搜索过程中自动平衡全局探索和局部挖掘。\n  优秀的全局搜索能力：蚁群算法具有较强的全局搜索能力，可以在较大规模的问题空间中找到近似最优解。这是因为蚂蚁在搜索过程中不仅考虑局部信息，还会受到其他蚂蚁留下的信息素的影响，从而在一定程度上避免了局部最优解。\n  适用于离散和连续问题：蚁群算法可以处理离散和连续型问题。对于离散问题，蚂蚁可以在解空间中移动；对于连续问题，可以将问题离散化，或将蚂蚁移动到相邻解空间。\n  鲁棒性强：蚁群算法对问题的初始条件和参数设置具有较好的鲁棒性。即使初始解不理想或参数设置不合理，算法仍然有可能在搜索过程中找到较好的解。\n  易于实现：蚁群算法的实现相对简单，易于理解和实现。此外，由于其分布式计算特性，蚁群算法可以很容易地实现并行化，提高计算效率。\n  尽管蚁群算法具有以上优点，但其收敛速度较慢，容易陷入局部最优解。因此，在具体应用过程中，为了提高搜索效率，研究人员提出了许多改进方法，如：多蚁群系统、精英策略、ACS 算法等。\n蚁群算法的应用 蚁群算法具有广泛的应用，主要包括以下几个方面：\n  组合优化问题：蚁群算法可以有效地解决旅行商问题（TSP）、车辆路径问题（VRP）、背包问题等组合优化问题。通过构建解空间和设计合适的信息素更新规则，蚁群算法可以在这些问题中找到近似最优解。\n  调度与分配问题：蚁群算法可以用于解决作业车间调度问题、生产计划问题、任务分配问题等。这些调度与分配问题通常具有离散、复杂的特点，蚁群算法能够在较大的解空间中找到较优解。\n  图论与网络优化：蚁群算法在图论和网络优化问题中也有广泛应用，如最大割问题、最小生成树问题、最短路径问题等。通过设计合适的启发式信息，蚁群算法可以在这些问题中取得较好的结果。\n  机器学习与人工智能：蚁群算法在人工神经网络、聚类分析、模式识别等领域也有一定应用。通过模拟自然界蚂蚁的协作行为，蚁群算法可以为这些领域提供有效的优化方法。\n  机器人路径规划：蚁群算法可以应用于机器人的路径规划问题，如避障导航、目标搜索等。蚁群算法可以为机器人提供一种高效的搜索策略，使其在复杂环境中找到最优路径。\n  电力系统与能源管理：蚁群算法在电力系统调度、能源管理等领域也有应用，如机组组合问题、电力负荷调度问题等。通过求解这些问题，蚁群算法可以为电力系统提供更好的运行策略和能源管理方案。\n  金融与经济学：蚁群算法还可以应用于金融和经济学领域，如投资组合优化、风险管理、市场预测等。通过模拟自然界的协作行为，蚁群算法可以为这些问题提供有效的优化方法。\n  这些应用领域仅是蚁群算法众多应用之一，随着研究的深入，蚁群算法将继续拓展到更多的领域，为实际问题的求解提供新的思路和方法。\n粒子群算法 粒子群优化（Particle Swarm Optimization, PSO）是一种基于群体智能的全局优化算法，由Kennedy和Eberhart于1995年首次提出。PSO算法模拟了鸟群或者鱼群在寻找食物过程中的行为，通过群体中个体之间的协作来搜索最优解。它具有较强的全局搜索能力，在很多领域，如函数优化、机器学习、神经网络训练等，都得到了广泛应用。\n实现步骤 PSO算法的基本原理可以概括为以下几点：\n  初始化和计算适应度：在问题的搜索空间中，随机生成一群粒子（搜索代理），并为每个粒子随机分配一个初始位置和初始速度。确定当前位置的适应度。\n  速度更新：每个粒子根据自身的速度和历史最优位置（pBest）以及群体历史最优位置（gBest）来更新自己的速度和位置。速度更新的公式如下：\nv_i(t+1) = w * v_i(t) + c1 * r1 * (pBest_i - x_i(t)) + c2 * r2 * (gBest - x_i(t))\n其中，v_i(t)表示粒子i在时刻t的速度，x_i(t)表示粒子i在时刻t的位置，w表示惯性权重，c1和c2是加速因子，r1和r2是随机因子。\n  位置更新：根据更新后的速度，更新每个粒子的位置。位置更新的公式如下：\nx_i(t+1) = x_i(t) + v_i(t+1)\n  终止条件：当达到预定的迭代次数或满足其他终止条件时，算法停止运行。此时，算法输出的最优解即为问题的近似最优解。\n  一种受大雁飞行的启发式算法，\n以下元素构成了粒子的概念:\n位置一粒子在问题空间中的坐标，由所有维度构成的向量来描述\n最佳位置一利用适应度函数所能找到的最佳位置\n速度一粒子运动的当前速度\n初始化粒子群需要考虑的三个重要因素:\n粒子数量一一粒子数量将直接影响计算量。粒子越多，需要的计算量就越大。此外，更多的粒子可能意味着需要更长的时间才能收敛到全局最优解，因为更多的粒子可能被吸引到它们所在位置附近的局部最优解。问题的约束条件也会影响粒子数量的设置。更大的搜索空间可能需要更多的粒子来探索它。粒子数量可能多达 1000 个，也可能少至4个。通常来说，50~100 个粒子就可产生理想的解决方案,同时在计算上不会太耗时。\n每个粒子的起始位置\u0026ndash;每个粒子的起始位置应该是在各个维度上的随机位置。粒子必须在搜索空间中均匀分布。如果大多数粒子都分布在搜索空间的某个特定区域，它们将很难找到该区域之外的解决方案。\n每个粒子的初始速度一粒子的速度被初始化为 0，因为此时粒子尚未受到影响。这就好比鸟类从静止的位置起飞。\n开发人员通常用三个分量来计算每个粒子的新速度:惯性(imertia)、认知(cognitive)和社交(social)。\n惯性一一惯性分量代表特定粒子运动快慢或运动方向要发生变化时受到的阻力，这种阻力会对粒子的速度产生影响。惯性分量由两个值组成:惯性常数和粒子的当前速度。惯性常数是一个介于 0和 1之间的数字。接近0的惯性常数意味着算法更倾向于探索，可能需要更多次的选代。接近 1的惯性常数意味着在更少的迭代中对粒子进行更多的探索。\n惯性代表了原来的速度，惯性分量=惯性常数 *当前速度。\n认知一一认知分量代表特定粒子的自我认知能力。认知能力指的是粒子知道其最佳位置并利用这一位置影响其运动的能力。认知常数是一个大于 0小于 2 的浮点数。认知常数越大，粒子就越倾向于利用自身的信息。\n认知分量也可以计算处理，他代表了个体最佳位置。\n社交一一社交分量代表粒子与群体互动的能力。粒子知道群体的最佳位置，并能使用这一信息来影响其运动。社交加速度由一个常数和一个随机数决定。社交常数在算法的生命周期内保持不变，而随机社交因子会引入有利于社交因素的多样性。社交常数越大，算法就越倾向于探索，因为粒子的速度矢量会更偏向于它的社交分量。社交常数为介于 0和 2之间的某个浮点数。更大的社交常数意味着更多的探索。\n社交分量代表群体最佳位置。\n下面是一种用来理解位置更新的图，实际计算是是对那些分量进行标量相加即可。\n确定终止条件，当最佳解决方案停滞时，可以试着调节速度更新的各个参数\n代码实现 import math import random # The function that is being optimized. Namely the Booth function. # Reference: https://en.wikipedia.org/wiki/Test_functions_for_optimization def calculate_booth(x, y): return math.pow(x + 2 * y - 7, 2) + math.pow(2 * x + y - 5, 2) # Particle Swarm Optimization (PSO) # Representing the concept of a particle: # - Position: The position of the particle in all dimensions. # - Best position: The best position found using the fitness function. # - Velocity: The current velocity of the particle’s movement. class Particle: # Initialize a particle; including its position, inertia, cognitive constant, and social constant def __init__(self, x, y, inertia, cognitive_constant, social_constant): self.x = x self.y = y self.fitness = math.inf self.velocity = 0 self.best_x = x self.best_y = y self.best_fitness = math.inf self.inertia = inertia self.cognitive_constant = cognitive_constant self.social_constant = social_constant self.update_fitness() # Get the fitness of the particle def get_fitness(self): return self.fitness # Update the particle\u0026#39;s fitness based on the function we\u0026#39;re optimizing for def update_fitness(self): self.fitness = calculate_booth(self.x, self.y) if self.fitness \u0026lt; self.best_fitness: self.best_fitness = self.fitness self.best_x = self.x self.best_y = self.y # Calculate the inertia component for the particle # inertia * current velocity @staticmethod def calculate_inertia(inertia, current_velocity): return inertia * current_velocity # Calculate the cognitive component for the particle # cognitive acceleration * (particle best solution - current position) def calculate_cognitive(self, cognitive_constant, cognitive_random, particle_best_position_x, particle_best_position_y, particle_current_position_x, particle_current_position_y): cognitive_acceleration = self.calculate_acceleration(cognitive_constant, cognitive_random) cognitive_distance = math.sqrt(((particle_best_position_x-particle_current_position_x)**2) + ((particle_best_position_y-particle_current_position_y)**2)) return cognitive_acceleration * cognitive_distance # Calculate the social component for the particle # social acceleration * (swarm best position - current position) def calculate_social(self, social_constant, social_random, swarm_best_position_x, swarm_best_position_y, particle_current_position_x, particle_current_position_y): social_acceleration = self.calculate_acceleration(social_constant, social_random) social_distance = math.sqrt(((swarm_best_position_x-particle_current_position_x)**2) + ((swarm_best_position_y-particle_current_position_y)**2)) return social_acceleration * social_distance # Calculate acceleration for the particle @staticmethod def calculate_acceleration(constant, random_factor): return constant * random_factor # Calculate the new velocity for the particle @staticmethod def calculate_updated_velocity(inertia, cognitive, social): return inertia + cognitive + social # Calculate the new position for the particle @staticmethod def calculate_position(current_position_x, current_position_y, updated_velocity): return current_position_x + updated_velocity, current_position_y + updated_velocity # Perform the update on inertia component, cognitive component, social component, velocity, and position def update(self, swarm_best_x, swarm_best_y): i = self.calculate_inertia(self.inertia, self.velocity) print(\u0026#39;Inertia: \u0026#39;, i) c = self.calculate_cognitive(self.cognitive_constant, random.random(), self.x, self.y, self.best_x, self.best_y) print(\u0026#39;Cognitive: \u0026#39;, c) s = self.calculate_social(self.social_constant, random.random(), self.x, self.y, swarm_best_x, swarm_best_y) print(\u0026#39;Social: \u0026#39;, s) v = self.calculate_updated_velocity(i, c, s) self.velocity = v print(\u0026#39;Velocity: \u0026#39;, v) p = self.calculate_position(self.x, self.y, v) self.x = p[0] self.y = p[1] print(\u0026#39;Position: \u0026#39;, p) def to_string(self): print(\u0026#39;Inertia: \u0026#39;, self.inertia) print(\u0026#39;Velocity: \u0026#39;, self.velocity) print(\u0026#39;Position: \u0026#39;, self.x, \u0026#39;,\u0026#39;, self.y) # Ant Colony Optimization (ACO). # The general lifecycle of a particle swarm optimization algorithm is as follows: # - Initialize the population of particles: This involves determining the number of particles to be used and initialize # each particle to a random position in the search space. # - Calculate the fitness of each particle: Given the position of each particle, determine the fitness of that particle # at that position. # - Update the position of each particle: This involves repetitively updating the position of all the particles using # principles of swarm intelligence. Particles will explore then converge to good solutions. # - Determine stopping criteria: This involves determining when the particles stop updating and the algorithm stops. class Swarm: # Initialize a swarm of particles randomly def __init__(self, inertia, cognitive_constant, social_constant, random_swarm, number_of_particles, number_of_iterations): self.inertia = inertia self.cognitive_constant = cognitive_constant self.social_constant = social_constant self.number_of_iterations = number_of_iterations self.swarm = [] if random_swarm: self.swarm = self.get_random_swarm(number_of_particles) else: self.swarm = self.get_sample_swarm() # Return a static swarm of particles @staticmethod def get_sample_swarm(): p1 = Particle(7, 1, INERTIA, COGNITIVE_CONSTANT, SOCIAL_CONSTANT) p2 = Particle(-1, 9, INERTIA, COGNITIVE_CONSTANT, SOCIAL_CONSTANT) p3 = Particle(5, -1, INERTIA, COGNITIVE_CONSTANT, SOCIAL_CONSTANT) p4 = Particle(-2, -5, INERTIA, COGNITIVE_CONSTANT, SOCIAL_CONSTANT) particles = [p1, p2, p3, p4] return particles # Return a randomized swarm of particles @staticmethod def get_random_swarm(number_of_particles): particles = [] for p in range(number_of_particles): particles.append(Particle(random.randint(-10, 10), random.randint(-10, 10), INERTIA, COGNITIVE_CONSTANT, SOCIAL_CONSTANT)) return particles # Get the best particle in the swarm based on its fitness def get_best_in_swarm(self): best = math.inf best_particle = None for p in self.swarm: p.update_fitness() if p.fitness \u0026lt; best: best = p.fitness best_particle = p return best_particle # Run the PSO lifecycle for every particle in the swarm def run_pso(self): for t in range(0, self.number_of_iterations): best_particle = self.get_best_in_swarm() for p in self.swarm: p.update(best_particle.x, best_particle.y) print(\u0026#39;Best particle fitness: \u0026#39;, best_particle.fitness) # Set the hyper parameters for the PSO INERTIA = 0.4 COGNITIVE_CONSTANT = 0.3 SOCIAL_CONSTANT = 0.7 RANDOM_CHANCE = True NUMBER_OF_PARTICLES = 200 NUMBER_OF_ITERATIONS = 500 # Initialize and execute the PSO algorithm swarm = Swarm(INERTIA, COGNITIVE_CONSTANT, SOCIAL_CONSTANT, RANDOM_CHANCE, NUMBER_OF_PARTICLES, NUMBER_OF_ITERATIONS) swarm.run_pso() 应用 PSO算法的优点包括简单、易于实现、收敛速度快、鲁棒性强等。然而，它也存在一些局限性，如容易陷入局部最优解、参数选择对算法性能影响较大等。\n粒子群优化（PSO）算法具有较强的全局搜索能力，被广泛应用于各种领域。以下是一些常见的PSO算法应用：\n  函数优化：PSO算法可以应用于无约束或者约束优化问题，如求解复杂非线性函数的最小值。在这些问题中，PSO算法通常能够找到全局最优解或者近似最优解。\n  机器学习与数据挖掘：PSO算法在机器学习和数据挖掘领域具有广泛的应用，如分类、聚类、特征选择、关联规则挖掘等。在这些任务中，PSO算法通常用于优化模型的参数，以提高模型的性能。\n  神经网络训练：PSO算法可以用于神经网络的训练，包括前向神经网络、递归神经网络、自组织映射等。在这些问题中，PSO算法通常用于调整网络的权重和阈值，以最小化网络的误差。\n  调度与路径规划：PSO算法在调度和路径规划领域有很好的应用，如任务调度、车辆路径规划、TSP问题（旅行商问题）等。在这些问题中，PSO算法通常用于寻找最优的调度策略或路径。\n  控制器设计：PSO算法在控制器设计中也有应用，如PID控制器参数优化、模型预测控制（MPC）等。在这些问题中，PSO算法通常用于优化控制器的参数，以提高控制系统的性能。\n  电力系统优化：PSO算法在电力系统优化领域也有广泛应用，如电力系统调度、无功优化、负荷预测等。在这些问题中，PSO算法通常用于寻找最优的解决方案。\n  机械设计与优化：PSO算法在机械设计与优化领域也有应用，如结构优化、拓扑优化、形状优化等。在这些问题中，PSO算法通常用于优化结构的几何形状或材料分布，以提高结构的性能。\n  粒子群优化算法的一个有趣的应用是深度脑电刺激。这一应用的主要概念涉及一种治疗方式，即在人脑中安装带有电极的探针，刺激大脑以治疗帕金森氏症等疾病。每个探针都包含电极，可配置在不同的方向，以正确地治疗每个患者。明尼苏达大学的研究人员开发了一种粒子群优化算法来优化每个电极的方向，以最大限度地增强对有效区域的刺激，并减弱对回避区域的刺激，同时尽量减少所用的能量。因为粒子能在这一类多维问题空间中进行有效的搜索，所以粒子群优化算法非常适用于解决为探针上的电极寻找最佳配置这一类问题。\n这些只是PSO算法应用的一部分，实际上，PSO算法在许多其他领域也得到了广泛应用。\n优缺点 粒子群优化（PSO）算法是一种基于群体智能的全局优化算法。它具有一些显著的优点，但同时也存在一些局限性。以下是PSO算法的优缺点：\n优点：\n  简单易实现：PSO算法的原理和实现相对简单，易于理解和编程实现。\n  收敛速度快：PSO算法通常能在较少的迭代次数内找到满意的解，具有较快的收敛速度。\n  鲁棒性强：PSO算法对问题的初始解和参数选择具有较好的鲁棒性，能够在多种问题中找到较好的解。\n  全局搜索能力：PSO算法具有较强的全局搜索能力，能够有效地避免陷入局部最优解。\n  并行性：PSO算法天然具有并行性，能够利用多核处理器或分布式计算资源进行加速。\n  局限性：\n  容易陷入局部最优解：虽然PSO算法具有较强的全局搜索能力，但在某些情况下，尤其是在高维问题中，仍然有可能陷入局部最优解。\n  参数敏感：PSO算法的性能受到惯性权重、加速因子和随机因子等参数的影响，参数的选择对算法性能有很大影响。不同的问题可能需要不同的参数设置，这使得PSO算法的参数调整变得较为困难。\n  缺乏理论支持：虽然PSO算法在实践中表现出良好的性能，但其收敛性和最优解性质缺乏严格的理论支持。\n  ","permalink":"https://tassel234.github.io/posts/note/%E7%AE%97%E6%B3%95%E9%A2%84%E8%A7%88%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AF%87-2/","summary":"前言 使用资源： 人工智能算法图解 https://github.com/rishal-hurbans/Grokking-Artificial-Intelligence-Algorithms https://www.zhihu.com/people/MicrostrongAI/posts?page=2 chatgtp aim 知道算法可以解决什么问题 对一些重要的算法要知道每行代码代表代码，然后可以进行修改 lightgbm LightGBM（Light Gradient Boosting Machine）是一种基于梯度提升框架的高效机器学习算法，由微软亚洲研究院的研究员提出。LightGBM主要针对GBDT（Gra","title":"算法预览（数学建模篇-2）"},{"content":"前言 使用资源： 人工智能算法图解\nhttps://github.com/rishal-hurbans/Grokking-Artificial-Intelligence-Algorithms\nhttps://www.zhihu.com/people/MicrostrongAI/posts?page=2\nchatgtp\nhttps://zhuanlan.zhihu.com/p/399770354\nhttps://scikit-opt.github.io/scikit-opt/#/zh/\naim  知道算法可以解决什么问题 对一些重要的算法要知道每行代码代表代码，然后可以进行修改  智能算法预览 遗传算法：优点是能很好的处理约束，能很好的跳出局部最优，最终得到全局最优解，全局搜索能力强；缺点是收敛较慢，局部搜索能力较弱，运行时间长，且容易受参数的影响。\n遗传算法适合求解离散问题，具备数学理论支持，但是存在着汉明悬崖等问题。\n模拟退火：优点是局部搜索能力强，运行时间较短；缺点是全局搜索能力差，容易受参数的影响。\n爬山算法：显然爬山算法较简单，效率高，但是处理多约束大规模问题时力不从心，往往不能得到较好的解。\n粒子群算法适合求解实数问题，算法简单，计算方便，求解速度快，但是存在着陷入局部最优等问题。\n蚁群算法适合在图上搜索路径问题，计算开销会大。\n可以讲什么的某些算法进行混合，针对特定问题，融合其中的优势。比如将遗传算法中的变异算子加入粒子群中就可以形成基于变异的粒子群算法。\n遗传算法 背包问题介绍 背包问题是一类常见的组合优化问题，它在计算机科学、运筹学、经济学和工程学等领域具有广泛的应用。背包问题的主要目标是在给定的限制条件下，从一组可选物品中选择一些物品进行组合，使得总价值最大或总重量最小。这个问题最初是由瑞士数学家丹尼尔·卡内曼（Daniel Kahneman）在1970年代提出的。\n背包问题有多种变体，其中最基本的两种变体是：\n  0/1背包问题：在这个问题中，你有一个背包和一组物品。每个物品有两个属性：体积（w）和价值（v）。你需要在不超过背包总容量的前提下，选择一些物品放入背包，使得放入的物品的总价值最大。\n  完全背包问题：在这个问题中，每个物品都有无限个，且每个物品的价值和体积都是恒定的。你需要在不超过背包总容量的前提下，选择一些物品放入背包，使得放入的物品的总价值最大。\n  此外，还有其他变体，如多重背包问题、分组背包问题和黄金背包问题等。\n解决背包问题的一种常见算法是动态规划。动态规划是一种将复杂问题分解为更小、更简单的子问题的方法，并逐个求解这些子问题，从而得到原问题的解。动态规划可以高效地解决背包问题，并提供一种顺序访问的方式，避免了重复计算。\n可以使用遗传算法解决背包问题。\n基本步骤 遗传算法是一种启发式优化算法，它基于自然选择和遗传机制的概念进行优化搜索。遗传算法的灵感来源于自然界中生物进化的过程，通过模拟这个过程来寻找问题的最优解或近似最优解。遗传算法的基本思想是利用编码、选择、交叉和变异等操作，实现问题空间中的全局搜索。\n以下是遗传算法的基本步骤：\n  编码：首先需要将优化问题的解空间进行编码，通常使用二进制编码（如二进制编码法、遗传算子编码法等）。\n  初始种群：初始化一组解作为遗传算法的初始种群，每个解表示一个个体。\n  适应度函数：定义一个适应度函数，用于衡量个体的优劣。适应度函数通常与目标函数（如最小化问题）相关。\n  选择操作：根据适应度函数，将适应度较高的个体保留在下一代种群中，适应度较低的个体则被淘汰。\n  交叉操作：通过交叉操作，在下一代种群中产生新的个体。交叉操作是遗传算法中的核心操作，通过组合两个个体的部分染色体，生成新的染色体。\n  变异操作：对新产生的染色体进行变异操作，以引入随机性和多样性。变异操作可以改变染色体的某个或多个基因位的值，以增加算法的探索性。\n  迭代操作：重复执行选择、交叉和变异操作，直到满足终止条件。终止条件通常包括迭代次数上限、达到预定的适应度水平或其他优化目标。\n  输出结果：从遗传算法的最终种群中，选择适应度最高的个体作为最优解。\n  以背包问题举例，物品被选上记为一，没有就记为0，使用二进制编码构成染色体。\n根据适应度得分筛选亲本 ，可以使用轮盘法，即将适应度函数计算出来 的数值分配给轮盘 的面积，然后随机抽取亲本，适应度高的亲本 占总群样本中 的比例就大，此外还有几种筛选方法。排序筛选法：均分赛场； 联赛筛选法：分组对抗；精英筛选法：只选最好的。\n交叉操作一般采用均匀交叉，即从每个亲本继承多个部分，变异操作也是利用随机数进行。通过交叉变异构成下一代的总群，然后迭代操作。\n遗传算法的参数配置 在设计遗传算法并配置其参数时，需要作出几个对算法性能产生影响的决性能方面的关注点主要有两个:从精度的角度来看，算法应该致力于寻找当前题的最佳解决方案;从计算效率的角度来看，算法应该能被高效地执行。如果算法的计算成本比其他传统方法(如暴力搜索)更高，那就没必要选用遗传算法来解决当前问题。我们所采用的编码方法、适应度函数以及在算法中设定的其他参数，都会对算法的精度和效率产生影响。为了在寻求良好的解决方案的同时保证计算效率，我们需要考虑下列参数。\n染色体编码方法一一我们需要对染色体编码方法再三斟酌，以确保它适用于当前问题，并确保潜在的解决方案能获取全局最大值。编码方法是遗传算法成功的核心。\n种群规模一一种群规模是可被配置的另一个重要参数。种群规模越大.可选的解决方案就越多样化。然而，种群规模越大，每次迭代的计算量也越大。有时，过大的种群规模抵消了突变的需求，导致开始时种群多样性良好，但随着算法迭代，多样性逐渐消失。一个有效的方法是从某个较小的种群规模开始，并根据每代种群的表现逐步增大种群规模。\n种群初始化一一虽然种群中的个体是随机初始化的，但为了确保解决方案的有效性，也为了优化遗传算法的计算效率，必须在合适的约束条件下对个体进行初始化。\n后代数量一一每一代所需要繁衍的后代数量也是可配置的。在每一次繁殖后，种群中的一部分个体会消亡，以确保种群规模固定不变。更多的后代意味着更高的种群多样性,但是存在一种风险一一为了腾出空间来容纳新的后代，原本种群中好的解决方案可能会被扼杀。如果种群规模被设置为动态的，那么种群中的个体数量可能在每一次繁殖后发生变化，但是这种方法需要更多的参数来控制。\n亲本筛选方法一一用于选择亲本的筛选方法是可配置的。亲本筛选策略的定义必须基于问题的上下文和算法需要平衡的可探索性与可挖掘性。\n交叉方法一一交叉方法与使用的编码方法相关，但通过配置这一参数我们可将算法设计为鼓励或阻止种群多样性。无论如何设计交叉方法我们都需要保证后代个体能产生有效的解。\n突变率一一突变率是另一个可配置的参数，它会导致所繁衍的后代(或者说潜在解决方案)更加多样化。更高的突变率意味着更高的多样性，但是引入过高的多样性可能会使表现良好的个体恶化。突变率可随着时间的推移而变化，我们可使算法在早期引入更高的多样性，并在晚期逐渐减少多样性。这种设计也可描述为在开始时偏重于探索，在后期偏重于挖掘。\n突交方法一一突变方法类似于交叉方法，因为它也取决于所使用的编码方法。突变方法需要具备一个重要的属性一一突变后产生的新解决方案仍然是有效的;否则，我们需要为该个体分配一个极低的适应度分数\n世代筛选方法一一与亲本筛选方法非常相似，世代筛选方法需要选出能幸存到下一代的个体。如果选用了不合适的筛选方法，算法可能发生收敛过快、陷入停滞或过度探索等不利状况。\n停止条件一一算法的停止条件必须基于问题的上下文设计，并能保证所获取的结果有意义。计算复杂度和时间是停止条件的主要考虑因素。\n此外还有实值编码，用来处理有多个相同的物品，编码的数字代表个数。\n顺序编码用来处理序列 。\n树编码用来处理层次结构 。\n算法实现 import random # The indexes for data array # 0 = name, 1 = weight, 2 = value, 3 = fitness KNAPSACK_ITEM_NAME_INDEX = 0 KNAPSACK_ITEM_WEIGHT_INDEX = 1 KNAPSACK_ITEM_VALUE_INDEX = 2 # Small knapsack dataset # knapsack_items = [ # [\u0026#39;Pearls\u0026#39;, 3, 4], # [\u0026#39;Gold\u0026#39;, 7, 7], # [\u0026#39;Crown\u0026#39;, 4, 5], # [\u0026#39;Coin\u0026#39;, 1, 1], # [\u0026#39;Axe\u0026#39;, 5, 4], # [\u0026#39;Sword\u0026#39;, 4, 3], # [\u0026#39;Ring\u0026#39;, 2, 5], # [\u0026#39;Cup\u0026#39;, 3, 1], # ] # Large knapsack dataset knapsack_items = [ [\u0026#39;Axe\u0026#39;, 32252, 68674], [\u0026#39;Bronze coin\u0026#39;, 225790, 471010], [\u0026#39;Crown\u0026#39;, 468164, 944620], [\u0026#39;Diamond statue\u0026#39;, 489494, 962094], [\u0026#39;Emerald belt\u0026#39;, 35384, 78344], [\u0026#39;Fossil\u0026#39;, 265590, 579152], [\u0026#39;Gold coin\u0026#39;, 497911, 902698], [\u0026#39;Helmet\u0026#39;, 800493, 1686515], [\u0026#39;Ink\u0026#39;, 823576, 1688691], [\u0026#39;Jewel box\u0026#39;, 552202, 1056157], [\u0026#39;Knife\u0026#39;, 323618, 677562], [\u0026#39;Long sword\u0026#39;, 382846, 833132], [\u0026#39;Mask\u0026#39;, 44676, 99192], [\u0026#39;Necklace\u0026#39;, 169738, 376418], [\u0026#39;Opal badge\u0026#39;, 610876, 1253986], [\u0026#39;Pearls\u0026#39;, 854190, 1853562], [\u0026#39;Quiver\u0026#39;, 671123, 1320297], [\u0026#39;Ruby ring\u0026#39;, 698180, 1301637], [\u0026#39;Silver bracelet\u0026#39;, 446517, 859835], [\u0026#39;Timepiece\u0026#39;, 909620, 1677534], [\u0026#39;Uniform\u0026#39;, 904818, 1910501], [\u0026#39;Venom potion\u0026#39;, 730061, 1528646], [\u0026#39;Wool scarf\u0026#39;, 931932, 1827477], [\u0026#39;Cross bow\u0026#39;, 952360, 2068204], [\u0026#39;Yesteryear book\u0026#39;, 926023, 1746556], [\u0026#39;Zinc cup\u0026#39;, 978724, 2100851, 0] ] # The best knapsack score from the brute force approach BEST_LARGE_KNAPSACK_SCORE = 13692887 # Genetic algorithms are used to evaluate large search spaces for a good solution. It is important to note that a # genetic algorithm is not guaranteed to find the absolute best solution. It attempts to find the global best whilst # avoiding local best solutions. The general lifecycle of a genetic algorithm is as follows: # - Creation of a population: This involves creating a random population of potential solutions. # - Measuring fitness of individuals in the population: This involves determining how good a specific solution is. # This is accomplished by using a fitness function which scores solutions to determine how good they are. # - Selecting parents based on their fitness: This involves selecting a number of pairs of parents that will reproduce # offspring. # - Reproducing individuals from parents: This involves creating offspring from their respective parents by mixing # genetic information and applying slight mutations to the offspring. # - Populating the next generation: This involves selecting individuals and offspring from the population that will # survive to the next generation. # The indexes for an individual\u0026#39;s properties INDIVIDUAL_CHROMOSOME_INDEX = 0 INDIVIDUAL_FITNESS_INDEX = 1 INDIVIDUAL_PROBABILITY_INDEX = 2 # Generate an initial population of random individuals def generate_initial_population(population_size): population = [] for individual in range(0, population_size): individual = \u0026#39;\u0026#39;.join([random.choice(\u0026#39;01\u0026#39;) for n in range(26)]) population.append([individual, 0, 0]) return population # Calculate the fitness for each individual in the population given the maximum weight def calculate_population_fitness(population, maximum_weight): best_fitness = 0 for individual in population: individual_fitness = calculate_individual_fitness(individual[INDIVIDUAL_CHROMOSOME_INDEX], maximum_weight) individual[INDIVIDUAL_FITNESS_INDEX] = individual_fitness if individual_fitness \u0026gt; best_fitness: best_fitness = individual_fitness if individual_fitness == -1: population.remove(individual) return best_fitness # Calculate the fitness for an individual def calculate_individual_fitness(individual, maximum_weight): total_individual_weight = 0 total_individual_value = 0 for gene_index in range(len(individual)): gene_switch = individual[gene_index] if gene_switch == \u0026#39;1\u0026#39;: total_individual_weight += knapsack_items[gene_index][KNAPSACK_ITEM_WEIGHT_INDEX] total_individual_value += knapsack_items[gene_index][KNAPSACK_ITEM_VALUE_INDEX] if total_individual_weight \u0026gt; maximum_weight: return -1 return total_individual_value # Set the probabilities for selection for each individual in the population def set_probabilities(population): population_sum = sum(individual[INDIVIDUAL_FITNESS_INDEX] for individual in population) for individual in population: individual[INDIVIDUAL_PROBABILITY_INDEX] = individual[INDIVIDUAL_FITNESS_INDEX] / population_sum # Roulette wheel selection to select individuals in a population def roulette_wheel_selection(population, number_of_selections): set_probabilities(population) slices = [] total = 0 for r in range(0, len(population)): individual = population[r] slices.append([r, total, total + individual[INDIVIDUAL_PROBABILITY_INDEX]]) total += individual[INDIVIDUAL_PROBABILITY_INDEX] chosen_ones = [] for r in range(number_of_selections): spin = random.random() result = [s[0] for s in slices if s[1] \u0026lt; spin \u0026lt;= s[2]] chosen_ones.append(population[result[0]]) return chosen_ones # Reproduce children given two individuals using one point crossover def one_point_crossover(parent_a, parent_b, xover_point): children = [parent_a[:xover_point] + parent_b[xover_point:], parent_b[:xover_point] + parent_a[xover_point:]] return children # Reproduce children given two individuals using two point crossover def two_point_crossover(parent_a, parent_b, xover_point_1, xover_point_2): children = [parent_a[:xover_point_1] + parent_b[xover_point_1:xover_point_2] + parent_a[xover_point_2:], parent_b[:xover_point_1] + parent_a[xover_point_1:xover_point_2] + parent_b[xover_point_2:]] return children # Randomly mutate children def mutate_children(children, mutation_rate): for child in children: random_index = random.randint(0, mutation_rate) if child[INDIVIDUAL_CHROMOSOME_INDEX][random_index] == \u0026#39;1\u0026#39;: mutated_child = list(child[INDIVIDUAL_CHROMOSOME_INDEX]) mutated_child[random_index] = \u0026#39;0\u0026#39; child[INDIVIDUAL_CHROMOSOME_INDEX] = mutated_child else: mutated_child = list(child[INDIVIDUAL_CHROMOSOME_INDEX]) mutated_child[random_index] = \u0026#39;1\u0026#39; child[INDIVIDUAL_CHROMOSOME_INDEX] = mutated_child return children # Reproduce children given selected individuals def reproduce_children(chosen_selections): children = [] for parent_index in range(len(chosen_selections)//2 - 1): children = one_point_crossover(chosen_selections[parent_index], chosen_selections[parent_index + 1], CROSSOVER_POSITION_1) return children # Combine the existing population and newly reproduced children def merge_population_and_children(population, children): return population + children # Set the hyper parameters for the genetic algorithm NUMBER_OF_GENERATIONS = 1000 INITIAL_POPULATION_SIZE = 1000 KNAPSACK_WEIGHT_CAPACITY = 6404180 CROSSOVER_POSITION_1 = 13 CROSSOVER_POSITION_2 = 22 MUTATION_RATE = 10 NUMBER_OF_ITERATIONS = 5 # Run the genetic algorithm def run_ga(): best_global_fitness = 0 global_population = generate_initial_population(INITIAL_POPULATION_SIZE) for generation in range(NUMBER_OF_GENERATIONS): current_best_fitness = calculate_population_fitness(global_population, KNAPSACK_WEIGHT_CAPACITY) if current_best_fitness \u0026gt; best_global_fitness: best_global_fitness = current_best_fitness the_chosen = roulette_wheel_selection(global_population, 100) the_children = reproduce_children(the_chosen) the_children = mutate_children(the_children, MUTATION_RATE) global_population = merge_population_and_children(global_population, the_children) # print(global_population) print(\u0026#39;Best fitness: \u0026#39;, best_global_fitness) print(\u0026#39;Actual best: \u0026#39;, BEST_LARGE_KNAPSACK_SCORE) print(\u0026#39;Accuracy: \u0026#39;, best_global_fitness / BEST_LARGE_KNAPSACK_SCORE * 100) print(\u0026#39;Final population size: \u0026#39;, len(global_population)) # calculate_population_fitness(global_population, KNAPSACK_WEIGHT_CAPACITY) # the_chosen = roulette_wheel_selection(global_population, 100) # the_children = reproduce_children(the_chosen) # the_children = mutate_children(the_children) # global_population = merge_population_and_children(global_population, the_children) # global_population = roulette_wheel_selection(global_population, 100) # Run the genetic algorithm for a number of iterations for i in range(0, NUMBER_OF_ITERATIONS): run_ga() # print(calculate_individual_fitness(\u0026#39;01100100010110001110001001\u0026#39;, 6404180)) # print(calculate_individual_fitness(\u0026#39;00110101000100011010001000\u0026#39;, 6404180)) # print(calculate_individual_fitness(\u0026#39;11100100110110000100101101\u0026#39;, 6404180)) # print(calculate_individual_fitness(\u0026#39;00001000010010101101001001\u0026#39;, 6404180)) 也可以选择使用scikit-opt进行调用，可以自己写算子，也可以调用提供的算子。\nimport numpy as np from sko.GA import GA, GA_TSP demo_func = lambda x: x[0] ** 2 + (x[1] - 0.05) ** 2 + (x[2] - 0.5) ** 2 ga = GA(func=demo_func, n_dim=3, size_pop=100, max_iter=500, prob_mut=0.001, lb=[-1, -10, -5], ub=[2, 10, 2], precision=[1e-7, 1e-7, 1]) 算法的运行速度比较慢，大概几分钟才解完。\n优点和缺点 遗传算法具有以下优点：\n 能够处理连续和离散问题。 全局搜索能力强。 具有一定的自适应性。 具有较强的并行性和鲁棒性。  遗传算法的缺点： 尽管遗传算法具有很强的全局搜索能力和一定的自适应性，但在实际应用中，它也存在一些缺点和挑战：\n  初始种群的选择：遗传算法的性能在很大程度上取决于初始种群的质量。如果初始种群选择不当，可能导致算法陷入局部最优解，甚至无法收敛。为了解决这个问题，研究者们提出了多种方法，如自适应进化策略、启发式搜索等。\n  收敛速度：遗传算法的收敛速度可能较慢，尤其是在处理复杂问题时。为了加速收敛，可以采用其他优化方法（如梯度下降法、共轭梯度法等）作为辅助，或通过调整遗传算法的参数来提高收敛速度。\n  计算复杂性：遗传算法的计算复杂性随问题规模的增加而增加。在处理大规模问题时，遗传算法可能会面临较高的计算成本和较低的效率。\n  局部搜索能力：遗传算法在局部搜索方面的性能相对较弱，容易陷入局部最优解。为了提高局部搜索能力，可以使用遗传算子（如变异算子）或局部搜索策略。\n  噪声敏感性：遗传算法对初始种群的噪声敏感。在高噪声的初始种群中，算法容易陷入局部最优解，甚至无法收敛。为了减小噪声对算法性能的影响，可以尝试使用合适的初始种群策略、自适应遗传算子等方法。\n  参数调整：遗传算法的性能在很大程度上取决于参数的选择。为了获得最佳性能，需要对参数进行精细调整。然而，参数调整的难度较大，可能需要多次试验才能获得合适的参数设置。\n  应用领域限制：遗传算法的应用领域相对有限，主要适用于求解那些具有一定全局搜索能力和自适应性的问题。对于那些需要精确求解或具有很强局部搜索能力的问题，遗传算法可能不是最佳选择。\n  实际应用 在实际应用中，可以根据问题特点和计算资源选择适当的优化方法。遗传算法和其他优化方法的结合可以互补各自的优缺点，提高问题求解的效果。 遗传算法作为一种全局优化方法，已经成功地应用于许多领域的问题求解。以下是遗传算法的一些主要应用：\n  函数优化：遗传算法被广泛应用于求解函数的最小值或最大值问题，如函数f(x) = x^3 + 2x^2 + 3x - 5在区间[-2, 2]上的最小值。\n  组合优化问题：遗传算法在求解组合优化问题方面具有很好的性能，如旅行商问题（TSP）、背包问题、装箱问题等。\n  机器学习和数据挖掘：遗传算法在机器学习和数据挖掘中的特征选择、降维、模型选择等方面也有广泛应用。\n  化学和材料科学：遗传算法在化学反应优化、材料结构优化，分子结构仿真和设计等方面发挥重要作用。\n  控制系统：遗传算法被用于求解复杂的控制系统，如PID控制器参数优化、非线性控制系统设计等。\n  经济学：遗传算法在经济领域的供应链优化、成本最小化、投资组合选择等问题中发挥作用。\n  机器人学：遗传算法在机器人学中的路径规划、运动规划、操作臂控制等方面具有应用价值。\n  神经科学：遗传算法被用于研究神经网络的优化问题，以寻找最佳的突触权重和连接方式。\n  分布式计算和并行计算：遗传算法具有较好的并行性，可以与其他优化算法结合，实现分布式计算和并行优化。\n  密码破解\n  电路设计与优化是电气工程、电子工程、计算机科学等领域中的重要问题，如逻辑门电路、存储器、微处理器等。遗传算法在电路设计与优化方面的应用主要涉及以下方面：\n  电路综合：电路综合是将多个门电路、触发器和其他电子元件组合在一起，形成一个具有所需功能的电路。遗传算法可以帮助设计者找到具有最佳性能和面积（或功耗）的电路结构。\n  网络分析：网络分析是一种分析电子系统中信号传输特性的技术。遗传算法可以用于分析不同网络拓扑结构的性能，以找到最佳的网络拓扑。\n  逻辑优化：逻辑优化是通过调整门电路、触发器和其他逻辑元件的连接方式，以提高电路的性能。遗传算法可以用于自动寻找最优的逻辑优化方案。\n  多目标优化：电路设计与优化通常涉及到多个性能指标，如功耗、面积、速度等。遗传算法可以同时考虑这些指标，实现多目标优化。\n  遗传算法在电路设计与优化中的应用需要解决一些挑战，如有限的计算资源、设计空间的复杂性以及收敛速度等问题。因此，在实际应用中，通常需要与其他优化方法（如模拟退火、蚁群算法、粒子群优化等）结合使用，以提高求解性能。 需要注意的是，遗传算法在实际应用中需要根据具体问题进行参数调整和优化，以获得最优解。同时，为了处理大规模问题，常常需要使用并行计算或分布式计算技术。\n全局最优解和局部最优解 全局最优解和局部最优解是优化问题中的两个重要概念。\n  全局最优解（Global Optimality）：如果一个优化问题的解是全局最优的，那么它在所有可能的局部最优解中是最优的。也就是说，如果改变一个解的微小部分（例如，移动一个变量的小量），新的解仍然是最优的，并且在所有可能的移动中仍然是最优的。全局最优解通常是最优化问题的目标，因为它们保证找到了问题的最优解。\n  局部最优解（Local Optimality）：如果一个优化问题的解是局部最优的，那么它在当前的搜索空间内是最优的。也就是说，如果改变一个解的微小部分，新的解不一定仍然是最优的，而且在所有可能的移动中不一定仍然是最优的。局部最优解是优化问题中的一种常见解。\n  优化问题通常是寻找全局最优解，但实际上，局部最优解经常是首选。原因是：\n 计算复杂性：全局最优解可能需要在非常大的搜索空间中进行搜索，这在实际问题中可能是不可行的。相反，局部最优解通常更容易搜索，因为它们只需要在一个小的搜索区域中进行搜索。 实际影响：局部最优解可能对实际应用产生较大影响，而全局最优解的影响可能相对较小。  有许多算法，如梯度下降法、牛顿法、拟牛顿法等，都旨在找到优化问题的全局最优解。然而，实际上，这些算法往往在搜索的早期阶段就达到了一个局部最优解，而不是全局最优解。这就是所谓的\u0026quot;局部最优陷阱\u0026quot;问题。为了解决这个问题，有些算法，如模拟退火、遗传算法等，试图在搜索过程中跳出局部最优解，以寻找全局最优解。\n","permalink":"https://tassel234.github.io/posts/note/%E7%AE%97%E6%B3%95%E9%A2%84%E8%A7%88%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AF%87-1/","summary":"前言 使用资源： 人工智能算法图解 https://github.com/rishal-hurbans/Grokking-Artificial-Intelligence-Algorithms https://www.zhihu.com/people/MicrostrongAI/posts?page=2 chatgtp https://zhuanlan.zhihu.com/p/399770354 https://scikit-opt.github.io/scikit-opt/#/zh/ aim 知道算法可以解决什么问题 对一些重要的算法要知道每行代码代表代码，然后可以进行修改 智能算法预览 遗传算法：优点是能很好的处理约束，能很好的跳出局部最优，最终得到全局最优解，全局搜索能力强；缺点是收敛较慢，局部搜索能力较弱，运行时间长，且容易受","title":"算法预览（数学建模篇-1）"},{"content":"Python数学建模算法-6（评价和预测） 14.1 综合评价指标体系 综合评价（Comprehensive Evaluation，CE），也叫综合评价方法或多指标综合评价方法，是指使用比较系统的、规范的方法对于多个指标、多个单位同时进行评价的方法。它不只是一种方法，而是一个方法系统，是指对多指标进行综合的一系列有效方法的总称。综合评价方法在现实中应用范围很广。综合评价是针对研究的对象，建立一个进行测评的指标体系，利用一定的方法或模型，对搜集的资料进行分析，对被评价的事物作出定量化的总体判断。\n14.2 综合评价数据处理 首先应该进行数据的预处理，包括一致化处理（把极小型转化为极大型），无量纲化处理（向量归一化等方法），定性指标的定量化（把高，很高的描述转化为数字）。\nimport numpy as np import pandas as pd a = np.loadtxt(\u0026#39;data14_1_1.txt\u0026#39;) b = np.linalg.norm(a,axis=0) #逐列求2范数 m1 = a.max(axis=0) #逐列求最大值 m2 = a.min(axis=0) #逐列求最小值 R1 = a / b #全部列向量归一化处理 R2 = a / m1 #全部列向量比例变换 R3 = (a-m2) / (m1-m2) #全部列向量极差变换 R1[:,3] = 1 - a[:,3] / b[3] #第4列特殊处理 R2[:,3] = m2[3] / a[:,3] #第4列特殊处理 R3[:,3] = (m1[3]-a[:,3]) / (m1[3]-m2[3]) np.savetxt(\u0026#39;data14_1_2.txt\u0026#39;, R1, fmt=\u0026#39;%.4f\u0026#39;) f = pd.ExcelWriter(\u0026#39;data14_1_3.xlsx\u0026#39;) pd.DataFrame(R1).to_excel(f, index=None) #写入Excel文件方便做表 pd.DataFrame(R2).to_excel(f, \u0026#39;Sheet2\u0026#39;, index=None) pd.DataFrame(R3).to_excel(f, \u0026#39;Sheet3\u0026#39;, index=None); f.save() 14. 3 常用的综合评价数学模型 线型加权评价法，TOPSIS评价法，熵值法，秩和比法。层次分析、模糊评价、数据包络分析、灰色综合评价、多维标度法 。\n14.3.6 综合评价示例 import numpy as np from scipy.stats import rankdata a = np.loadtxt(\u0026#39;data14_1_2.txt\u0026#39;) bp = a.max(axis=0) #求正理想解 bm = a.min(axis=0) #求负理想解 d1 = np.linalg.norm(a-bp,axis=1) #求到正理想解的距离 d2 = np.linalg.norm(a-bm,axis=1) #求到负理想解的距离 f1 = d2 / (d1+d2); print(\u0026#39;TOPSIS评价值：\u0026#39;, f1) c = bp - a #计算参考序列与每个序列的差 m1 = c.max(); m2 = c.min() #计算最大差和最小差 r = 0.5 #分辨系数 xs = (m2+r*m1)/(c+r*m1) #计算灰色关联系数 f2 = xs.mean(axis=1) #求灰色关联度 print(\u0026#39;灰色关联度：\u0026#39;, np.round(f2,4)) n = a.shape[0]; s = a.sum(axis=0) #逐列求得 P = a / s #求特征比重矩阵 e = -(P*np.log(P)).sum(axis=0)/np.log(n) #计算熵值 g = 1- e; w = g / sum(g) #计算差异系数和权重系数 f3 = P @ w #计算各对象的评价值 print(\u0026#39;评价值：\u0026#39;, np.round(f3,4)) R = rankdata(a, axis=0) #逐列编秩 RSR = R.mean(axis=1) / n #计算秩和比 print(\u0026#39;秩和比：\u0026#39;, np.round(RSR,4)) 14.4 模糊数学方法 隶属函数（模糊分布），模糊贴合度。\nimport numpy as np a = np.loadtxt(\u0026#39;data14_4.txt\u0026#39;) f1 = lambda x: x/8800 f2 = lambda x: 1-x/8000 f3 = lambda x: (x\u0026lt;=5.5)+(8-x)/(8-5.5)*((x\u0026gt;5.5) \u0026amp; (x\u0026lt;8)) f4 = lambda x: 1-x/200 f5 = lambda x: (x-50)/(1500-50) R = [] for i in range(len(a)): s = \u0026#39;f\u0026#39;+str(i+1)+\u0026#39;(a[\u0026#39;+str(i)+\u0026#39;])\u0026#39;; R.append(eval(s)) R = np.array(R) w = np.array([0.25, 0.2, 0.2, 0.1, 0.25]) B = w @ R #计算综合评价值 print(\u0026#39;评价值：\u0026#39;, np.round(B,4)) 14.5 数据包络分析 适用于多输入多输出的复杂系统，应用数学规划模型计算比较决策单元之间的相对效率。计算投入产出比最大。\nimport numpy as np import cvxpy as cp d = np.loadtxt(\u0026#39;data14_5.txt\u0026#39;) a = d[:,:3]; b = d[:,3:] u = cp.Variable(3, pos=True); v = cp.Variable(2, pos=True) for j in range(10): con = [ a @ u \u0026gt;= b @ v, a[j] @ u ==1] obj = cp.Maximize(b[j]@v) prob = cp.Problem(obj, con) prob.solve() print(\u0026#39;第\u0026#39;,str(j+1),\u0026#39;个对象最优值：\u0026#39;,round(prob.value,4)) print(\u0026#39;最优解：\\n\u0026#39;, np.round(u.value,4),\u0026#39;\\n\u0026#39;, np.round(v.value,4)) 15.1 灰色预测模型 灰色预测模型是通过少量的、不完全的信息，建立数学模型做出预测的一种预测方法。是基于客观事物的过去和现在的发展规律，借助于科学的方法对未来的发展趋势和状况进行描述和分析，并形成科学的假设和判断。\n灰色预测是一种对含有不确定因素的系统进行预测的方法。灰色预测通过鉴别系统因素之间发展趋势的相异程度，即进行关联分析，并对原始数据进行生成处理来寻找系统变动的规律，生成有较强规律性的数据序列，然后建立相应的微分方程模型，从而预测事物未来发展趋势的状况。其用等时距观测到的反映预测对象特征的一系列数量值构造灰色预测模型，预测未来某一时刻的特征量，或达到某一特征量的时间。\n15.1.1 GM(1,1)预测模型 一阶微分方程和只含有一个变量的灰色模型。\n有两个检验方法，分别是相对误差检验和级比偏差值检验。\nimport numpy as np import sympy as sp x0 = np.array([71.1, 72.4, 72.4, 72.1, 71.4, 72.0, 71.6]) n = len(x0); lamda = x0[:-1]/x0[1:] #计算级比 b1 = [min(lamda), max(lamda)] #计算级比取值范围 b2 = [np.exp(-2/(n+1)), np.exp(2/(n+1))] #计算级比容许范围 x1 = np.cumsum(x0) #求累加序列 z = (x1[:-1]+x1[1:]) / 2 #求均值生成序列 B = np.vstack([-z, np.ones(n-1)]).T u = np.linalg.pinv(B) @ x0[1:] #最小二乘法拟合参数 sp.var(\u0026#39;t\u0026#39;); sp.var(\u0026#39;x\u0026#39;, cls=sp.Function) #定义符号变量和函数 eq = x(t).diff(t)+u[0]*x(t)-u[1] #定义符号微分方程 xt0 = sp.dsolve(eq, ics={x(0):x0[0]}) #求解符号微分方程 xt0 = xt0.args[1] #提取方程中的符号解 xt = sp.lambdify(t, xt0, \u0026#39;numpy\u0026#39;) #转换为匿名函数 t = np.arange(n+1); xh = xt(t) #求预测值 x0h = np.hstack([x0[0], np.diff(xh)]) #还原数据 x1993 = x0h[-1] #提取1993年的预测值 cha = x0 - x0h[:-1]; delta = abs(cha/x0) * 100 #计算相对误差 rho = abs(1 - (1-0.5*u[0])/(1+0.5*u[0])*lamda) print(cha) print(\u0026#39;1993年预测值：\u0026#39;, round(x1993,4)) [ 0. -0.00574144 0.16376344 0.0328715 -0.49841633 0.26990088 0.03782405] 1993年预测值： 71.3946\n上述的代码也代表了模型的建立过程：\n 级比检验 数据累加，构建数据矩阵好数据向量，计算求解 建立微分方程模型，求解预测值和模糊还原值 求相对误差检验  15.1.2 GM(2,1)、DGM和Verhulst模型 GM(2,1)和DGM 二阶微分方程，只含有一个变量的灰色模型。DGM和GM(2,1)的区别在于DGM没有自变量0阶微分的项。\nVerhulst 模 型 的 提 出 : 将 离 散 的 随 机 数 列 进 行 一 次 累 加 , 生 成 新 序 列 , 再 对 其 进 行 建 模 计 算 , 得 到 预 测 值 。 该 模 型 主 要 用 来饱和状态的过程, 即 S 型 过 程 , 常 用 于 人 口 预 测 , 生 物 生 长 , 繁 殖 预 测 及 产 品 经 济 寿 命 预 测 等 。\nimport numpy as np x0 = np.array([4.93, 2.33, 3.87, 4.35, 6.63, 7.15, 5.37, 6.39, 7.81, 8.35]) n = len(x0); x1 = np.cumsum(x0) #求累加序列 z = (x1[1:]+x1[:-1]) / 2 #求均值生成序列 B = np.vstack([-z, z**2]).T u = np.linalg.pinv(B) @ x0[1:] #最小二乘法拟合参数 print(\u0026#39;参数u：\u0026#39;, np.round(u,4)) #下面直接利用解的表达式写出对应的匿名函数 x = lambda t: u[0]*x0[0]/(u[1]*x0[0]+(u[0]-u[1]*x0[0])*np.exp(u[0]*t)) xh1 = x(np.arange(n)) #求预测值 xh0 = np.hstack([x0[0], np.diff(xh1)]) #还原数据 ea = x0 - xh0 #计算预测的残差 er = abs(ea)/x0*100 #计算相对误差 15.2 马尔科夫预测 系统未来下一刻的状态只和现在有关，而与过去无关。类似于编程的迭代递归。\n步骤是先写出第一次的概率分布，然后写出状态转移矩阵，然后求解。\nimport numpy as np P1 = np.mat([0.2, 0.4, 0.4]) P = np.mat([[0.8, 0.1, 0.1],[0.5, 0.1, 0.4],[0.5, 0.3, 0.2]]) P4 = P1 @ P ** 3 print(\u0026#39;P4:\u0026#39;, P4) 若转移矩阵是正则的，概率转移进行了比较大的次数，概率值会稳定下来。\n可以使用线性方程去解，也可以用特征值向量去解题。\nimport numpy as np import sympy as sp p = np.array([[0.8, 0.1, 0.1],[0.5, 0.1, 0.4],[0.5, 0.3, 0.2]]) a = np.vstack([p.T-np.eye(3), np.ones(3)]) #构造方程组系数矩阵 b = np.hstack([np.zeros(3),1]) #构造方程组常数项列 x = np.linalg.pinv(a) @ b #求线性方程组的数值解 print(\u0026#39;解为：\u0026#39;, np.round(x,4)) 15. 3 神经元网络 感知器 感知器是由 Rosenblatt于 1957年提出的它是最早的人工神经网络。单层感知器是一个具有一层神经元、采用闽值激活函数的前向网络,通过对网络权值的训练,可以使感知器对一组输入向量的响应达到0或1的目标输出,从而实现对输入向量的分类。学习方法是梯度下降法。\nfrom sklearn.linear_model import Perceptron import numpy as np x0=np.array([[-0.5,-0.5,0.3,0.0],[-0.5,0.5,-0.5,1.0]]).T y0=np.array([1,1,0,0]) md = Perceptron().fit(x0,y0) #构造并拟合模型 print(\u0026#39;模型系数和常数项分别为：\u0026#39;, md.coef_,\u0026#39;,\u0026#39;,md.intercept_) print(\u0026#39;模型精度：\u0026#39;,md.score(x0,y0)) #模型检验 print(\u0026#39;预测值为：\u0026#39;,md.predict([[-0.5,0.2]])) BP神经网络 P神经网络是一种按误差反向传播(简称误差反传)训练的多层前馈网络，其算法称为BP算法，它的基本思想是梯度下降法，利用梯度搜索技术，以期使网络的实际输出值和期望输出值的误差均方差为最小。\nBP网络是在输入层与输出层之间增加若干层(一层或多层)神经元，这些神经元称为隐单元，它们与外界没有直接的联系，但其状态的改变，则能影响输入与输出之间的关系，每一层可以有若干个节点。\n有下面几个缺点:\n①学习速度慢，即使是一个简单的问题，一般也需要几百次甚至上千次的学习才能收敛。\n②容易陷入局部极小值。\n③网络层数、神经元个数的选择没有相应的理论指导。\nfrom sklearn.neural_network import MLPRegressor import numpy as np import pylab as plt a = np.loadtxt(\u0026#39;data15_12.txt\u0026#39;) x0 = a[:,:3]; y0 = a[:,3] #提出训练样本数据 m1 = x0.max(axis=0); m2 = x0.min(axis=0) #计算逐列最大值和最小值 bx0 = 2*(x0-m2)/(m1-m2)-1 #数据标准化 #构造并拟合模型 md = MLPRegressor(solver=\u0026#39;lbfgs\u0026#39;,activation=\u0026#39;identity\u0026#39;, hidden_layer_sizes=10).fit(bx0, y0) x = np.array([[73.39,75.55],[3.9635,4.0975],[0.9880,1.0268]]).T bx = 2*(x-m2) / (m1-m2)-1 #数据标准化 yh = md.predict(bx); print(\u0026#39;预测值为：,\u0026#39;,np.round(yh,4)) yh0 = md.predict(bx0); delta = abs(yh0-y0)/y0*100 print(\u0026#39;已知数据预测的相对误差：\u0026#39;, np.round(delta,4)) t = np.arange(1990, 2010) plt.rc(\u0026#39;font\u0026#39;, size=15); plt.rc(\u0026#39;font\u0026#39;, family=\u0026#39;SimHei\u0026#39;) plt.plot(t, y0, \u0026#39;--o\u0026#39;, label=\u0026#39;原始数据\u0026#39;) plt.plot(t, yh0, \u0026#39;-*\u0026#39;, label=\u0026#39;预测数据\u0026#39;) plt.xticks(t, rotation=55); plt.legend(); plt.show() 每一次的运行结果都有所不同，比如接下的数据：\n预测值为： [54449.6151 56573.6823]\n","permalink":"https://tassel234.github.io/posts/note/python%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AE%97%E6%B3%95-6%E8%AF%84%E4%BB%B7%E5%92%8C%E9%A2%84%E6%B5%8B/","summary":"Python数学建模算法-6（评价和预测） 14.1 综合评价指标体系 综合评价（Comprehensive Evaluation，CE），也叫综合评价方法或多指标综合评价方法，是指使用比较系统的、规范的方法对于多个指标、多个单位同时进行评价的方法。它不只是一种方法，而是一个方法系统，是指对多","title":"Python数学建模算法-6（评价和预测）"},{"content":"6.1 图与网络的基础理论 图是描述于一组对象的结构，其中某些对象对在某种意义上是“相关的”。这些对象对应于称为顶点的数学抽象（也称为节点或点），并且每个相关的顶点对都称为边（也称为链接或线）。图论的主要表示方式是邻接矩阵或者邻接表。\n6.2 NetworkX简介 是Python的一个库，用来创建和辅助plot绘画一个图.\n而且可以将图以邻接矩阵或者邻接表的方式进行导出，并且可以方便的调用各种遍历算法。\nimport networkx as nx import pylab as plt G=nx.DiGraph() List=[(1,2),(1,3),(2,3),(3,2),(3,5),(4,2),(4,6), (5,2),(5,4),(6,5)] G.add_nodes_from(range(1,7)) #必须显式地对顶点赋值 G.add_edges_from(List) plt.rc(\u0026#39;font\u0026#39;,size=16) pos=nx.shell_layout(G) nx.draw(G,pos,with_labels=True, font_weight=\u0026#39;bold\u0026#39;, node_color=\u0026#39;y\u0026#39;) W = nx.to_numpy_array(G) #从图G导出邻接矩阵 print(W);plt.show() 6. 3 最短路算法 6.3.1 固定起点的最短路 一般使用迪杰斯特拉算法算法，示例如下：\nimport networkx as nx G = nx.DiGraph() List = [(1,2,6), (1,3,3), (1,4,1), (2,5,1), (3,2,2), (3,4,2), (4,6,10), (5,4,6), (5,6,4), (5,7,3), (5,8,6), (6,5,10), (6,7,2), (7,8,4), (9,5,2), (9,8,3)] G.add_nodes_from(range(1,10)) G.add_weighted_edges_from(List) path = nx.dijkstra_path(G, 1, 8, weight=\u0026#39;weight\u0026#39;) #求最短路径 d = nx.dijkstra_path_length(G, 1, 8, weight=\u0026#39;weight\u0026#39;) print(\u0026#39;最短路径为：\u0026#39;, path) print(\u0026#39;最小费用为：\u0026#39;, d) 输出结果：\n最短路径为： [1, 3, 2, 5, 8]\n最小费用为： 12\n6.3.2 所有点对之间最短路的Floyd算法 可以知道所有点的最小的距离，可以有效简化复杂的，多节点的问题。\nimport networkx as nx import numpy as np G = nx.Graph() List = [(1, 3, 10), (1, 4, 60), (2, 3, 5), (2, 4, 20), (3, 4, 1)] G.add_nodes_from(range(1,5)) G.add_weighted_edges_from(List) d = nx.floyd_warshall_numpy(G) print(\u0026#39;最短距离矩阵为：\\n\u0026#39;, d) path = nx.shortest_path(G, weight=\u0026#39;weight\u0026#39;, method=\u0026#39;bellman-ford\u0026#39;) for i in range(1,len(d)): for j in range(i+1, len(d)+1): print(\u0026#39;顶点{}到顶点{}的最短路径为：\u0026#39;.format(i,j), path[i][j]) 最短距离矩阵为：\n[[ 0. 15. 10. 11.]\n[15. 0. 5. 6.]\n[10. 5. 0. 1.]\n[11. 6. 1. 0.]]\n顶点1到顶点2的最短路径为： [1, 3, 2]\n顶点1到顶点3的最短路径为： [1, 3]\n顶点1到顶点4的最短路径为： [1, 3, 4]\n顶点2到顶点3的最短路径为： [2, 3]\n顶点2到顶点4的最短路径为： [2, 3, 4]\n顶点3到顶点4的最短路径为： [3, 4]\n对于最短路问题的，也可以采用0-1整数规划模型进行解决，但最短路径已经有了较为高效的算法，因此不做赘述。\n6.4 最小生成树 6.4.1 基本概念和算法 在图（包括赋权图）中，可以找到的路径长度之和最小的树。\n只要达到每一个地点就行，形成连通图。可以解决电缆安装问题等。普里姆算法，克鲁斯卡尔算法 都是较为高效的算法。\nT=nx.minimum_spanning_tree(G)\n可以直接采用这条语句进行求解。\nimport numpy as np import networkx as nx import pylab as plt L=[(0,1,2),(0,2,1),(0,3,3),(0,4,4),(0,5,4),(0,6,2),(0,7,5),(0,8,4), (1,2,4),(1,8,1),(2,3,1),(3,4,1),(4,5,5),(5,6,2),(6,7,3),(7,8,5)] G=nx.Graph() G.add_weighted_edges_from(L) T=nx.minimum_spanning_tree(G) #返回可迭代对象 c=nx.to_numpy_array(T) #返回最小生成树的邻接矩阵 print(\u0026#34;邻接矩阵c=\\n\u0026#34;,c) w=c.sum()/2 #求最小生成树的权重 print(\u0026#34;最小生成树的权重W=\u0026#34;,w) pos=nx.circular_layout(G) plt.subplot(121) #下面画连通图 nx.draw(G,pos,with_labels=True, font_size=13) w1=nx.get_edge_attributes(G, \u0026#39;weight\u0026#39;) nx.draw_networkx_edge_labels(G, pos, edge_labels=w1) plt.subplot(122) #下面画最小生成树 nx.draw(T, pos, with_labels=True, font_weight=\u0026#39;bold\u0026#39;) w2=nx.get_edge_attributes(T, \u0026#39;weight\u0026#39;) nx.draw_networkx_edge_labels(T, pos, edge_labels=w2) plt.show() 最小生成树的权重W= 13.0\n6.4.2 最小生成树的数学规划模型 为了防止形成子圈有第三四条限制。\nimport cvxpy as cp import numpy as np L=[(0,1,2),(0,2,1),(0,3,3),(0,4,4),(0,5,4),(0,6,2),(0,7,5),(0,8,4), (1,2,4),(1,8,1),(2,3,1),(3,4,1),(4,5,5),(5,6,2),(6,7,3),(7,8,5)] a=np.ones((9,9))*10000 for i in range(len(L)): a[L[i][0], L[i][1]]=L[i][2] a[L[i][1], L[i][0]]=L[i][2] x=cp.Variable((9,9), integer=True) u=cp.Variable(9, pos=True) obj=cp.Minimize(cp.sum(cp.multiply(a,x))) con=[cp.sum(x[0,:])\u0026gt;=1, u[0]==0, u[1:]\u0026gt;=1, u[1:]\u0026lt;=8, x\u0026gt;=0, x\u0026lt;=1] for i in range(1,9): con.append(sum(x[:,i])==1) for i in range(9): for j in range(1,9): con.append(u[i]-u[j]+9*x[i,j]\u0026lt;=8) prob = cp.Problem(obj, con) prob.solve() i, j = np.nonzero(x.value) print(\u0026#34;最优值为:\u0026#34;,prob.value) print(\u0026#34;最优解为：\\n\u0026#34;,x.value) print(\u0026#39;i=\u0026#39;, i); print(\u0026#39;j=\u0026#39;, j) 最优值为: 13.0\n6.5 着色问题 用来处理某些事物不能共存在一起的问题。和安排会议时间的问题。\n比如下面的例子中，有6个部门的会议，有一些相同的人参加，安排不同的最少的时间段，就是着色问题。\n三个要素分别是点，线，和需要最小的涂色。连上的线代表如果安排在同一时间，就会因为有相同的人而导致会议有人缺席。\nimport cvxpy as cp import networkx as nx import numpy as np L = [{\u0026#39;张\u0026#39;,\u0026#39;李\u0026#39;,\u0026#39;王\u0026#39;},{\u0026#39;李\u0026#39;,\u0026#39;赵\u0026#39;,\u0026#39;刘\u0026#39;},{\u0026#39;张\u0026#39;,\u0026#39;刘\u0026#39;,\u0026#39;王\u0026#39;}, {\u0026#39;赵\u0026#39;,\u0026#39;刘\u0026#39;,\u0026#39;孙\u0026#39;},{\u0026#39;张\u0026#39;,\u0026#39;王\u0026#39;,\u0026#39;孙\u0026#39;},{\u0026#39;李\u0026#39;,\u0026#39;刘\u0026#39;,\u0026#39;王\u0026#39;}] w = np.zeros((6,6)) for i in range(5): for j in range(i+1,6): if len(L[i] \u0026amp; L[j])\u0026gt;=1: w[i,j] = 1 #构造邻接矩阵的上三角元素 ni, nj = np.nonzero(w) #边的端点编号 w = w + w.T #构造完整的邻接矩阵 deg = w.sum(axis=1) #求各个顶点的度 K = int(max(deg)) #顶点的最大度 n = len(w) #顶点的个数 x = cp.Variable((n, K+1), integer=True) y = cp.Variable() #定义一个变量 obj = cp.Minimize(y) con = [cp.sum(x, axis=1)==1, x\u0026gt;=0, x\u0026lt;=1] for i in range(n): con.append(y\u0026gt;=range(1,K+2)@x[i,:]) for k in range(K+1): for i in range(len(ni)): con.append(x[ni[i],k]+x[nj[i],k]\u0026lt;=1) prob = cp.Problem(obj, con) prob.solve() i, k = np.nonzero(x.value) print(\u0026#34;最优值为:\u0026#34;,prob.value) print(\u0026#34;最优解为：\\n\u0026#34;,x.value) print(\u0026#39;顶点和颜色的对应关系如下：\u0026#39;) print(\u0026#39;i=\u0026#39;, i+1); print(\u0026#39;k=\u0026#39;, k+1) 最优值为: 4.0\n6.6 最大流与最小费用流问题 6.6.1 最大流问题 最大流问题是一种组合优化问题，讨论如何充分利用装置的能力，使得运输的流量最大以取得最好的效果的问题。有容量限制原则和流量守恒原则。\n#程序文件ex6_17.py import numpy as np import networkx as nx import pylab as plt L=[(1,2,6),(1,3,4),(1,4,5),(2,3,3),(2,5,9),(2,6,9), (3,4,5),(3,5,6),(3,6,7),(3,7,3),(4,3,2),(4,7,5), (5,8,12),(6,5,8),(6,8,10),(7,6,4),(7,8,15)] G=nx.DiGraph() G.add_nodes_from(range(1,9)) G.add_weighted_edges_from(L,weight=\u0026#39;capacity\u0026#39;) value, flow_dict= nx.maximum_flow(G, 1, 8) print(\u0026#34;最大流的流量为：\u0026#34;,value) print(\u0026#34;最大流为：\u0026#34;, flow_dict) n = len(flow_dict) adj_mat = np.zeros((n, n), dtype=int) for i, adj in flow_dict.items(): for j, weight in adj.items(): adj_mat[i-1,j-1] = weight print(\u0026#34;最大流的邻接矩阵为：\\n\u0026#34;,adj_mat) ni,nj=np.nonzero(adj_mat) #非零弧的两端点编号 plt.rc(\u0026#39;font\u0026#39;,size=16) pos=nx.shell_layout(G) #设置布局 w=nx.get_edge_attributes(G,\u0026#39;capacity\u0026#39;) nx.draw(G,pos,font_weight=\u0026#39;bold\u0026#39;,with_labels=True,node_color=\u0026#39;y\u0026#39;) nx.draw_networkx_edge_labels(G,pos,edge_labels=w) path_edges=list(zip(ni+1,nj+1)) nx.draw_networkx_edges(G,pos,edgelist=path_edges,edge_color=\u0026#39;r\u0026#39;,width=3) plt.show() 6.6.2 最小费用流问题 求解总运费最小的方案。流量等于最大流就是最小费用最大流问题。\n第一个赋权的数字是流量，第二个是单位运费。\nnx.max_flow_min_cost(G,\u0026lsquo;vs\u0026rsquo;,\u0026lsquo;vt\u0026rsquo;)\nnx.max_flow_min_cost(G,\u0026lsquo;vs\u0026rsquo;,\u0026lsquo;vt\u0026rsquo;)\n求解语句分别是上面的两个。\nimport numpy as np import networkx as nx L=[(\u0026#39;vs\u0026#39;,\u0026#39;v2\u0026#39;,5,3),(\u0026#39;vs\u0026#39;,\u0026#39;v3\u0026#39;,3,6),(\u0026#39;v2\u0026#39;,\u0026#39;v4\u0026#39;,2,8),(\u0026#39;v3\u0026#39;,\u0026#39;v2\u0026#39;,1,2),(\u0026#39;v3\u0026#39;,\u0026#39;v5\u0026#39;,4,2), (\u0026#39;v4\u0026#39;,\u0026#39;v3\u0026#39;,1,1),(\u0026#39;v4\u0026#39;,\u0026#39;v5\u0026#39;,3,4),(\u0026#39;v4\u0026#39;,\u0026#39;vt\u0026#39;,2,10),(\u0026#39;v5\u0026#39;,\u0026#39;vt\u0026#39;,5,2)] G=nx.DiGraph() for k in range(len(L)): G.add_edge(L[k][0], L[k][1], capacity=L[k][2], weight=L[k][3]) maxFlow=nx.max_flow_min_cost(G,\u0026#39;vs\u0026#39;,\u0026#39;vt\u0026#39;) print(\u0026#34;所求最大流为：\u0026#34;,maxFlow) mincost=nx.cost_of_flow(G, maxFlow) print(\u0026#34;最小费用为：\u0026#34;, mincost) node = list(G.nodes()) #导出顶点列表 n=len(node); flow_mat=np.zeros((n,n)) for i,adj in maxFlow.items(): for j,f in adj.items(): flow_mat[node.index(i),node.index(j)]=f print(\u0026#34;最大流的流量为：\u0026#34;, sum(flow_mat[:,-1])) print(\u0026#34;最小费用最大流的邻接矩阵为：\\n\u0026#34;,flow_mat) 6.7 关键路径 在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系。这样的有向图为顶点表示活动的网，我们称为AOV网（Activity On Vertex Network）。先做某些工作才可以做接下来的工作。\n一个AOV网应该是一个有向无环图，即不应该带有回路，因为若带有回路，则回路上的所有活动都无法进行。\nimport numpy as np import cvxpy as cp x = cp.Variable(8, pos=True) L = [(1,2,5), (1,3,10), (1,4,11), (2,5,4), (3,4,4), (3,5,0), (4,6,15), (5,6,21), (5,7,25), (5,8,35), (6,7,0), (6,8,20), (7,8,15)] obj = cp.Minimize(sum(x)); con = [] for k in range(len(L)): con.append(x[L[k][1]-1] \u0026gt;= x[L[k][0]-1] + L[k][2]) prob = cp.Problem(obj, con); prob.solve(solver = \u0026#39;SCIPY\u0026#39;) print(\u0026#39;最优值为\u0026#39;, prob.value); print(\u0026#39;最优解为：\u0026#39;, x.value) 最优值为 156.0\n最优解为： [ 0. 5. 10. 14. 10. 31. 35. 51.]\n最优解代表各个任务开始在第几天，最后一个数据就是最短工期。\n可以通过一些方法进行开工时间范围的求解。\n后记 W = nx.to_numpy_matrix(G) 报错\n应该修改为：\nW = nx.to_numpy_array(G) #从图G导出邻接矩阵\n推测为版本过低，导致的错误。\n安装cvx conda install cvxopt的安装速度即使使用conda也慢的让人发指。\nsolver=\u0026lsquo;GLPK_MI\u0026rsquo;没有，显示报错，可以去掉，或者改为solver=\u0026lsquo;SCIPY\u0026rsquo;\n报错的一些策略\n是可以求得解的，最终的目标结果相差不大，但组成目标结果的各个参数的值都有所不同。\nconda config \u0026ndash;add channels \u0026ldquo;http://conda.anaconda.org/gurobi\u0026quot;\n在添加默认安装渠道。\nconda info -e\n","permalink":"https://tassel234.github.io/posts/note/python%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AE%97%E6%B3%95-5%E5%9B%BE%E8%AE%BA/","summary":"6.1 图与网络的基础理论 图是描述于一组对象的结构，其中某些对象对在某种意义上是“相关的”。这些对象对应于称为顶点的数学抽象（也称为节点或点），并且每个相关的顶点对都称为边（也称为链接或线）。图论的主要表示方式是邻接矩阵或者邻接表。 6.2 NetworkX简介 是Python的一个库，用来创建","title":"Python数学建模算法-5（图论）"},{"content":"py数模（pca，聚类和判别） 前言 使用资源： https://blog.csdn.net/weixin_43584807/article/details/105539675\nhttps://blog.csdn.net/qq_46092061/article/details/119045393\nhttps://zhuanlan.zhihu.com/p/37777074\npython数学建模算法与应用（司守奎）\naim  知道编程可以做到什么 会看每一行代码在表达什么意思 知道生成数据或者表格的意义 提高建模水平，对各种应用问题进行归纳总结  聚类分析与判别分析 聚类分析 聚类分析的目标就是在相似的基础上收集数据来分类。聚类源于很多领域，包括数学，计算机科学，统计学，生物学和经济学。在不同的应用领域，很多聚类技术都得到了发展，这些技术方法被用作描述数据，衡量不同数据源间的相似性，以及把数据源分类到不同的簇中。\n聚类是将数据分类到不同的类或者簇这样的一个过程，所以同一个簇中的对象有很大的相似性，而不同簇间的对象有很大的相异性。\n从机器学习的角度讲，聚类是搜索簇的无监督学习过程。与分类不同，无监督学习不依赖预先定义的类或带类标记的训练实例，需要由聚类学习算法自动确定标记，而分类学习的实例或数据对象有类别标记。聚类是观察式学习，而不是示例式的学习。\n聚类分析是一种探索性的分析，在分类的过程中，人们不必事先给出一个分类的标准，聚类分析能够从样本数据出发，自动进行分类。聚类分析所使用方法的不同，常常会得到不同的结论。不同研究者对于同一组数据进行聚类分析，所得到的聚类数未必一致。\n从实际应用的角度看，聚类分析是数据挖掘的主要任务之一。而且聚类能够作为一个独立的工具获得数据的分布状况，观察每一簇数据的特征，集中对特定的聚簇集合作进一步地分析。聚类分析还可以作为其他算法（如分类和定性归纳算法）的预处理步骤。\n数据变换 拿到数据首先要消除量纲的影响，常用的处理方法为：\n 中心化处理（坐标轴平移） 规格化处理（最大值减去最小值做分母） 标准化处理（使用标准差）  样本（或指标）间亲疏程度的测度计算 在聚类分析中， 对于两个m维样本常用的距离度量有欧式距离、曼哈顿距离、切比雪夫距离和明可夫斯基距离等。\n欧式距离（Euclidean Distance）是计算欧式空间中两点之间的距离，是最容易理解的距离计算方法。\n曼哈顿距离（Manhattan Distance）也称城市街区距离，欧式距离表明了空间中两点间的直线距离，但是在城市中，两个地点之间的实际距离是要沿着道路行驶的距离，而不能计算直接穿过大楼的直线距离，曼哈顿距离就用于度量这样的实际行驶距离。\n切比雪夫距离（Chebyshev Distance）是向量空间中的一种度量，将空间坐标中两个点的距离定义为其各坐标数值差绝对值的最大值。切比雪夫距离在国际象棋棋盘中，表示国王从一个格子移动到此外一个格子所走的步数。\n明可夫斯基距离（Minkowski Distance）是欧式空间的一种测度，是一组距离的定义，被看作是欧式距离和曼哈顿距离的一种推广。\n基于类间距离的系统聚类 使用linkage,默认是使用最短距离的方法，使用欧几里得距离进行计算。\nimport numpy as np import scipy.cluster.hierarchy as sch import pylab as plt plt.rc(\u0026#39;text\u0026#39;, usetex=True); plt.rc(\u0026#39;font\u0026#39;, size=16) a=np.loadtxt(\u0026#39;data11_2.txt\u0026#39;); n=a.shape[0] b=(a-a.min(axis=0))/(a.max(axis=0)-a.min(axis=0)) z=sch.linkage(b) s=[\u0026#39;$\\\\omega_\u0026#39;+str(i+1)+\u0026#39;$\u0026#39; for i in range(n)] sch.dendrogram(z, labels=s); plt.show() 最长距离的方法和最短距离的步骤基本相似，但距离的定义不同以及计算新类与类的方法不同。 下面的例子是使用马氏距离进行计算的。\nimport numpy as np import scipy.cluster.hierarchy as sch import pylab as plt plt.rc(\u0026#39;text\u0026#39;,usetex=True) a=np.array([[2, 3, 3.5, 7, 9]]).T; n=len(a) c=sch.linkage(a, \u0026#39;complete\u0026#39;, \u0026#39;mahalanobis\u0026#39;) s=[\u0026#39;$\\\\omega_\u0026#39;+str(i+1)+\u0026#39;$\u0026#39; for i in range(n)] sch.dendrogram(c, labels=s); plt.show() n0=eval(input(\u0026#39;请输入聚类的类数n0:\\n\u0026#39;)) cluster= sch.fcluster(c, t=n0, criterion=\u0026#39;maxclust\u0026#39;) print(\u0026#39;聚类的结果为：\u0026#39;,cluster) 可以从图像看出是通过高度进行划分的。\n动态聚类法 k‐均值聚类是基于划分的聚类算法，计算样本点与类簇质心的距离，与类簇质心相近的样本点划分为同一类簇。k‐均值通过样本间的距离来衡量它们之间的相似度，两个样本距离越远，则相似度越低，否则相似度越高。属于一种动态聚类，可以降低内存占用以及运行时间。适用于大量的数据，可以用来简化数据处理的作用。\n#程序文件ex11_5.py import numpy as np from sklearn.cluster import KMeans a = np.array([[2,3,3.5,7,9]]).T md = KMeans(2).fit(a) #构造并求解模型 labels = md.labels_ #提取聚类标签 centers = md.cluster_centers_ #每一行是一个聚类中心 print(labels,\u0026#39;\\n-----------\\n\u0026#39;,centers) 最佳的簇数可以使用探索法，多改几次参数运行代码，然后人工选择。\n还可以采用程序编写的轮廓系数法或者拐点法。\nR型聚类法 研究变量之间的相似程度，按变量的相似程度聚合成多个类。\nimport pandas as pd import scipy.cluster.hierarchy as sch import pylab as plt import numpy as np a = pd.read_excel(\u0026#39;data11_8.xlsx\u0026#39;, header=None) b = a.values.T; b = np.triu(b, k=1) #取对角线上方元素 r = b[np.nonzero(b)]; d = 1 - abs(r) z = sch.linkage(d,\u0026#39;complete\u0026#39;) sch.dendrogram(z,labels=range(1,15)); plt.show() 判别分析 已经确定了分类的结果（比如病人和正常人），对这些分类的大量数据进行判别分析，然后对未知样本进行所属类别的判定。\n距离判别法 通过计算样本均值和协方差来获得马氏距离和判别函数，然后进行判别。inv\nimport numpy as np import sympy as sp from numpy.linalg import inv f = open(\u0026#39;data11_9.txt\u0026#39;); d = f.readlines() a = []; b = [] for i in range(2): a.extend(d[i].split()) a = np.array([eval(e) for e in a]).reshape(2,-1) mu1 = a.mean(axis=1, keepdims=True); s1 = np.cov(a, ddof=1) for i in range(2,4): b.extend(d[i].split()) b = np.array([eval(e) for e in b]).reshape(2,-1) mu2 = b.mean(axis=1, keepdims=True); s2 = np.cov(b, ddof=1) sp.var(\u0026#39;x1,x2\u0026#39;); X = sp.Matrix([x1, x2]) #X为列向量 d1 = (X-mu1).T@inv(s1)@(X-mu1) d1 = sp.expand(d1) d2 = (X-mu2).T@inv(s2)@(X-mu2) d2 = sp.expand(d2) W = sp.lambdify(\u0026#39;x1,x2\u0026#39;, d1-d2, \u0026#39;numpy\u0026#39;) sol = W(np.array([1.24,1.28,1.40]), np.array([1.80,1.84,2.04])) check1 = W(a[0], a[1]); check2 = W (b[0], b[1]) print(np.round(sol,4)) #输出3个判别函数值 Fisher判别 基本思想是投影。LDA\nimport numpy as np from numpy.linalg import inv from sklearn.discriminant_analysis import LinearDiscriminantAnalysis as LDA a = np.loadtxt(\u0026#39;data11_11.txt\u0026#39;) a1 = a[:5, :]; a2 = a[5:10, :]; x = a[10:, :] V = np.cov(a[:10, :].T, ddof=1) #计算协方差阵 VI = inv(V) #计算协方差阵的逆阵 mu1 = a1.mean(axis=0); mu2 = a2.mean(axis=0) k = VI @ (mu1-mu2) #判别函数系数向量 b = -(mu1+mu2) @ VI @ (mu1-mu2)/2 #判别函数常数项 val = x @ k + b #计算判别函数的值 print(\u0026#39;判别函数的值：\u0026#39;, val) d = {0:\u0026#39;B\u0026#39;, 1:\u0026#39;A\u0026#39;} print(\u0026#39;直接计算结果：\u0026#39;,[d[e\u0026gt;0] for e in val]) #输出判别结果 y0 = np.hstack([np.ones(5), np.zeros(5)]) md = LDA().fit(a[:10, :], y0) #直接使用库函数 k2 = md.coef_; b2 = md.intercept_ c = b2/b; check = k * c #验证直接计算和库函数调用等价 val2 = md.predict(x) print(\u0026#39;库函数结果： \u0026#39;,[d[e] for e in val2]) print(\u0026#39;k=\u0026#39;,k, \u0026#39;,b=\u0026#39;,b); print(\u0026#39;k2=\u0026#39;,k2, \u0026#39;,b2=\u0026#39;,b2); print(\u0026#39;比例c=\u0026#39;, c) print(\u0026#39;已知样本误判率为：\u0026#39;, 1-md.score(a[:10, :], y0)) 判别准则的评价 一种评价的估计方法是回代法，估计是有一些偏小的，便于计算。\n还有一种评价的方法是交叉法，较为真实。\n#程序文件ex11_12.py import pandas as pd from sklearn.discriminant_analysis import LinearDiscriminantAnalysis as LDA from sklearn.model_selection import cross_val_score a=pd.read_excel(\u0026#34;data11_10.xlsx\u0026#34;,header=None) b=a.values; x0=b[:-2,:-1].astype(float) y0=b[:-2,-1].astype(float) md = LDA(); print(cross_val_score(md, x0, y0,cv=2)) 主成分分析与因子分析 降维到底是什么，原来的变量和生成的是一样的吗。答案是否定的，他只是多个变量间系数不同的多种组合方式。\n提取成分和降维的区别。 降维和特征提取是机器学习和数据分析中常用的技术，它们之间有一定的区别，但也有很多相似之处。\n  目标： 降维的目标是将高维数据转化为低维数据，同时尽量保留原始数据的重要信息和结构。降维技术通常应用于可视化、压缩和加速计算等领域。 特征提取的目标是从原始数据中提取有意义的特征，以便更好地描述数据。特征提取技术通常应用于分类、回归和聚类等机器学习任务。\n  概念： 降维是一种数据预处理方法，旨在减少数据的复杂性，同时保留数据中的重要信息。降维技术主要包括线性降维（如主成分分析（PCA））和非线性降维（如局部线性嵌入（LLE）和t-分布邻域嵌入算法（t-SNE））。 特征提取是数据预处理的一种形式，旨在从原始数据中提取相关信息，以便更好地用于机器学习算法。特征提取方法包括从原始数据中提取特征，例如图像处理中的边缘检测、形状检测等。\n  数据类型： 降维通常应用于数值型数据，如多维数组和矩阵。降维技术可以将高维数据转换为低维数据，同时保留数据的重要信息。 特征提取通常应用于非数值型数据，如图像、文本和音频数据。特征提取技术可以从原始数据中提取有意义的特征，以便更好地描述数据。\n  总之，降维和特征提取都是数据预处理的重要方法。降维主要关注将高维数据转化为低维数据，以便更好地进行可视化、压缩和加速计算等操作。而特征提取关注从原始数据中提取有意义的特征，以便更好地应用于分类、回归和聚类等机器学习任务。\n降维的两种方式：\n特征选择 主成分分析（可以理解一种特征提取的方式）  主成分分析 主成分分析的基本原理和步骤 数学建模中的降维是指将高维数据转化为低维数据的过程。在这个过程中，数据从高维空间映射到低维空间，同时保留数据的重要信息。降维技术在数学建模中具有很多应用，包括数据可视化、特征选择、模型解释和数据压缩等。降维的主要目的是减少数据中的冗余信息，降低计算复杂度，提高模型的效率和准确性。同时，降维有助于我们更好地理解数据的结构和内在规律。\n在减少需要分析的指标同时，尽量减少原指标包含信息的损失，以达到对所收集数据进行全面分析的目的。由于各变量之间存在一定的相关关系，因此可以考虑将关系紧密的变量变成尽可能少的新变量，使这些新变量是两两不相关的，那么就可以用较少的综合指标分别代表存在于各个变量中的各类信息。主成分分析与因子分析就属于这类降维算法。\n在实际应用中，选择哪种降维方法取决于数据本身的特性、任务需求和模型性能。通过对数据进行有效的降维处理，可以提高模型的解释性、预测准确性和计算效率。\n主成分分析的应用 pca函数的系数分析 （1）在第一主成分的表达式中,可以看出第一、二四五六七项的系数比较大,这6项指标对城镇居民消费水平的影响较大,其中食品消费和医疗保健消费系数比另外几项都大,说明居民现在很注重吃和健康两方面。\n(2)在第二主成分的表达式中 只有第八项的系数比较大,远远超过其他指标的系数,因此可以单独看作是杂项商品与服务的影响,说明杂项商品与服务在消费水平中也据了很大的比例。\n主成分回归分析\n为了减少最小二乘法估计在数据矩阵存在多重共线性而出现的不稳定性提出来的。\n就是把回归的变量改为主成分。\nimport numpy as np from sklearn.decomposition import PCA import statsmodels.api as sm a=np.loadtxt(\u0026#39;data12_2.txt\u0026#39;) mu=a.mean(axis=0) #逐列求均值 s=a.std(axis=0,ddof=1) #逐列求标准差 b=(a-mu)/s #数据标准化 r=np.corrcoef(b[:,:-1].T) #计算相关系数矩阵 md1=PCA().fit(b[:,:-1]) #构造并拟合模型 print(\u0026#39;特征值为：\u0026#39;, md1.explained_variance_) print(\u0026#39;各主成分贡献率：\u0026#39;, md1.explained_variance_ratio_) xs=md1.components_ #提出各主成分系数，每行是一个主成分 print(\u0026#39;主成分系数：\\n\u0026#39;, np.round(xs,4)) print(\u0026#39;累积贡献率：\u0026#39;, np.cumsum(md1.explained_variance_ratio_)) n=3 #选定主成分的个数 f=b[:,:-1]@(xs[:n,:].T) #主成分的得分 d2={\u0026#39;y\u0026#39;:a[:,-1],\u0026#39;x\u0026#39;: a[:,:-1]} md2=sm.formula.ols(\u0026#39;y~x\u0026#39;,d2).fit() #原始数据线性回归 d3={\u0026#39;y\u0026#39;:a[:,-1], \u0026#39;z\u0026#39;:f} md3=sm.formula.ols(\u0026#39;y~z\u0026#39;,d3).fit() #对主成分的回归方程 xs3=md3.params #提取主成分回归方程的系数 xs40=xs3[0]-sum(xs3[1:]@xs[:n,:]*mu[:-1]/s[:-1]) #常数项 xs4=xs3[1:]@xs[:n,:]/s[:-1] #原始变量回归方程的其他系数 print(\u0026#39;回归方程的常数项：\u0026#39;,round(xs40,4)) print(\u0026#39;回归方程的其他系数：\u0026#39;,np.round(xs4,4)) print(\u0026#39;直接回归的残差方差：\u0026#39;,md2.mse_resid) print(\u0026#39;主成分回归的残差方差：\u0026#39;,md3.mse_resid) 核主成分分析\n即KPCA。PCA可以出来线型相关的问题，但没有考虑那些非线性相关的关系，KPCA就是用来解决这个问题的，还可以提供更多的特征信息。\n因子分析 因子分析的数学理论 因子分析是把原始变量分解为若干个因子的线型组合。\n 因子分析模型 因子旋转 因子得分  import numpy as np r=np.array([[1, 1/5, -1/5],[1/5, 1, -2/5],[-1/5, -2/5, 1]]) val,vec=np.linalg.eig(r) #求相关系数阵的特征值和特征向量 A0=vec*np.sqrt(val) #利用广播运算求载荷矩阵 print(\u0026#39;特征值:\u0026#39;,val,\u0026#39;\\n载荷矩阵：\\n\u0026#39;,A0,\u0026#39;\\n----------\u0026#39;) num=int(input(\u0026#34;请输入选择公共因子的个数：\u0026#34;)) A=A0[:,:num] #提出num个因子的载荷矩阵 Ac=np.sum(A**2, axis=0) #逐列元素求和，求信息贡献 Ar=np.sum(A**2, axis=1) #逐行元素求和，求共同度 print(\u0026#34;对x的贡献为：\u0026#34;,Ac) print(\u0026#34;共同度为：\u0026#34;,Ar) u是期望向量，A因子载荷矩阵，艾布西隆是特殊因子向量。\n公共因子的贡献率不同，可以提取较强的公共因子，其他都归为特殊因子艾布西隆。\n不同变量之间有较强的相关性，这些也有一个或者多个公共因子在驱动。\n","permalink":"https://tassel234.github.io/posts/note/python%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AE%97%E6%B3%95-4pca%E5%92%8C%E8%81%9A%E7%B1%BB%E4%B8%8E%E5%88%A4%E5%88%AB/","summary":"py数模（pca，聚类和判别） 前言 使用资源： https://blog.csdn.net/weixin_43584807/article/details/105539675 https://blog.csdn.net/qq_46092061/article/details/119045393 https://zhuanlan.zhihu.com/p/37777074 python数学建模算法与应用（司守奎） aim 知道编程可以做到什么 会看每一行代码在表达什么意思 知道生成数据或者表格的意义 提高建模水平，对各种应用问题进行归纳总结 聚类分析与判别分析 聚类分析 聚类分析的目标就是在相似的基础上收集数据来分类。","title":"Python数学建模算法-4（pca和聚类与判别）"},{"content":"使用资源 （主）目前爬虫真正的应用\n（主）爬虫实例视频\n基础知识 爬虫大概可以分为网页爬虫（也就是搜索引擎）和精确爬虫（爬取单个页面的数据，比如建模使用的机场数据）。\nRobots协议 (也称为爬虫协议、机器人协议等) 的全称是\u0026quot;网络爬虫排除标准”，robots.txt是报索引警访问网站时第一个查看的文件，当我们网站有部分内容希望收提索警抓取时，就可以通过Robots协议来告诉提索察哪些页面是不能抓取的，大多用来保护网站的隐私，以及一些死链、重复页面等等。是君子协议，遵守与否全看你的品行和判刑。\nhttps://www.zhihu.com\nhttps://www.zhihu.com/robots.txt\n为了不进橘子要注意的：不要侵犯个人信息，不要恶意破坏计算机系统，政府网站尽量爬的慢一点。\n爬虫的本质所见即所得，如果你没有b站vip就爬爬不了vip视频，如果真的想爬就学习渗透，不过更容易进橘子。\n如何使用爬虫 第一步:请求信息 网页的一些快捷键：F6选择网页地址。F11当前页面全屏。F12检查（爬虫用的多，还可以鼠标右键进行选择）。control+u显示源代码。control+f可以进行查找。\nget请求直接传过去网址，但有的网站只提供了一个框架，点击内容网站并不跳转，这个时候需要抓包。这种情况一般使用post，有一些情况要自己去查看。\n请求头header，也作为输入的参数之一。还有一些网站的请求头被加密了，如果要使用还要破解，不过这种情况一般比较少。\nparams字典可以让网址的书写更加优雅。\n第二步:提取数据 .json。json的一个字典，提取数据，可以进行遍历。\n.content。保存一些视频图片的二进制等。\n第三步:保存数据 导入csv库，进行csv保存，一般通过记事本看，excel也可以打开。\n注意utf-8,gbk等编码格式。\nopen的Python语法打开和书写文件。\nwith open可以自动关掉。\n反爬之一: 需要登录 .session\n复制加密的cookie\n手搓一个爬虫 tqdm是引入进度条的一个库。 headers的内容直接在检查，网络里面找，搜索pek找到。虽然账号和密码加密了，但是可以直接复制然后使用。\n数据在json库中。\nimport csv from concurrent import futures import requests import pandas as pd import time import tqdm import random def get_data(start_time, end_time, air=\u0026#34;CTU\u0026#34;): url_get_data = \u0026#34;https://data-api.133.cn/api/v1/airport/statistics\u0026#34; params = { \u0026#34;airport\u0026#34;: air, \u0026#34;route_type\u0026#34;: \u0026#34;all\u0026#34;, \u0026#34;start_time\u0026#34;: start_time, \u0026#34;end_time\u0026#34;: end_time } headers = { \u0026#34;Authorization\u0026#34;: \u0026#34;复制自己的\u0026#34;, \u0026#34;Origin\u0026#34;: \u0026#34;https://dast.133.cn\u0026#34;, \u0026#34;Referer\u0026#34;: \u0026#34;https://dast.133.cn/\u0026#34;, \u0026#34;user-agent\u0026#34;: \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36\u0026#34;, \u0026#34;client-id\u0026#34;: \u0026#34;复制自己的\u0026#34;,# 后面要有逗号 \u0026#34;Content-Type\u0026#34;: \u0026#34;application/x-www-form-urlencoded\u0026#34;, \u0026#34;sec-ch-ua-mobile\u0026#34;: \u0026#34;?0\u0026#34;, \u0026#34;sec-ch-ua-platform\u0026#34;: \u0026#34;Windows\u0026#34;, \u0026#34;Sec-Fetch-Dest\u0026#34;: \u0026#34;empty\u0026#34;, \u0026#34;Sec-Fetch-Mode\u0026#34;: \u0026#34;cors\u0026#34;, \u0026#34;Sec-Fetch-Site\u0026#34;: \u0026#34;same-site\u0026#34; } resp = requests.get(url=url_get_data, params=params, headers=headers) resp_json = resp.json() print(resp_json ) arr_plan = resp_json[\u0026#34;data\u0026#34;][\u0026#34;fluctuation\u0026#34;][\u0026#34;arr_plan\u0026#34;] # 计划进港 arr_real = resp_json[\u0026#34;data\u0026#34;][\u0026#34;fluctuation\u0026#34;][\u0026#34;arr_real\u0026#34;] # 实际进港 dep_plan = resp_json[\u0026#34;data\u0026#34;][\u0026#34;fluctuation\u0026#34;][\u0026#34;dep_plan\u0026#34;] # 计划出港 dep_real = resp_json[\u0026#34;data\u0026#34;][\u0026#34;fluctuation\u0026#34;][\u0026#34;dep_real\u0026#34;] # 实际出港 data_list = arr_plan + arr_real + dep_plan + dep_real return data_list def main(da): data = get_data(start_time=da, end_time=da) dataWriter.writerow([da] + data) if __name__ == \u0026#39;__main__\u0026#39;: with open(\u0026#34;CTU_data_twoYears.csv\u0026#34;, mode=\u0026#34;a\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;, newline=\u0026#34;\u0026#34;) as f: dataWriter = csv.writer(f) for date in tqdm.tqdm(pd.date_range(\u0026#34;2020-06-25\u0026#34;, \u0026#34;2022-07-27\u0026#34;)): date_str = str(date.date()) main(date_str) time.sleep(random.random() + 2) # 一定要 2 秒以上，不然大概率封号一阵子 最后爬取到的数据：\n2020-07-16,21,21,19,17,1,1,0,0,0,2,1,1,0,0,1,1,0,6,2,10,14,20,13,11,13,18,19,14,13,15,14,15,15,10,19,12,13,16,13,15,18,17,20,11,22,15,21,24,15,18,13,11,3,0,0,1,2,0,0,0,0,0,1,0,2,6,6,8,11,13,11,12,10,16,16,12,12,14,13,12,12,13,10,12,15,13,13,12,13,14,13,17,15,13,14,12,0,0,0,1,1,0,1,0,0,0,0,5,18,27,23,23,25,20,20,14,14,11,18,18,15,10,14,14,17,15,14,16,14,14,15,13,19,15,17,10,17,10,12,10,7,9,3,3,2,1,1,0,0,1,0,0,0,0,0,1,11,23,22,18,18,17,15,8,10,15,15,15,13,6,11,15,16,11,13,13,14,15,12,15,12,13,17,14,14,10,9,10,8,6,9,1\n2020-07-17,18,18,19,18,1,1,0,0,0,1,1,1,1,0,1,2,1,6,2,10,18,14,15,10,13,19,18,18,15,16,14,17,14,18,15,14,15,15,14,17,20,14,18,11,23,15,25,24,14,14,14,13,7,9,8,0,2,1,0,0,0,0,1,0,1,6,9,11,14,12,12,7,10,16,14,13,13,12,12,12,14,11,11,16,13,11,8,14,16,13,13,16,19,16,17,16,0,0,2,2,2,0,1,0,0,0,0,4,18,23,24,24,29,20,26,18,13,13,19,18,15,9,14,17,15,16,16,12,18,15,15,11,15,17,18,12,14,16,12,11,9,7,3,2,1,2,1,0,1,0,0,1,0,0,0,0,11,16,21,13,19,19,17,14,12,16,13,10,10,13,10,8,14,14,14,15,15,15,15,12,12,14,15,10,12,11,12,8,6,7,7,5\n2020-07-18,23,21,17,19,0,1,0,0,1,0,2,0,1,0,1,2,0,6,2,11,15,18,14,12,13,18,20,16,12,12,17,15,17,15,17,10,14,15,15,15,19,18,17,11,21,15,19,22,13,16,19,8,2,2,3,0,1,0,0,0,0,0,1,1,4,3,7,9,13,8,11,8,11,15,14,11,13,11,12,12,12,10,8,7,13,11,13,15,15,15,15,17,19,17,13,12,0,0,2,4,0,0,1,0,0,0,1,3,19,28,22,25,22,22,24,16,13,12,16,19,15,10,14,15,17,18,15,17,13,13,16,14,18,16,17,11,15,11,12,9,7,9,3,2,0,2,1,1,0,0,0,0,0,0,0,1,11,19,15,13,17,20,18,15,14,15,16,14,15,13,10,9,3,11,14,12,11,5,15,15,15,14,15,14,7,12,9,11,7,5,5,6\n2020-07-19,21,18,20,19,0,1,0,0,1,0,1,0,2,0,1,3,0,7,2,12,17,17,12,12,14,17,19,15,16,13,16,13,14,16,17,12,15,14,13,18,22,12,17,9,26,14,24,24,15,15,10,13,10,9,2,2,0,0,1,1,0,0,2,1,3,4,10,10,15,12,11,10,9,11,15,16,12,14,12,12,13,9,9,6,14,14,16,16,15,9,15,15,17,12,14,17,0,0,0,2,1,0,1,0,0,0,0,3,17,24,24,24,27,19,24,16,15,13,17,20,15,10,14,18,14,14,16,12,16,17,15,11,16,19,15,12,14,15,13,11,8,7,6,2,2,4,1,2,2,2,1,1,0,0,0,1,11,21,18,16,19,18,18,17,14,12,11,10,12,14,12,13,11,10,16,15,14,13,14,13,9,15,13,8,12,11,13,14,5,11,6,3\n上面是爬下来的一些数据，像这样的还有700多行，保存的是csv文件，使用逗号分隔，通过空白页面寻找逗号的个数，可以知道数字的数量。\n191个逗号，192=48*4个数据。\n# tasks = [] # with futures.ThreadPoolExecutor(20) as t: # for date in pd.date_range(\u0026#34;2020-01-01\u0026#34;, \u0026#34;2022-07-27\u0026#34;): # tasks.append(t.submit(main, date)) # print(\u0026#34;爬\u0026#34;) # for task in tqdm.tqdm(futures.as_completed(tasks), total=len(tasks)): # task.result() 这一位是多线程爬虫，是20个爬虫一起爬的存在，很容易封号，因为这二十个爬虫都是使用同一个账号，\n可以买账号，但还是有可能被封，因为20个爬虫公用一个ip地址了，这个时候应该买代理（IP地址）。\n后续学习可以参考的资源 爬虫实例视频\ngithub上的教学，比较全面learn_python3_spider\n爬虫视频2\n各种软件应用的爬虫\n书籍：爬虫实战案例 python让工作自动化 不能使用书籍的代码爬虫写博客，直接使用github的代码。\n在应用更多造好的爬虫之前应该首先学会伪装技术，\n目前阶段只爬取一些人畜无害的东西，学会基础的数据抓取和导入excel表格，比如机场数据。\nsulenium 模拟人工。\nuu模拟器，安卓6，爬取头条等。\n正则表达式，较为万能。\n","permalink":"https://tassel234.github.io/posts/note/%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8-1/","summary":"使用资源 （主）目前爬虫真正的应用 （主）爬虫实例视频 基础知识 爬虫大概可以分为网页爬虫（也就是搜索引擎）和精确爬虫（爬取单个页面的数据，比如建模使用的机场数据）。 Robots协议 (也称为爬虫协议、机器人协议等) 的全称是\u0026quot;网络爬虫排除标准”，robots.txt是报索引警访问","title":"爬虫入门-1"},{"content":"本书是社会派推理小说，主要探讨了死刑制度和普通刑法附带的社会惩罚，以及人性善恶。\n作者高野和明，也是人类灭绝这本书的作者。\n杀人的动机，为了正当防卫而杀人，以及罪犯的改过自新可能性都是这本书的讨论范围。\n一对老夫妇惨遭杀害。一切证据都指向树原亮，他却因车祸，恰好丧失了案发前后数小时的记忆。于是死刑执行官南乡携手刚假释出狱的纯一调查，希望替这位丧失记忆的死刑犯洗清冤屈。但他们查到的线索，只有树原亮记得自己曾“走在台阶上”。距离树原亮被执行死刑的时间所剩无几，但这起案件始终疑云重重，仅有的线索“台阶”仿佛也凭空消失了。\n通过读这本书我知道了日本的死刑制度怎么执行的。十三级台阶是什么。以及执行死刑的人似乎也会被罪恶感所折磨。这是让我想起来之前的一个小故事。在二战时，美国士兵开枪常常因为对方是人而无法瞄准，导致美国士兵被日本士兵反杀。而日本士兵却不会有这种情况，他们下手开枪就要干净利落很多。但这倒不是论证了日本人是天生的恶魔，因为在之后美国的军官发明出了让美国士兵果断开枪的方法，即通过把标靶改为人形，然后训练美国士兵条件反射的开枪，这样就避免了上述的情况。日本士兵的情况我不太了解，不过大概率与他们对天皇近乎病态的信仰有关，然后他们就成为了杀人机器。然后在和平年代的日本，竟然会有执行死刑的人似乎也会被罪恶感所折磨的情况。这只是是说明人类是可以通过一些社会的教化来达到克服本能的效果。不过还有一个反例是天生的杀人魔的情况，只能感叹基因 的神奇了，杀人偿命的观念对杀人魔的基因付出了很多年的清洗，所以到底是为什么呢。是因为时间还不够吗。\n还有一个是关于死刑制度的废除的观点。基于被害人父亲的角度，面对法律的不能偿命的判决，只能收下巨额的抚恤金，然后自己策划对“过失杀人”的主角的复仇。从朴素的复仇观念来考虑，夺走了自己最亲近的人，自己想报仇也无可厚非。实际上这也是大多数国人的观点，至少是我在b站弹屏看到的观点。关于废除死刑的观点下面几个视频有一些表述。不过B站到底还是一个更属于非常年轻的人的一个平台，低龄化严重，似乎不具有代表性（但毕竟他们会成为我们的未来）。还有一个我比较在意的就是网文情节，以前看过一个外国人说的如何辨别中国网文的方法，那就是是否快意恩仇，灭族之类的行为（基督山伯爵也有类似的复仇情节，不过做的就没有中国网文那么果敢了）。关于复仇的情节应该说似乎是一种非常好的爽点。我个人认为这似乎和我们从小接受的历史有关，1840年开始，中国就开始在山河破碎，多国胁迫下度日，屈辱不断，民生凋零。到了二战，日本人又对中国人进行了惨无人道的屠杀，我在历史课本中看到时往往是悲愤的情感，我们把自己带入了前几代人的角色，感受到了自己是受害者，有非常充足的理由去找那些伤害我们的人去复仇。\nhttps://www.bilibili.com/video/BV1Ep4y1J7mk\nhttps://www.bilibili.com/video/BV1Ep4y1J7mk\nhttps://www.bilibili.com/video/BV1Ch411B7FY\n","permalink":"https://tassel234.github.io/posts/read/%E6%B6%88%E5%A4%B1%E7%9A%84%E5%8D%81%E4%B8%89%E7%BA%A7%E5%8F%B0%E9%98%B6%E8%AF%BB%E5%90%8E%E6%84%9F/","summary":"本书是社会派推理小说，主要探讨了死刑制度和普通刑法附带的社会惩罚，以及人性善恶。 作者高野和明，也是人类灭绝这本书的作者。 杀人的动机，为了正当防卫而杀人，以及罪犯的改过自新可能性都是这本书的讨论范围。 一对老夫妇惨遭杀害。一切证据都指向树原亮，他却因车祸，恰好丧失了案发前后数小时的记","title":"《消失的十三级台阶》读后感"},{"content":"线性规划和整数规划模型 4.1 线性规划模型 分为目标方程，也是需要最优化的对象。以及s.t.（即约束条件）\n对于数学规划模型一定要进行灵敏度分析。\nimport cvxpy as cp from numpy import array c = array([70, 50, 60]) #定义目标向量 a = array([[2, 4, 3], [3, 1, 5], [7, 3, 5]]) #定义约束矩阵 b = array([150, 160, 200]) #定义约束条件的右边向量 x = cp.Variable(3, pos=True) #定义3个决策变量 obj = cp.Maximize(c@x) #构造目标函数 cons = [a@x \u0026lt;=b] #构造约束条件 prob = cp.Problem(obj, cons) prob.solve(solver=\u0026#39;SCIPY\u0026#39;) #求解问题 print(\u0026#39;最优解为：\u0026#39;, x.value) print(\u0026#39;最优值为：\u0026#39;, prob.value) Variable还 可以生成未知变量矩阵。\n最后默认求解器和SCIPY以及无法使用的glpk都给出了不一样的结果，但最优解都是相似的。\n4.2 整数规划 0-1规划，决策变量只能取0或者1的整数规划。\n可以用来求解背包问题 背包问题比较简单。\n指派问题 有点类似于穷举的方法。\n旅行商问题\n第三四个条件几乎是绑定的，用来约束不含子回路 的条件。\n前两个条件分别代表每个城市只允许进入和出去一次。\n非标准指派问题举例\n个数约束条件由等于1改为\u0026lt;=2.\nimport cvxpy as cp import numpy as np c = np.loadtxt(\u0026#39;data4_10.txt\u0026#39;) x = cp.Variable((4,5), integer=True) #定义3个决策变量 obj = cp.Minimize(cp.sum(cp.multiply(c,x))) #构造目标函数 cons = [0\u0026lt;=x, x\u0026lt;=1, cp.sum(x, axis=0)==1, cp.sum(x, axis=1)\u0026lt;=2] #构造约束条件 prob = cp.Problem(obj, cons) prob.solve() #求解问题 print(\u0026#39;最优解为：\\n\u0026#39;, x.value) print(\u0026#39;最优值为：\u0026#39;, prob.value) 4. 3 投资的收益与风险 分为三种模型\n1.固定风险，优化收益\n2.固定收益，极小化风险\n3.加权\n#模型一的实现代码 import cvxpy as cp import pylab as plt b = plt.array([0.025, 0.015, 0.055, 0.026]) c = plt.array([0.05, 0.27, 0.19, 0.185, 0.185]) x = cp.Variable(5, pos=True) aeq = plt.array([1, 1.01, 1.02, 1.045, 1.065]) obj = cp.Maximize( c @ x) a = 0; aa = []; Q = []; X = []; M = 10000; while a \u0026lt; 0.05: con = [aeq @ x == M, cp.multiply(b,x[1:])\u0026lt;=a*M] prob = cp.Problem(obj, con) prob.solve(solver=\u0026#39;SCIPY\u0026#39;) aa.append(a); Q.append(prob.value) X.append(x.value) a = a + 0.001 plt.rc(\u0026#39;text\u0026#39;, usetex=True); plt.rc(\u0026#39;font\u0026#39;, size=15) plt.plot(aa, Q, \u0026#39;r*\u0026#39;); plt.xlabel(\u0026#39;$a$\u0026#39;) plt.ylabel(\u0026#39;$Q$\u0026#39;, rotation=0); plt.show() 4. 4 比赛项目排序问题 05年电工杯B题\n先使用0 1对必须同时参加两个项目的人数进行数学描述，赋值为0或者1.\n然后可以可以划分为旅行商问题，安排比赛的行程，然后使同时参加两个项目的人数最小。\nD5章 非线性规划和多目标规划模型 5.1 非线性规划概念和理论 可以使用拉格朗日乘数法或者罚函数法。\n其实对应python编写程序的复杂度来说并没有什么大的不同。\n5.2 一个简单非线性规划模型 彩电例子，有两种彩电，他们每售出一台，会让自己和对方的价格都有所下降。\n#程序文件ex5_2.py import sympy as sp import pylab as plt plt.rc(\u0026#39;text\u0026#39;, usetex=True) #使用LaTeX字体 plt.rc(\u0026#39;font\u0026#39;,size=14) sp.var(\u0026#39;x1, x2\u0026#39;) #定义符号变量 y = (339-0.01*x1-0.003*x2)*x1+(399-0.004*x1-0.01*x2)*x2-(400000+195*x1+225*x2) y = sp.simplify(y) #化简 dy1 = y.diff(x1) #求关于x1的偏导 dy2 = y.diff(x2) #求关于x2的偏导 s = sp.solve([dy1, dy2], [x1, x2]) x10 = round(float(s[x1])) #取整 x20 = round(float(s[x2])) y0 = y.subs({x1: x10, x2: x20}) #符号函数代入数值 f = sp.lambdify(\u0026#39;x1, x2\u0026#39;, y, \u0026#39;numpy\u0026#39;) #符号函数转换为匿名函数 x = plt.linspace(0, 10000, 100) X, Y = plt.meshgrid(x, x) #转换为网格数据 Z = f(X, Y) ax=plt.subplot(121, projection=\u0026#39;3d\u0026#39;) #第一个子窗口三维画图 ax.plot_surface(X, Y, Z,cmap=\u0026#39;viridis\u0026#39;) ax.set_xlabel(\u0026#39;$x_1$\u0026#39;); ax.set_ylabel(\u0026#39;$x_2$\u0026#39;) plt.subplot(122) #激活第二个子窗口 contr=plt.contour(X,Y,Z,10) #10条等高线 plt.clabel(contr) #等高线标注 plt.ylabel(\u0026#39;$x_2$\u0026#39;,rotation=0) plt.xlabel(\u0026#39;$x_1$\u0026#39;) sp.var(\u0026#39;a\u0026#39;, pos=True) #定义灵敏度分析的符号参数 y = (339-a*x1-0.003*x2)*x1+(399-0.004*x1-0.01*x2)*x2-(400000+195*x1+225*x2) y = sp.simplify(y) #化简 dy1 = y.diff(x1) #求关于x1的偏导 dy2 = y.diff(x2) #求关于x2的偏导 s = sp.solve([dy1, dy2], [x1, x2]) sx1 = s[x1]; sx2 = s[x2] #提取解分量 s1 = sp.lambdify(\u0026#39;a\u0026#39;, sx1, \u0026#39;numpy\u0026#39;) #符号函数转换为匿名函数 s2 = sp.lambdify(\u0026#39;a\u0026#39;, sx2, \u0026#39;numpy\u0026#39;) a0 = plt.linspace(0.002, 0.02, 50) plt.figure() plt.subplots_adjust(wspace = 0.65) plt.subplot(121); plt.plot(a0, s1(a0)) plt.xlabel(\u0026#39;$a$\u0026#39;); plt.ylabel(\u0026#39;$x_1$\u0026#39;) plt.subplot(122); plt.plot(a0, s2(a0)) plt.xlabel(\u0026#39;$a$\u0026#39;); plt.ylabel(\u0026#39;$x_2$\u0026#39;) dx1 = sx1.diff(a); dx10 = dx1.subs(a, 0.01) sx1a = dx10 * 0.01 / 4735 dx2 = sx2.diff(a); dx20 = dx2.subs(a, 0.01) sx2a = dx20 * 0.01 / 7043 Y = y.subs({x1: s[x1], x2: s[x2]}) #求关于a的目标函数 Y = sp.factor(Y); Y = sp.simplify(Y) Ya = sp.lambdify(\u0026#39;a\u0026#39;, Y, \u0026#39;numpy\u0026#39;) #转换为匿名函数 a0 = plt.linspace(0.002, 0.02, 1000) plt.figure(); plt.plot(a0, Ya(a0)) plt.xlabel(\u0026#39;$a$\u0026#39;); plt.ylabel(\u0026#39;$y$\u0026#39;, rotation=0) Sya = - 4735 ** 2 * 0.01 / 553641.025 y2 = y.subs({x1: 4735, x2: 7043, a: 0.011}) #计算近似最优利润 y3 = Y.subs(a, 0.011) #计算最优利润 delta = (y3 - y2) / y2 #计算利润的相对误差 plt.show() 使用到了sympy进行公式推导。\n5. 3 二次规划模型 这个点要注意双变量组合的方程，普通的方差加上协方差。\n5.4 非线性规划的求解及应用 直接使用scipy库里面 的minimize函数可以进行求解。\n不过程序编写的属性发生了一点改变，不需要写没有大于等于或者小于等于的符号了，需要人工转换为\u0026gt;=的表示方法。\n#程序文件ex5_6.py import numpy as np from scipy.optimize import minimize obj=lambda x: sum(x**2)+8 def constr1(x): x1, x2, x3 = x return [x1**2-x2+x3**2, 20-x1-x2**2-x3**2] def constr2(x): x1, x2, x3 = x return [-x1-x2**2+2, x2+2*x3**2-3] con1={\u0026#39;type\u0026#39;: \u0026#39;ineq\u0026#39;, \u0026#39;fun\u0026#39;: constr1} con2={\u0026#39;type\u0026#39;: \u0026#39;eq\u0026#39;, \u0026#39;fun\u0026#39;: constr2} con=[con1, con2] #构造全部约束条件 bd = [(0, np.inf) for i in range(3)] res = minimize(obj, np.random.randn(3), constraints=con, bounds=bd) print(res) #输出解的信息 5.5 多目标规划 分为4种对多目标的处理方法。\n 线型加权法 约束法 理想点法 优先级法  理想点法是通过分别求各个目标的最优解，然后做目标函数和最优解的差的平方之和，合并为同一个目标函数。\n优先级法是先确保某一个目标有最优解，然后才保证其他目标的最优解。\n#程序文件ex5_9.py import numpy as np import cvxpy as cp c1 = np.array([-2, -3]) c2 = np.array([1, 2]) a = np.array([[0.5, 0.25], [0.2, 0.2], [1, 5], [-1, -1]]) b = np.array([8, 4, 72, -10]) x = cp.Variable(2, pos=True) obj = cp.Minimize(0.5 * (c1 + c2) @ x) con = [a @ x \u0026lt;= b] prob = cp.Problem(obj, con) prob.solve(solver=\u0026#39;SCIPY\u0026#39;) print(\u0026#39;最优解为：\u0026#39;, x.value) print(\u0026#39;最优值为：\u0026#39;, prob.value) obj1 = cp.Minimize(c1 @ x) prob1 = cp.Problem(obj1, con) prob1.solve(solver=\u0026#39;SCIPY\u0026#39;) v1 = prob1.value #线型加权目标函数的最优值 obj2 = cp.Minimize(c2 @ x) prob2 = cp.Problem(obj2, con) prob2.solve(solver=\u0026#39;SCIPY\u0026#39;) v2 = prob2.value #理想点法的目标函数的最优值 print(\u0026#39;两个目标函数的最优值分别为：\u0026#39;, v1, v2) obj3 = cp.Minimize((c1@x-v1)**2+(c2@x-v2)**2) prob3 = cp.Problem(obj3, con) prob3.solve() print(\u0026#39;解法二的最优解：\u0026#39;, x.value) con.append( c1 @ x == v1) prob4 = cp.Problem(obj2, con) prob4.solve(solver=\u0026#39;SCIPY\u0026#39;) x3 = x.value #优先级法求最优解的值 print(\u0026#39;解法三的最优解：\u0026#39;, x3) print(\u0026#39;利润：\u0026#39;, -c1@x3); print(\u0026#39;排放污染物：\u0026#39;, c2@x3) ","permalink":"https://tassel234.github.io/posts/note/python%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AE%97%E6%B3%95-3%E8%A7%84%E5%88%92/","summary":"线性规划和整数规划模型 4.1 线性规划模型 分为目标方程，也是需要最优化的对象。以及s.t.（即约束条件） 对于数学规划模型一定要进行灵敏度分析。 import cvxpy as cp from numpy import array c = array([70, 50, 60]) #定义目标向量 a = array([[2, 4, 3], [3, 1, 5], [7, 3, 5]]) #定义约束矩阵 b = array([150, 160, 200]) #定义约束条件的右边向量 x = cp.Variable(3, pos=True) #定义3个决策变量 obj = cp.Maximize(c@x) #","title":"Python数学建模算法-3（规划）"},{"content":"树结构 树的基本概念 树广泛应用于计算机的操作系统，数据库管理系统。\n树可以形成森林。\n二叉树 二叉树的定义 二叉树的链接浪费率最低，约为1/2。\n树根是上面的那个节点，最下面的是树叶。\n二叉树的左子数存放比较小的数字，右边存放比较大的数字。\n空集合可以是二叉树，但不能是树，很奇怪，但是就是这样规定的。\n两个定理： 高度为k的满二叉树的节点为2的K次方-1。 度数为2的节点数是树叶节点的个数减一。  特殊二叉树 满二叉树，完全二叉树，斜二叉树，严格二叉树。 从上到下，从左到右，编号一一对应。\n二叉树的存储方式 用一维数组来实现二叉树 从上到下，从左到右，编号一一对应。空的地方填0.\n用链表来实现二叉树 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; #define ArraySize 10 using namespace std; class Node //二叉树的节点声明 { public: int value; //节点数据 struct Node *left_Node; //指向左子树的指针 struct Node *right_Node; //指向右子树的指针 }; typedef class Node TreeNode; //定义新的二叉树节点数据类型 typedef TreeNode *BinaryTree; //定义新的二叉树指针数据类型 BinaryTree rootNode; //二叉树的根节点的指针 //将指定的值加入到二叉树中适当的节点 void Add_Node_To_Tree(int value) { BinaryTree currentNode; BinaryTree newnode; int flag=0; //用来记录是否插入了新的节点 newnode=(BinaryTree) new TreeNode; //建立节点内容 newnode-\u0026gt;value=value; newnode-\u0026gt;left_Node=NULL; newnode-\u0026gt;right_Node=NULL; //如果为空的二叉树，则将新的节点设置为根节点 if(rootNode==NULL) rootNode=newnode; else { currentNode=rootNode; //设置一个指针指向根节点 while(!flag) if (value\u0026lt;currentNode-\u0026gt;value) { //在左子树 if(currentNode-\u0026gt;left_Node==NULL) { currentNode-\u0026gt;left_Node=newnode; flag=1; } else currentNode=currentNode-\u0026gt;left_Node; } else { //在右子树 if(currentNode-\u0026gt;right_Node==NULL) { currentNode-\u0026gt;right_Node=newnode; flag=1; } else currentNode=currentNode-\u0026gt;right_Node; } } } int main(void) { int tempdata; int content[ArraySize]; int i=0; rootNode=(BinaryTree) new TreeNode; rootNode=NULL; cout\u0026lt;\u0026lt;\u0026#34;请连续输入10个数据：\u0026#34;\u0026lt;\u0026lt;endl; for(i=0;i\u0026lt;ArraySize;i++) { cout\u0026lt;\u0026lt;\u0026#34;请输入第\u0026#34;\u0026lt;\u0026lt;setw(1)\u0026lt;\u0026lt;(i+1)\u0026lt;\u0026lt;\u0026#34;个数据：\u0026#34;; cin\u0026gt;\u0026gt;tempdata; content[i]=tempdata; } for(i=0;i\u0026lt;ArraySize;i++) Add_Node_To_Tree(content[i]); cout\u0026lt;\u0026lt;\u0026#34;完成了用链表建立二叉树！\u0026#34;; cout\u0026lt;\u0026lt;endl; return 0; } 二叉树的遍历 中序遍历, 后序遍历 ,前序遍历 中序遍历, 后序遍历 ,前序遍历 指的顺序都是树根什么时候被查。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; class tree //节点链表结构声明 { public : int data; //节点数据 class tree *left,*right; //节点左指针和右指针 }; typedef class tree node; typedef node *btree; btree creat_tree(btree,int); void pre(btree); void in(btree); void post(btree); int main(void) { int arr[]={7,4,1,5,16,8,11,12,15,9,2}; //原始数组内容 btree ptr=NULL; //声明树根 cout\u0026lt;\u0026lt;\u0026#34;[原始数组内容]\u0026#34;\u0026lt;\u0026lt;endl; for (int i=0;i\u0026lt;11;i++) //建立二叉树，并将二叉树的内容打印出来 { ptr=creat_tree(ptr,arr[i]); cout\u0026lt;\u0026lt;\u0026#34;[\u0026#34;\u0026lt;\u0026lt;setw(2)\u0026lt;\u0026lt;arr[i]\u0026lt;\u0026lt;\u0026#34;] \u0026#34;; } cout\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;[二叉树的内容]\u0026#34;\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;前序遍历的结果：\u0026#34;\u0026lt;\u0026lt;endl; //打印前、中、后序遍历的结果 pre(ptr); cout\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;中序遍历的结果：\u0026#34;\u0026lt;\u0026lt;endl; in(ptr); cout\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;后序遍历的结果：\u0026#34;\u0026lt;\u0026lt;endl; post(ptr); cout\u0026lt;\u0026lt;endl; return 0; } btree creat_tree(btree root,int val) //建立二叉树的子程序 { btree newnode,current,backup; //声明一个新节点newnode来存放数组中的数据 newnode = new node; //其中current和backup用于暂存指针 newnode-\u0026gt;data=val; //设置新节点的数据及左右指针 newnode-\u0026gt;left=NULL; newnode-\u0026gt;right=NULL; if (root==NULL) //如果root为空值，则把新节点返回当作树根 { root=newnode; return root; } else //若root不是树根，则建立二叉树 { for(current=root;current!=NULL;) //current复制root以保留当前的树根值 { backup=current; //暂存父节点 if(current-\u0026gt;data \u0026gt; val) //比较树根节点和新节点的数据 current=current-\u0026gt;left; else current=current-\u0026gt;right; } if(backup-\u0026gt;data \u0026gt; val) //把新节点和树根链接起来 backup-\u0026gt;left=newnode; else backup-\u0026gt;right=newnode; } return root; //返回指向树的指针，即指向树根的指针 } void pre(btree ptr) //前序遍历 { if (ptr != NULL) { cout\u0026lt;\u0026lt;\u0026#34;[\u0026#34;\u0026lt;\u0026lt;setw(2)\u0026lt;\u0026lt;ptr-\u0026gt;data\u0026lt;\u0026lt;\u0026#34;] \u0026#34;; pre(ptr-\u0026gt;left); pre(ptr-\u0026gt;right); } } void in(btree ptr) //中序遍历 { if (ptr != NULL) { in(ptr-\u0026gt;left); cout\u0026lt;\u0026lt;\u0026#34;[\u0026#34;\u0026lt;\u0026lt;setw(2)\u0026lt;\u0026lt;ptr-\u0026gt;data\u0026lt;\u0026lt;\u0026#34;] \u0026#34;; in(ptr-\u0026gt;right); } } void post(btree ptr) //后序遍历 { if (ptr != NULL) { post(ptr-\u0026gt;left); post(ptr-\u0026gt;right); cout\u0026lt;\u0026lt;\u0026#34;[\u0026#34;\u0026lt;\u0026lt;setw(2)\u0026lt;\u0026lt;ptr-\u0026gt;data\u0026lt;\u0026lt;\u0026#34;] \u0026#34;; } } 二叉树节点的插入与删除 #include \u0026lt;iostream\u0026gt; using namespace std; struct tree { int data; struct tree *left,*right; }; typedef struct tree node; typedef node *btree; btree creat_tree(btree root,int val) { btree newnode,current,backup; newnode=(btree)new node; newnode-\u0026gt;data=val; newnode-\u0026gt;left=NULL; newnode-\u0026gt;right=NULL; if(root==NULL) { root=newnode; return root; } else { for(current=root;current!=NULL;) { backup=current; if(current-\u0026gt;data \u0026gt; val) current=current-\u0026gt;left; else current=current-\u0026gt;right; } if(backup-\u0026gt;data \u0026gt; val) backup-\u0026gt;left=newnode; else backup-\u0026gt;right=newnode; } return root; } btree search(btree ptr,int val) //查找二叉树的子程序 { while(1) { if(ptr==NULL) //没找到就返回NULL return NULL; if(ptr-\u0026gt;data==val) //节点值等于查找值 return ptr; else if(ptr-\u0026gt;data \u0026gt; val) //节点值大于查找值 ptr=ptr-\u0026gt;left; else ptr=ptr-\u0026gt;right; } } void inorder(btree ptr) //中序遍历的子程序 { if(ptr!=NULL) { inorder(ptr-\u0026gt;left); cout\u0026lt;\u0026lt;\u0026#34;[\u0026#34;\u0026lt;\u0026lt;ptr-\u0026gt;data\u0026lt;\u0026lt;\u0026#34;]\u0026#34;; inorder(ptr-\u0026gt;right); } } int main() { int i,data,arr[]={7, 1, 4, 2, 8, 13, 12, 11, 15, 9, 5}; btree ptr=NULL; cout\u0026lt;\u0026lt;\u0026#34;[原始数组内容]\u0026#34;\u0026lt;\u0026lt;endl; for (i=0;i\u0026lt;11;i++) { ptr=creat_tree(ptr,arr[i]); //建立二叉树 cout\u0026lt;\u0026lt;\u0026#34;[\u0026#34;\u0026lt;\u0026lt;arr[i]\u0026lt;\u0026lt;\u0026#34;] \u0026#34;; } cout\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;请输入要查找的值：\u0026#34;; cin\u0026gt;\u0026gt;data; if((search(ptr,data))!=NULL) //查找二叉树 cout\u0026lt;\u0026lt;\u0026#34;二叉树中有此节点了!\u0026#34;\u0026lt;\u0026lt;data\u0026lt;\u0026lt;endl; else { ptr=creat_tree(ptr,data); inorder(ptr); } return 0; } 二叉运算树 线索二叉树 可以提高节点的利用率，中序遍历时不需要使用栈堆与递归。但运行速度较慢。\n按中序遍历顺序，空连接指针如果是该节点的左指针，指向中序遍历顺序下的前一个节点；空连接指针如果是该节点的右指针，指向中序遍历顺序下的后一个节点。没有前后的就空着。 树的二叉树表示法 （左儿子，右兄弟） 树转化为二叉树 二叉树转化为树 实际上是上述过程的逆运算，先把右子树旋转45度，然后删除兄弟连接，改为父子。\n森林转化为二叉树 方法基本一样，把根节点当兄弟节点连接到一起。\n二叉树转化为森林 逆运算。\n树与森林的遍历 中序遍历, 后序遍历 ,前序遍历 指的顺序都是树根什么时候被查。 方向是从左到右。\n确定唯一二叉树 知道中序遍历, 后序遍历或知道中序遍历, 前序遍历都可以确定唯一的树，但知道后序遍历 ,前序遍历 不能确定唯一的树。\n优化二叉查找树 扩充二叉树 对空链接加上外节点，其他的节点都是内节点。\n内径长是所有内节点的到根节点的距离。外径长也顾名思义。\n可对外径长进行加权处理。\n哈夫曼树 平衡树 （AVL树） 所有内部节点的左右子树的高度大概平衡，左右子树的节点相差小于或等于1.\n高级树结构的研究 博弈树 博弈树(game tree)是一种特殊的根树,它是人工智能领域一个重要的研究课题。博弈树就是符合博弈规则的决策树。\n博弈决策形成人工智能的方式是查找，在所有情况下找出获胜的情况。\nB树 平衡树概念的延申。 一棵m阶B树(balanced tree of order m)是一棵平衡的m路搜索树。它或者是空树，或者是满足下列性质的树： 1、根结点至少有两个子女； 2、每个非根节点所包含的关键字个数 j 满足：┌m/2┐ - 1 \u0026lt;= j \u0026lt;= m - 1； 3、除根结点以外的所有结点（不包括叶子结点）的度数正好是关键字总数加1，故内部子树个数 k 满足：┌m/2┐ \u0026lt;= k \u0026lt;= m ； 4、所有的叶子结点都位于同一层。\n二叉空间分割树 属于二叉树，特点是每一个节点都有两个子节点。这是游戏空间常用的一种分割方法，通常应用于平面绘图软件。\n二叉树节点内的数据结构以平面方式分割场景。\n四叉树与八叉树 提供更好的分类能力。\n堆 树的形状取决于数据的个数。结点的排列顺序为从上到下，同一行里则为从左到右。\n在堆中存储数据时必须遵守这样一条规则:子结点必定大于父结点。因此最小值被存储在顶端的根结点中。往堆中添加数据时，为了遵守这条规则，一般会把新数据放在最下面一行靠左的位置。当最下面一行里没有多余空间时，就再往下另起一行，把数据加在这一行的最左端。\n按顺序加入 在堆中取出数字，取得是上面最小的数据。 然后把最后的数据移到上面，和下面的节点按照规则比较并移动。最终的结果如下。\n图的数据表示法 邻接矩阵法 无向图的邻接矩阵是对称的，因为连接是双向的，而有向图不是。\n声明的元素个数是6x6个，而点只有5个 ,声明7个可以，方便填入。\n#include \u0026lt;iostream\u0026gt; using namespace std; int main(void) { int arr[6][6];\t//声明矩阵arr， int data[14][2]={{1,2},{2,1},{1,5},{5,1}, //无向图各边的起点值和终点值 {2,3},{3,2},{2,4},{4,2}, {3,4},{4,3},{3,5},{5,3}, {4,5},{5,4}}; for (int i=0;i\u0026lt;6;i++)\t//把矩阵清为0 for (int j=0;j\u0026lt;6;j++) arr[i][j]=0; for (int i=0;i\u0026lt;14;i++)\t//读取图的数据 //for (int j=0;j\u0026lt;6;j++)\t//填入arr矩阵,源代码加上了这一行和下面一行， //for (int k=0;k\u0026lt;6;k++)//但貌似没什么用，可以直接去掉 { int tmpi, tmpj; tmpi=data[i][0];\t//tmpi为起始顶点 tmpj=data[i][1];\t//tmpj为终止顶点 arr[tmpi][tmpj]=1;\t//有边的点填入1 } cout\u0026lt;\u0026lt;\u0026#34;无向图矩阵：\u0026#34;\u0026lt;\u0026lt;endl; for (int i=1;i\u0026lt;6;i++) { for (int j=1;j\u0026lt;6;j++) cout\u0026lt;\u0026lt;\u0026#34;[\u0026#34;\u0026lt;\u0026lt;arr[i][j]\u0026lt;\u0026lt;\u0026#34;] \u0026#34;; //打印矩阵内容 cout\u0026lt;\u0026lt;endl; } } 有向图的表示方法类似。 只是修改了一点。\nint data[5][2]={{1,2},{2,1},{2,3},{2,4},{4,3}} 邻接链表法 空间利用率高。\n/* [示范]:使用邻接表来表示图(a)和(b) */ #include \u0026lt;iostream\u0026gt; using namespace std; class list { public: int val; class list *next; }; class list head[6];//声明一个节点类型的数组 int main(void) { list *ptr,*newnode; int data[14][2]={{1,2},{2,1},{1,5},{5,1},//声明存储图的数组 {2,3},{3,2},{2,4},{4,2}, {3,4},{4,3},{3,5},{5,3}, {4,5},{5,4}}; cout\u0026lt;\u0026lt;\u0026#34;图(a)的邻接表内容：\u0026#34;\u0026lt;\u0026lt;endl; for (int i=1;i\u0026lt;6;i++) { head[i].val=i; //链表头head head[i].next=NULL; cout\u0026lt;\u0026lt;\u0026#34;顶点 \u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; =\u0026gt;\u0026#34;;\t//把顶点值打印出来 ptr=\u0026amp;(head[i]); //暂存节点ptr for (int j=0;j\u0026lt;14;j++) //遍历图数组 { if (data[j][0]==i) //如果节点值=i，加入节点到链表头 { newnode = new list; newnode-\u0026gt;val=data[j][1];//声明新节点，值为终点值 newnode-\u0026gt;next=NULL; while(ptr!=NULL) //判断是否为链表的末尾 ptr=ptr-\u0026gt;next; ptr=newnode; //加入新节点 cout\u0026lt;\u0026lt;\u0026#34;[\u0026#34;\u0026lt;\u0026lt;newnode-\u0026gt;val\u0026lt;\u0026lt;\u0026#34;] \u0026#34;;//打印相邻顶点 } } cout\u0026lt;\u0026lt;endl; } } 其他方法 邻接复合链表法 索引表格法\n图的遍历 深度优先遍历 首先需要生成邻接链表，方便之后遍历。\n然后使用递归和堆栈的知识去进行广度优先搜索。压入一个点相邻的所有顶点，然后用堆栈去取出一个点，压入这个点相邻的所有顶点，递归调用，循环往复。\n/* [示范]:深度优先遍历法(BFS) */ #include \u0026lt;iostream\u0026gt; using namespace std; class list { public: int val; class list *next; }; typedef class list node; typedef node *link; class list* head[9]; void dfs(int); int run[9]; int main(void) { link ptr,newnode; int data[20][2]={{1,2},{2,1},{1,3},{3,1},//声明存放图的边的数组 {2,4},{4,2},{2,5},{5,2}, {3,6},{6,3},{3,7},{7,3}, {4,5},{5,4},{6,7},{7,6}, {5,8},{8,5},{6,8},{8,6}}; for (int i=1;i\u0026lt;=8;i++)//共有八个顶点 { run[i]=0; //把所有顶点设置为尚未遍历过 head[i]= new node; head[i]-\u0026gt;val=i; //设置各个链表头的初值 head[i]-\u0026gt;next=NULL; ptr=head[i]; //设置指针为链表头 for(int j=0;j\u0026lt;20;j++) //二十条边 { if(data[j][0]==i) //如果起点和链表头相等，则把顶点加入链表 { newnode =new node; newnode-\u0026gt;val=data[j][1]; newnode-\u0026gt;next=NULL; do { ptr-\u0026gt;next=newnode;//加入新节点 ptr=ptr-\u0026gt;next; }while(ptr-\u0026gt;next!=NULL); } } } cout\u0026lt;\u0026lt;\u0026#34;图的邻接表内容：\u0026#34;\u0026lt;\u0026lt;endl;//打印图的邻接表内容 for(int i=1;i\u0026lt;=8;i++) { ptr=head[i]; cout\u0026lt;\u0026lt;\u0026#34;顶点 \u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34;=\u0026gt; \u0026#34;; ptr = ptr-\u0026gt;next; while(ptr!=NULL) { cout\u0026lt;\u0026lt;\u0026#34;[\u0026#34;\u0026lt;\u0026lt;ptr-\u0026gt;val\u0026lt;\u0026lt;\u0026#34;] \u0026#34;; ptr=ptr-\u0026gt;next; } cout\u0026lt;\u0026lt;endl; } cout\u0026lt;\u0026lt;\u0026#34;深度优先遍历顶点：\u0026#34;\u0026lt;\u0026lt;endl;//打印深度优先遍历的顶点 dfs(1); cout\u0026lt;\u0026lt;endl; } void dfs(int current) //深度优先遍历子程序 { link ptr; run[current]=1; cout\u0026lt;\u0026lt;\u0026#34;[\u0026#34;\u0026lt;\u0026lt;current\u0026lt;\u0026lt;\u0026#34;] \u0026#34;; ptr=head[current]-\u0026gt;next; while(ptr!=NULL) {\tif (run[ptr-\u0026gt;val]==0) //如果顶点尚未遍历， dfs(ptr-\u0026gt;val); //就进行dfs的递归调用 ptr=ptr-\u0026gt;next; } } 广度优先遍历 仍然先 生成邻接链表，然后使用队列进行广度优先搜索。\n部分实现如下。\n/* [示范]:广度优先遍历法(BFS) */ void bfs(int current) { link tempnode;\t//临时的节点指针 enqueue(current);\t//将第一个顶点加入队列 run[current]=1;\t//将遍历过的顶点设置为1 cout\u0026lt;\u0026lt;\u0026#34;[\u0026#34;\u0026lt;\u0026lt;current\u0026lt;\u0026lt;\u0026#34;]\u0026#34;;\t//打印出该遍历过的顶点 while(front!=rear) {\t//判断当前是否为空队列 current=dequeue();\t//将顶点从队列中取出 tempnode=Head[current].first; //先记录当前顶点的位置 while(tempnode!=NULL) { if(run[tempnode-\u0026gt;x]==0) { enqueue(tempnode-\u0026gt;x); run[tempnode-\u0026gt;x]=1; //记录已遍历过 cout\u0026lt;\u0026lt;\u0026#34;[\u0026#34;\u0026lt;\u0026lt;tempnode-\u0026gt;x\u0026lt;\u0026lt;\u0026#34;]\u0026#34;; } tempnode=tempnode-\u0026gt;next; } } } 生成树 深度优先生成树和广度优先生成树 又叫花费树，成本树。联通所有的顶点。可以利用bfs或者dfs来生成。\n最小生成树 又叫最小花费树，最小成本树。如果路径上有权重，就使用最小权重和的生成树。\nKruskal算法 先把权值从小到大排列，从最小的边开始，建立最小生成树，如果形成圈就舍弃不用，直到加入n-1条边。\n/* [示范]:最小成本生成树 */ #include \u0026lt;iostream\u0026gt; #define VERTS 6 //图的顶点数 using namespace std; void mintree(mst head) //最小成本生成树子程序 { mst ptr,mceptr; int result=0; ptr=head; for(int i=0;i\u0026lt;=VERTS;i++) v[i]=0; while(ptr!=NULL) { mceptr=findmincost(head); v[mceptr-\u0026gt;from]++; v[mceptr-\u0026gt;to]++; if(v[mceptr-\u0026gt;from]\u0026gt;1 \u0026amp;\u0026amp; v[mceptr-\u0026gt;to]\u0026gt;1) { v[mceptr-\u0026gt;from]--; v[mceptr-\u0026gt;to]--; result=1; } else result=0; if(result==0) cout\u0026lt;\u0026lt;\u0026#34;起始顶点 [\u0026#34;\u0026lt;\u0026lt;mceptr-\u0026gt;from \u0026lt;\u0026lt;\u0026#34;]\\t终止顶点 [\u0026#34;\u0026lt;\u0026lt;mceptr-\u0026gt;to\u0026lt;\u0026lt;\u0026#34;]\\t路径长度 [\u0026#34; \u0026lt;\u0026lt;mceptr-\u0026gt;val\u0026lt;\u0026lt;\u0026#34;]\u0026#34;\u0026lt;\u0026lt;endl; ptr=ptr-\u0026gt;next; } } Prim算法 图的最短路径 单点对全部顶点——Dijkstra算法 果然福特算法过于费时间，所以这本书没有提及。可以看看其他的图论笔记。\n/* [示范]:Dijkstra算法(单点对全部顶点的最短路径) */ #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;iomanip\u0026gt; #define SIZE 7 #define NUMBER 6 #define INFINITE 99999\t//无穷大 using namespace std; int Graph_Matrix[SIZE][SIZE];\t//存放图的数组 int distance[SIZE];\t//路径的长度 //建立图 void BuildGraph_Matrix(int *Path_Cost) { int Start_Point;\t//边的起点 int End_Point;\t//边的终点 int i, j; for ( i = 1; i \u0026lt; SIZE; i++ ) for ( j = 1; j \u0026lt; SIZE; j++ ) if ( i == j ) Graph_Matrix[i][j] = 0;\t//对角线设为0 else Graph_Matrix[i][j] = INFINITE; //存入图的边 i=0; while(i\u0026lt;SIZE) { Start_Point = Path_Cost[i*3]; End_Point = Path_Cost[i*3+1]; Graph_Matrix[Start_Point][End_Point]=Path_Cost[i*3+2]; i++; } } //打印出图 void printGraph_Matrix() { int i, j; for ( i = 1; i \u0026lt; SIZE; i++ ) { cout\u0026lt;\u0026lt;\u0026#34;vex\u0026#34;\u0026lt;\u0026lt;i; for ( j = 1; j \u0026lt; SIZE; j++ ) if ( Graph_Matrix[i][j] == INFINITE ) cout\u0026lt;\u0026lt;setw(5)\u0026lt;\u0026lt;\u0026#39;x\u0026#39;; else cout\u0026lt;\u0026lt;setw(5)\u0026lt;\u0026lt;Graph_Matrix[i][j]; cout\u0026lt;\u0026lt;endl; } } //单点对全部顶点的最短距离 void shortestPath(int vertex1, int vertex_total) { extern int distance[SIZE];\t//声明为外部变量 int shortest_vertex = 1; //记录最短距离的顶点 int shortest_distance; //记录最短距离 int goal[SIZE]; //用来记录该顶点是否被选取 int i,j; for ( i = 1; i \u0026lt;= vertex_total; i++ ) { goal[i] = 0; distance[i] = Graph_Matrix[vertex1][i]; } goal[vertex1] = 1; distance[vertex1] = 0; cout\u0026lt;\u0026lt;endl; for (i=1; i\u0026lt;=vertex_total-1; i++ ) { shortest_distance = INFINITE; //找出最短距离的顶点 for (j=1;j\u0026lt;=vertex_total;j++ ) if (goal[j]==0\u0026amp;\u0026amp;shortest_distance\u0026gt;distance[j]) { shortest_distance=distance[j]; shortest_vertex=j; } goal[shortest_vertex] = 1; //计算开始顶点到各顶点的最短距离 for (j=1;j\u0026lt;=vertex_total;j++ ) { if ( goal[j] == 0 \u0026amp;\u0026amp; distance[shortest_vertex] +Graph_Matrix[shortest_vertex][j]\u0026lt;distance[j]) { distance[j]=distance[shortest_vertex] +Graph_Matrix[shortest_vertex][j]; } } } } //主程序 int main(void) { extern int distance[SIZE];\t//声明为外部变量 int Path_Cost[7][3] = { {1, 2, 10}, {2, 3, 20}, {2, 4, 25}, {3, 5, 18}, {4, 5, 22}, {4, 6, 95}, {5, 6, 77} }; int j; BuildGraph_Matrix(\u0026amp;Path_Cost[0][0]); cout\u0026lt;\u0026lt;\u0026#34;==================================\u0026#34;\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;此范例图的邻接矩阵如下: \u0026#34;\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;==================================\u0026#34;\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;顶点 vex1 vex2 vex3 vex4 vex5 vex6\u0026#34;\u0026lt;\u0026lt;endl; printGraph_Matrix(); //显示图 shortestPath(1,NUMBER); //查找最短路径 cout\u0026lt;\u0026lt;\u0026#34;==================================\u0026#34;\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;顶点1到各顶点最短距离的最终结果\u0026#34;\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;==================================\u0026#34;\u0026lt;\u0026lt;endl; for (j=1;j\u0026lt;SIZE;j++) cout\u0026lt;\u0026lt;\u0026#34;顶点 1到顶点\u0026#34;\u0026lt;\u0026lt;setw(2)\u0026lt;\u0026lt;j\u0026lt;\u0026lt;\u0026#34;的最短距离=\u0026#34; \u0026lt;\u0026lt;setw(3)\u0026lt;\u0026lt;distance[j]\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;endl; return 0; } A*算法 引用推测权重，使用距离预估函数，但有一定可能会出错而造成找不到最短路径。\n两两顶点间的最短路径——Floyd算法 弗洛伊德算法，可以找到任意两点之间的最小路径。\nAOV网络与拓扑排序 也叫顶点活动网络，在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系。这样的有向图为顶点表示活动的网，我们称为AOV网（Activity On Vertex Network）。先做某些工作才可以做接下来的工作。\n一个AOV网应该是一个有向无环图，即不应该带有回路，因为若带有回路，则回路上的所有活动都无法进行。\n在AOV网中，若不存在回路，则所有活动可排列成一个线性序列，使得每个活动的所有前驱活动都排在该活动的前面，我们把此序列叫做拓扑序列(Topological order)，由AOV网构造拓扑序列的过程叫做拓扑排序(Topological sort)。AOV网的拓扑序列不是唯一的，满足上述定义的任一线性序列都称作它的拓扑序列。\nAOE网络 在带权有向图中若以顶点表示事件，有向边表示活动，边上的权值表示该活动持续的时间，这样的图简称为AOE网。\n完成工程的最短时间：从工程开始点（源点）到完成点（汇点）的最短路径称为完成工程的最短时间。\n关键路径：路径长度最长的路径称为关键路径。\n","permalink":"https://tassel234.github.io/posts/note/%E4%BD%BF%E7%94%A8cpp%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-3%E6%A0%91%E5%92%8C%E5%9B%BE%E8%AE%BA/","summary":"树结构 树的基本概念 树广泛应用于计算机的操作系统，数据库管理系统。 树可以形成森林。 二叉树 二叉树的定义 二叉树的链接浪费率最低，约为1/2。 树根是上面的那个节点，最下面的是树叶。 二叉树的左子数存放比较小的数字，右边存放比较大的数字。 空集合可以是二叉树，但不能是树，很奇怪，但是就是这样规","title":"使用Cpp实现数据结构-3（树和图论）"},{"content":"数组的定义和使用 （1）一维数组的定义、初始化、引用 使用数组，可以方便地定义一个名字（数组名）来表示大批量数据，并能够通过循环批处理大量数据。\n一维数组是由元素类型、数组名和长度组成的构造类型。例如：\nint A[10], B[20]; // 元素是整型 常量表达式表示数组中元素的个数，称为数组长度。常量表达式的值必须为正整数且大于等于1。数组一经定义，数组长度就始终不变。定义中数组的值不能是变量。\n初值列表提供的元素个数不能超过数组长度，但可以小于数组长度。如果初值个数小于数组长度，则只初始化前面的数组元素，剩余元素初始化为0。\n可以用下面的表达式计算出数组A的长度：\nint A[]={1,8,9}; sizeof(A) / sizeof(int) 下标表达式可以是常量、变量、表达式，但必须是正整数，不允许为负。下标由0开始。整个数组不允许进行赋值运算、算术运算等操作，只有元素才可以。\n（2）二维数组的定义、初始化、引用 本质上，C++的多维数组都是一维数组。\nint A[2][3]={ {1,2,3},{4,5,6}};//初值按二维形式 int A[2][3]={ 1,2,3,4,5,6 };//初值按一维形式 初值列表提供的元素个数不能超过数组长度，但可以小于数组长度。如果初值个数小于数组长度，则只初始化前面的数组元素；剩余元素初始化为0。这个规则两种初始化形式都适用。\nint A[3][4]={{1},{1,2},{1,2,3}}; int A[3][4]={1,2,3,4,5}; 多维数组定义时可以不用指定第1维的数组长度，但其余维的长度必须指定，编译器会根据列出的元素个数自动确定第1维的长度。\nint A[][2][3]={1,2,3,4,5,6,7,8,9,10,11,12};//正确 int B[2][][3]={1,2,3,4,5,6,7,8,9,10,11,12};//错误，只能省略第1维 数组与函数 （1）数组作为函数的参数 x=max(c,-10); //使用变量或常数作为函数实参 x=max(A[2],-10); //使用数组元素作为函数实参 a[5]的a就是数组的首地址，可以作为参数传递到数组。如果实参使用数组名调用，本质上是将这个数组的首地址传递到形参中。这就造成了数组即使形式参数又是实际参数，（内存中 两个对象所处位置相同，则它们实为同一个对象）不像变量是生成副本，无法在函数体内修改它的值。\nvoid fun(int A[5],int n) { A[1]=100; //A[1]实质就是实参a[1] n=10; //赋值给形参n，不影响实参x } void caller() { int a[5]={1,2,3,4,5},x=5; fun(a,x); cout\u0026lt;\u0026lt;a[1]\u0026lt;\u0026lt;“,“\u0026lt;\u0026lt;x\u0026lt;\u0026lt;endl; //a[1]=100,x=5 } 数组的定义中可以不写长度，写长或者写短都可以。而且名字可以不同，只有是数组就可以。（对一维数组而言）\n（2）数组参数的传递机制 既然形参数组就是实参数组，所以函数调用时不会为形参数组分配存储空间。\n多维数组作为函数的参数，形参数组第1维可以与实参相同，也可以不相同；可以是任意长度，也可以不写长度；但其他维的长度需要相同。\nvoid f(int A[5][10]); //正确 void f(int A[2][10]); //正确 void f(int A[][10]); //正确 void f(int A[][]); //错误，第2维长度必须给出 void f(int A[5][5]); //错误，第2维长度必须相同 void f(int A[50]); //错误，必须是二维数组 字符串的处理 （1）字符数组 char s[20]; //定义字符数组 char s[4]={\u0026#39;J\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;v\u0026#39;,\u0026#39;a\u0026#39;}; //字符数组初始化 C++语言规定字符串是以'\\0'（ASCII值为0）字符作为结束符的字符数组。C++总是在编译时为字符串常量自动在其后增加一个空字符。以定义字符数组时数组的长度至少为字符串长度加1（空字符也要占位）。\nchar c; char s[10]=“hello.”; c=‘a’; //正确 c=“a”; //错误 //因为使用\u0026#34;\u0026#34;会造成自动带一个空字符，数组的长度至少为2 （1）使用标准输入输出流，将整个字符串一次输入或输出\nchar str[80];//数组应该比较大 cin \u0026gt;\u0026gt; str; //输入字符串 cout \u0026lt;\u0026lt; str; //输出字符串 （2）使用字符串输入输出函数\nchar str[80]; gets(str); //输入字符串 char str[80]=\u0026#34;Programming\u0026#34;; puts(str); //输出字符串 （2）字符串处理函数 C++标准库提供了兼容C语言的字符串处理函数，其头文件为string.h。\n►（1）字符串复制函数strcpy char str1[10],str2[]=\u0026#34;Computer\u0026#34;; strcpy(str1,str2); //复制str2到str1 ►（2）字符串复制函数strncpy char str1[10], str2[]=\u0026#34;Computer\u0026#34;; strncpy(str1,str2,4);//复制str2的前4个字符到str1 ►（3）字符串连接函数strcat char str1[10]=\u0026#34;ABC\u0026#34;, str2[]=\u0026#34;123\u0026#34;; strcat(str1,str2);//在str1后面连接str2,str2未变化 ►（4）字符串连接函数strncat char str1[10]=\u0026#34;ABC\u0026#34;,str2[]=\u0026#34;123456\u0026#34;; strncat(str1,str2,4);//将str2前4个字符连接到str1后面 ►（5）字符串比较函数strcmp if (strcmp(str1,str2)==0)...... //比较字符串相等 if (strcmp(str1,str2)\u0026gt;0)......//比较str1大于str2 ►（6）计算字符串长度函数 n=strlen(\u0026#34;Language\u0026#34;); //n=8 char str[20]=\u0026#34;Visual Basic\u0026#34;; n=strlen(str); //n=12 ►（7）字符串转换成数值函数 f=atof(\u0026#34;123.456\u0026#34;); //f=123.456 i=atoi(\u0026#34;-456\u0026#34;); //i=-456 （3）字符串对象 C++特有，使用string类型，比使用C风格字符串更方便、更安全。这样和python非常类似了。\n#include \u0026lt;string\u0026gt; //不能写为string.h char S2[20]=\u0026#34;Java\u0026#34;; //C风格字符串初始化 string str2=\u0026#34;Java\u0026#34;; //string对象复制初始化 string str3(\u0026#34;C++\u0026#34;); //string对象直接初始化 输入输出和上个章节类似。\nstr1=\u0026#34;Java\u0026#34;; //C风格字符串可以直接赋给string str1.c_str(); //string转换为C风格字符串，返回char指针 str1.copy(S1,n,pos); //把str1中从pos开始的n个字符复制到S1字符数组 （4）字符串对象的操作 string对象允许使用运算符进行操作，实现类似C风格字符串的处理。如复制（strcpy）、连接（strcat）、比较（strcmp）等。下面的这些运算和python非常类似了。\n字符串连接运算\nstr1=\u0026#34;12\u0026#34; , str2=\u0026#34;AB\u0026#34; , str3=\u0026#34;CD\u0026#34;; str1 = str2 + str3; //str1结果为ABCD str1 = str1 + \u0026#34;PHP\u0026#34;; //str1结果为12PHP str1 += str3; //str1结果为12CD 字符串关系运算\nstr1=\u0026#34;ABC\u0026#34; , str1=\u0026#34;XYZ\u0026#34;; str1 \u0026gt; str2; //结果为假 str1 == str2; //结果为假 str1 == \u0026#34;ABC\u0026#34;; //结果为真 其他\nstr1=\u0026#34;ABCDEFGHIJK\u0026#34;; //获取字符串的长度 n = str1.size(); //n为11 n = str1.length(); //n为11 //检查字符串是否为空字符串 b = str1.empty(); //b为假 //得到子字符串 str2 = str1.substr(2,4); //从下标2开始的4个字符，str2为CDEF //查找子字符串 n = str1.find(\u0026#34;DEF\u0026#34;,pos); //从pos开始查找字符串\u0026#34;DEF\u0026#34;在str1中的位置，n为3 //删除字符 str1.erase(3,5); //从下标3开始往后删5个字符，str1变为ABCIJK //增加字符 str1.append(\u0026#34;12345\u0026#34;,1,3); //在str1末尾增加\u0026#34;12345\u0026#34;下标从1开始的3个字符，即\u0026#34;234\u0026#34; //字符串替换和插入操作 str1.replace(p0,n0,S1,n); //删除从p0开始的n0个字符，然后在p0处插入字符串S1前n个字符 str1.replace(p0,n0,str2,pos,n); //删除从p0开始的n0个字符，然后在p0处插入字符串str2中pos开始的前n个字符 str1.insert(p0,S1,n); //在p0位置插入字符串S1前n个字符 str1.insert(p0,str2,pos,n); //在p0位置插入字符串str2中pos开始的前n个字符 字符串对象数组\nstring SY[5]={\u0026#34;123\u0026#34;,\u0026#34;12\u0026#34;,\u0026#34;1234\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;12345\u0026#34;}; //长度 3,2,4,1,5 数组的应用 （1）用数组解决排序问题 冒泡排序 冒泡排序法（bubble sort）的基本思想是通过相邻两个记录之间的比较和交换，使关键码较小的记录逐渐从底部移向顶部。\n#include \u0026lt;iostream\u0026gt; using namespace std; #define N 10 //数组元素个数 int main() { int A[N], i, j, t; //注意数组下标从0开始 for (i=0; i\u0026lt;N; i++) cin\u0026gt;\u0026gt;A[i]; //输入N个数 for(j=0 ; j\u0026lt;N-1 ; j++) //冒泡排序法 for(i=0 ; i\u0026lt;N-1-j; i++) //一趟冒泡排序 if(A[i] \u0026gt; A[i+1]) //A[i]与A[i+1]比较 \u0026lt;升序 \u0026gt;降序 t=A[i], A[i]=A[i+1], A[i+1]=t; //交换 for (i=0; i\u0026lt;N; i++) cout\u0026lt;\u0026lt;A[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; //输出排序结果 return 0; } 选择排序法 选择排序法（selection sort）的基本思想是第i趟选择排序通过n-i次关键码的比较，从n-i+1个记录中选出关键码最小的记录，并和第i个记录进行交换。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;ctime\u0026gt; using namespace std; void SelectionSort(int A[],int n) //选择排序 n为数组元素个数 { int i,j,k,t; for(i=0; i\u0026lt;n-1; i++) { //选择排序法 k=i; for(j=i+1; j\u0026lt;n; j++) //一趟选择排序 if (A[j] \u0026lt; A[k]) k=j; //\u0026lt;升序 \u0026gt;降序 if(i!=k) t=A[i], A[i]=A[k], A[k]=t; } } #define N 10 int main() { int A[N],i; srand((unsigned int)time(0)); //设置随机数种子 for(i=0; i\u0026lt;N; i++) { //随机产生N个数 A[i] = rand()%100; cout\u0026lt;\u0026lt;A[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; SelectionSort(A,N); for(i=0; i\u0026lt;N; i++) cout\u0026lt;\u0026lt;A[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; //输出排序结果 return 0; （2）用数组解决查找问题 顺序查找法 就是这个比较，返回数组下标。\n#include \u0026lt;iostream\u0026gt; using namespace std; int Search(int A[],int n,int find) { //顺序查找 n=序列元素个数 find=欲查找数据 int i; for (i=0; i\u0026lt;n ; i++) if (A[i]==find) return i; return -1; //未找到 } #define N 10 int main() { int A[N]={18,-3,-12,34,101,211,12,90,77,45}, i,find; cin\u0026gt;\u0026gt;find; i=Search(A,N,find); if(i\u0026gt;=0) cout\u0026lt;\u0026lt;\u0026#34;A[\u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34;]=\u0026#34;\u0026lt;\u0026lt;find\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;\u0026#34;not found\u0026#34;\u0026lt;\u0026lt;endl; return 0; } 二分查找法 先排序，后查找\n#include \u0026lt;iostream\u0026gt; using namespace std; int BinarySearch(int A[],int n,int find) { //二分查找 n=序列元素个数 find=欲查找数据 int low,upper,mid; low=0 , upper=n-1; //左右两部分 while(low\u0026lt;=upper) { mid = low + (upper-low)/2; //不用(upper+low)/2，避免upper+low溢出 if( A[mid] \u0026lt; find) low = mid+1; //右半部分 else if (A[mid] \u0026gt; find) upper = mid - 1; //左半部分 else return mid; //找到 } return -1; //未找到 } #define N 10 int main() { int A[N]={8,24,30,47,62,68,83,90,92,95},i,find; cin\u0026gt;\u0026gt;find; i=BinarySearch(A,N,find); if(i \u0026gt;= 0) cout\u0026lt;\u0026lt;\u0026#34;A[\u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34;]=\u0026#34;\u0026lt;\u0026lt;find\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;\u0026#34;not found\u0026#34;\u0026lt;\u0026lt;endl; return 0; } 指针的定义与使用 （1）指针的定义 return语句只能返回一个值，即使有多个return也只还回第一个。加上数组也是只针对多个相同类型的数据，如果使用指针就可以想返回多少就返回多少。指针是两个函数进行数据交换必不可少的工具。\n 指针记录某一变量的地址，指针本身也有地址，存于特定的区域 int *pa=pb的写法正确，* 是间接寻址符或者叫取值符,可以理解为从pa指针取出的值是整形。但如果在声明中赋值也是可以的，因为pa在声明中也确实是指针，可以理解为把 *分配给了int，可以理解定义了一个指向int的指针，所以应该使用地址赋值，而不是数值赋值。 *pa单独出现代表了从pa指向的地址中取出来的值，前面要是加上int,char等声明，* pa就只是代表pa指针了。 int *pa;pa=\u0026amp;a这样声明也可以 \u0026amp; 是取地址运算符  由于指针数据的特殊性，其初始化和赋值运算是有约束条件的，只能使用以下四种值： （1）0值常量表达式\np1=null; //正确，指针允许0值常量表达式 p1=0; //正确，指针允许0值常量表达式 （2）相同指向类型的对象的地址。 （3）相同指向类型的另一个有效指针。例如：\nint x, *px=\u0026amp;x; //正确 int *py=px; //正确，相同指向类型的另一个指针 （4）对象存储空间后面下一个有效地址，如数组下一个元素的地址。\nint a[10], *px=\u0026amp;a[2]; //正确 int *py=\u0026amp;a[++i]; //正确，相同指向类型的另一个指针 （2）指针的有效性和运算 无效的情况 如果指针的值为0，称为0值指针，又称空指针（null pointer），空指针是无效的。\n如果指针未经初始化，或者没有赋值，或者指针运算后指向未知对象，那么该指针是无效的。\n一个指针曾经指向一个已知对象，在对象的内存空间释放后，虽然该指针仍是原来的内存地址，但指针所指已是未知对象，称为“迷途指针”\n如果指针的位置停留在未知的位置，那么修改指针的值有可能造成重要的数据被修改。\n指针的运算 （1）指针加减整数运算\nint x[10], n=3 , *p=\u0026amp;x[5]; p+1 //指向存储空间中x[5]后面的第1个int型存储单元 p+n //指向存储空间中x[5]后面的第n(3)个int型存储单元 p-1 //指向存储空间中x[5]前面的第1个int型存储单元 p-n //指向存储空间中x[5]前面的第n(3)个int型存储单元 （2）指针变量自增自减运算\nint x[10], *p=\u0026amp;x[5]; p++ //p指向x[5]后面的第1个int型内存单元 ++p //p指向x[5]后面的第1个int型内存单元 p-- //p指向x[5]前面的第1个int型内存单元 --p //p指向x[5]前面的第1个int型内存单元 （3）两个指针相减运算\nint x[5], *p1=\u0026amp;x[0], *p2=\u0026amp;x[4]; int n; n=p2-p1;//n的值为4 （4）指针的关系运算 即比较地址数据的大小，位置的前后。\nconst的三种 主要应用领域是让实参于函数中不可修改 单const\nconst int *p//代表不可以改变变量的值，但是可以改变指针指向， //实际编程中，指向const的指针常用作函数的形参，以此确保传递给函数的实参对象在函数中不被修改。 int *const pc=\u0026amp;a//代表地址不可以改了，但数值可以改 双const\nconst int *const cpc=\u0026amp;b\n指针与数组 一维数组与指针 数组名既代表数组本身，又代表整个数组的地址，还是是数组首元素的地址值.\nint a[10], b[10], c[10]; a=b; //错误，a是常量不能出现在左值的位置 c=a+b; //错误，a、b是地址值，不允许加法运算 a++; //错误，a是常量不能使用++运算 int a[]; int *p p=a//数组的名称就代表了地址 pb=\u0026amp;a[0]//a[0]就是变量了，要用取地址运算符 *(a+i) *(p+i) 上述代码都是成立的\n区别  指针并不能被赋予常量的值int *p,p=2//是错的 指针所存储的是变量的地址值，指针可以进行数加减，自增，自减；相减时值得注意，间隔几个元素取决他的类型。也可以进行关系运算 数组的数组名不可以进行这些操作  （1）使用下标法访问数组元素，程序写法比较直观，能直接知道访问的是第几个元素。\n（2）而使用指针引用法，指针变量直接指向元素，不必每次都重新计算地址，能提高运行效率。\n（3）将自增和自减运算用于指针变量十分有效，可以使指针变量自动向前或向后指向数组的下一个或前一个元素。\n指针写起来更简捷一些\n（2）指针与字符串 char *p=\u0026#34;C Language\u0026#34;; //或者 char *p; p=\u0026#34;C Language\u0026#34;; 访问\nchar str[]=\u0026#34;C Language\u0026#34;, *p=str; //p指向字符串的指针 cout\u0026lt;\u0026lt;p\u0026lt;\u0026lt;endl; //输出：C Language cout\u0026lt;\u0026lt;p+2\u0026lt;\u0026lt;endl; //输出：Language cout\u0026lt;\u0026lt;\u0026amp;str[7]\u0026lt;\u0026lt;endl; //输出：age 遍历\nchar str[]=\u0026#34;C Language\u0026#34; , *p=str; //p指向字符串的指针 while (*p!=\u0026#39;\\0\u0026#39;) cout\u0026lt;\u0026lt;*p++; 指针与函数 （1）指针作为函数的参数 指针是函数参数传递的重要工具。比如swap交换函数要使用指针，直接使用变量会生成副本。通过将指针作为函数参数的方法，既可以返回多个运算结果，又避免了使用全局变量。\n（2）数组作为函数的参数 数组同样是直接使用地址，不使用副本，直接修改原数组数据。将一个字符串传递到函数中，传递的是地址，则函数形参既可以用字符数组，又可以用指针变量，两种形式完全等价。在子函数中可以修改字符串的内容，主调函数得到的是变化后的字符串。\n（3）引用 引用类型是结合了数组和指针的优点，不在C语言中，而属于C++的一个特性。\n 引用类型自带const限定，引用一旦被初始化，就不能改变引用关系，不能再作为其他对象的引用。 初始化是必定要绑定赋值，不能为空 写法是int x;\u0026amp;r=x  int x, \u0026amp;r=x; //定义整型变量x,y int *p1=\u0026amp;x; //p1指向x int *p2=\u0026amp;r; //p2指向r，本质上指向x //程序① 传递对象本身 #include \u0026lt;iostream\u0026gt; using namespace std; //对象作为函数形参 void swap(int a,int b) { int t; t=a, a=b, b=t; } int main() { int x=10, y=20; swap(x,y); 12 cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34;,\u0026#34;\u0026lt;\u0026lt;y; 13 return 0; 14 } //程序② 传递对象的指针 #include \u0026lt;iostream\u0026gt; using namespace std; //指针作为函数形参 void swap(int *a,int *b) { int t; t=*a, *a=*b, *b=t; } int main() { int x=10, y=20; swap(\u0026amp;x,\u0026amp;y); cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34;,\u0026#34;\u0026lt;\u0026lt;y; return 0; } //程序③ 传递对象的引用 #include \u0026lt;iostream\u0026gt; using namespace std; //引用作为函数形参 void swap(int \u0026amp;a,int \u0026amp;b) { int t; t=a, a=b, b=t; } int main() { int x=10, y=20; swap(x,y); cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34;,\u0026#34;\u0026lt;\u0026lt;y; return 0; （4）指向函数的指针 函数代码在内存中也要占据一段存储空间（代码区内），这段存储空间的起始地址称为函数入口地址。C++规定函数入口地址为函数的指针，即函数名既代表函数，又是函数的指针（或地址）。\nC++允许定义指向函数的指针变量，定义形式为：\nint (*p)(int a, int b); //定义函数指针变量 int max(int a, int b); //max函数原型 int min(int a, int b); //min函数原型 int (*p)(int a, int b); //定义函数指针变量 p=max; c=p(a,b); //等价于c=max(a,b); 变为动态方式调用。熟练掌握函数指针的应用，有利于程序的模块化设计，提高程序的可扩展性。\n动态分配内存 （1）new与delete运算符 数据类型* 指针名称 = new 数据类型 int* p = new int delete p; 可以拓展到结构体或类\n动态分配是根据程序的需要适时分配，且分配的大小就是程序要求的大小。分配的空间可以根据程序的需要扩大或缩小；\nnew 动态分配\nnew [] 动态分配数组\ndelete 释放空间\ndelete [] 释放数组空间\n（2）动态内存的应用 ►（1）静态内存管理由编译器进行，而动态内存管理按程序员人为的指令进行。\n►（2）动态内存分配和释放必须对应，即有分配就必须有释放，后果是随着程序运行多次，可以使用的内存空间越来越少.\n► （3）动态分配内存的生命期由程序员决定，即从分配时开始，至释放时结束。特别地，动态分配内存的生命期允许跨多个函数。\n►（4）避免释放内存后出现“迷途指针”，应及时设置为空指针。\n#include \u0026lt;iostream\u0026gt; using namespace std; int *f1(int n) //分配n个整型内存，返回首地址 { int *p, i; p = new int[n]; //分配 for (i=0; i\u0026lt;n; i++) p[i]=i; //赋初始值 return p; //动态分配的指针返回是有意义的 } void f2(int *p,int n) //输出动态内存中的n个数据 { while (n--\u0026gt;0) cout\u0026lt;\u0026lt;*p++\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } void f3(int *p) { delete [] p; } //释放内存 int main() { int *pi; pi=f1(5); //分配 f2(pi,5); //输出 f3(pi); //释放 return 0; } int *f1(int n)返回指针的函数\n（3）动态分配数组 #include \u0026lt;iostream\u0026gt; using namespace std; double AVE(double *A,int N) //计算N*N二维数组元素的平均值 { int i,j,sum=0; for(i=0;i\u0026lt;N;i++) for(j=0;j\u0026lt;N;j++) sum=sum+*(A+i*N+j); return sum/(N*N); } int main() { int i,j,n=4; cin\u0026gt;\u0026gt;n; double *A=new double[n*n]; //分配“数组”A[n][n] for (i=0;i\u0026lt;n;i++) for (j=0;j\u0026lt;n;j++) cin\u0026gt;\u0026gt;*(A+i*n+j); //输入数据到A[i][j] cout\u0026lt;\u0026lt;\u0026#34;detA=\u0026#34;\u0026lt;\u0026lt;AVE(A,n)\u0026lt;\u0026lt;endl; delete [] A; //释放“数组” return 0; } （4）动态分配字符串 char *p=new char[1000]; //分配字符串空间 cin\u0026gt;\u0026gt;p; //输入字符串 cout\u0026lt;\u0026lt;p; //输出字符串 delete [] p; //释放字符串空间 结构体 基本知识 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { cout\u0026lt;\u0026lt;\u0026#34;hello\\n\u0026#34;; struct DATA{ int year; int mouth; int day; }; struct staff{ int no; char name[21]; char sex; DATA birthday; double salary; }; staff s1={1001,\u0026#34;archer\u0026#34;,\u0026#39;m\u0026#39;,{1980,1,1},2900.0};//s1是一个结构体对象， cout\u0026lt;\u0026lt;s1.birthday.year;//成员引用使用. //成员只可以逐个输入和输出 }  结构体声明一般放在开头，也可以放在main的外面。大概等价于数据类型的定义和声明，也不会在声明中分配存储空间，实例化才会分配存储空间，空间是连续按顺序的。 可以放在函数内部，但此时这个声明是局部的，而不是全局的。 结构体对象可以赋值，但不可以算数和比较运算。  结构体和指针的关系 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { cout\u0026lt;\u0026lt;\u0026#34;hello\\n\u0026#34;; struct DATA{ int year; int mouth; int day; }; DATA d={1980,1,1};//一个奇怪的devc++规则，即用即声明，但反正也不麻烦 //更新，可以在结构体后声明成员，但前提是要把结构体的创建写到main函数外部 struct staff{ int no; char name[21]; char sex; DATA *pbirthday; double salary; }; staff *p;//指针可以提前声明然后赋值，这里声明s1会报错 staff s1={1001,\u0026#34;archer\u0026#34;,\u0026#39;m\u0026#39;,\u0026amp;d,2900.0}; p=\u0026amp;s1;//赋地址值，没有*，下方编译成功 cout\u0026lt;\u0026lt;p-\u0026gt;sex\u0026lt;\u0026lt;endl;//这是字母l不是一数字1，/用于除法和注释 p-\u0026gt;pbirthday-\u0026gt;year=2008; p-\u0026gt;sex=\u0026#39;w\u0026#39;; cout\u0026lt;\u0026lt;s1.sex\u0026lt;\u0026lt;endl; } 结构体和数组的关系 如同声明int,char数组，可以用结构体进行声明。用这个方法可以表示几何的点。\n#include\u0026lt;iostream\u0026gt; using namespace std; struct staff{ int no; char name[21]; double salary; }a[3],t; int main() { cout\u0026lt;\u0026lt;\u0026#34;hello\\n\u0026#34;; int i,j; for (i=0;i\u0026lt;3;i++) cin\u0026gt;\u0026gt;a[i].name \u0026gt;\u0026gt;a[i].no \u0026gt;\u0026gt;a[i].salary; for (i=0;i\u0026lt;3;i++) cout\u0026lt;\u0026lt;a[i].name \u0026lt;\u0026lt;a[i].no \u0026lt;\u0026lt;a[i].salary\u0026lt;\u0026lt;endl; }; 结构体和函数的关系 就像传int类型等，直接传递进去，在函数内部进行各种操作。 对结构体数组进行传递，是对首地址进行传入。\n共用体  对于实体对象，分配的存储空间是成员内存的最大值。 定义和结构体的定义和引用相似。使用union定义，   修改一个成员的值会让其他值都改变 成员的首地址相同，所有成员的值相同，不同成员所用到的内存长度有差异  枚举类型(enum)  定义都是相似的 必须是指定值 枚举常量是右值不是左值  没有给定值时从0往后排\nenum COLORS {RED=10,GREEN=8,BLUE,BLACK,WHITE}; //RED为10、GREEN为8、BLUE为9、BLACK为10、WHITE为11。 RED=10; //错误，RED不是左值，不能被赋值 GREEN++; //错误，GREEN不是左值，不能自增自减 enum DIRECTION {LEFT,UP,RIGHT,DOWN,BEFORE,BACK} dir=LEFT; typedef 就是把一个结构的名字进行更改\n自定义数据类型的应用——链表 基础知识 链表主要用于两个目的：一是建立不定长度的数组。二是链表可以 在不重新安排整个存储结构的情况下，方便且迅速地插入和删除数 据元素。\nstruct NODE { //结点数据类型 ElemType data; //数据域 NODE *link; //指针域 }; 首先设计一种称为结点（node）的数据类型： 这个结构体类型中，data成员表示数据域，代表结点的数据信息。\nElemType可以是简单的内置数据类型，也可以是复杂的数据类型， 如\ntypedef struct tagElemType { //复杂的数据元素类型 ...... //任意数目、任意组合、任意类型的数据成员 } ElemType; 数据域是链表中的信息对象（元素），实际应用中结合具体要求设 计其数据类型。为方便介绍，将ElemType简单设定为int型，即\ntypedef int ElemType; //简单的数据元素类型 link成员表示指针域，存放另一个结点的地址，是链表中的组织者。 假定有一个NODE类型的对象指针L，将一个新结点的地址赋给L的 link成员，则L可以通过它的link成员“链接”到新结点上，重复这 个过程可以得到链表结构。\n链表的类型 struct LNode { //单链表结点类型 ElemType data; //数据域\nLNode *next; //指针域：指向直接后继结点 }; typedef LNode* LinkList; //LNode为单链表结构体类型， LinkList为单链表指针类型\n此外还有双链表和循环链表\n创建单链表 创建链表常用两种方法：头插法和尾插法。\n头插法 #include \u0026lt;iostream\u0026gt; using namespace std; typedef int ElemType; //简单的数据元素类型 struct LNode { //单链表结点类型 ElemType data; //数据域 LNode *next; //指针域：指向直接后继结点 }; typedef LNode* LinkList; //LNode为单链表结构体类型，LinkList为单链表指针类型 void input(ElemType *ep) //实现数据域元素输入的定制函数 { //在函数中可以写更加复杂、任意形式、任意数目的输入 cin\u0026gt;\u0026gt;*ep; } void CreateLinkF(LinkList *L,int n,void(*input)(ElemType*)) { //头插法创建单链表，调用input输入函数输入数据 LinkList s; *L=new LNode;//创建头结点 (*L)-\u0026gt;next=NULL; //初始时为空表 for (; n\u0026gt;0; n--) { //创建n个结点链表 s=new LNode; //创建新结点 input(\u0026amp;s-\u0026gt;data); //调用input输入数据域 s-\u0026gt;next=(*L)-\u0026gt;next; //将s增加到开始结点之前 (*L)-\u0026gt;next=s; //头结点之后 } } int main() { LinkList L; int n; cin\u0026gt;\u0026gt;n; CreateLinkF(\u0026amp;L,n,input); } 尾插法 #include \u0026lt;iostream\u0026gt; using namespace std; typedef int ElemType; //简单的数据元素类型 struct LNode { //单链表结点类型 ElemType data; //数据域 LNode *next; //指针域：指向直接后继结点 }; typedef LNode* LinkList; //LNode为单链表结构体类型，LinkList为单链表指针类型 void input(ElemType *ep) //实现数据域元素输入的定制函数 { //在函数中可以写更加复杂、任意形式、任意数目的输入 cin\u0026gt;\u0026gt;*ep; } void CreateLinkR(LinkList *L,int n,void(*input)(ElemType*)) { //尾插法创建单链表，调用input输入函数输入数据 LinkList p,s; p=*L=new LNode; //创建头结点 for (; n\u0026gt;0; n--) { //创建n个结点链表 s=new LNode; //创建新结点 input(\u0026amp;s-\u0026gt;data); //调用input输入数据域 p-\u0026gt;next=s, p=s; //将s插入到当前链表末尾 } p-\u0026gt;next=NULL; //尾结点 } int main() { LinkList L; int n; cin\u0026gt;\u0026gt;n; CreateLinkR(\u0026amp;L,n,input); } 链表的撤销 void DestroyList(LinkList *L) //销毁单链表L { LinkList q,p=*L; //p指向头结点 while(p!=NULL) { //若不是链尾继续 q=p-\u0026gt;next; //指向直接后继结点 delete p; //释放结点存储空间 p=q; //直接后继结点 } *L=NULL; //置为空表 链表的运算 链表的遍历 即p=p-\u0026gt;next\n查找节点 int compare(ElemType *ep1,ElemType *ep2) //实现两个数据元素关系比较的定制函数 {//在函数中对数据元素进行定制的关系比较，如相等，大于或小于 if (*ep1==*ep2) return 1; //满足相等关系返回真（1） return 0; //不满足关系返回假（0） int LocateElem(LinkList L,ElemType e, int(*compare)(ElemType*,ElemType*)) {//返回L中第1个与e满足关系compare()的元素的位序 int i=0; LinkList p=L-\u0026gt;next; //p指向开始结点 while(p!=NULL) { //若不是链尾继续 i++; //记录结点的位序 if(compare(\u0026amp;(p-\u0026gt;data),\u0026amp;e)) return i; p=p-\u0026gt;next; //指向直接后继结点 } return 0; //关系不存在返回0 插入节点 int ListInsert(LinkList *L,int i,ElemType e) { //在第i个位置之前插入元素e LinkList s,p=*L; //p指向头结点 while(p!=NULL \u0026amp;\u0026amp; i\u0026gt;1) { //寻找第i-1个结点 p=p-\u0026gt;next; //p指向直接后继结点 i--; } if(p==NULL||i\u0026lt;1) return 0; //i值不合法返回假（0） s=new LNode; //创建新结点 s-\u0026gt;data=e; //插入L中 s-\u0026gt;next=p-\u0026gt;next, p-\u0026gt;next=s; //结点插入算法 return 1; //操作成功返回真（1） 删除节点 int ListDelete(LinkList *L,int i,ElemType *ep) { //删除第i个结点,并由*ep返回其值 LinkList p=NULL,q=*L; //q指向头结点 while(q!=NULL \u0026amp;\u0026amp; i\u0026gt;=1) { //直到第i个结点 p=q; //p是q的前驱 q=q-\u0026gt;next; //q指向直接后继结点 i--; } if(p==NULL||q==NULL) return 0;//i值不合法返回假（0） p-\u0026gt;next=q-\u0026gt;next; //结点删除算法 if(ep!=NULL) *ep=q-\u0026gt;data; //删除结点由*ep返回其值 delete q; //释放结点 return 1; //操作成功返回真（1） ","permalink":"https://tassel234.github.io/posts/note/c++%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/","summary":"数组的定义和使用 （1）一维数组的定义、初始化、引用 使用数组，可以方便地定义一个名字（数组名）来表示大批量数据，并能够通过循环批处理大量数据。 一维数组是由元素类型、数组名和长度组成的构造类型。例如： int A[10], B[20]; // 元素是整型 常量表达式表示数组中元素的个数，称为数组长度。常量表达式的值必须为","title":"C++入门学习笔记-3(数组，指针，结构体)"},{"content":"图论入门_2 图着色 图着色可以应用于调度问题，平面图的点着色也和著名的四色问题也有很深的联系。\n点着色 即一条边上两点的颜色均不相同。顶点着色可以应用于调度问题，即日程安排或工作安排问题。对不同的人执行两种或以上的操作构成图，对着色相同的各个事件，在同一段时间平行的去做，节约时间成本。\n任意图都是最大度加一可顶点着色的。\n布鲁克斯定理 对于连通图G，如果G不是完全图，又不是奇数长的圈，则G是可顶点着色的  可以知道，除了上述给出的两种情况，其他图都是可以（最大度加一）减 可着色的。\n非正则的连通图都是最大度-可以顶点着色的。 G是2-可顶点着色，G是二部图，G中不含奇数长的圈这三个命题等价。  3-顶点可着色问题是np完全问题。\n4-顶点也是np完全问题，等价于四色问题。\n任意平面图都存在度不超过5的顶点。 五色定理：任意平面图都是5-可着色的。  边着色 如果图中用5中颜色进行了边着色，因为任意平面图都存在度不超过5的顶点，所以不能使用颜色更少的方案。\n维京定理：任意图可边着色数都小于或等于最大度加一。  而由定义可知，图可边着色数要大于等于最大度数。\n克里希定理：对任意二部图，边着色就是最大度数。  最大流问题 什么是最大流问题 最大流问题是一种组合优化问题，讨论如何充分利用装置的能力，使得运输的流量最大以取得最好的效果的问题。有容量限制原则和流量守恒原则。\ns表示网络的源点. t表示网络的汇点.\n福特- 富尔克森算法 残留网络，给出某路径和流量后反向生成新的路径和对应的流量，生成的路径可以视为新的路（增广路），增广路相当于可以把流量流回去，然后进行查找，重复几次，同向的流可以合并，没有流量的路可以擦掉。当找不到通往终点的路径了，就可以认为程序完成了。\n最大流最小割定理 穿过某些路径进行分割，一个部分含s,一个部分含t,将节点分为两个部分称为割。\n割选中的路径流量累计，也称作容量（特别注意，流量的计算是针对对含起点的部分指向外部的割边，反向的路不计算）最小的割叫做图的最小割。\n最小割定理：最大流等于最小割的容量。\n匹配问题 什么是匹配 就是把点和点通过线做一一对应，一个点只能被一个点匹配和一个点只能匹配一个点。 主要应用于二部图，在二部图里像一一映射。\n二向图中的匹配 极大匹配的定义是不能再添加其他边了。\n最大匹配的就是指边数最多的情况。\n最大匹配一定是极大匹配，但极大匹配不一定是最大匹配。\n如四点三段直线图。\n霍尔定理刻画了二部图完美匹配的存在性。\n匈牙利算法 和福特- 富尔克森算法很类似\n先随意确定几个路径，然后利用增广路进行反悔，如搜索5a1d这条路，然后修改。\n用求解最大流问题的算法求解匹配问题 甚至可以直接转化为最大流问题，使用对应的算法求解。\n","permalink":"https://tassel234.github.io/posts/note/%E5%9B%BE%E8%AE%BA%E5%85%A5%E9%97%A8_2/","summary":"图论入门_2 图着色 图着色可以应用于调度问题，平面图的点着色也和著名的四色问题也有很深的联系。 点着色 即一条边上两点的颜色均不相同。顶点着色可以应用于调度问题，即日程安排或工作安排问题。对不同的人执行两种或以上的操作构成图，对着色相同的各个事件，在同一段时间平行的去做，节约时间成本。","title":"图论入门_2"},{"content":"资源 (主)算法图解动画软件\n我的第一本算法书\n图解算法使用c++\n传输数据的四个问题及其解决方法 B从A那里收到了消息,但作为消息发送者的A可能对卫抱有恶意,并在事后声称“这不是我发送的消息“。这种情况会导致互联网上的商业交易或合同签罪无法成立。这种行为便是事后否认。\n哈希函数 哈希值简介和特征 哈 希 函 数 可 以 把 给 定 的 数 据 转 换 成 固 定 长 度 的 无 规 律 数 值 。 转 换 后 的 无 规 律 数 值 可 以 作 为 数 据 摘 要 应 用 于 各 种 各 样 的 场 景 。哈希值多用16进制表示。\n 第 一 个 特 征 是 输 出 的 哈 希值 数 据 长 度 不 变 。 如果输入的数据相同，那么输出的哈希值也必然相同。 输入的数据相似，哪怕只有一比特的差别，也会导致输出的哈希值大不相同。 如果两个数据完全不同，输出的哈希值也可能是相同的，叫做哈希冲突。 不可能从哈希值反向推出原本的数据。 求哈希值的计算相对容易  哈 希 函 数 的 算 法 中 具 有 代 表 性 的 是 MD5、SHA-1 和 SHA-2 等 。 其 中 SHA-2是 现 在 应 用 较 为 广 泛 的 一 个 , 而 MD5 和 SHA-1 存 在 安 全 隐 患 , 不 推 荐 使 用 。\n哈希算法 哈希算法是使用哈希函数计算出一个键值对应的地址，然后建立哈希表。查找的速度和数据大小无关，在没有碰撞好溢出的情况下，一次即可查找成功。\n除留余数法 h（key）= key mod B //B最好选一个质数。 算出来的数当索引，索引对应地址。\n平方取中法 把数组平方后区中间的两个数字，也要分配100个地址。\n折叠法 把数据拆成几个部分，然后相加，即得到索引值。\n不过哈希值的设计原则之一是减小碰撞的产生（虽然前面几个例子碰的可厉害了），可以对拆分后的数据进行奇数或者偶数的反转，改进后的做法称为边界折叠法。\n数字分析法 适用于数据不会更改，且为数字类型的静态表。\n然后观察分析，排除重复率高的存在。\n碰撞和溢出处理 线型探测法 如果发生了碰撞，就以线型的方式往后查找空的位置。\n线性探测法通常视为环状结构，当后面满了，数据也可以加在前面。\n平方探测法 相当类似的键值聚集在一起后，线性探测法就不太适用了。\n可以使用平方探测法，把数先平方，然后加或者减某数字i，然后用质数b取模。\nb必须是4j+3的质数，i大于等于1，小于等于(b-1)/2\n再哈希法 第一种哈希函数溢出，就用第二种，再溢出，就是第三种，第四种等。\n链表法 让哈希表所在空间建立对应数目的链表，如果溢出直接加到后面。\n应 用 示 例 哈希函数也常用于数据的压缩。\n将 用 户 输 入 的 密 码 保 存 到 服 务 器 时 也 需 要 用 到 哈 希 函 数 。\n如 果 把 密 码 直 接 保 存 到 服 务 器 , 可 能 会 被 第 三 者 窃 听 , 因 此 需 要 算 出 密 码 的哈 希 值 , 并 只 存 储 哈 希 值 。 当 用 户 输 入 密 码 时 , 先 算 出 该 输 入 密 码 的 哈 希 值 , 再把 它 和 服 务 器 中 的 哈 希 值 进 行 比 对 。 这 样 一 来 , 就 算 保 存 的 晗 希 值 暴 露 了 , 鉴 于上 文 中 提 到 的 哈 希 函 数 的 第 五 个 特 征 ( 输 入 输 出 不 可 逆 ) , 第 三 者 也 无 法 得 知 原本 的 密 码 。\n共享密钥加密 就是加密方式和解密方式两者都知道，可以理解为实际上给的是一把钥匙和完全一样的副本，传输的是加密的数据，就不怕被窃听了。\n实 现 共 享 密 钥 加 密 的 算 法 有 凯 撤 密 码 、AES、DES、 动 态 口 令 等 , 其中 AES 的 应 用 最 为 广 泛 。\n但是因为加密的密钥也应该会通过互联网发送，密匙也有可能被窃听者盗取，于是信息又不安全了。\n既 然 密 钥 有 被 第 三 者 窃 听 的 风 险 , 那 也 可 以 先 加 密 密 钢 再 发 送 。用 这 种 方 式 , 又 会 产 生 如 何 把 加 密 密 钥 的 密 钢 发 送 给 对 方 的 问 题 , 还 是 回 到 了 一开 始 的 问 题 。因 此 需 要 找 到 可 以 把 密 钢 安 全 送 出 的 方 法 , 这 就 是 “ 密 钥 分 配 问 题 “。\n要 想 解 决 这 个 问 题 , 可 以 使 用 “ 宿 钥 交 换 协 议 “ 和 “ 公 开 密 钢 加 密 “ 两 种 方 法 。\n公开密匙加密 首先先由B生成共开密匙和私有密匙（开锁和上锁的钥匙不同），然后公开密匙发给A，或者发给很多人，或者直接公布在互联网，其他人用公开密匙进行加密，然后发给B，只有B可以用私有密匙对数据进行解密。\n提 示 实 现 公 开 密 钥 加 密 的 算 法 有 RAS 算 法 、 椭 圆 曲 线 加 密 算 法 等 , 其 中 使用 最 为 广 泛 的 是 RSA 算 法 。RSA 算 法 由 其 开 发 者 Rivest、Shamir、Adleman 的首 字 母 命 名 而 来 , 三 人 在 2002 年 获 得 了 图灵 奖 。\n这样做的安全性很高，因为只有B知道怎么解密。而且可以让其他很多人都可以发送数据给B，而不用一一传递密匙。 缺点是一般这种加密算法的实现速度很慢，比共享密钥法慢的多。 但即使这样监听者用一些方法也可以盗取，比如上图。因为公开密匙并不会显示是谁创建的，窃听者把 密 文 发 送 给 B, 这 个 密 文 由 B 发 出 的 公 开 密 钢 B 来 解 密 。 从 收 到 密文 到 解 密 密 文 都 没 发 生 任 何 问 题 , 因 此 B 也 意 识 不 到 数 据 己 经 被 穸 听 。 这 种通 过 中 途 替 换 公 开 密匙来 窃 听 数 据 的 攻 击 方 法 叫 作 \u0026quot; 中 间 人 攻 击 \u0026ldquo;。\n公 开 密 钥 的 可 靠 性 会 出 现 问 题 , 就 是 因 为 A 无 法 判 断 收 到 的 公 开 密 钢 是 否 来自 B。 要 想 解 决 这 个 问 题 , 就 要 用 到 之 后 会 讲 到 的 “ 数 字 证 书 “。\n公 开 密 钥 加 密 还 有 一 个 问 题 , 那 就 是 加 密 和 解 密 都 比 较 耗 时 , 所 以 这 种 方 法不 适 用 于 持 续 发 送 零 碎 数 据 的 情 况 。 要 想 解 决 这 个 问 题 , 就 要 用 到 “ 混 合 加 密 “。\n混合加密 对数据量较小的共享密匙进行公开加密，保证安全性。\n用加密和解密速度快的共享密匙进行主要数据的加密，保证速度。\n迪菲-赫尔曼密钥交换 这 种 合 成 方 法 有 三 个 特 征 。\n第 一 ,即使 持 有 P 和 合 成 的 密 钥 P-S, 也 无 法 把 密 钥 S 单 独 取 出 来 。\n第 二 , 不 管 是 怎 样 合 成 而 来 的 密匙 , 都 可 以 把 它 作 为 新 的 元 素 , 继 续 与别 的 密 钥 进 行 合 成 。 使 用 密 钥 卫 和 密 锏 P-S, 还 能合 成 出 新 的 密 钥 P-P-S。\n第三：合成的结果和顺序无关。\n双方分别创建自己的私有密匙并且妥善保管，然后使用一个公开密匙，反复加密。 得到相同的加密方式，相同的密匙。\n具体实现可以使用非常大的素数。\n消息认证码 我是真的感觉下面这三个兄弟，是真的兵来将挡水来土掩，反复套娃。\n首先是消息认证码，为了解决密文被篡改的情况。 必要条件是制作一个用于消息认证码的密钥，然后用安全的方法发送为B。消息认证码简称mac, 但还是有缺陷。 加密和解密是双向的，消息的来源A可能是恶意的，A可能在发送信息后矢口否认。\n数字签名 数字加密使用的公开密匙，但和一般的公开密匙不同，私有的是用来加密的，共有的是用来解密的，这在加密通信层面毫无意义，但却可以肯定是A发送的。\n补 充 说 明\n公 开 密 钥 加 密 的 加 密 和 解 密 都 比 较 耗 时 。 为 了 节 约 运 算 时 间 , 实 际 上 不 会 对消 息 直 接 进 行 加 密 , 而 是 先 求 得 消 息 的 哈 希 值 , 再 对 哈 希 值 进 行 加 密 , 然 后 将 其作 为 签 名 来 使 用 ( 请 参 考 下 图 ）\n但这样就完美了吗，不，还没有。\n因为公开密匙加密好数字签名 无法保证是信息的发送者。公开密匙可能会被第三方恶意替换，中转破译发送，接受者甚至无法注意到。\n数字证书 A应该向一个非常权威的认证中心去申请认证证书。\n将 公 开 密 钥 A 和 包 含 邮 箱 信 息 的 个 人 资 料 发 送 给 认 证 中 心 。\n认 证 中 心 对 收 到 的 资 料 进 行 确 认 , 判 断 其 是 否 为 A 本 人 的 资 料 。 确 认 完毕 后 , 认 证 中 心 使 用 自 己 的 私 有 密匙， 根 据 A 的 资 料 生 成 数 字 签 名 。\n认 证 中 心 将 生 成 的 数 字 签 名 和 资 料 放 进 同 一 个 文 件 中 。然后交给A，B确认邮箱地址，使用认证中心的密匙确认是否为认证中心给出的数字签名。\n但这是完美的了吗，其实还没有，因为窃听者也可以假冒认证公司发布证书。\n认 证 中 心 是 管 理 数 字 证 书 的 组 织 机 构 。 原 则 上 谁 都 可 以 成 为 认 证 中 心 ,所 以 认 证 中 心 的 数 量 也 比 较 多 , 但 建 议 在 经 过 政 府 审 查 的 大 型 企 业 机 构 进 行 申请 , 这 些 机 构 更 令 人 放 心 。\n所以套娃到最后信任的是权威。\n拓展资源 图解密码技术\n信息安全数学基础网课\n应用密码学 协议、算法与C源程序_protocols, algorithms, and source code in C\n密码学C_C++语言实现 原书第2版\n信息论、编码与密码学\n","permalink":"https://tassel234.github.io/posts/note/%E7%AE%97%E6%B3%95%E9%A2%84%E8%A7%88%E5%AE%89%E5%85%A8%E7%AF%87/","summary":"资源 (主)算法图解动画软件 我的第一本算法书 图解算法使用c++ 传输数据的四个问题及其解决方法 B从A那里收到了消息,但作为消息发送者的A可能对卫抱有恶意,并在事后声称“这不是我发送的消息“。这种情况会导致互联网上的商业交易或合同签罪无法成立。这种行为便是事后否认。 哈希函数 哈希值简介和","title":"算法预览（安全篇）"},{"content":"使用资源 图解数据结构，使用C++ 吴灿明 （源代码来自这里）\n递归法详解 斐波那契数列 /* [示范]：斐波那契数列的递归程序 */ #include\u0026lt;iostream\u0026gt; using namespace std; int fib(int);\t//fib()函数的原型声明 int main() { int i,n; cout\u0026lt;\u0026lt;\u0026#34;请输入要计算到第几项斐波那契数列：\u0026#34;;//如果输入的数字太大会导致算到负数 ，后面会越来越慢 cin\u0026gt;\u0026gt;n; for(i=0;i\u0026lt;=n;i++) //计算前n项斐波那契数列 cout\u0026lt;\u0026lt;\u0026#34;fib(\u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34;)=\u0026#34;\u0026lt;\u0026lt;fib(i)\u0026lt;\u0026lt;endl; return 0; } int fib(int n) // 定义函数fib() { if (n==0) return 0; // 如果n=0，则返回0 else if(n==1 || n==2)\t//如果n=1或n=2，则返回1 return 1; else\t// 否则返回 fib(n-1)+fib(n-2) return (fib(n-1)+fib(n-2)); } 汉诺塔问题 /* [示范]:利用汉诺塔函数求出不同圆盘数时圆盘的移动步骤 */ #include \u0026lt;iostream\u0026gt; using namespace std; void hanoi(int, int, int, int); // 函数原型 int main(void) { int j; cout\u0026lt;\u0026lt;\u0026#34;请输入圆盘数量：\u0026#34;; cin\u0026gt;\u0026gt;j; hanoi(j,1, 2, 3); return 0; } void hanoi(int n, int p1, int p2, int p3) { if (n==1) cout\u0026lt;\u0026lt;\u0026#34;圆盘从 \u0026#34;\u0026lt;\u0026lt;p1\u0026lt;\u0026lt;\u0026#34; 号木桩移到 \u0026#34;\u0026lt;\u0026lt;p3\u0026lt;\u0026lt;\u0026#34; 号木桩\u0026#34;\u0026lt;\u0026lt;endl; else { hanoi(n-1, p1, p3, p2); cout\u0026lt;\u0026lt;\u0026#34;圆盘从 \u0026#34;\u0026lt;\u0026lt;p1\u0026lt;\u0026lt;\u0026#34; 号木桩移到 \u0026#34;\u0026lt;\u0026lt;p3\u0026lt;\u0026lt;\u0026#34; 号木桩\u0026#34;\u0026lt;\u0026lt;endl; hanoi(n-1, p2, p1, p3); } } 由一些数学公式可得汉诺塔的执行步骤最小为$2^{n} -1$,n代表圆盘的个数\n动态规划法（DPA） 动态规划法（Dynamic Programming Aigorithm）是一种优化算法策略，主要应用于求解具有重叠子问题和最优子结构性质的问题。动态规划法的核心思想是将问题分解为更小的子问题(和分治法类似)，并将子问题的解存储在一个表中（分治法没有的），从而避免了对相同子问题的重复计算。\n动态规划法的基本步骤如下：\n 定义子问题：将原问题分解为若干个子问题。 定义状态：用数学表示子问题的解。 定义状态转移方程：描述子问题之间的关系，如何通过子问题的解计算原问题的解。 初始化边界条件：确定状态转移方程的初始值。 自底向上或自顶向下计算：根据状态转移方程逐步计算子问题的解，最终得到原问题的解。  动态规划法可以应用于各种问题，如最短路径问题、背包问题、字符串匹配问题等。动态规划法的一个重要应用场景是求解最优化问题，例如最大（最小）问题。通过动态规划，可以在多项式时间内求解这些问题，而其他方法（如穷举法）可能需要指数级时间。\n例如使用递归法进行斐波那契数列的Fib(9)计算时，需要反复计算Fib(4),Fib(5)等值，浪费了时间，使用动态规划算法将计算过的结果储存起来，在后续的计算中只需要判断数值的存在与否，若存在就直接调用。\nDijkstra 算法 Dijkstra算法,中文名音译作迪杰斯特拉算法或戴克斯特拉算法。\n回溯法—老鼠走迷宫 回溯法（Backtracking）是一种用于搜索解空间的算法，通常在组合问题、优化问题和约束满足问题等领域中使用。回溯法通过对解空间的节点进行深度优先搜索，尝试找到问题的解。当搜索到某个节点时，如果该节点不能继续搜索下去，就回溯到该节点的父节点并尝试其他分支。回溯法的基本思想是：先广搜索，后深入搜索。\n以下是回溯法的一般步骤：\n 定义问题的解空间：首先需要明确问题的解空间，即所有可能的解的集合。 确定解空间的组织结构：将解空间组织成树形结构，每个节点表示一个部分解。 设计回溯算法的递归函数：递归函数需要完成以下功能： a. 判断当前节点是否包含问题的解，如果是，则保存解并返回。 b. 如果当前节点不能包含问题的解，则回溯到父节点并尝试其他分支。  回溯法是枚举法的一种。\n老鼠走迷宫就是一种回溯法的应用。老鼠走迷宫问题的描述是:假设把一只老鼠放在一个没有盖子的大迷宫盒的入口处，盒中有许多墙，使得大部分路径都被挡住而无法前进。老鼠可以采用尝试错误的方法找到出口。不过，这只老鼠必须在走错路时就退回来并把走过的路记下来，避免下次走重复的路，就这样直到找到出口为止。简单来说，老鼠行进时必须遵守以下3 个原则:\n(1)一次只能走一格。\n(2) 遇到墙无法往前走时，则退回一步找找看是否有其他的路可以走。\n(3)走过的路不会再走第二次。\n人们对这个问题感兴趣的原因是它可以提供一种典型堆栈应用的思考方法。\n/*题目：设计一个 C++程序，使用链表堆栈来找出老鼠走迷宫的路线，1 表示该处有墙无法通过， 0表示[i][i]处无墙可通行，并且将走过的位置对应的数组元素内容标记为 2。*/ #include \u0026lt;iostream\u0026gt; #define EAST MAZE[x][y+1] //定义东方的相对位置 #define WEST MAZE[x][y-1] //定义西方的相对位置 #define SOUTH MAZE[x+1][y]\t//定义南方的相对位置 #define NORTH MAZE[x-1][y]\t//定义北方的相对位置 using namespace std; const int ExitX = 8; //定义出口的X坐标在第8列 const int ExitY = 10; //定义出口的Y坐标在第10行 struct list { int x,y; struct list* next; }; typedef struct list node; typedef node* link; int MAZE[10][12] = {1,1,1,1,1,1,1,1,1,1,1,1, //声明迷宫数组 1,0,0,0,1,1,1,1,1,1,1,1, 1,1,1,0,1,1,0,0,0,0,1,1, 1,1,1,0,1,1,0,1,1,0,1,1, 1,1,1,0,0,0,0,1,1,0,1,1,//1是墙，0是可走的路 1,1,1,0,1,1,0,1,1,0,1,1, 1,1,1,0,1,1,0,1,1,0,1,1, 1,1,1,1,1,1,0,1,1,0,1,1, 1,1,0,0,0,0,0,0,1,0,0,1,//最右下角的0代表出口 1,1,1,1,1,1,1,1,1,1,1,1}; link push(link stack,int x,int y); link pop(link stack,int* x,int* y); int chkExit(int ,int ,int,int); int main(void) { int i,j; link path = NULL; int x=1;\t//入口的X坐标 int y=1; //入口的Y坐标 cout\u0026lt;\u0026lt;\u0026#34;[迷宫的路径(0的部分)]\\n\u0026#34;\u0026lt;\u0026lt;endl; //打印出迷宫的路径图 for(i=0;i\u0026lt;10;i++) { for(j=0;j\u0026lt;12;j++) cout\u0026lt;\u0026lt;MAZE[i][j]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;endl; } while(x\u0026lt;=ExitX\u0026amp;\u0026amp;y\u0026lt;=ExitY) { MAZE[x][y]=2; if(NORTH==0) { x -= 1; path=push(path,x,y); } else if(SOUTH==0) { x+=1; path=push(path,x,y); } else if(WEST==0) { y-=1; path=push(path,x,y); } else if(EAST==0) { y+=1; path=push(path,x,y); } else if(chkExit(x,y,ExitX,ExitY)==1) // 检查是否走到出口了 break; else { MAZE[x][y]=2; path=pop(path,\u0026amp;x,\u0026amp;y); } } cout\u0026lt;\u0026lt;\u0026#34;[老鼠走过的路径(2的部分)]\u0026#34;\u0026lt;\u0026lt;endl; // 打印出老鼠走完迷宫后的路径图 for(i=0;i\u0026lt;10;i++) { for(j=0;j\u0026lt;12;j++) cout\u0026lt;\u0026lt;MAZE[i][j]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;endl; } return 0; } link push(link stack,int x,int y) { link newnode; newnode = new node; if(!newnode) { cout\u0026lt;\u0026lt;\u0026#34;Error！内存分配失败！\u0026#34;\u0026lt;\u0026lt;endl; return NULL; } newnode-\u0026gt;x=x; newnode-\u0026gt;y=y; newnode-\u0026gt;next=stack; stack=newnode; return stack; } link pop(link stack,int* x,int* y) { link top; if(stack!=NULL) { top=stack; stack=stack-\u0026gt;next; *x=top-\u0026gt;x; *y=top-\u0026gt;y; delete top; return stack; } else *x=-1; return stack; } int chkExit(int x,int y,int ex,int ey) { if(x==ex\u0026amp;\u0026amp;y==ey) { if(NORTH==1||SOUTH==1||WEST==1||EAST==2) return 1; if(NORTH==1||SOUTH==1||WEST==2||EAST==1) return 1; if(NORTH==1||SOUTH==2||WEST==1||EAST==1) return 1; if(NORTH==2||SOUTH==1||WEST==1||EAST==1) return 1; } return 0; } 八皇后问题 八皇后问题也是一种常见的堆栈应用实例。在国际象棋中的皇后可以对棋盘中的其他棋子直吃、横吃和对角斜吃(左斜吃或右斜吃都可)。现在要放入多个皇后到棋盘上，后放入的新皇后，放入前必须考虑所放位置的直线方向、横线方向或对角线方向是否已被放置了旧皇后，否则就会被先放入的旧皇后吃掉。这个问题难倒了高斯，但如果使用计算机思维和计算机的算力可以比较轻松的求得结果。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;cmath\u0026gt; #define EIGHT 8 //定义堆栈的最大容量 #define TRUE 1 #define FALSE 0 using namespace std; int queen[EIGHT]; //存放8个皇后的行位置 int number=0; //计算总共有几组解 //决定皇后存放的位置 //输出所需要的结果 int attack(int ,int); void print_table() { int x=0,y=0; number+=1; cout\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;八皇后问题的第\u0026#34;\u0026lt;\u0026lt;setw(2)\u0026lt;\u0026lt;number\u0026lt;\u0026lt;\u0026#34;组解\u0026#34;\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;\u0026#34;\\t\u0026#34;; for(x=0;x\u0026lt;EIGHT;x++) { for(y=0;y\u0026lt;EIGHT;y++) if(x==queen[y]) cout\u0026lt;\u0026lt;\u0026#34;\u0026lt;q\u0026gt;\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;\u0026lt;-\u0026gt;\u0026#34;; cout\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;\u0026#34;\\t\u0026#34;; } system(\u0026#34;pause\u0026#34;); } void decide_position(int value) { int i=0; while(i\u0026lt;EIGHT) { //是否受到攻击的判断式 if(attack(i,value)!=1) { queen[value]=i; if(value==7) print_table(); else decide_position(value+1); } i++; } } //测试在(row,col)上的皇后是否遭受攻击 //若遭受攻击则返回值为1,否则返回0 int attack(int row,int col) { int i=0,atk=FALSE; int offset_row=0,offset_col=0; while((atk!=1)\u0026amp;\u0026amp;i\u0026lt;col) { offset_col=abs(i-col); offset_row=abs(queen[i]-row); //判断两皇后是否在同一行或同一对角线上 if((queen[i]==row)||(offset_row==offset_col)) atk=TRUE; i++; } return atk; } //主程序 int main(void) { decide_position(0); return 0; } 算术表达式的表示法 我们正常的算数公式书写是中序法，而对于计算机来说处理较为复杂，解决方法就是使用前序法与后序法（后序法只使用一个堆栈缓冲区，前序法两个）。\n中序法转为前序法与后序法 可以使用括号法，值得注意的是每两个数进行一次运算就要一次括号。\n也可以使用堆栈法。\n(1)从右到左读进中序法表达式的每个字符\n(2)如果读进的字符为操作数，则直接输出到前序法表达式中。\n(3) 如果遇到“(”，则弹出堆内的运算符，直到弹出到一个“)”，两者互相抵消。\n(4)“)”的优先级在堆内比任何运算符都小，任何运算符的优先级都高过它，不过在堆栈外却是优先级最高者。\n(5)当运算符准备进入堆栈内时，必须和堆顶端的运算符比较，如果外面的运算符优先级高于或等于堆栈顶端的运算符则压入堆栈，如果优先级低于堆栈顶端的运算符就把堆栈顶端的运算符弹出直到堆栈顶端的运算符优先级低于外面的运算符或堆栈为空时，就再把外面这个运算符压入堆栈\n(6) 中序法表达式读完后，如果运算符堆栈不是空的，则将其内的运算符逐一弹出，输出到前序法表达式中即可。 前序法与后序法表达式转为中序法表达式 也可以使用括号法或堆栈法。\n 括号法的乘法除法运算符在前序法向后括一个，加减法括两个。符号向右取代 括号法的乘法除法运算符在后序法向前括一个，加减法括两个。符号向左取代  中序法求值 需要两个堆栈，一个用于存储运算符，一个存放操作数。 但计算方法和人算大同小异。\n前序法求值 需要两个堆栈，一个用于存储表达式，一个存放操作数。不需要比较操作符的优先级。\n后序法求值 只需要一个堆栈。不需要比较操作符的优先级，计算非常直观简单\n","permalink":"https://tassel234.github.io/posts/note/%E7%AE%97%E6%B3%95%E9%A2%84%E8%A7%88%E9%80%92%E5%BD%92%E6%B3%95%E5%92%8C%E7%AE%97%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/","summary":"使用资源 图解数据结构，使用C++ 吴灿明 （源代码来自这里） 递归法详解 斐波那契数列 /* [示范]：斐波那契数列的递归程序 */ #include\u0026lt;iostream\u0026gt; using namespace std; int fib(int); //fib()函数的原型声明 int main() { int i,n; cout\u0026lt;\u0026lt;\u0026#34;请输入要计算到第几项斐波那契数列：\u0026#34;;//如果输入的数字太大会导致算到负数","title":"算法预览（递归法和算数表达式）"},{"content":"堆栈简介 基本知识 也可以简写为栈，具有后进先出的特性（LIFO）\n与链表和数组一样，栈的数据也是线性排列，但在栈中，添加和删除数据的操作只能在一端进行，访问数据也只能访问到顶端的数据。想要访问中间的数据时，就必须通过出栈操作将目标数据移到栈顶才行。\n放入栈的顶端，称为压入PUSH,从顶端取出，称为弹出pop\n栈只能在一端操作，这一点看起来似乎十分不便，但在只需要访问最新数据时，使用它就比较方便了。另外，我们将要在接下来学习深度优先搜索算法，通常会选择最新的数据作为候补顶点。在候补顶点的管理上就可以使用栈。\n代码实现 使用数组实现堆栈 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; #define MAXSTACK 100\t//定义堆栈的最大容量 using namespace std; int stack[MAXSTACK];\t//声明用于堆栈操作的数组 int top=-1;\t//堆栈的顶端 //判断是否为空堆栈 int isEmpty() { if(top==-1) return 1; else return 0; } //将指定的数据压入堆栈 int push(int data) { if(top\u0026gt;=MAXSTACK) { cout\u0026lt;\u0026lt;\u0026#34;堆栈已满,无法再压入\u0026#34;\u0026lt;\u0026lt;endl; return 0; } else { stack[++top]=data;\t//top的值一直在变化，将数据压入堆栈 return 1; } } //从堆栈弹出数据 int pop() { if(isEmpty())\t//判断堆栈是否为空,如果是则返回-1 return -1; else return stack[top--];\t//将数据弹出后,再将堆栈指针往下移 //先输出，再自减 } //主程序 int main(void) { int value; int i; cout\u0026lt;\u0026lt;\u0026#34;请按序输入10个数据:\u0026#34;\u0026lt;\u0026lt;endl; for(i=0;i\u0026lt;10;i++) { cin\u0026gt;\u0026gt;value; push(value); } cout\u0026lt;\u0026lt;\u0026#34;====================\u0026#34;\u0026lt;\u0026lt;endl; while(!isEmpty())\t//将数据陆续从顶端弹出 cout\u0026lt;\u0026lt;\u0026#34;堆栈弹出的顺序为:\u0026#34;\u0026lt;\u0026lt;setw(4)\u0026lt;\u0026lt;pop()\u0026lt;\u0026lt;endl; //C++ setw() 函数用于设置字段的宽度, //语法格式如下setw(n)n 表示宽度,用数字表示。setw() 函数只对紧接着的输出产生作用。 //当后面紧跟着的输出字段长度小于 n 的时候，在该字段前面用空格补齐，当输出字段长度大于 n 时，全部整体输出。 cout\u0026lt;\u0026lt;\u0026#34;====================\u0026#34;\u0026lt;\u0026lt;endl; return 0; } //发牌程序 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;ctime\u0026gt; #include \u0026lt;cstdlib\u0026gt; using namespace std; void Swap(int*,int*); void push(int statck[],int MAX,int val); int pop(int stack[]); int top=-1; int main(void) { int card[52],stack[52]={0}; int i,j,k=0, ascVal; char suit[4][10]={\u0026#34;草花\u0026#34;,\u0026#34;方块\u0026#34;,\u0026#34;红桃\u0026#34;,\u0026#34;黑桃\u0026#34;}; int style; srand((unsigned)time(NULL));//srand函数是C语言中的种子函数,它的功能是生成一个随机数。 //srand(1); 直接使用1来初始化种子。不过为了防止随机数每次重复，常常使用系统时间来初始化， //即使用 time函数来获得系统时间，它的返回值为从 00:00:00 GMT, January 1, 1970 到现在所持续的秒数， //然后将time_t型数据转化为(unsigned)型再传给srand函数，即: srand((unsigned) time(\u0026amp;t)); //还有一个经常用法，不需要定义time_t型t变量,即: srand((unsigned) time(NULL)); //直接传入一个空指针，因为你的程序中往往并不需要经过参数获得的数据。 //若去掉这段语句，会造成接下来的数据一直保持在同一个值 for (i=0;i\u0026lt;52;i++) card[i]=i+1; cout\u0026lt;\u0026lt;\u0026#34;[洗牌中...请稍后!]\u0026#34;\u0026lt;\u0026lt;endl; while(k\u0026lt;30) { for(i=0;i\u0026lt;51;i++) for(j=i+1;j\u0026lt;52;j++) if(rand()%52==2)//不是52也可以，为什么是52呢 Swap(\u0026amp;card[i],\u0026amp;card[j]);//洗牌 k++; } i=0; while(i!=52) { push(stack,52,card[i]);//将52张牌压入堆栈 i++; } cout\u0026lt;\u0026lt;\u0026#34;[逆时针发牌]\u0026#34;\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;[显示各家拿到的牌]\u0026#34;\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34; 东家\\t\\t 北家\\t\\t 西家\\t\\t 南家\u0026#34;\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;=========================================================\u0026#34;\u0026lt;\u0026lt;endl; while (top \u0026gt;=0) { style = stack[top]/13;\t//计算扑克牌的花色 switch(style)\t//扑克牌花色对应的图标 { case 0:\t//梅花 ascVal=0; break; case 1:\t//方块 ascVal=1; break; case 2:\t//红心 ascVal=2; break; case 3:\t//黑桃 ascVal=3; break; } cout\u0026lt;\u0026lt;\u0026#34;[\u0026#34;\u0026lt;\u0026lt;suit[ascVal]\u0026lt;\u0026lt;setw(3)\u0026lt;\u0026lt;stack[top]%13+1\u0026lt;\u0026lt;\u0026#34;]\\t\u0026#34;; if(top%4==0) cout\u0026lt;\u0026lt;endl; top--; } return 0; } void push(int stack[],int MAX,int val) { if(top\u0026gt;=MAX-1) cout\u0026lt;\u0026lt;\u0026#34;[堆栈已经满了]\u0026#34;\u0026lt;\u0026lt;endl; else { top++; stack[top]=val; } } int pop(int stack[]) { if(top\u0026lt;0) cout\u0026lt;\u0026lt;\u0026#34;[堆栈已经空了]\u0026#34;\u0026lt;\u0026lt;endl; else top--; return stack[top]; } void Swap(int* a,int* b) { int temp; temp=*a; *a=*b; *b=temp; } 使用链表实现堆栈 使用链表设计堆栈的好处是链表的大小是可以变动的，不会造成内存空间的浪费 缺点是设计复杂\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; class Node\t//声明堆栈链表节点 { public: int data;\t//声明存放堆栈数据的变量 class Node *next;\t//堆栈中用来指向下一个节点的指针 }; typedef class Node Stack_Node;\t//定义堆栈中节点的新类型 typedef Stack_Node *Linked_Stack;\t//定义链表堆栈的新类型 Linked_Stack top=NULL;\t//指向堆栈顶端的指针 //判断是否为空堆栈 int isEmpty() { if(top==NULL) return 1; else return 0; } //将指定的数据压入堆栈 void push(int data) { Linked_Stack new_add_node;\t//新加入节点的指针 new_add_node=new Stack_Node;//分配内存给新节点 new_add_node-\u0026gt;data=data;\t//将传入的值赋值给节点的数据变量 new_add_node-\u0026gt;next=top;\t//将新节点指向堆栈的顶端 top=new_add_node;\t//新节点成为堆栈的顶端 } //从堆栈弹出数据 int pop() { Linked_Stack ptr;\t//指向堆栈顶端的指针 int temp; if(isEmpty())\t//判断堆栈是否为空,如果是则返回-1 { cout\u0026lt;\u0026lt;\u0026#34;===目前为空堆栈===\u0026#34;\u0026lt;\u0026lt;endl; return -1; } else { ptr=top;\t//指向堆栈的顶端 top=top-\u0026gt;next;\t//将堆栈顶端的指针指向下一个节点 temp=ptr-\u0026gt;data;\t//取出堆栈的数据 free(ptr);\t//将节点占用的内存释放 return temp;\t//将从堆栈取出的数据返回给主程序 } } //主程序 int main(void) { int value; int i; cout\u0026lt;\u0026lt;\u0026#34;请按序输入10个数据:\u0026#34;\u0026lt;\u0026lt;endl; for(i=0;i\u0026lt;10;i++) { cin\u0026gt;\u0026gt;value; push(value); } cout\u0026lt;\u0026lt;\u0026#34;====================\u0026#34;\u0026lt;\u0026lt;endl; while(!isEmpty()) //将数据陆续从顶端弹出 cout\u0026lt;\u0026lt;\u0026#34;堆栈弹出的顺序为:\u0026#34;\u0026lt;\u0026lt;setw(2)\u0026lt;\u0026lt;pop()\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;====================\u0026#34;\u0026lt;\u0026lt;endl; return 0; } 堆栈类模板的实现 样板的设计概念也被称为泛型编程，通过对模板输入特定的数据类型可以形成对应的函数或类。 C++有stl模板库，但本书并没有使用。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; using namespace std; template \u0026lt;class Type\u0026gt;\t// 定义链表中的节点 struct Node { Type data;\t// 记录数据 Node* next;\t// 记录下一笔节点的地址 }; template \u0026lt;class Type\u0026gt; class LinkedList\t// 链表类型 { private: Node\u0026lt;Type\u0026gt;* first;\t// 指到第一个节点的指针 public: LinkedList()\t// 构造函数 { first = NULL; } void addNode(Type data);\t// 加入节点 void display();\t// 显示所有的节点 }; template\u0026lt;class Type\u0026gt; void LinkedList\u0026lt;Type\u0026gt;::addNode(Type data) { Node\u0026lt;Type\u0026gt;* newNode = new Node\u0026lt;Type\u0026gt;;\t// 新增一个节点 newNode-\u0026gt;data = data;\t// 记录数据 newNode-\u0026gt;next = first;\t// 指向前一个节点 first = newNode;\t// 指向新的节点 } template\u0026lt;class Type\u0026gt; void LinkedList\u0026lt;Type\u0026gt;::display() { Node\u0026lt;Type\u0026gt;* currentNode = first; // 从第一个节点开始显示 while( currentNode != NULL ) { cout \u0026lt;\u0026lt; currentNode-\u0026gt;data \u0026lt;\u0026lt; \u0026#34; -\u0026gt; \u0026#34;; currentNode = currentNode-\u0026gt;next; } } int main() { LinkedList\u0026lt;double\u0026gt; dblList;\t// 建立一个存储double类型数据的链表 double num;\t// 记录输入的数据 char ch;\t// 记录用户的选择 do{ cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt;\u0026#34;请输入一个数字 : \u0026#34;; cin \u0026gt;\u0026gt; num; dblList.addNode( num ); cout \u0026lt;\u0026lt; \u0026#34;继续输入(y / n)?\u0026#34;; cin \u0026gt;\u0026gt; ch; }while( ch != \u0026#39;n\u0026#39; ); cout \u0026lt;\u0026lt; endl; dblList.display();\t// 显示所有的数据 cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; return 0; } #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; using namespace std; // 设置类样版的类型参数Type的默认值为整数int,非类型参数的类型为整数int,默认值为5 template \u0026lt;class Type = int, int size = 5\u0026gt;\t// 声明类样板 class Stack { private: Type st[size];\t// 声明一数组作为堆栈的存储空间 int top;\t// 堆栈数据顶端的索引 public: Stack() { top = -1; } void push(Type data);\t// 将数据压入堆栈 Type pop();\t// 将数据从堆栈中弹出 }; template \u0026lt; class Type, int size \u0026gt; void Stack\u0026lt; Type, size \u0026gt; :: push ( Type data ) { st[ ++top ] = data; } template \u0026lt; class Type, int size \u0026gt; Type Stack\u0026lt;Type, size\u0026gt; :: pop() { return st[ top-- ]; } int main() { Stack\u0026lt;\u0026gt; stk_1;\t// 声明一个堆栈对象, 并使用其默认值 Stack\u0026lt;char*, 4\u0026gt; stk_2;\t// 声明堆栈对象, 其类型为字符串, 大小为4 stk_1.push( 11 ); stk_1.push( 22 ); stk_1.push( 33 ); cout \u0026lt;\u0026lt; \u0026#34;stack_1 [1] = \u0026#34; \u0026lt;\u0026lt; stk_1.pop() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;stack_1 [2] = \u0026#34; \u0026lt;\u0026lt; stk_1.pop() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;stack_1 [3] = \u0026#34; \u0026lt;\u0026lt; stk_1.pop() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; endl; stk_2.push( \u0026#34;第一名\u0026#34; ); stk_2.push( \u0026#34;第二名\u0026#34; ); stk_2.push( \u0026#34;第三名\u0026#34; ); cout \u0026lt;\u0026lt; \u0026#34;stack_2 [1] = \u0026#34; \u0026lt;\u0026lt; stk_2.pop() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;stack_2 [2] = \u0026#34; \u0026lt;\u0026lt; stk_2.pop() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;stack_2 [3] = \u0026#34; \u0026lt;\u0026lt; stk_2.pop() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; endl; return 0; } 队列 (1)图遍历的广度优先搜索法 (BFS) 就是使用队列。 (2)可用于计算机的模拟，在模拟过程中，由于各种事件 的输入时间不一定，可以使用队列来反映真实的情况。 (3)可用于 CPU 的作业调度 ，利用队列来处理，可实现作业先到先执行的要求。 (4)外围设备联机并发处理系统的应用，也就是让输入/输出的数据先在高速磁驱动器中完成，把磁盘当成一个大型的工作缓冲区，如此可让输入/输出操作快速完成，因而缩短了系统响应的时间，接下来由系统软件负责将磁盘数据输出到打印机，其中就应用了队列的工作原理。\n认识队列 队列的基本操作 create,add,delete,front,empty\n用数组来实现队列 好处是算法简单，只需要front和rear来指队首和队尾，初始值都赋上-1，add,delete时对数据增加。 rear指向最后的元素，front指向最前面的元素的前一个位置，刚开始就是-1。 坏处是只能声明固定长度。\n/* [示范]：实现往队列中加入数据和从队列中取出数据 */ #include \u0026lt;iostream\u0026gt; using namespace std; const int MAX=20; //定义队列的大小 int main(void) { int front,rear,val,queue[MAX]={0}; char ch; front=rear=-1; while(rear\u0026lt;MAX-1\u0026amp;\u0026amp;ch!=\u0026#39;E\u0026#39;) { cout\u0026lt;\u0026lt;\u0026#34;输入I：往队列加入一个数据 输入G：从队列中取出一个数据\\n输入E：结束程序\\n请输入：\u0026#34;; cin\u0026gt;\u0026gt;ch; switch(ch) { case \u0026#39;I\u0026#39;: cout\u0026lt;\u0026lt;\u0026#34;[请输入数据]：\u0026#34;; cin\u0026gt;\u0026gt;val; rear++; queue[rear]=val; break; case \u0026#39;G\u0026#39;: if(rear\u0026gt;front) { front++; cout\u0026lt;\u0026lt;\u0026#34;[从队列中取出的数据为]: [\u0026#34;\u0026lt;\u0026lt;queue[front]\u0026lt;\u0026lt;\u0026#34;]\u0026#34;; cout\u0026lt;\u0026lt;endl; queue[front]=0; } else { cout\u0026lt;\u0026lt;\u0026#34;[队列已经空了]\u0026#34;\u0026lt;\u0026lt;endl; exit(0); } break; default: cout\u0026lt;\u0026lt;endl; break; } } if(rear==MAX-1) cout\u0026lt;\u0026lt;\u0026#34;[队列已经满了]\u0026#34;\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;[目前队列中的数据]:\u0026#34;; if (front\u0026gt;=rear) { cout\u0026lt;\u0026lt;\u0026#34;没有\u0026#34;\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;[队列已经空了]\u0026#34;\u0026lt;\u0026lt;endl; } else { while (rear\u0026gt;front) { front++; cout\u0026lt;\u0026lt;\u0026#34;[\u0026#34;\u0026lt;\u0026lt;queue[front]\u0026lt;\u0026lt;\u0026#34;]\\t\u0026#34;; } cout\u0026lt;\u0026lt;endl; } return 0; } 用链表实现队列 /* [示范]：以链表来实现队列 */ #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; class Node { public: int data; class Node *next; }; typedef class Node QueueNode; typedef QueueNode *QueueByLinkedList; QueueByLinkedList front=NULL; QueueByLinkedList rear=NULL; //方法enqueue：把数据加入队列 void enqueue(int value) { QueueByLinkedList node; //建立节点 node=new QueueNode; node-\u0026gt;data=value; node-\u0026gt;next=NULL; //检查是否为空队列 if (rear==NULL) front=node; //如果rear为NULL，表示这是队列的第一个元素（节点） else rear-\u0026gt;next=node; //将新元素（新节点）连接至队列末尾 rear=node; //将队列的末尾指针指向新加入的节点 } //方法dequeue：从队列中取出数据 int dequeue() { int value; //检查队列是否为空队列 if (!(front==NULL)) { if(front==rear) rear=NULL; value=front-\u0026gt;data; //从队列中取出数据 front=front-\u0026gt;next; //将队列的前端指针指向下一个 return value; } else return -1; } int main(void) { int temp; cout\u0026lt;\u0026lt;\u0026#34;用链表来实现队列\u0026#34;\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;====================================\u0026#34;\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;在队列前端加入第1个数据，此数据为1\u0026#34;\u0026lt;\u0026lt;endl; enqueue(1); cout\u0026lt;\u0026lt;\u0026#34;在队列前端加入第2个数据，此数据为3\u0026#34;\u0026lt;\u0026lt;endl; enqueue(3); cout\u0026lt;\u0026lt;\u0026#34;在队列前端加入第3个数据，此数据为5\u0026#34;\u0026lt;\u0026lt;endl; enqueue(5); cout\u0026lt;\u0026lt;\u0026#34;在队列前端加入第4个数据，此数据为7\u0026#34;\u0026lt;\u0026lt;endl; enqueue(7); cout\u0026lt;\u0026lt;\u0026#34;在队列前端加入第5个数据，此数据为9\u0026#34;\u0026lt;\u0026lt;endl; enqueue(9); cout\u0026lt;\u0026lt;\u0026#34;====================================\u0026#34;\u0026lt;\u0026lt;endl; while (1) { if (!(front==NULL)) { temp=dequeue(); cout\u0026lt;\u0026lt;\u0026#34;从队列前端按序取出的数据为：\u0026#34;\u0026lt;\u0026lt;setw(1)\u0026lt;\u0026lt;temp\u0026lt;\u0026lt;endl; } else break; } cout\u0026lt;\u0026lt;endl; return 0; } 环形队列 上述的数组程序可以实现先进先出的排队策略，但没有办法模拟排队的人走了接下来几位向前走的情形，没法加入其他数据。可以利用环形队列解决这个问题。\n当数据满了，把rear的值重写为0. (rear+1)mod n\nfront指向最前面的元素的前一个位置。\nrear指向的下一个是front时判断队列已经满了，队列只可以存放n-1个数据。\n/* [示范]：实现环状队列数据的进队和出队 */ #include \u0026lt;iostream\u0026gt; using namespace std; int main(void) { int front,rear,val=0,queue[5]={0}; front=rear=-1; while(rear\u0026lt;5\u0026amp;\u0026amp;val!=-1) { cout\u0026lt;\u0026lt;\u0026#34;请输入一个值以存入队列，欲取出值请输入-2。(结束输入-1)：\u0026#34;; cin\u0026gt;\u0026gt;val; if(val==-2) { if(front==rear) { cout\u0026lt;\u0026lt;\u0026#34;[队列已经空了]\u0026#34;\u0026lt;\u0026lt;endl; break; } front++; if (front==5) front=0; cout\u0026lt;\u0026lt;\u0026#34;取出队列值 [\u0026#34;\u0026lt;\u0026lt;queue[front]\u0026lt;\u0026lt;\u0026#34;]\u0026#34;\u0026lt;\u0026lt;endl; queue[front]=0; } else if(val!=-1 \u0026amp;\u0026amp; rear\u0026lt;5) { if(rear+1==front || rear==4 \u0026amp;\u0026amp; front\u0026lt;=0) { cout\u0026lt;\u0026lt;\u0026#34;[队列已经满了]\u0026#34;\u0026lt;\u0026lt;endl; break; } rear++; if(rear==5) rear=0; queue[rear]=val; } } cout\u0026lt;\u0026lt;\u0026#34;\\n队列剩余数据：\u0026#34;\u0026lt;\u0026lt;endl; if (front==rear) cout\u0026lt;\u0026lt;\u0026#34;队列已空!!\u0026#34;\u0026lt;\u0026lt;endl; else { while(front!=rear) { front++; if (front==5) front=0; cout\u0026lt;\u0026lt;\u0026#34;[\u0026#34;\u0026lt;\u0026lt;queue[front]\u0026lt;\u0026lt;\u0026#34;]\u0026#34;; queue[front]=0; } } cout\u0026lt;\u0026lt;endl; return 0; } 双向队列 一般双向队列的应用可以分为2种，一种是两端都可以加入数据但只有一段可以取出数据，另一种是两端都可以取出数据但只有一段可以加入数据。\n优先队列 每一个元素都赋给了一个优先级，加入任意，但取出时优先级高的先出，不是FIFO了。\n后记 我是使用devc++打开源代码的，其中可能会用目录寻找错误而导致打不开文件，这是因为编码方式不一样，容易出现汉字乱码，可以试试把文件打开路径的中文改成英文或拼音。\n","permalink":"https://tassel234.github.io/posts/note/%E4%BD%BF%E7%94%A8cpp%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/","summary":"堆栈简介 基本知识 也可以简写为栈，具有后进先出的特性（LIFO） 与链表和数组一样，栈的数据也是线性排列，但在栈中，添加和删除数据的操作只能在一端进行，访问数据也只能访问到顶端的数据。想要访问中间的数据时，就必须通过出栈操作将目标数据移到栈顶才行。 放入栈的顶端，称为压入PUSH,从顶","title":"使用Cpp实现数据结构-2（栈和队列）"},{"content":"资源 （主）图解数据结构，使用C++ 吴灿明 （源代码来自这里）\n使用软件\u0026quot;算法动画图解\u0026quot;\n我的第一本算法书（书中彩色配图来自上面那个软件）\n算法简单介绍 算法加数据结构构成可执行程序。\n算法的五个条件，输入，输出，有效，明确，有穷\n链表 链表主要用于两个目的：一是建立不定长度的数组。二是链表可以 在不重新安排整个存储结构的情况下，方便且迅速地插入和删除数 据元素。\n动态分配内存 3.1.1 C++的动态分配变量\n数据类型* 指针名称 = new 数据类型 int* p = new int delete p; 可以拓展到结构体或类\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; using namespace std; int main() { int *intptr = new int(50); //声明一指向整数的指针,在该内存中存入整数值50 float *floatptr = new float; //声明一指向浮点数的指针,但未指定内存中存储的数据值 cout \u0026lt;\u0026lt; \u0026#34;intptr 指向的数据值：\u0026#34; \u0026lt;\u0026lt; *intptr \u0026lt;\u0026lt; \u0026#34;\\n\\n\u0026#34;; *floatptr = 0.5; cout \u0026lt;\u0026lt; \u0026#34;floatptr 指向的数据值：\u0026#34; \u0026lt;\u0026lt; *floatptr \u0026lt;\u0026lt; \u0026#34;\\n\\n\u0026#34;; delete intptr; delete floatptr; return 0; } 3.1.2 动态分配数组\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; using namespace std; int main(){ int no,count=0, Total=0; // 定义整数变量 count 与 Total cout\u0026lt;\u0026lt;\u0026#34;要输入计算的个数为:\u0026#34;; cin\u0026gt;\u0026gt;no; int *ptr=new int[no]; // 动态分配数组为n个元素 cout\u0026lt;\u0026lt;endl;\tfor (count=0; count \u0026lt; no; count++)\t{\tcout \u0026lt;\u0026lt; \u0026#34;输入ptr[\u0026#34; \u0026lt;\u0026lt; count \u0026lt;\u0026lt; \u0026#34;]:\u0026#34;; cin \u0026gt;\u0026gt; ptr[count]; // 采用数组下标来输入数组元素 } for (count=0; count \u0026lt; no; count++) Total+=*(ptr+count); // 采用指针变量运算来存取数组的元素值 cout\u0026lt;\u0026lt;\u0026#34;---------------------------------------\u0026#34;\u0026lt;\u0026lt;endl; cout \u0026lt;\u0026lt; no\u0026lt;\u0026lt;\u0026#34;个数的总和=\u0026#34; \u0026lt;\u0026lt; Total; // 显示结果 cout \u0026lt;\u0026lt; endl; delete [] ptr; // 释放分配给 ptr 的内存空间 ptr=NULL;\treturn 0; } 单向链表 在C++网课学习期间已经对该部分内容有部分了解，和网课不同的是本书的程序不是由结构体，而是由类写的。\n接下来的笔记主要以程序为主，笔记以标注//形式写出。\n3.2.1 单向链表的创建与遍历\n#include \u0026lt;iostream\u0026gt; using namespace std; class list { public: int num,score; char name[10]; class list *next; }; typedef class list node;//删除class也可以，有class是偏c语言的写法 typedef node *link; int main() { link newnode,ptr,delptr; //声明三个链表结构的指针 cout\u0026lt;\u0026lt;\u0026#34;请输入 5 位学生的数据：\u0026#34;\u0026lt;\u0026lt;endl; delptr=new node; //delptr暂当链表头指针 if (!delptr) { cout\u0026lt;\u0026lt;\u0026#34;[Error!!内存分配失败!]\u0026#34;\u0026lt;\u0026lt;endl; exit(1); } cout\u0026lt;\u0026lt;\u0026#34;请输入学号：\u0026#34;; cin\u0026gt;\u0026gt;delptr-\u0026gt;num; cout\u0026lt;\u0026lt;\u0026#34;请输入姓名：\u0026#34;; cin\u0026gt;\u0026gt;delptr-\u0026gt;name; cout\u0026lt;\u0026lt;\u0026#34;请输入成绩：\u0026#34;; cin\u0026gt;\u0026gt;delptr-\u0026gt;score; ptr=delptr; //保留链表头指针，以ptr为指向当前节点的指针 for (int i=1;i\u0026lt;5;i++) { newnode=new node; //创建新节点 if(!newnode) { cout\u0026lt;\u0026lt;\u0026#34;[Error!!内存分配失败!\u0026#34;\u0026lt;\u0026lt;endl; exit(1); } cout\u0026lt;\u0026lt;\u0026#34;请输入学号：\u0026#34;; cin\u0026gt;\u0026gt;newnode-\u0026gt;num; cout\u0026lt;\u0026lt;\u0026#34;请输入姓名：\u0026#34;; cin\u0026gt;\u0026gt;newnode-\u0026gt;name; cout\u0026lt;\u0026lt;\u0026#34;请输入成绩：\u0026#34;; cin\u0026gt;\u0026gt;newnode-\u0026gt;score; newnode-\u0026gt;next=NULL; ptr-\u0026gt;next=newnode; //把新节点加在链表后面 ptr=ptr-\u0026gt;next; //让ptr保持在链表的最后面 } cout\u0026lt;\u0026lt;\u0026#34;\\n 学 生 成 绩\u0026#34;\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34; 学号\\t姓名\\t成绩\\n=====================\u0026#34;\u0026lt;\u0026lt;endl; ptr=delptr; //让ptr回到链表头 while(ptr!=NULL) { cout\u0026lt;\u0026lt;ptr-\u0026gt;num\u0026lt;\u0026lt;\u0026#34;\\t\u0026#34;\u0026lt;\u0026lt;ptr-\u0026gt;name\u0026lt;\u0026lt;\u0026#34;\\t\u0026#34;\u0026lt;\u0026lt;ptr-\u0026gt;score\u0026lt;\u0026lt;endl; delptr=ptr; ptr=ptr-\u0026gt;next; //ptr按序往后遍历整个链表 delete delptr; //释放内存空间 } } 3.2.2 单向链表中新节点的插入\n方法同网课\n3.2.3 单向链表中节点的删除\ny=ptr-\u0026gt;next; ptr-\u0026gt;next=y-\u0026gt;next; delete y; 也可以采用网课讲的方法。\n3.2.4 单向链表的反转 （指全部数据）\n/* [示范]:将学生成绩按学号反转打印出来 */ #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;ctime\u0026gt; #include \u0026lt;cstdlib\u0026gt; using namespace std; class list { public: int num,score; char name[10]; class list *next; }; typedef class list node; typedef node *link; int main() { link ptr,last,before; int i,j,findword=0,data[12][2]; char namedata[12][10]={{\u0026#34;Allen\u0026#34;},{\u0026#34;Mako\u0026#34;},{\u0026#34;Lean\u0026#34;}, {\u0026#34;Melissa\u0026#34;},{\u0026#34;Angel\u0026#34;},{\u0026#34;Sabrina\u0026#34;},{\u0026#34;Joyce\u0026#34;}, {\u0026#34;Jasica\u0026#34;},{\u0026#34;Hanson\u0026#34;},{\u0026#34;Amy\u0026#34;},{\u0026#34;Bob\u0026#34;},{\u0026#34;Jack\u0026#34;}}; srand((unsigned)time(NULL)); for (i=0;i\u0026lt;12;i++) { data[i][0]=i+1; data[i][1]=rand()%50+51;//随机给成绩 } link head=new node;\t//建立链表头指针 if(!head) { cout\u0026lt;\u0026lt;\u0026#34;Error!! 内存分配失败!!\u0026#34;\u0026lt;\u0026lt;endl; exit(1); } head-\u0026gt;num=data[0][0]; for (j=0;j\u0026lt;10;j++) head-\u0026gt;name[j]=namedata[0][j]; head-\u0026gt;score=data[0][1]; head-\u0026gt;next=NULL; ptr=head; for(i=1;i\u0026lt;12;i++) //建立链表 { link newnode=new node; newnode-\u0026gt;num=data[i][0]; for (j=0;j\u0026lt;10;j++) newnode-\u0026gt;name[j]=namedata[i][j]; newnode-\u0026gt;score=data[i][1]; newnode-\u0026gt;next=NULL; ptr-\u0026gt;next=newnode; ptr=ptr-\u0026gt;next; } ptr=head; i=0; cout\u0026lt;\u0026lt;\u0026#34;原始链表数据：\u0026#34;\u0026lt;\u0026lt;endl; while (ptr!=NULL) { //打印链表数据 cout\u0026lt;\u0026lt;\u0026#34;[\u0026#34;\u0026lt;\u0026lt;setw(2)\u0026lt;\u0026lt;ptr-\u0026gt;num\u0026lt;\u0026lt;setw(8) \u0026lt;\u0026lt;ptr-\u0026gt;name\u0026lt;\u0026lt;setw(3)\u0026lt;\u0026lt;ptr-\u0026gt;score\u0026lt;\u0026lt;\u0026#34;] -\u0026gt; \u0026#34;; i++; if(i\u0026gt;=3) //三个元素为一行 { cout\u0026lt;\u0026lt;endl; i=0; } ptr=ptr-\u0026gt;next; } ptr=head; before=NULL; cout\u0026lt;\u0026lt;\u0026#34;\\n反转后链表数据：\u0026#34;\u0026lt;\u0026lt;endl; while(ptr!=NULL) //链表反转 { last=before; before=ptr; ptr=ptr-\u0026gt;next; before-\u0026gt;next=last; } ptr=before; while(ptr!=NULL) { cout\u0026lt;\u0026lt;\u0026#34;[\u0026#34;\u0026lt;\u0026lt;setw(2)\u0026lt;\u0026lt;ptr-\u0026gt;num\u0026lt;\u0026lt;setw(8) \u0026lt;\u0026lt;ptr-\u0026gt;name\u0026lt;\u0026lt;setw(3)\u0026lt;\u0026lt;ptr-\u0026gt;score\u0026lt;\u0026lt;\u0026#34;] -\u0026gt; \u0026#34;; i++; if(i\u0026gt;=3) { cout\u0026lt;\u0026lt;endl; i=0; } ptr=ptr-\u0026gt;next; } } 3.2.5 多项式链表表示法\n/* [示范]:多项式相加 */ #include \u0026lt;iostream\u0026gt; using namespace std; class list //声明链表结构 { public : int coef,exp; class list *next; }; typedef class list node; typedef node *link; link creat_link(int data[4]); void print_link(link head);//函数定义 link sum_link(link a,link b); int main() { link a,b,c; int data1[4]={3,0,4,2}; //多项式A的系数 int data2[4]={6,8,6,9}; //多项式B的系数 cout\u0026lt;\u0026lt;\u0026#34;原始多项式：\u0026#34;\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;\u0026#34;A=\u0026#34;; a=creat_link(data1); //建立多项式A b=creat_link(data2); //建立多项式B print_link(a); //打印多项式A cout\u0026lt;\u0026lt;\u0026#34;B=\u0026#34;; print_link(b); //打印多项式B cout\u0026lt;\u0026lt;\u0026#34;多项式相加的结果：\\nC=\u0026#34;; c=sum_link(a,b); //C为A、B多项式相加的结果 print_link(c); //打印多项式C } link creat_link(int data[4])//建立多项式子程序 { link head,newnode,ptr; for(int i=0;i\u0026lt;4;i++) { newnode = new node; if(!newnode) { cout\u0026lt;\u0026lt;\u0026#34;Error!! 内存分配失败!!\u0026#34;\u0026lt;\u0026lt;endl; exit(1); } if(i==0) { newnode-\u0026gt;coef=data[i]; newnode-\u0026gt;exp=3-i; newnode-\u0026gt;next=NULL; head=newnode; ptr=head; } else if(data[i]!=0) { newnode-\u0026gt;coef=data[i]; newnode-\u0026gt;exp=3-i; newnode-\u0026gt;next=NULL; ptr-\u0026gt;next=newnode; ptr=newnode; } } return head; } void print_link(link head) //打印多项式子程序 { while(head!=NULL) { if(head-\u0026gt;exp==1 \u0026amp;\u0026amp; head-\u0026gt;coef!=0)\t//X^1时不显示指数 cout\u0026lt;\u0026lt;head-\u0026gt;coef\u0026lt;\u0026lt;\u0026#34;X + \u0026#34;; else if(head-\u0026gt;exp!=0 \u0026amp;\u0026amp; head-\u0026gt;coef!=0) cout\u0026lt;\u0026lt;head-\u0026gt;coef\u0026lt;\u0026lt;\u0026#34;X^\u0026#34;\u0026lt;\u0026lt;head-\u0026gt;exp\u0026lt;\u0026lt;\u0026#34; + \u0026#34;; else if(head-\u0026gt;coef!=0) //X^0时不显示变量 cout\u0026lt;\u0026lt;head-\u0026gt;coef; head=head-\u0026gt;next; } cout\u0026lt;\u0026lt;endl; } link sum_link(link a,link b) //多项式相加子程序 { int sum[4],i=0; link ptr; ptr=b; while(a!=NULL) //判断多项式1 { b=ptr; //重复比较A和B的指数 while(b!=NULL) { if(a-\u0026gt;exp==b-\u0026gt;exp)\t//指数相等，系数相加 { sum[i]=a-\u0026gt;coef+b-\u0026gt;coef; a=a-\u0026gt;next; b=b-\u0026gt;next; i++; } else if(b-\u0026gt;exp \u0026gt; a-\u0026gt;exp)\t//B指数较大，指定系数给C { sum[i]=b-\u0026gt;coef; b=b-\u0026gt;next; i++; } else if(a-\u0026gt;exp \u0026gt; b-\u0026gt;exp)\t//A指数较大，指定系数给C { sum[i]=a-\u0026gt;coef; a=a-\u0026gt;next; i++; } } } return creat_link(sum);\t//建立相加结果的链表C } 环形链表 单链表如果头指针丢失，整个链表就会丢失。\n对单向链表进行了改进，把尾节点本该空着的指针改为指向头节点。这样每一个节点都可以作为头指针。\n环形链表通常应用于内存工作区和IO缓冲区。\n双向链表 把指针增加为2个，一个指向前方，一个指向后方，增加链表的结实长度，让链表不会因为某指针，链接的断裂而失去数据。同时也可以反方向遍历。\n","permalink":"https://tassel234.github.io/posts/note/%E4%BD%BF%E7%94%A8cpp%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1%E9%93%BE%E8%A1%A8/","summary":"资源 （主）图解数据结构，使用C++ 吴灿明 （源代码来自这里） 使用软件\u0026quot;算法动画图解\u0026quot; 我的第一本算法书（书中彩色配图来自上面那个软件） 算法简单介绍 算法加数据结构构成可执行程序。 算法的五个条件，输入，输出，有效，明确，有穷 链表 链表主要用于两个目的：一是建立不定长度的","title":"使用Cpp实现数据结构-1（链表）"},{"content":"类的定义 （1）定义类 面向程序设计更偏向于把每一个细节都做好，从每一个零件开始是制造汽车。面向对象编程偏向于把很多细小的零件已经主装好了，保留集成了很多接口，只需要把部件进行拼接就可以得到产品。\n面向对象编程的意义在于自然界都是由实体组成，面向对象也是软件开发的主流方式。\n面对对象的三大特征，分别是抽象，封装，继承。抽象指的是将成员和成员的行为分别表示为数据成员和成员函数。封装就是把抽象来的对象代码写到类里面，并设计一些接口。继承和派生，指的是可以对一些类进行修改，得到子类，比如把本科学生信息管理系统稍作修改就可以变成研究生学生信息管理系统。\n类的定义和结构体相似，但比结构体多了对共有，私有成员的声明，还有就是类里面可以由函数。公有成员就是所有类的用户都可以使用，私有成员是只有类的成员可以用，被保护的成员基本和私有成员相同，但派生继承的类的成员也可以访问\n函数可以定义先声明在类的里面，然后定义在类外。使用：：符号\nclass Data { //Data类定义 void set(int d); //成员函数原型声明，与 void set(int); 等价 int get() { //成员函数类内部定义 return data; } //get函数定义结束 int data; //数据成员 }; //Data类定义结束 void Data::set(int d) //成员函数类外部定义 { data=d; //访问类的数据成员 } 类定义一般放在程序文件开头，或者放到头文件中被程序文件包含， 此时这个定义是全局的。在全局作用域内，该定义处处可见，因此 同作用域内的所有函数都可以使用它。\n类定义向编译器声明了一种新的数据类型，该数据类型有不同类型 的数据成员和成员函数。因此尽管数据成员类似变量的定义，但类 型声明时并不会产生该成员的实体，即为它分配存储空间。\n（2）成员的访问控制 类的每个成员都有访问控制属性，由以下三种访问标号说明：public（公有的）、private（私有的）和protected（保护的）。\npublic实现了类的外部接口。私有成员用private标号声明，只有类成员可以访问私有成员，类用户的访问是不允许的。显然，private实现了私有成员的隐蔽。保护成员用protected标号声明，在不考虑继承的情况下，protected的性质和private的性质一致，但保护成员可以被派生类的类成员访问。\n实际编程中，为了使程序清晰，每一种成员访问限定符在类体中只出现一次\n（3）类的数据成员 类的数据成员可以是基本类型、数组、指针、引用、共用体、枚举 类型、void指针、const限定等数据类型。\n但不可以是自身，后面会提到构造函数，可以构造同名的函数体。\n（4）类的成员函数 在成员函数中可以访问这个类的任何成员，无论它是公有的 或是私有的，是类内部声明的还是类外部定义的。\n（::）是作用域限定符（field qualifed）。如果在作用域限定符的前面没有类名，或者函数前面既无类名又无作用域限定符，例 如：::set(10) 或 set(10）则表示set函数不属于任何类，这个函数不是成员函数，而是全局的普通函数。此时的（::）不是类作用域限定符的含义，而是命名空间域限定符的含义。\n类的成员函数可以指定为inline，即内联函数。声明在类外或者类内都可以。\n可以对成员函数重载或使用默认参数。需要注意，声明成员函数的多个重载版本或指定成员函数的默认参 数，只能在类内部中进行。\n用类实例化一个对象时，系统会为每一个对象分配存储空问。如果 一个类包括了数据成员和成员函数，则要分别为数据和函数的代码 分配存储空间。 （5）类的声明 类不能具有自身类型的数据成员。然而，只要类名一经出现就可以 认为该类己声明。因此，类的数据成员可以是指向自身类型的指针 或引用。\nclass Point; //Point类声明，非Point类定义，因为没有类体 class Line { Point a; //错误，不能使用仅有类声明而没有类定义的类定义数 据对象 Point *pp, \u0026amp;rp; //正确，只有类声明，即可用它定义该类的指 针或引用 Line b; //错误，类不能具有自身类型的数据成员 Line *pl, \u0026amp;rl; //正确，类可以有指向自身类型的指针或引用 的数据成员 }; 对象的定义和使用 （1）对象的的定义 从现在起，“对象”一词专门表示类的实体。\nPoint a,b; //C++特色定义对象 class Point x,y; //兼容C语言特色定义对象 具体定义方式和结构体类似\n（2）对象的动态建立和释放 利用new运算符可以动态地分配对象空间，delete运算符释放对象空间。 用new运算动态分配得到的对象是无名的，它返回一个指向新对象的指针的值，即分配得到是对象的内存单元的起始地址。程序通过这个地址可以间接访问这个对象，因此需要定义一个指向类的对象的指针变量来存放该地址。显然，用new建立的动态对象是通过指针来引用的。\n在执行new运算时，如果内存不足，无法开辟所需的内存空间，C++编译器会返回一个0值指针。\n#include\u0026lt;iostream\u0026gt; using namespace std; class Box { public: int width, length, height; }; int main() { Box * p=new Box; p-\u0026gt;width=10; p-\u0026gt;length=20; p-\u0026gt;height=30; 1 cout\u0026lt;\u0026lt;p-\u0026gt;width\u0026lt;\u0026lt;\u0026#34;\\t\u0026#34;\u0026lt;\u0026lt;p-\u0026gt;length\u0026lt;\u0026lt;\u0026#34;\\t\u0026#34;\u0026lt;\u0026lt;p-\u0026gt;height\u0026lt;\u0026lt;endl; delete p; return 0; （3）对象成员的引用 访问对象中的成员可以有3种方法：\n①通过对象名和对象成员引用运算符（.）访问对象中的成员；\n②通过指向对象的指针和指针成员引用运算符（-\u0026gt;）访问对象中的成员；\n③通过对象的引用变量和对象成员引用运算符（.）访问对象中的成员；\n需要注意，从类外部只能访问类公有的成员\nvoid caller1() { Data A, *p, *p1; //定义对象指针变量 p1=\u0026amp;A; //p1指向对象A p1-\u0026gt;data=100; //正确，类外部可以访问类的public数据成员 p1-\u0026gt;fun(1,2,3); //正确，类外部可以访问类的public成员函数 p = new Data; //动态分配Data对象 p-\u0026gt;data=100; //正确，类外部可以访问类的public数据成员 p-\u0026gt;fun(1,2,3); //正确，类外部可以访问类的public成员函数 delete p; //撤销p所指向的Data对象 } void caller1() { Data A, \u0026amp;r=A; //定义对象引用变量 r.data=100; //正确，类外部可以访问类的public数据成员 r.fun(1,2,3); //正确，类外部可以访问类的public成员函数 } （4）对象的赋值 如果一个类定义了两个或多个对象，则这些同类的对象之间可以互相赋值。这里所指的对象的“值”是指对象中所有数据成员的值。\n（5）对象、对象指针或对象引用作为函数的参数和返回值 当形参是对象时，实参要求是相同类的对象名，C++不能对类对象进行任何隐式类型转换。此时形参是实参对象的副本。实际编程中，传递对象时需要考虑类的规模带来的调用开销，如果开销很大时建议不用对象作为函数参数。\n当形参是对象指针时，实参要求是同类对象的指针，C++不能对对象指针进行任何隐式类型转换。采用地址传递方式，在函数中若按间接引用方式修改了形参对象本质上就是修改实参对象。因此，使用对象指针作为函数参数可以向主调函数传回变化后的对象。\n当形参是对象引用时，实参要求是同类的对象，其功能与对象指针相似。\n#include \u0026lt;iostream\u0026gt; using namespace std; void func1(Data a,Data *p,Data \u0026amp;r) { a.data=100; p-\u0026gt;data=200; r.data=300; } int main() { Data A, B, C; A.fun(1,2,3); B.fun(4,5,6); C.fun(7,8,9); func1(A,\u0026amp;B,C);//将对象A、B的地址、对象C的引用传递到函数func1 return 0; 如果不希望在函数中修改实参对象的值，函数形参可以作const限定\nvoid func2(Data a,const Data *p,const Data \u0026amp;r) { a.data=100; p-\u0026gt;data=200; //错误，左值是const对象 r.data=300; //错误，左值是const对象 } 函数返回值可以是对象、对象指针或对象引用。函数返回对象指针或引用，本质上返回的是对象的地址而不是它的存储内容，因此不要返回局部对象的指针或引用，因为它在函数返回后是无效的。\nData* func() { Data a; Data *p=\u0026amp;a; return p; //返回局部对象a的指针p } void caller() { Data *p1; p1=func(); p1-\u0026gt;data=100; //a已不存在，引用错误 } 构造函数 （1）什么是构造函数 在类的对象创建之处就会被执行，用来对数据成员（公有还是私有都可以）进行赋值，函数的名字要和类的名字相同。 类的数据成员是不能在类定义时初始化的，因为本身不分配存储空间如果一个类中所有的数据成员是公有的，则可以在定义对象时对数据成员进行初始化，如果类中的数据成员是私有的，如private的或protected的，就不能用这种方法初始化，因为外部不能直接访问私有的数据成员。构造函数不需要人为调用，而是在建立对象时自动被执行。\n（2）构造函数的定义 与其他任何函数一样，构造函数可以声明为内联的。\n#include \u0026lt;iostream\u0026gt; using namespace std; class Cuboid { //Cuboid类表示长方体 public: Cuboid(int l,int h, int d); //构造函数 int volumn() { return length*height*depth; } //计算体积 private: int length,height,depth; //长、高、深 }; Cuboid::Cuboid(int l,int h,int d) //外部定义的构造函数 { length=l, height=h, depth=d; //初始化数据成员 cout\u0026lt;\u0026lt;\u0026#34;Cuboid: \u0026#34;\u0026lt;\u0026lt;\u0026#34;L=\u0026#34;\u0026lt;\u0026lt;l\u0026lt;\u0026lt;\u0026#34; ,H=\u0026#34;\u0026lt;\u0026lt;h\u0026lt;\u0026lt;\u0026#34; ,D=\u0026#34;\u0026lt;\u0026lt;d\u0026lt;\u0026lt;endl; } int main() { Cuboid a(1,2,3); //定义长方体对象a，调用构造函数初始化 cout\u0026lt;\u0026lt;\u0026#34;volumn=\u0026#34;\u0026lt;\u0026lt;a.volumn()\u0026lt;\u0026lt;endl; //输出体积 Cuboid b(10,20,30); //定义长方体对象b，调用构造函数初始化 cout\u0026lt;\u0026lt;\u0026#34;volumn=\u0026#34;\u0026lt;\u0026lt;b.volumn()\u0026lt;\u0026lt;endl; //输出体积 return 0; 构造函数一般声明为公有的（public），因为创建对象通常是在类的外部进行的。如果构造函数声明为保护的（protected）或私有的（protected），那就意味着在类外部创建对象（并调用构造函数）是错误的。\n每个构造函数应该为每个数据成员提供初始化。否则将使那些数据成员处于未定义的状态。而使用一个未定义的成员是错误的。\n构造函数初始化列表 与普通函数一样，构造函数具有函数名、形参列表和函数体。与其他函数不同的是，构造函数可以包含一个构造函数初始化列表。与其他的成员函数一样，构造函数可以定义在类的内部或外部，但构造函数初始化列表只在构造函数的定义中而不是函数原型声明中指定。\n#include \u0026lt;iostream\u0026gt; using namespace std; class Cuboid { //Cuboid类表示长方体 public: Cuboid(int l,int h, int d); //构造函数 int volumn() { return length*height*depth; }; //计算体积 private: int length,height,depth; //长、高、深 }; Cuboid::Cuboid(int l,int h,int d) :length(l),heght(h),depth(d) //带构造函数初始化列表的构造函数 { cout\u0026lt;\u0026lt;\u0026#34;Cuboid: \u0026#34;\u0026lt;\u0026lt;\u0026#34;L=\u0026#34;\u0026lt;\u0026lt;l\u0026lt;\u0026lt;\u0026#34; ,H=\u0026#34;\u0026lt;\u0026lt;h\u0026lt;\u0026lt;\u0026#34; ,D=\u0026#34;\u0026lt;\u0026lt;d\u0026lt;\u0026lt;endl; } 如果没有为类类型的数据成员提供初始化列表，编译器会隐式地使用该成员的默认构造函数。如果那个类没有默认构造函数，则编译器会报告错误。在这种情况下，为了初始化类类型的数据成员，必须提供初始化列表。\n一般地，没有默认构造函数的成员，以及const或引用类型的成员，都必须在构造函数初始化列表中进行初始化。\n（3）构造函数的重载 在一个类中可以定义多个构造函数版本，即构造函数允许被重载，只要每个构造函数的形参列表是唯一的\n尽管在一个类中可以包含多个构造函数，但是对于每一个对象来说，建立对象时只执行其中一个，并非每个构造函数都被执行。\n（4）带默认参数的构造函数 构造函数的参数允许使用默认值。对类的设计者来说，使用默认参数可以减少代码重复；对类的使用者者来说，使用默认参数可以方便地用适当的参数进行初始化。\n必须在类的内部指定构造函数的默认参数，不能在类外部指定默认参数。\n如果构造函数的全部参数都指定了默认值，则在定义对象时可以给一个或几个实参，也可以不给出实参。这时，就与无参数的构造函数有歧义了。\nclass Point { public: Point(){x=y=0;} Point(int a=1,int b=1):x(a),y(b) { }; void display() { cout\u0026lt;\u0026lt;\u0026#34;x=\u0026#34;\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34; ,y=\u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl; } private: int x,y; //坐标值 }; int main() { Point k; //出现歧义，既可以x=0，y=0；也可以x=1，y=1 return 0; } 一般地，不应同时使用构造函数的重载和带默认参数的构造函数。\n默认构造函数和复制构造函数 （1）定义默认构造函数 默认构造函数就是在没有显式提供初始化式时调用的构造函数，它 是一个不带参数的构造函数。如果定义某个类的对象时没有提供初 始化式就会使用默认构造函数。\n它由不带参数的构造函数，或者所有形参均是默认参数的构造函数 定义。\n任何一个类有且只有一个默认构造函数。如果定义的类中没有显式 定义任何构造函数，编译器会自动为该类生成默认构造函数，称为 合成默认构造函数.一个类哪怕只定义了一个构造函数，编译器也不会再生成默认构造 函数。一般地，任何一个类都应定义一个默认构造函数。\n（2）隐式类类型转换 #include \u0026lt;iostream\u0026gt; using namespace std; class Data { //Data类定义 public: Data(const string\u0026amp; str=\u0026#34;\u0026#34;) : s1(str) { } //const限定 引用字符串类型 为str变量设置默认初值 提供初始化列表 void SetString(const Data\u0026amp; r) //期待的是Data类型的对象 { s1=r.s1; } void print() { cout\u0026lt;\u0026lt;s1\u0026lt;\u0026lt;endl; } private: string s1; } int main() { Data a,b,c(\u0026#34;world\u0026#34;); string i=\u0026#34;string\u0026#34;; a.SetString(c); b.SetString(string(\u0026#34;world\u0026#34;)); //隐式转换 a.print(); b.print(); Data d=Data(i); //隐式转换 d.print(); return 0; 类名(const 指定数据类型\u0026amp; obj)\nC++关键字explicit用来修饰类的构造函数，指明该构造函数是显式 的。explicit关键字只能用于类内部的构造函数声明上，在类定义外 部不能重复它。\n可以禁止由构造函数定义的隐式转换，方法是通过将构造函数声明 为explicit，来防止在需要隐式转换的上下文中使用构造函数。\n（3）复制构造函数与合成复制构造函数 ►复制构造函数又称为拷贝构造函数，它是一种特殊的构造函数。它 的作用就是用一个已经生成的对象来初始化另一个同类的对象。\nPoint pt1(10,20); Point pt2=pt1 复制构造函数定义的一般形式为：\n类名(const 类名\u0026amp; obj) { 函数体 } class Point { //Point类 public: Point() : x(0), y(0) { } //默认构造函数 Point(const Point\u0026amp; r) : x(r.x), y(r.y) { } //复制构造函 数 Point(int a,int b) : x(a), y(b) { } //带参数构造函数 private: int x,y; }; ►复制构造函数有且只有一个本类类型对象的引用形参，通常使用const限定。\n每个类必须有一个复制构造函数。如果类没有定义复制构造函数， 编译器就会自动合成一个，称为合成复制构造函数 与合成默认构造函数不同，即使定义了其他构造函数，编译器也会合成复制构造函数。\n►以下3种情况会使用复制构造函数。\n►（1）用一个对象显式或隐式初始化另一个对象。\n►C++支持两种初始化形式：复制初始化和直接初始化。复制初始化 使用等号（=），而直接初始化将初始化式放在圆括号中。\n►复制初始化和直接初始化是有区别的：直接初始化会调用与实参匹 配的构造函数；而复制初始化总是调用复制构造函数。\nPoint pt1(10,20); Point pt2=pt1; //复制初始化 Point pt3(pt1); //直接初始化 （2）函数参数按值传递对象时或函数返回对象时 当函数形参为对象类型，而非指针和引用类型时，函数调用按值传 递对象，即编译器调用复制构造函数产生一个实参对象副本传递到 函数中。\n类似地，以对象类型作为返回值时，编译器调用复制构造函数产生 一个return语句中的值的副本返回到调用函数。\n（3）根据元素初始化式列表初始化数组元素时。\n总的来说，正是有了复制构造函数，函数才可以传递对象和返回对 象，对象数组才能用初值列表的形式初始化。\n（4）深复制与浅复制 是合成复制构造函数和复制构造函数的区别。 若复制对象但未复制资源内容称为浅复制， 如果一个拥有资源（如用new得到的动态内存）的类对象发生复制 的时候，若对象数据与资源内容一起复制，称为深复制。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string.h\u0026gt; using namespace std; class CA { public: CA(int b,char *cstr) //构造函数 { a=b; str=new char[b]; strcpy(str,cstr); } CA(const CA \u0026amp;C) //复制构造函数 { a=C.a; str=new char[a]; //深复制，浅复制则写成str=C.str; if(str!=0) strcpy(str,C.str); } void show() { cout\u0026lt;\u0026lt;str\u0026lt;\u0026lt;endl; } ~CA() //析构函数 { delete str; } private: int a; char *str; }; int main() { CA a(10,\u0026#34;hello\u0026#34;); CA b=a; b.show(); return 0; } 析构函数 （1）析构函数的定义 析构函数：当对象脱离其作用域时（例如对象所在的函数已调用完 毕），系统会自动执行析构函数。析构函数往往用来做“清理善后” 的工作（例如在建立对象时用new开辟了一段内存空间，则在该对 象消亡前应在析构函数中用delete释放这段存储空间）。\n一个类可以有多个构造函数，但是只能有一个析构函数。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string.h\u0026gt; using namespace std; class Point { public: Point(int a,int b):x(a),y(b){} //带参数的构造函数 ~Point() //析构函数 { cout\u0026lt;\u0026lt;\u0026#34;析构函数被调用。\u0026#34;\u0026lt;\u0026lt;endl; } void show() { cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34;,\u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl; } private: int x,y; }; int main() { Point pt1(10,20); pt1.show(); return 0; （2）合成析构函数 与复制构造函数不同，编译器总是会为类生成一个析构函数，称为合成析构函数 需要注意，合成析构函数并不删除指针成员所指向的对象，它需要 程序员显式编写析构函数去处理。\n（3）何时需要编写析构函数 需要注意，合成析构函数并不删除指针成员所指向的对象，它需要 程序员显式编写析构函数去处理。\n如果类需要析构函数，则该类几乎必然需要定义自己的复制构造函 数和赋值运算符重载，这个规则称为析构函数三法则(三个同时出现)\n#include \u0026lt;iostream\u0026gt; using namespace std; class CString { //CString类 public: CString(const char *str); //单个参数构造函数 ~CString(); //析构函数 void show() { cout\u0026lt;\u0026lt;p\u0026lt;\u0026lt;endl; } //显示字符串 private: char *p; //存储字符串动态内存区 CString::CString(const char *str) { p=new char[strlen(str)+1]; //为存储str动态分配内存 strcpy(p,str); //复制str到p cout\u0026lt;\u0026lt;\u0026#34;构造：\u0026#34;\u0026lt;\u0026lt;str\u0026lt;\u0026lt;endl; } CString::~CString() { cout\u0026lt;\u0026lt;\u0026#34;析构：\u0026#34;\u0026lt;\u0026lt;p\u0026lt;\u0026lt;endl; delete [] p; //析构函数必须是否p占用的内存 } int main() { CString s1(\u0026#34;C++\u0026#34;), s2=\u0026#34;JavaScript\u0026#34;; //定义对象 s1.show(); s2.show(); return 0; } （4）构造函数和析构函数的调用次序 构造函数和析构函数的调用很像一个栈的先进后出，调用析构函数 的次序正好与调用构造函数的次序相反。最先被调用的构造函数， 其对应的（同一对象中的）析构函数最后被调用，而最后被调用的 构造函数，其对应的析构函数最先被调用。\n","permalink":"https://tassel234.github.io/posts/note/c++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1-1/","summary":"类的定义 （1）定义类 面向程序设计更偏向于把每一个细节都做好，从每一个零件开始是制造汽车。面向对象编程偏向于把很多细小的零件已经主装好了，保留集成了很多接口，只需要把部件进行拼接就可以得到产品。 面向对象编程的意义在于自然界都是由实体组成，面向对象也是软件开发的主流方式。 面对对象的三","title":"C++学习笔记-1（类和对象-1）"},{"content":"注释语句 /* ......块注释内容 */ //......行注释内容 输入和输出 标准输入输出流库的头文件\ncin输入时，为了分隔多项数据，默认要求在键盘输入数据之间使用空格、Tab键、回车作为分隔符。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; int main() { bool v; int a,m,n; double x,y,z,p,f; float f1;//除了已经定义的变量，下面出现的oct,setw都是关键字 cin\u0026gt;\u0026gt;boolalpha\u0026gt;\u0026gt;v; //输入：true cin\u0026gt;\u0026gt;oct\u0026gt;\u0026gt;a\u0026gt;\u0026gt;hex\u0026gt;\u0026gt;m\u0026gt;\u0026gt;dec\u0026gt;\u0026gt;n;//输入：144 46 -77 cin\u0026gt;\u0026gt;p\u0026gt;\u0026gt;f\u0026gt;\u0026gt;f1\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;z;//输入：3.14 3.14 3.14 3.14159 0.1 0.1e1 cout\u0026lt;\u0026lt;v\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;boolalpha\u0026lt;\u0026lt;v\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;noboolalpha\u0026lt;\u0026lt;v\u0026lt;\u0026lt;endl;//输出：1 true 1 cout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;p\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;a*p\u0026lt;\u0026lt;endl;//输出：100 3.14 314 cout\u0026lt;\u0026lt;hex\u0026lt;\u0026lt;m\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;oct\u0026lt;\u0026lt;m\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;dec\u0026lt;\u0026lt;m\u0026lt;\u0026lt;endl;//输出：46 106 70，分别是16，8，10进制 cout\u0026lt;\u0026lt;showbase\u0026lt;\u0026lt;hex\u0026lt;\u0026lt;m\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;oct\u0026lt;\u0026lt;m\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;dec\u0026lt;\u0026lt;m\u0026lt;\u0026lt;endl; //输出：0x46 0106 70 cout.precision(5); cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;z\u0026lt;\u0026lt;endl;//输出：3.1416 0.1 1 cout\u0026lt;\u0026lt;fixed\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;z\u0026lt;\u0026lt;endl;//输出：3.14159 0.10000 1.00000 cout\u0026lt;\u0026lt;scientific\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;z\u0026lt;\u0026lt;endl; //输出：3.14159e+000 1.00000e-001 1.00000e+000 cout\u0026lt;\u0026lt;left\u0026lt;\u0026lt;setw(6)\u0026lt;\u0026lt;n\u0026lt;\u0026lt;endl; //输出：-77 cout.width(6); cout\u0026lt;\u0026lt;right\u0026lt;\u0026lt;n\u0026lt;\u0026lt;endl; //输出：_ _ _-77 cout\u0026lt;\u0026lt;setw(10)\u0026lt;\u0026lt;77\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;setfill(\u0026#39;0\u0026#39;)\u0026lt;\u0026lt;setw(10)\u0026lt;\u0026lt;77\u0026lt;\u0026lt;endl; //输出：_ _ _ _ _ _ _77 0000000077 cout\u0026lt;\u0026lt;fixed\u0026lt;\u0026lt;setprecision(5)\u0026lt;\u0026lt;f\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;setprecision(9)\u0026lt;\u0026lt;f\u0026lt;\u0026lt;endl; //输出：3.14000 3.140000000 cout\u0026lt;\u0026lt;showpos\u0026lt;\u0026lt;1\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;0\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;endl; //输出：+1 +0 -1 cout\u0026lt;\u0026lt;noshowpos\u0026lt;\u0026lt; 1\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;0\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;endl; //输出：1 0 -1 return 0; } 顺序结构 所谓顺序结构是指：语句以其出现的顺序执行。\n分支 if语句 if (a\u0026gt;b) { x=a+b; y=a-b; } else { x=a-b; y=a+b; } a=5,b=2; if ( a ) x=a*10; //等价于a!=0 switch语句 switch ( 表达式 ) { case 常量表达式1 : … 语句序列1 case 常量表达式2 : … 语句序列2 ┇ case 常量表达式n : … 语句序列n default : … 默认语句序列//其他值都在这，无论表达式的值是什么（特指case没有的值），写在最后的该语句都会被执行 } switch语句中case分支的语句序列可以是一个语句，也可以是任意多的语句序列，也可以没有语句；\nswitch语法中各个case分支和default分支的出现次序在语法上没有规定，但次序的不同安排会影响执行结果。\nswitch (n) { default: cout\u0026lt;\u0026lt;\u0026#34;0\u0026#34;;//输入1或2不执行此语句 case 1 : cout\u0026lt;\u0026lt;\u0026#34;1\u0026#34;; case 2 : cout\u0026lt;\u0026lt;\u0026#34;2\u0026#34;; } switch语法中default分支是可选的，若没有default分支且没有任何case标号的值相等时，switch语句将什么也不做，直接执行后续语句。\nswitch语句的分支表达式可以是C++语言的任意表达式，但其值必须是整数（含字符类型）、枚举类型。\n更常见的switch结构应该如下，它提供了程序多分支选择执行流程。\nswitch ( 表达式 ) { case 常量表达式1: … 语句序列1; break; case 常量表达式2: … 语句序列2; break; ┇ case 常量表达式n: … 语句序列n; break; default : … 默认语句序列 } //成绩分层程序 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; int main() { int g; cin\u0026gt;\u0026gt;g; //输入成绩等级 switch(g) { case \u0026#39;A\u0026#39;:cout\u0026lt;\u0026lt;\u0026#34;85～100\\n\u0026#34;; break; case \u0026#39;B\u0026#39;:cout\u0026lt;\u0026lt;\u0026#34;70～84\\n\u0026#34;; break; case \u0026#39;C\u0026#39;:cout\u0026lt;\u0026lt;\u0026#34;60～69\\n\u0026#34;; break; case \u0026#39;D\u0026#39;:cout\u0026lt;\u0026lt;\u0026#34;\u0026lt;60\\n\u0026#34;; break; default: cout\u0026lt;\u0026lt;\u0026#34;error\\n\u0026#34;; } return 0; } 选择语句的嵌套 if第一种方式\nif ( 表达式1 ) 语句1 else if ( 表达式2 ) 语句2 else if ( 表达式3 ) 语句3 ...... else if ( 表达式n ) 语句n else 语句m if第二种方式\nif ( 表达式1 ) if ( 表达式2 ) 语句1 else 语句2 else if ( 表达式3 ) 语句3 else 语句4 switch的嵌套\n#include \u0026lt;iostream\u0026gt; using namespace std; int main() { int y,m,d,Days; cin\u0026gt;\u0026gt;y\u0026gt;\u0026gt;m\u0026gt;\u0026gt;d; //输入日期 switch(m) { //计算每月的天数 case 2 : Days=28; if((y%4==0\u0026amp;\u0026amp;y%100!=0)|| (y%400==0)) Days++; //闰年天数加1 break; case 4 : case 6 : case 9 : case 11 : Days=30;break; default: Days=31; //其余月份为31天 } d++; if (d\u0026gt;Days) d=1,m++; //判断月末 if (m\u0026gt;12) m=1,y++; //判断年末 cout\u0026lt;\u0026lt;y\u0026lt;\u0026lt;“-”\u0026lt;\u0026lt;m\u0026lt;\u0026lt;“-”\u0026lt;\u0026lt;d\u0026lt;\u0026lt;endl; //输出第二天的日期 return 0; } 循环 基本语法 循环语句大致可以分为下面三种\n1、while语句\n2、do while语句（几乎和while等价，可以相互转化，区别在于do while多少要执行一次）\n3、for语句\nfor语句的说明。\n►（1）整个循环过程中表达式1只求解一次；作用是给循环控制变量赋初值。\n►（2）表达式2相当于是for的循环条件。\n►（3）表达式3是重复执行的内容；通常是改变循环控制变量值的语句。\n//判断质数 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int i,m; cin\u0026gt;\u0026gt;m;//从2到m-1之间逐一检查是否被m整除 for (i=2 ; i\u0026lt;=m-1 ; i++) if (m % i==0) break; //如果整除则结束检查 if (i==m) cout\u0026lt;\u0026lt;\u0026#34;Yes\u0026#34;\u0026lt;\u0026lt;endl; //根据循环结束位置判断是否素数 else cout\u0026lt;\u0026lt;\u0026#34;No\u0026#34;\u0026lt;\u0026lt;endl; return 0;\t} ►break语句的作用是结束switch语句和循环语句的运行，转到后续语句，语法形式为：break；\n►break语句只能用在switch语句和循环语句（while、do、for）中，不得单独使用。\n►continue语句的作用是在循环体中结束本次循环，直接进入下一次循环，语句形式为：continue；（可以用来求解奇书偶数的和） ► continue语句只能用在循环语句（while、do、for）中，不能单独使用。\n循环语句的选用 ►计数型循环常使用for语句\n►计数型循环用于处理已知循环次数的循环过程。\n►控制变量在每次循环时都要发生规律性变化（递增或递减），当控制变量达到预定的循环次数时，循环就结束。\n►条件型循环常使用while语句和do while语句。可以写较为抽象的条件。\n►条件型循环用于处理循环次数未知的循环过程，称为“不定次数循环”。\n►在条件型循环中，由于事先不能准确知道循环的次数，因此循环控制是由条件来判定的。在每次循环时检测这个条件，当条件一旦满足，循环就结束。\n//求π的近似值 π/4≈1-1/3+1/5-1/7+1/9-…，直到最后一项的绝对值小于10-7为止。 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; int main() { double s=1,pi=0,n=1,t=1; while (fabs(t)\u0026gt;1e-7) pi=pi+t, n=n+2, s=-s, t=s/n; cout\u0026lt;\u0026lt;pi*4\u0026lt;\u0026lt;endl; return 0; } 循环语句应用举例 百元买鸡问题\n百钱买百鸡问题：有人有一百块钱，打算买一百只鸡。公鸡一只5元，母鸡一只3元，小鸡3只1元，求应各买多少？\n//百元买鸡问题 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int x,y,z; for (x=0; x\u0026lt;=20; x++) //枚举公鸡的可能数量，最多为20 for (y=0; y\u0026lt;=33; y++) //枚举母鸡的可能数量，最多为33 for (z=0; z\u0026lt;=100; z++)//枚举小鸡的可能数量，最多为100 if(z%3==0\u0026amp;\u0026amp;x+y+z==100\u0026amp;\u0026amp;5*x+3*y+z/3==100)//约束条件 cout\u0026lt;\u0026lt;\u0026#34;公鸡=\u0026#34;\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34;,母鸡=\u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;\u0026#34;,小鸡=\u0026#34;\u0026lt;\u0026lt;z\u0026lt;\u0026lt;endl; return 0; } //百元买鸡问题（二重循环优化） #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int x,y,z; for (x=0; x\u0026lt;=20; x++) //枚举公鸡的可能数量，最多为20 for (y=0; y\u0026lt;=33; y++) { //枚举母鸡的可能数量，最多为33 z=100-x-y; //小鸡的数量根据约束条件求得 if (z%3==0 \u0026amp;\u0026amp; 5*x+3*y+z/3==100) //约束条件 cout\u0026lt;\u0026lt;\u0026#34;公鸡=\u0026#34;\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34;,母鸡=\u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;\u0026#34;,小鸡=\u0026#34;\u0026lt;\u0026lt;z\u0026lt;\u0026lt;endl;} return 0; } //百元买鸡问题（一重循环） #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { int rooster, hen, chick; int count; count = 0; //设公鸡r只,母鸡h只,雏鸡c只 //由计算可得,r = (4 * c - 300) / 3 //但是必须使等式有意义,即r\u0026gt;=0,即可求解出r的范围:c\u0026gt;=75 //此外,因为1钱可买3雏鸡,雏鸡的数量c必须是3的整数倍* //经检验,75是\u0026gt;=75且能被三整除的最小整数 //由*可知,雏鸡增加的数量也必须为3的整数倍,所以变量c每次加3 for(chick = 75; chick \u0026lt;= 300; chick = chick + 3) //这条语句限定了chick的范围 75~300 { count++; if ((4 * chick - 300) % 3 == 0)//rooster表达式递增且大于0,但要保证为整数 { rooster = (4 * chick - 300) / 3; hen = (600 - 7 * chick) / 3;//这里无需检验hen是否为整数,因为hen=100-r-c,且前面保证了r,c为整数 if (hen \u0026gt;= 0)//因为hen的表达式递减,这条语句限定了hen的范围\u0026gt;0 printf(\u0026#34;Rooster: %d, Hen: %d, Chick: %d\\n\u0026#34;, rooster, hen, chick); else break; } } printf(\u0026#34;Total count: %d\u0026#34;, count); return 0; } 函数 函数的定义和使用 （1）函数的定义和函数的参数\n返回类型可以是C++除数组之外的内置数据类型或自定义类型。 函数可以不返回数据，此时返回类型应写成void，表示没有返回值。\n#include \u0026lt;iostream\u0026gt; using namespace std; int IsPrime(int m) //求素数函数 { //枚举法求m是否素数 int i; for (i=2 ; i\u0026lt;=m-1 ; i++) if (m % i==0) return 0; //不是素数返回0 return 1; //是素数返回1 } int main() { int m; cin\u0026gt;\u0026gt;m; if (IsPrime(m)) cout\u0026lt;\u0026lt;\u0026#34;Yes\u0026#34;\u0026lt;\u0026lt;endl; //是素数输出Yes else cout\u0026lt;\u0026lt;\u0026#34;No\u0026#34;\u0026lt;\u0026lt;endl; //不是素数输出No return 0; } 1）函数定义时指定的形参，在未进行函数调用前，并不实际占用 内存中的存储单元。\n2）只有在发生函数调用时，形参才分配实际的内存单元，接受从 主调函数传来的数据。\n3）当函数调用结束后，形参占用的内存单元被自动释放。\n值传递（pass-by-value）过程中，形参作为被调函数的内部变量来处理，即开辟内存空间以存放由主调函数复制过来的实参的值，从而成为实参的一个副本。实参数据传递给形参是单向传递，即只能由实参传递给形参，而不能由形参传回给实参。\n函数调用时提供给被调函数的参数称为实际参数（arguments）， 简称实参。\n实参必须有确定的值，因为调用函数会将它们传递给形参。实参可 以是常量、变量或表达式，还可以是函数的返回值。例如：\nx = max(a,b); //max函数调用，实参为a,b y = max(a+3,128); //max函数调用，实参为a+3,128 z = max(max(a,b),c); //max函数调用，实参为max(a,b),c （2）函数的声明与内联函数\n声明时使用函数原型（function prototype）。其作用是提供函数调用所必须的接口信息，函数原型可以没有形式参数的名字，到后面函数定义可以再写。但为了调用函数原型必须放在调用之前，而函数定义可以放在函数调用之后。\nint gcd(int m, int n) //求最大公约数，gcd函数实现在后 { int r; while (n!=0) { //欧几里德算法，举例是：m=9, n=6 ① r=3, m=6, n=3 ② r=0, m=3, n=0 r = m % n ; //r为m/n的余数 m = n ; //则gcd(m,n)=gcd(n,r)=... n = r ; //r=0时n即是gcd } return m; } C++提供一种提高函数效率的方法，即在编译时将被调函数的代码 直接嵌入到主调函数中，取消调用这个环节。这种嵌入到主调函数 中的函数称为内联函数（inline function）。\ninline 返回类型 函数名(形式参数列表) { 函数体 } 但因为过于复杂的函数内联会导致错误，内联函数中不允许用循环语句和switch语句。\n函数的设计 默认参数\nint add(int x=5,int y=6) 可以这样调用。 add(10,20); //10+20 add(10); //10+6 add(); //5+6\n可以设置多个默认参数，设置的顺序为自右向左，换言之，要为某个参数设置默认值，则它右边的所有参数必须都是默认参数。\n默认值可以是常量、全局变量，甚至是一个函数调用，但不可以是局部变量。 函数重载 就是可以取同名的函数。\n函数重载的使用说明：\n（1）重载函数的形参必须不同（个数不同或类型不同）。\n（2）编译程序将根据实参和形参的类型及个数的最佳匹配来选择调用哪一个函数。\n（3）不要将不同功能的函数声明为重载函数，以免出现调用结果的误解、混淆。\n函数模板与库函数的调用\n函数模板（function template）是一个独立于类型的函数，可作为一种模式，产生函数的特定类型版本。\ntemplate\u0026lt;typename T\u0026gt; T abs(T x) { return x\u0026lt;0?-x:x; } 标准库函数的连接在开发环境中是默认的，一般可以不用特别设置，只需要在文件开头输入#include 声明一下就行。包括stl,c语言库等。\n对于一些特殊的由其他人编写的库，一般提前下载，然后再按配置说明进行安装就行。\n函数的调用 （1）函数的嵌套调用\n在调用一个函数的过程中，又调用另一个函数，称为函数的嵌套调 用，C++允许函数多层嵌套调用，只要在函数调用前有函数声明即 可。\n（2）函数的递归调用\n可以使用递归解决阶乘，汉诺塔问题的求解。\n作用域、生命期和程序的组织结构 （1）作用域和生命期\n局部变量只能在定义它的区域及其子区域中使用。\n在不同区域中允许定义相同名字的变量，但本质上它们是不同的变量\n如果一个变量所处区域的子区域中有同名的变量，则该变量在子区域无效，有效的是子区域的变量，称为定义屏蔽。\n#include \u0026lt;iostream\u0026gt; using namespace std; void swap(int x,int y) { int t; t=x; x=y; y=t; } int main( ) { int a,b; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; swap(a,b); cout\u0026lt;\u0026lt;\u0026#34;a=\u0026#34;\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026#34;,b=\u0026#34;\u0026lt;\u0026lt;b\u0026lt;\u0026lt;endl; return 0;//最后不交换次序 } #include \u0026lt;iostream\u0026gt; using namespace std; int x,y; void swap() { int t; t=x; x=y; y=t; } int main( ) { int a,b; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; swap(a,b); cout\u0026lt;\u0026lt;\u0026#34;a=\u0026#34;\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026#34;,b=\u0026#34;\u0026lt;\u0026lt;b\u0026lt;\u0026lt;endl; return 0;//会交换次序 作用域是程序中的一段区域。在同一个作用域上，C++程序中每个名字都与唯一的实体对应；如果在不同的作用域上，程序中可以多次使用同一个名字，对应不同作用域中的不同实体。\n实体在包含它的作用域内，从定义或声明的位置开始，按文件行的顺序往后（往下）直到该作用域结束均是可见的，包含作用域内的所有子区域及其嵌套。但是往前就看不到了。\n可以使用extern声明将变量或函数实体的可见区域往前延伸，称为前置声明。\n在全局作用域中，变量或函数实体若使用static修饰，则该实体对于其他源文件是屏蔽的，称为私有的（private）。\n动态存储在分配和释放的形式有两种，一种是由函数调用来自动完 成的，称为自动存储（automatic storage）如默认参数，结构体和类的实例化，一种是由程序员通过 指令的方式来人工完成的，称为自由存储（free storage）\n现代程序设计的观点是，除非有必要尽量少地使用静态存储\nC++语言允许用CPU的寄存器来存放局部变量，称为寄存器变量。 在局部变量前加上register存储类别修饰来定义的，其形式为：\nregister 类型 变量名[=初值] 在局部对象的前面加上static存储类别修饰用来指明对象是静态局 部对象（static local ）\n#include \u0026lt;iostream\u0026gt; using namespace std; int fun() { static int cnt=0; //静态局部变量会保持其值 ，可以做计数器 cnt++; return cnt; } int main() { int i,c; for (i=1;i\u0026lt;=10;i++) c=fun(); cout\u0026lt;\u0026lt;c\u0026lt;\u0026lt;endl; return 0; } （2）程序的组织结构\n函数本质上是全局的，在多文件的程序中，在连接时会检查函数在 全局作用域内是否名字唯一，如果不是则出现连接错误。\n在函数定义前加上static修饰，则函数称为内部函数。内部函数仅在包含它的文件中有效。\n在函数定义前加上extern声明，则函数称为外部函数。C++中所有的函数本质上都是外部函数。因此，上面的extern都可以省略。\n头文件与工程文件\n如果是多文件结构程序，欲在文件中调用别的文件中的函数，需要有函数的声明，而且每个文件均是如此。如果是函数声明比较多的情况下，在每个文件中都写上函数声明不是好办法，很难管理。如果某个函数定义有变动，那么所有含有这个函数声明的调用文件都需要找出来，逐一修改。使用头文件可以解决这个问题，其工作原理是通过将每个源文件中外部函数的函数声明等信息集中写到一个文件中，称为头文件（有别于源文件），而别的源文件只需用文件包含命令将这个头文件包含，则编译时编译器自然就有了函数声明。\n多文件结构程序在编译时需要工程文件来管理，不同的编译器有不 同的工程文件格式。\n多文件编译\n头文件a.h和cpp文件a.cpp\n#include \u0026#34;a.h\u0026#34;//\u0026#34;\u0026#34;表示在工程文件夹寻找，\u0026lt;\u0026gt;是只在系统文件夹找 //直接引用.h头文件 ","permalink":"https://tassel234.github.io/posts/note/c++%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%87%BD%E6%95%B0/","summary":"注释语句 /* ......块注释内容 */ //......行注释内容 输入和输出 标准输入输出流库的头文件 cin输入时，为了分隔多项数据，默认要求在键盘输入数据之间使用空格、Tab键、回车作为分隔符。 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; int main() { bool v; int a,m,n; double x,y,z,p,f; float f1;//除了已经定义的变量，下面出现的oct,setw都","title":"C++入门学习笔记-2(语句和函数)"},{"content":"前言 使用资源 （主）程序员的数学4：图论 算法图解动画软件演示 b站视频图解\n目标指向 了解图的基本知识，可以对图论模型进行数学建模和程序求解。\n图的基础知识 什么是图 在数学中，图是描述于一组对象的结构，其中某些对象对在某种意义上是“相关的”。这些对象对应于称为顶点的数学抽象（也称为节点或点），并且每个相关的顶点对都称为边（也称为链接或线）。通常，图形以图解形式描绘为顶点的一组点或环，并通过边的线或曲线连接。 图形是离散数学的研究对象之一。\n图的表示法 在计算机中表示图的方式由邻接矩阵，关联矩阵，邻接表。\n其他图论术语 度（Degree）：一个顶点的度是指与该顶点相关联的边的条数，顶点v的度记作d(v)。\n对任意图，度的个数之和都是偶数，也就是握手定理。\n迹：如果路径P(u,v)中的边各不相同，则该路径称为u到v的一条行迹。 路（轨道）：如果路径P(u,v)中的顶点各不相同，则该路径称为u到v的一条轨道。 闭的行迹称作回路（Circuit），闭的轨称作圈（Cycle）。\n定理1 设图G的邻接矩阵为A，A的K次幂的（i,j元素）等于在图G中由i到j长度为K的路径数  子图（Sub-Graph）：当图G'=(V',E')其中V‘包含于V，E’包含于E，则G\u0026rsquo;称作图G=(V,E)的子图。每个图都是本身的子图。\n生成子图（Spanning Sub-Graph）：指满足条件V(G') = V(G)的G的子图G'。\n导出子图（Induced Subgraph）：以图G的顶点集V的非空子集V1为顶点集，以两端点均在V1中的全体边为边集的G的子图，称为V1导出的导出子图；以图G的边集E的非空子集E1为边集，以E1中边关联的顶点的全体为顶点集的G的子图，称为E1导出的导出子图。\n补图。点不变，完全图的补线构成的图。\n几类特殊的图 树和森林 联通且不含圈的图称为树，多个不相连的树构成森林。 单个树可以看作一个比较特殊的森林。\n二部图（二分图） 二分图：顶集，且每一条边都有一个顶点在X中，而另一个顶点在Y中。 完全二分图：二分图G中若任意两个X和Y中的顶点都有边相连。若，则图G记作Km,n。 如上图，树是二部图。\n可平面图 图可以被画成边各不相交的图，称为可平面图。\n定理2：欧拉公式 不论什么形状的可平面图（凸多面体），其顶点数V、棱数E、面数F之间总有关系V+F-E=2  其他 完全图：每一对不同顶点间都有边相连的的图，记作Kn。\n正则图：如果图中所有顶点的度皆相等，则此图称为正则图\n图的度序列 定理3：通过度判断一个序列是否为可图化序列 首先把各顶点的度按降序排列形成度序列 。 去掉第一个数字k，然后把前k个数字减1，再按降序排列，循环步骤简化图。  最小生成树 什么是最小生成树 在图（包括赋权图）中，可以找到的路径长度之和最小的树。 可以解决电缆安装问题，只要达到每一个地点就行，形成连通图。\n克鲁斯卡尔算法 属于贪心算法的一种。 按找赋权的大小依次查找，让其不构成圈，最后可以产生最小生成树 。\n普里姆算法 也属于贪心算法的一种。 以某个节点开始，查找赋权小的。\n最小斯坦纳树问题 某些节点可以连（作为中继节点），也可以不连。 NP难的问题，不太可能存在高效的算法。\n最短路径问题 什么是最短路径问题 由一点到另一点所用路径的权值总和最小的问题。\n迪杰斯特拉算法 每一个节点初始化为非常大的数，路径上赋权正常的数字，赋值方式是节点的值加上路径的值。 通过查找可行路径给节点赋值，节点的值往小的地方更新。 满足条件因为使用其他路径时，必须经过点C，但AC成本大于AB成本 但也因为这个限制，权值不能为负，否则可能会出错，这一点不如福特算法 但斯拉特算法也有优点，比如他的速度要快上很多 对于单行道和双向通道值不一致时也可以非常好的解决，这是福特算法做不到的\n欧拉回路与哈密顿圈 欧拉回路 就像七桥问题，把每一个边走且只走一遍，就是欧拉回路。\n形成欧拉回路的充分必要条件是顶点的度都是偶数。\n哈密顿圈 把每一个点走且只走一遍，就是哈密顿圈 。\n是NP完全问题，不太可能存在高效算法。\n狄拉克定理 狄拉克定理：如果图是一个具有至少3个顶点的简单图G，并且图中每个顶点的度数至少为节点数的一半，那么图包含哈密顿图。\n奥尔定理\n奥尔定理是图论在1960年由挪威数学家奥斯汀·奥尔证明的结果，它为图成为哈密顿量提供了充分的条件，从本质上说，具有“足够多的边”的图必须包含哈密顿环。 具体来说，该定理考虑非相邻顶点对的度数之和：如果每个这样的对具有至少等于图中顶点总数的和，则该图为哈密顿图。如果一个总点数至少为3的简单图G满足：G的任意两个不相邻的点u和v度数之和至少为n，即d(u)+d(v)≥n，那么G必然有哈密顿回路。\n","permalink":"https://tassel234.github.io/posts/note/%E5%9B%BE%E8%AE%BA%E5%85%A5%E9%97%A8-1/","summary":"前言 使用资源 （主）程序员的数学4：图论 算法图解动画软件演示 b站视频图解 目标指向 了解图的基本知识，可以对图论模型进行数学建模和程序求解。 图的基础知识 什么是图 在数学中，图是描述于一组对象的结构，其中某些对象对在某种意义上是“相关的”。这些对象对应于称为顶点的数学抽象（也称为节点或点）","title":"图论入门-1"},{"content":"参考资源 python数学建模算法与应用\nhttps://blog.csdn.net/weixin_35757704/article/details/117808073\nhttps://blog.csdn.net/chuididehuayiren/article/details/109765279\n图表解释 第一部分左边\nDep. Variable:即dependent variable，因变量 OLS:普通最小二乘法 least squares：最小化残差平方和 No. Observations:个案数，即样本容量 df residuals：残差自由度(观测数No.Observations - (参数数目Df Model+1))，这里的1是常量参数 df model：模型中自变量（即参数）个数 Covariance Type：协方差阵的稳健性  第一部分右边\nR-squared：R方，判定系数，01间越大越吻合，计算方法为SSR/SST，残差（sse）为0. Adj . R-squared：调整后的R方，利用奥卡姆剃刀修正后的R-squared值 （奥卡姆剃刀是一种理论，认为通用的模型倾向于更简单的参数，正所谓大道至简） F-statistic：F统计量，均方误差/残差的均方误差。值越大, H 0​ 越不可能，从而回归系数显著. F检验，这个值越大越能推翻原假设，值越大说明模型是线性模型，原假设是“我们的模型不是线性模型”。f检验（F-test）， 最常用的别名叫做联合假设检验（英语：joint hypotheses test），此外也称方差比率检验、方差齐性检验。 它是一种在零假设之下，统计值服从F-分布的检验。其通常是用来分析用了超过一个参数的统计模型， 以判断该模型中的全部或一部分参数是否适合用来估计母体。 Prob（F-statistic）：当 prob(F−statistic)\u0026lt;α时，表示拒绝原假设，即认为模型是显著的， 为F-statistic的概率，值越小越能拒绝原假设。 Log likelihood ：对数似然比LLR。值越大，模型拟合得越好。 （Davidson 与MacKinnon年说：对于线性回归模型，不管它误差是不是正态分布， 都不需要过问LM，W，LLR，因为这些信息已被F检验所含有） AIC: AIC=2k−2ln(L)。其中：k是参数的数量，L是似然函数。 它衡量拟合优良性,应选择AIC最小的模型,引入了惩罚项,避免参数过多,过拟合. BIC: 贝叶斯信息准则BIC=kln(n)−2ln(L) ,BIC相比AIC在大数据量时对模型参数惩罚得更多， 导致BIC更倾向于选择参数少的简单模型。  第二部分\nintercept：常数 coef：各自变量的估计系数 std err：系数估计的标准差 t : 衡量显著性的指标，就是我们常用的t统计量，这个值越大越能拒绝原假设。 P\u0026gt;|t|，H0​（系数=0）为真的概率。统计检验中的P值，这个值越小越能拒绝原假设。 [0.025,0.975]: 95％置信区间的下限和上限值  第三部分\nOmnibus :基于峰度和偏度进行数据正态性的检验，通常与Jarque-Bera检验共同使用 属于一种统计测验,测试一组数据中已解释方差是否显著大于未解释方差, 但omnibus不显著,模型也可能存在合法的显著影响, 比如两个变量中有一个不显著, 即便另一个显著.通常用于对比 Prob(Omnibus):将上面的统计数据变成概率 Skewness: 偏度 Kurtosis:峰度 Durbin-Watson:德宾-沃森检验（检验残差自相关最常用的方法），它用于检验一阶自相关性。 自相关系数 − 1 \u0026lt; ρ \u0026lt; 1 ⇒ 0 ≤ D W ≤ 4 -1\u0026lt;ρ\u0026lt;1\\Rightarrow0≤DW≤4 −1\u0026lt;ρ\u0026lt;1⇒0≤DW≤4 并且 D W ＝ 0 ⇔ ρ ＝ １ DW＝0 \\Leftrightarrow ρ＝１ DW＝0⇔ρ＝１　即存在正自相关性 D W ＝ ４ ⇔ ρ ＝ － １ DW＝４\\Leftrightarrow ρ＝－１ DW＝４⇔ρ＝－１即存在负自相关性 D W ＝ ２ ⇔ ρ ＝ ０ DW＝２\\Leftrightarrow ρ＝０ DW＝２⇔ρ＝０　即不存在（一阶）自相关性 Jarque-Bera(JB) :同样是基于峰度和偏度进行数据正态性的检验， 通常与Omnibus检验共同使用， Jarque–Bera检验。如果统计量≫0，则表示数据不是正态分布。 Prob(JB): JB统计量的概率形式 Cond. No :条件数。用于诊断多重共线性  一元线性回归模型 import numpy as np import statsmodels.api as sm import pylab as plt def check(d): x0 = d[0]; y0 = d[1]; d ={\u0026#39;x\u0026#39;:x0, \u0026#39;y\u0026#39;:y0} re = sm.formula.ols(\u0026#39;y~x\u0026#39;, d).fit() #拟合线性回归模型 print(re.summary()) print(re.outlier_test()) #输出已知数据的野值检验 print(\u0026#39;残差的方差\u0026#39;, re.mse_resid) pre=re.get_prediction(d) df = pre.summary_frame(alpha=0.05) dfv = df.values; low, upp = dfv[:,4:].T #置信下限上限 r = (upp-low)/2 #置信半径 num = np.arange(1, len(x0)+1) plt.errorbar(num, re.resid, r, fmt=\u0026#39;o\u0026#39;) plt.show() a = np.loadtxt(\u0026#39;data10_1.txt\u0026#39;) plt.rc(\u0026#39;font\u0026#39;, size=15); plt.plot(a[0], a[1], \u0026#39;o\u0026#39;) plt.figure(); check(a) a2 = a; a2 = np.delete(a2, 8, axis=1) #删除第9列 check(a2); a3 = a2 a3 = np.delete(a3, 4, axis=1); check(a3) 注意几个比较重要的值：R方，F，P，s方（残差的方差）\n多元线性回归 一种使用公式构建，一种使用数组构建。\nplot是制图\nfit是利用极大似然估计进行估计未知参数\nppf反函数\npdf概率密度函数\nimport numpy as np import statsmodels.api as sm import pylab as plt a = np.loadtxt(\u0026#39;data10_2.txt\u0026#39;) plt.rc(\u0026#39;text\u0026#39;, usetex=True); plt.rc(\u0026#39;font\u0026#39;, size=16) plt.plot(a[0], a[2], \u0026#39;*\u0026#39;, label=\u0026#39;$x_1$\u0026#39;) plt.plot(a[1], a[2], \u0026#39;o\u0026#39;, label=\u0026#39;$x_2$\u0026#39;) plt.legend(loc=\u0026#39;upper left\u0026#39;) d = {\u0026#39;x1\u0026#39;: a[0], \u0026#39;x2\u0026#39;: a[1], \u0026#39;y\u0026#39;: a[2]} re = sm.formula.ols(\u0026#39;y~x1+x2\u0026#39;, d).fit() print(re.summary()) yh = re.predict({\u0026#39;x1\u0026#39;: [9, 10], \u0026#39;x2\u0026#39;: [10, 9]}) print(\u0026#39;残差的方差:\u0026#39;, re.mse_resid) print(\u0026#39;预测值：\u0026#39;, yh); plt.show() import numpy as np import statsmodels.api as sm import pylab as plt a = np.loadtxt(\u0026#39;data10_2.txt\u0026#39;) plt.rc(\u0026#39;text\u0026#39;, usetex=True); plt.rc(\u0026#39;font\u0026#39;, size=16) plt.plot(a[0], a[2], \u0026#39;*\u0026#39;, label=\u0026#39;$x_1$\u0026#39;) plt.plot(a[1], a[2], \u0026#39;o\u0026#39;, label=\u0026#39;$x_2$\u0026#39;) plt.legend(loc=\u0026#39;upper left\u0026#39;) X = sm.add_constant(a[:2].T) re = sm.OLS(a[2], X).fit() print(re.summary()) yh = re.predict(np.array([[1,9,10],[1,10,9]])) print(\u0026#39;残差的方差:\u0026#39;, re.mse_resid) print(\u0026#39;预测值：\u0026#39;, yh); plt.show() 多项式回归和逐步回归 看图判定几次函数拟合比较好。\n#程序文件ex10_4.py import numpy as np import statsmodels.formula.api as smf import pylab as plt a = np.loadtxt(\u0026#39;data10_4.txt\u0026#39;); x1 = a[0]; x2 = a[1]; y = a[2] plt.rc(\u0026#39;text\u0026#39;, usetex=True); plt.rc(\u0026#39;font\u0026#39;, size=16) plt.plot(x1, y, \u0026#39;*\u0026#39;, label=\u0026#39;$x_1$\u0026#39;); plt.plot(x2, y, \u0026#39;o\u0026#39;, label=\u0026#39;$x_2$\u0026#39;) d = {\u0026#39;y\u0026#39;: y, \u0026#39;x1\u0026#39;: x1, \u0026#39;x2\u0026#39;: x2} re1 = smf.ols(\u0026#39;y~x1+x2\u0026#39;, d).fit() print(\u0026#39;线性回归的残差方差：\u0026#39;, re1.mse_resid) re2 = smf.ols(\u0026#39;y~x1+x2+I(x1**2)+I(x2**2)\u0026#39;, d).fit() #这里注意写法，\u0026#39;是括起来的，最后有一个d print(\u0026#39;纯二次的残差方差：\u0026#39;, re2.mse_resid) re3 = smf.ols(\u0026#39;y~x1*x2\u0026#39;, d).fit() print(\u0026#39;交叉的残差方差：\u0026#39;, re3.mse_resid) re4 = smf.ols(\u0026#39;y~x1*x2+I(x1**2)+I(x2**2)\u0026#39;, d).fit() print(\u0026#39;完全二次的残差方差：\u0026#39;, re4.mse_resid) print(\u0026#39;预测值：\u0026#39;, re2.predict({\u0026#39;x1\u0026#39;: 170, \u0026#39;x2\u0026#39;: 160})) print(re2.summary()); plt.legend(); plt.show() re2 = smf.ols(\u0026#39;y~x1+x2+I(x1 **2) +I(x2 * *2)\u0026#39;, d).fit() 这里注意写法，\u0026lsquo;是括起来的，最后有一个d\n这个模型寻求残差最小的值。\n#程序文件ex10_5.py import numpy as np import pandas as pd from scipy.stats import t, f import statsmodels.api as sm a = pd.read_excel(\u0026#39;data10_5.xlsx\u0026#39;, header=None) b = a.values; Y=np.hstack([b[:,1],b[:-1,6]]) X = np.vstack([b[:,2:5],b[:-1,7:]]) XX = np.hstack([np.ones((25,1)),X]) cs = np.linalg.pinv(XX) @ Y #最小二乘法拟合参数 print(\u0026#39;拟合的参数为：\u0026#39;, np.round(cs,4)) yb = Y.mean() #计算y的观测值的平均值 yh = XX @ cs #计算y的估计值 q = sum((yh-Y)**2) #计算残差平方和 u = sum((yh-yb)**2) #计算回归平方和 m =3; n = len(Y) #变量个数和样本容量 F = u/m/(q/(n-m-1)) #计算F统计量的值 print(\u0026#39;F=\u0026#39;, round(F,4)) fw = f.ppf(0.95, m, n-m-1) #计算上alpha分位数 print(\u0026#39;F分布的上alpha分位数：\u0026#39;, round(fw,4)) c = np.diag(np.linalg.inv(XX.T @ XX)) ts = cs/np.sqrt(c)/np.sqrt(q/(n-m-1)) #计算t统计量的值 tw = t.ppf(0.975, n-m-1) #计算上alpha/2分位数 print(\u0026#39;t统计量值为：\u0026#39;, np.round(ts,4)) print(\u0026#39;t分布的上alpha/2分位数：\u0026#39;, round(tw,4)) XD = np.delete(XX,1,axis=1) #删除x1的观测值 cs2 = np.linalg.pinv(XD) @ Y #重新拟合参数 print(\u0026#39;x2,x3模型的参数值：\u0026#39;,np.round(cs2,4)) d = {\u0026#39;y\u0026#39;:Y,\u0026#39;x1\u0026#39;:X[:,0],\u0026#39;x2\u0026#39;:X[:,1],\u0026#39;x3\u0026#39;:X[:,2]} md = sm.formula.ols(\u0026#39;y~x1*x2+x1*x3+x2*x3+I(x1**2)+I(x2**2)+I(x3**2)\u0026#39;,d).fit() print(\u0026#39;完全二次项的系数为：\u0026#39;, md.params) 上下和左右合并矩阵的方法。\n左取右不取。\n矩阵有一行是是空的，所以切片要-1。\n#程序文件ex10_6.py import numpy as np import statsmodels.api as sm a = np.loadtxt(\u0026#39;data10_6.txt\u0026#39;) d = {\u0026#39;x1\u0026#39;:a[:,0], \u0026#39;x2\u0026#39;:a[:,1], \u0026#39;x3\u0026#39;:a[:,2], \u0026#39;x4\u0026#39;:a[:,3], \u0026#39;y\u0026#39;:a[:,4]} md1 = sm.formula.ols(\u0026#39;y~x1+x2+x3+x4\u0026#39;,d).fit() print(md1.tvalues) #下面删除变量的t值绝对值最小的 md2 = sm.formula.ols(\u0026#39;y~x1+x2+x4\u0026#39;,d).fit() print(md2.tvalues) #下面删除变量的t值绝对值最小的 md3 = sm.formula.ols(\u0026#39;y~x1+x2\u0026#39;, d).fit() print(md3.summary()) print(\u0026#39;残差方差：\u0026#39;, md3.mse_resid) 每次舍去一个。\n广义线性回归模型 分组的logistic回归模型 处理01型因变量产生的问题。回归函数改为分布在01区间。\n可以使用Yi等于1的比例来代替yi本身作为因变量（yi只可以为0或1）\n分组的适用于样本量大的数据，样本小的不宜分组。\n可以使用ols或glm\n未分组的logistic回归模型 #程序文件ex10_8_1.py import numpy as np import statsmodels.api as sm a = np.loadtxt(\u0026#39;data10_8.txt\u0026#39;) x = np.vstack([a[:, 1:4], a[:, 6:-1]]) y = np.hstack([a[:, 4], a[:, 9]]) d={\u0026#39;x1\u0026#39;: x[:,0], \u0026#39;x2\u0026#39;:x[:,1], \u0026#39;x3\u0026#39;:x[:,2], \u0026#39;y\u0026#39;:y} md = sm.formula.logit(\u0026#39;y~x1+x2+x3\u0026#39;, d).fit() print(md.summary()) md2 = sm.formula.logit(\u0026#39;y~x1+x3\u0026#39;, d).fit() print(md2.summary()) 或使用glm函数\n#程序文件ex10_8_2.py import numpy as np import statsmodels.api as sm a = np.loadtxt(\u0026#39;data10_8.txt\u0026#39;) x = np.vstack([a[:, 1:4], a[:, 6:-1]]) y = np.hstack([a[:, 4], a[:, 9]]) d={\u0026#39;x1\u0026#39;: x[:,0], \u0026#39;x2\u0026#39;:x[:,1], \u0026#39;x3\u0026#39;:x[:,2], \u0026#39;y\u0026#39;:y} md1 = sm.formula.glm(\u0026#39;y~x1+x2+x3\u0026#39;, d, family=sm.families.Binomial()).fit() print(md1.summary()) md2 = sm.formula.glm(\u0026#39;y~x1+x3\u0026#39;, d, family=sm.families.Binomial()).fit() print(md2.summary()) probit回归模型 使用到了分布函数的反函数,ppf\n#程序文件ex10_9.py import numpy as np import statsmodels.api as sm from scipy.stats import norm a = np.loadtxt(\u0026#34;data10_7_1.txt\u0026#34;) x = a[:,0]; pi = a[:,2]/a[:,1]; yi = norm.ppf(pi) X = sm.add_constant(x) md = sm.OLS(yi, X).fit() #构建并拟合模型 print(md.summary()) #输出模型的所有结果 p0= norm.cdf(md.predict([1, 9])) print(\u0026#34;所求比例p0=%.4f\u0026#34;%p0) 偏最小二乘回归 多个因变量和自变量\n 数据标准化 求得相关系数矩阵 分别提出自变量组和因变量组的成分 求回归方程 模型的解释和检验，交叉有效性检验  建议的成分个数，使均方差最小。\n#程序文件ex13_2.py import numpy as np from sklearn.cross_decomposition import PLSRegression from scipy.stats import zscore from sklearn.model_selection import cross_val_predict from sklearn.metrics import mean_squared_error d0 = np.loadtxt(\u0026#39;data13_2.txt\u0026#39;) mu = d0.mean(axis=0) #求均值 s =d0.std(axis=0, ddof=1) #求标准差 r = np.corrcoef(d0.T) #求相关系数矩阵 d = zscore(d0, ddof=1) #数据标准化 a = d[:, :7]; b = d[:, 7:] n = a.shape[1]; m = b.shape[1] #自变量和因变量个数 mse = [] #均方误差初始化 for i in range(1, n+1): #以下确定成分的个数 pls = PLSRegression(i) y_cv = cross_val_predict(pls, a, b) mse.append(mean_squared_error(b, y_cv)) nmin = np.argmin(mse); print(\u0026#39;均方误差：\\n\u0026#39;, mse) print(\u0026#39;建议的成分个数: \u0026#39;, nmin+1) md = PLSRegression(2).fit(a, b) b = md.coef_ #每一列是y对x的回归系数 print(\u0026#39;标准化数据的回归系数(列)：\\n\u0026#39;, b) b0 = np.zeros((n+1, m)) b0[0, :] = mu[n:] - mu[:n]/s[:n] @ b * s[n:] for i in range(m): b0[1:, i] = s[n+i]/s[:n] * b[:,i] print(\u0026#39;(原始数据)y关于x回归系数(列):\\n\u0026#39;, b0) ","permalink":"https://tassel234.github.io/posts/note/python%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AE%97%E6%B3%95-2%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90/","summary":"参考资源 python数学建模算法与应用 https://blog.csdn.net/weixin_35757704/article/details/117808073 https://blog.csdn.net/chuididehuayiren/article/details/109765279 图表解释 第一部分左边 Dep. Variable:即dependent variable，因变量 OLS:普通最小二乘法 least squares：最小化残差平方和 No. Observations:个案数，即样本容量 df residuals：残差自由度(观测数No.Obs","title":"Python数学建模算法-2（回归分析）"},{"content":"python数模算法-1（库的基本使用和绘图基础） 前言 使用学习资源 python数学建模算法与应用（司守奎） 比较全面的建模算法视频（编程语言是matlab）\n目标指向 只需要会看那些代码并运行实现一次代码和理解用途就可以了，需要使用的时候查阅复制粘贴就可以了。\n算法具体实现的逻辑步骤要搞清楚，锻炼一些编程思想，可以对程序进行合理的修改。\n编程环境配置 conda-python3.10.9\nlatex（可无）\n库的使用 numpy对数组 数组生成\nimport numpy as np a1 = np.array([1, 2, 3, 4]) #生成整型数组 a2 = a1.astype(float) a3 = np.array([1, 2, 3, 4], dtype=float) #浮点数 print(a1.dtype); print(a2.dtype); print(a3.dtype) b = np.array([[1, 2, 3], [4, 5, 6]]) c = np.arange(1,5) #生成数组[1, 2, 3, 4] d = np.linspace(1, 4, 4) #前面是范围，后面是分割数，生成数组[1, 2, 3, 4] e = np.logspace(1, 3, 3, base=2) #生成等比数列数组[2, 4, 8] import numpy as np a = np.ones(4, dtype=int) #输出[1, 1, 1, 1] b = np.ones((4,), dtype=int) #逗号加在前面会报错，输出同a c= np.ones((4,1)) #输出4行1列的数组 d = np.zeros(4) #输出[0, 0, 0, 0] e = np.empty(3) #生成3个元素的空数组行向量 f = np.eye(3) #生成3阶单位阵 g = np.eye(3, k=-1) #主对角线是0，生成第k对角线的元素为1，其他元素为0的3阶方阵 h = np.zeros_like(a) #生成与a同维数的全0数组 print(g) print(c) 数组元素的索引\nimport numpy as np a = np.arange(16).reshape(4,4) #生成4行4列的数组 b = a[1][2] #输出6 c = a[1, 2] #同b d = a[1:2, 2:3] #输出[[6]] x = np.array([0, 1, 2, 1]) print(a[x==1]) #输出a的第2、4行元素 print(a) numpy对矩阵 矩阵的合并 np.vstack([a, b]) #上下合并矩阵 np.hstack([a, c]) #左右合并矩阵\n矩阵的分割 b = np.vsplit(a, 2) #行分割 c = np.hsplit(a, 4) #列分割\n矩阵的乘法\n使用符号@，前面的相当于行向量\n范数计算\nimport numpy as np a = np.array([[0, 3, 4], [1, 6, 4]]) b = np.linalg.norm(a, axis=1) #求行向量2范数 c = np.linalg.norm(a, axis=0) #求列向量2范数 d = np.linalg.norm(a) #求矩阵2范数 print(\u0026#39;行向量2范数为：\u0026#39;, np.round(b, 4)) print(\u0026#39;列向量2范数为：\u0026#39;, np.round(c, 4)) print(\u0026#39;矩阵2范数为：\u0026#39;, round(d, 4)) 求线性方程的唯一解\nimport numpy as np a = np.array([[3, 1], [1, 2]]) b = np.array([9, 8]) x1 = np.linalg.inv(a) @ b #第一种解法 #上面语句中@表示矩阵乘法 x2 = np.linalg.solve(a, b) #第二种解法 print(x1); print(x2) 求超定线性方程组的唯一解\nimport numpy as np a = np.array([[3, 1], [1, 2], [1, 1]]) b = np.array([9, 8, 6]) x = np.linalg.pinv(a) @ b print(np.round(x, 4)) 特征值和特征向量\nimport numpy as np a = np.eye(4) b = np.rot90(a) #好像代表转 c, d = np.linalg.eig(b) print(\u0026#39;特征值为：\u0026#39;, c) print(\u0026#39;特征向量为：\\n\u0026#39;, d) pandas 生成二维数组\nimport pandas as pd import numpy as np dates=pd.date_range(start=\u0026#39;20191101\u0026#39;,end=\u0026#39;20191124\u0026#39;,freq=\u0026#39;D\u0026#39;) a1=pd.DataFrame(np.random.randn(24,4), index=dates, columns=list(\u0026#39;ABCD\u0026#39;)) a2=pd.DataFrame(np.random.rand(24,4)) 读写文件\nimport pandas as pd import numpy as np dates=pd.date_range(start=\u0026#39;20191101\u0026#39;, end=\u0026#39;20191124\u0026#39;, freq=\u0026#39;D\u0026#39;) a1=pd.DataFrame(np.random.randn(24,4), index=dates, columns=list(\u0026#39;ABCD\u0026#39;)) a2=pd.DataFrame(np.random.randn(24,4)) a1.to_excel(\u0026#39;data2_38_1.xlsx\u0026#39;) #可以修改此行让其不带索引 a2.to_csv(\u0026#39;data2_38_2.csv\u0026#39;) f=pd.ExcelWriter(\u0026#39;data2_38_3.xlsx\u0026#39;) #创建文件对象 a1.to_excel(f,\u0026#34;Sheet1\u0026#34;) #把a1写入Excel文件 a2.to_excel(f,\u0026#34;Sheet2\u0026#34;) #把a2写入另一个表单中 f.save() 数据预处理\nimport pandas as pd import numpy as np d=pd.DataFrame(np.random.randint(1,6,(10,4)), columns=list(\u0026#34;ABCD\u0026#34;)) d1=d[:4] #获取前4行数据 d2=d[4:] #获取第5行以后的数据 dd=pd.concat([d1,d2]) #数据行合并 s1=d.groupby(\u0026#39;A\u0026#39;).mean() #数据分组求均值 s2=d.groupby(\u0026#39;A\u0026#39;).apply(sum) #数据分组求和 import pandas as pd import numpy as np a = pd.DataFrame(np.random.randint(1,6,(5,3)), index=[\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;], columns=[\u0026#39;one\u0026#39;, \u0026#39;two\u0026#39;, \u0026#39;three\u0026#39;]) a.loc[\u0026#39;a\u0026#39;, \u0026#39;one\u0026#39;] = np.nan #修改第1行第1列的数据 b = a.iloc[1:3, 0:2].values #提取第2、3行，第1、2列数据 a[\u0026#39;four\u0026#39;] = \u0026#39;bar\u0026#39; #增加第4列数据 a2 = a.reindex([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;]) a3 = a2.dropna() #删除有不确定值的行 scipy 求解非线性方程\nfrom scipy.optimize import fsolve, root fx = lambda x: x**980-5.01*x**979+7.398*x**978\\ -3.388*x**977-x**3+5.01*x**2-7.398*x+3.388 x1 = fsolve(fx, 1.5, maxfev=4000) #函数调用4000次 x2 = root(fx, 1.5) print(x1,\u0026#39;\\n\u0026#39;,\u0026#39;-------------\u0026#39;); print(x2) 最小二乘法\nfrom scipy.optimize import least_squares import numpy as np a=np.loadtxt(\u0026#39;data2_47.txt\u0026#39;) x0=a[0]; y0=a[1]; d=a[2] fx=lambda x: np.sqrt((x0-x[0])**2+(y0-x[1])**2)-d s=least_squares(fx, np.random.rand(2)) print(s, \u0026#39;\\n\u0026#39;, \u0026#39;------------\u0026#39;, \u0026#39;\\n\u0026#39;, s.x) 求最大模特征值和对应的特征向量\nfrom scipy.sparse.linalg import eigs import numpy as np a = np.array([[1, 2, 3], [2, 1, 3], [3, 3, 6]], dtype=float) #必须加float,否则出错 b, c = np.linalg.eig(a) d, e = eigs(a, 1) print(\u0026#39;最大模特征值为：\u0026#39;, d) print(\u0026#39;对应的特征向量为：\\n\u0026#39;, e) 此外，还可以求解积分，傅里叶变换，插值，信号处理等。\nsympy 可以用计算机推导表达式，可以对符号运算。\nimport sympy as sp a, b, c, x=sp.symbols(\u0026#39;a,b,c,x\u0026#39;) x0=sp.solve(a*x**2+b*x+c, x) print(x0) import sympy as sp sp.var(\u0026#39;x1,x2\u0026#39;) s=sp.solve([x1**2+x2**2-1,x1-x2],[x1,x2]) print(s) import numpy as np import sympy as sp a = np.identity(4) #单位矩阵的另一种写法 b = np.rot90(a) c = sp.Matrix(b) print(\u0026#39;特征值为：\u0026#39;, c.eigenvals()) print(\u0026#39;特征向量为：\\n\u0026#39;, c.eigenvects()) matplotlib绘图介绍 二维绘图 绘制折线图\nimport pandas as pd import pylab as plt plt.rc(\u0026#39;font\u0026#39;,family=\u0026#39;SimHei\u0026#39;) #用来正常显示中文标签，还有一个正常显示符号的语句 plt.rc(\u0026#39;font\u0026#39;,size=16) #设置显示字体大小 a=pd.read_excel(\u0026#34;data2_52.xlsx\u0026#34;, header=None) #和py文件保存在同一级目录 b=a.values #提取其中的数据 x=b[0]; y=b[1:] plt.plot(x,y[0],\u0026#39;-*b\u0026#39;,label=\u0026#39;铂金\u0026#39;) plt.plot(x,y[1],\u0026#39;--dr\u0026#39;,label=\u0026#39;铂金\u0026#39;) plt.xlabel(\u0026#39;月份\u0026#39;); plt.ylabel(\u0026#39;每月销量\u0026#39;) plt.legend(loc=\u0026#39;upper left\u0026#39;); plt.grid(); plt.show() ()使用pandas的Dateframe绘图 绘制柱状图\nimport pandas as pd import pylab as plt plt.rc(\u0026#39;font\u0026#39;,family=\u0026#39;SimHei\u0026#39;) #用来正常显示中文标签 plt.rc(\u0026#39;font\u0026#39;,size=16) #设置显示字体大小 a=pd.read_excel(\u0026#34;data2_52.xlsx\u0026#34;,header=None) b=a.T; b.plot(kind=\u0026#39;bar\u0026#39;); plt.legend([\u0026#39;钻石\u0026#39;, \u0026#39;铂金\u0026#39;]) plt.xticks(range(6), b[0], rotation=0); plt.show() 子图\nimport pylab as plt import numpy as np plt.rc(\u0026#39;text\u0026#39;, usetex=True) #调用tex字库 y1=np.random.randint(2, 5, 6); y1=y1/sum(y1); plt.subplot(2, 2, 1); str=[\u0026#39;Apple\u0026#39;, \u0026#39;grape\u0026#39;, \u0026#39;peach\u0026#39;, \u0026#39;pear\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;pineapple\u0026#39;] plt.barh(str,y1) #水平条形图 plt.subplot(222); plt.pie(y1, labels=str) #饼图 plt.subplot(212) x2=np.linspace(0.01, 10, 100); y2=np.sin(10*x2)/x2 plt.plot(x2,y2); plt.xlabel(\u0026#39;$x$\u0026#39;) plt.ylabel(\u0026#39;$\\\\mathrm{sin}(50x)/x$\u0026#39;); plt.show()#latex表示数学公式 linspace(a,b,c)表示的是把a-b平均分成c分, 三维绘图 三维曲线\nimport pylab as plt import numpy as np ax=plt.axes(projection=\u0026#39;3d\u0026#39;) #设置三维图形模式 z=np.linspace(-50, 50, 1000) x=z**2*np.sin(z); y=z**2*np.cos(z) plt.plot(x, y, z, \u0026#39;k\u0026#39;); plt.show() 三维表面图\nimport pylab as plt import numpy as np x=np.linspace(-4,4,100); x,y=np.meshgrid(x,x) z=50*np.sin(x+y); ax=plt.axes(projection=\u0026#39;3d\u0026#39;) ax.plot_surface(x, y, z, color=\u0026#39;y\u0026#39;) plt.show() import pylab as plt import numpy as np ax=plt.axes(projection=\u0026#39;3d\u0026#39;) X = np.arange(-6, 6, 0.25) Y = np.arange(-6, 6, 0.25) X, Y = np.meshgrid(X, Y) Z = np.sin(np.sqrt(X**2 + Y**2)) surf = ax.plot_surface(X, Y, Z, cmap=\u0026#39;coolwarm\u0026#39;) plt.colorbar(surf); plt.show() 概率统计模型专题绘图 直方图 也称频数图\nimport pandas as pd import pylab as plt df = pd.read_csv(\u0026#39;data9_5.txt\u0026#39;, header=None) df = df.T #转置 plt.subplot(121); h1 = plt.hist(df[0], 5); print(h1) plt.subplot(122); plt.hist(df[1], 5) df.hist(bins=5) #另一种方法画直方图 plt.show() 箱线图\n几个点分别是最小值，1/4值，中位数，3/4点，最大值。 用来观察离散程度。\nimport pandas as pd import pylab as plt df = pd.read_csv(\u0026#39;data9_5.txt\u0026#39;, header=None).T plt.rc(\u0026#39;font\u0026#39;, family=\u0026#39;SimHei\u0026#39;); plt.rc(\u0026#39;font\u0026#39;, size=16); plt.boxplot(df, labels=[\u0026#39;甲班\u0026#39;, \u0026#39;乙班\u0026#39;]); plt.show() QQ图\n可以检验拟合优度。同时不建议直接使用库函数绘制QQ图\nimport pandas as pd import pylab as plt from scipy.stats import norm, probplot df = pd.read_csv(\u0026#39;data9_5.txt\u0026#39;, header=None) d = df.values[0] #提取甲班成绩 mu = d.mean(); s = d.std(); sd = sorted(d); n = len(d) x = (plt.arange(n)+1/2)/n; yi = norm.ppf(x, mu, s) plt.rc(\u0026#39;font\u0026#39;, size=16); plt.rc(\u0026#39;font\u0026#39;, family=\u0026#39;SimHei\u0026#39;) plt.rc(\u0026#39;axes\u0026#39;, unicode_minus=False) plt.subplot(121); plt.plot(yi, sd, \u0026#39;o\u0026#39;, label=\u0026#39;QQ图\u0026#39;) plt.plot(sd, sd, label=\u0026#39;参照直线\u0026#39;); plt.legend() plt.subplot(122); probplot(d, plot=plt); plt.show() ","permalink":"https://tassel234.github.io/posts/note/python%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AE%97%E6%B3%95-1%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%92%8C%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80/","summary":"python数模算法-1（库的基本使用和绘图基础） 前言 使用学习资源 python数学建模算法与应用（司守奎） 比较全面的建模算法视频（编程语言是matlab） 目标指向 只需要会看那些代码并运行实现一次代码和理解用途就可以了，需要使用的时候查阅复制粘贴就可以了。 算法具体实现的逻辑步骤要搞","title":"Python数学建模算法-1（库的基本使用和绘图基础）"},{"content":"github和git的基础知识（可跳过不看）  Github 代码上边的Raw、Blame是什么意思？\n  Raw：文件内容。 blame：按行显示最新提交的信息。\n Pin，该词可被译为：钉住、按住。被Pin的仓库会显示在个人主页中，类似于仓库置顶。 Watch，默认是Unwatch，如果你想关注某个仓库，当这个库有新的通知时就会提醒你。 star,表示喜爱。\nFork代表从别人的代码仓库中复制一份到自己的代码库，包含了别人库中的提交历史记录。经过fork后的代码库是完全独立的，由自己维护，可以进行任何魔改。改完之后自己可以通过Pull Request向原来的库提交合并请求。 1. Fork别人的仓库：复制别人仓库（代码、文件、提交历史记录、issue等），复制后的仓库在自己的github账号中存着。 2. Clone远程仓库：将这个复制后的远程仓库克隆到本地。 3. 在工作区对代码进行CRUD操作（增删改查） 4. 将代码的更改提交暂存区（git add .） 5. 将暂存区的文件提交到本地仓库（git commit -m \u0026lsquo;小修一下\u0026rsquo;） 6. 将本地仓库的代码推送到远程仓库（git push） 7. 给别人的仓库发送Pull Request：如果原作者认为你的修改版本不错，就会将你代码中的修改合并到自己的库中。\n可以在写编写markdown文件于github网站\nGit是一款分布式源代码管理工具(版本控制工具) ，可以对我们写的代码进行托管和版本记录（每上传一次形成一个版本，可以找回）。github和git的关系非常紧密，hub在百度翻译有如下解释：\n n. 轮毂; (某地或活动的)中心; [例句]The island\u0026rsquo;s social hub is the Cafe Sport 该岛的社交中心是“体育咖啡馆”。 可以理解为github以git为传输路径，把程序员上传过的代码集中,迭代，存放在github的仓库中，方便和其他程序员的合作或交流。\n git的进一步学习\n前言 本文介绍如何使用Github+Hugo+PaperMod主题搭建一个人博客。\n此文章也记录了我搭建博客较为详细的步骤和一些在博客搭建过程中出现的问题和解决方案。\n参考资料 23年的hugo博客搭建视频\nsulv的博客\n333rd的博客\nrosefinch-midsummer的博客\n前置工作 需要一个github账号,可以在网页打开github,推荐使用fastgithub软件，翻墙也行。\n下载hugo,推荐安装比较原始的版本，后面会解释为什么。\n下载地址\n下载和安装git，见视频\n安装github desktop，使用该软件可以从本地库克隆到github仓库，并可以完成较为方便的上传更新。\n安装fastgithub，可以获得非常快的github访问速度，而且不用翻墙。\n下载fastgithub\n搭建博客  先下载好hugo,推荐下载hugo v0.85.0版本，之前我下载了最新版本，死活不能把配置文件改成yaml格式，也就没办法直接调用别人写好的漂亮的网站结构。接下来的文字是对视频的总结，更直观的步骤请查阅hugo博客搭建视频 把下载好后把hugo.exe所在的文件夹地址放置在环境变量的系统变量中。 在cmd窗口输入hugo version查看版本和确认安装成功。  生成新站点，hugo new site \u0026lt;想要存储到的位置\u0026gt;/\u0026lt;站点名字\u0026gt; -f yml ， 实例hugo new site D:/path/to/newst -f yml ，  -f yml是把toml文件格式改成yaml格式，最新版这个指令修改不了配置文件（config）格式。\n然后就可以在文件夹找到生成的站点   在路径栏目输入cmd,打开，\n  输入hugo new posts/tech/文章名称.md生成第一篇博客文章。应该在tech目录下写一个_index.md文件用于索引。\n  安装主题，使用命令行git clone https://github.com/adityatelange/hugo-PaperMod.git\n  下载最新版本，实际上后面cmd提示hugo版本和papermod版本不完全匹配，但最后还是可以生成不错的博客页面，然后对config.yaml进行重写，赋值代码和粘贴config.yml此外写入的md文本应该在github复制最新版，旧版会报错。\n写好了开始生成静态页面，站点目录的cmd输入hugo version在本地查看\n 站点目录的cmd输入hugo生成文件夹public\n  在public的文件夹的cmd进行git 导入，输入git init,一个文件夹导入一次就够了\n  博客上传 配置FastGithub(可以跳过不看) 双击打开FastGithub.UI.exe应用程序,程序会在后台运行。\nfirefox提示连接有潜在的安全问题 设置-\u0026gt;隐私与安全-\u0026gt;证书-\u0026gt;查看证书-\u0026gt;证书颁发机构，导入cacert/fastgithub.cer，勾选“信任由此证书颁发机构来标识网站”\n安全性说明\nFastGithub为每台不同的主机生成自颁发CA证书，保存在cacert文件夹下。客户端设备需要安装和无条件信任自颁发的CA证书，请不要将证书私钥泄露给他人，以免造成损失。\n合法性说明\n《国际联网暂行规定》第六条规定：“计算机信息网络直接进行国际联网，必须使用邮电部国家公用电信网提供的国际出入口信道。任何单位和个人不得自行建立或者使用其他信道进行国际联网。” FastGithub本地代理使用的都是“公用电信网提供的国际出入口信道”，从国外Github服务器到国内用户电脑上FastGithub程序的流量，使用的是正常流量通道，其间未对流量进行任何额外加密（仅有网页原有的TLS加密，区别于VPN的流量加密），而FastGithub获取到网页数据之后发生的整个代理过程完全在国内，不再适用国际互联网相关之规定。\n通过git和github desktop将博客上传到github 输入上述两串代码，然后在github desktop进行上传，浏览器的github就可以更新了。\n上传点击fetch origin按钮.\n网页显示 在GitHub网页端，点击hugo博客代码存放库，点击settings,点击pages,修改Branch的none为master,等待一会，就可以生成网页了。\n更新 hugo -F \u0026ndash;cleanDestinationDir完成public文件夹的更新, 然后再重复上传步骤即可.\n添加图片 笔者使用的是vnote，记markdown笔记。 图片引用代码如下： ![](vx_images/ex.png =481x)\n首先应该在static文件夹下创建vx_images文件夹，再把要用的图片导入，但有两个问题。\n 不能加图片大小，也就是把 =481x去掉 前面应该加一个/  如何改进博客 创建拥有美观界面的博客 sulv大佬已经写好了一个优美的yaml配置文件,我们只需要复制粘贴到config配置文件就可以了。 但博客网页的yaml代码不能成功执行，因为sulv的博客和333rd的博客的博客都是创作于几年前，hugo和papermod的版本更新导致了各种问题，所以应该直接在github中复制，config.yml\n至于配置头像，联系方式等，也请参照上面两个博客。\n改进指南 插件\n建站\n统计部署\n为什么要写博客  通过强迫自己记笔记，对知识进行整理，对日常和灵感进行记录 可以促进知识的输出，检验自己的掌握程度，类似费曼学习法 博客本身可以促进学习，并且有助于和别人交流自己的想法  ","permalink":"https://tassel234.github.io/posts/tech/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","summary":"github和git的基础知识（可跳过不看） Github 代码上边的Raw、Blame是什么意思？ Raw：文件内容。 blame：按行显示最新提交的信息。 Pin，该词可被译为：钉住、按住。被Pin的仓库会显示在个人主页中，类似于仓库置顶。 Watch，默认是Unwatch，如果你想关注某个仓库，","title":"Hugo搭建个人博客"},{"content":"故事梗概 《外婆的道歉信》是瑞典作家弗雷德里克·巴克曼创作的一部长篇小说，讲述了一个关于爱，原谅与守护的温馨故事。这部作品以其幽默、独特的叙事风格和深入浅出的人物描绘，受到了广泛关注。\n小说以小女孩爱莎的视角，展示了一个独特、充满想象力的世界。爱莎是一个聪明、机智的小女孩，她与外婆共同生活，度过了许多难忘的时光。外婆是一个疯狂古怪，打破世俗，四处惹麻烦的存在，却是小女孩爱莎心中的英雄和唯一的朋友。为了安抚爱莎不幸的童年，给与爱莎爱的守护，外婆创作了一个又一个童话故事。然而，外婆去世后，爱莎发现自己陷入了一场冒险——把外婆的道歉信分发给曾经受到外婆恶作剧的邻居们，于是爱莎在外婆留下的一系列谜团和线索中寻找真相并逐渐理解了外婆的良苦用心。这一趟送信之旅让爱莎发现：外婆和邻居的故事，比她听过的任何童话故事都更加精彩。\n爱莎与外婆之间的深厚感情贯穿始终，让人动容。虽然外婆在故事中并不完美，但她对爱莎的关爱和付出是无法替代的。无论发生什么情况，外婆都会站在爱莎这边，为了她和世界拼命。爱莎在寻找真相的过程中，逐渐理解了外婆的期待，理解了外婆所讲故事的隐含意义，最终学会了勇气和坚强，也原谅了外婆的离去。\n文章既有童话的温馨浪漫，也有现实的残酷黑暗。爱莎从小父母离异，在学校遭受霸凌，唯一的朋友外婆也在爱莎八岁时也因为癌症死去，但爱莎并未因此消极堕落，因为童话，外婆，父母，邻居们的共同守护与治愈，爱莎得以更加坚强，温柔的成长。\n读后感 文中我最喜欢的人毫无疑问是外婆。外婆独立，不拘世俗，经常打破常规，四处惹麻烦。“要大笑，要做梦，要与众不同”是外婆的口头禅，她甚至用她的敢打敢拼赢下过一座楼。外婆也是一个温柔善良的人，是一个不怕危险，到处救死扶伤的医生（外婆那个年代学医比较打破常规），奔赴过海啸受灾城市，战场前线救人，她还把一些无家可归的人安置在自己的楼里。外婆在行医的过程中结交过很多形形色色的人，锻炼了各种各样的技能（不过狂妄大胆像是天生的）。所以在爱莎眼里，外婆是一个无所不能的超级英雄。外婆为爱莎构建了一个童话世界，这个世界可以让她克服恐惧和不安，成为内心的支柱，可以为她疲惫之时提供栖息的港湾。\n文中第二个值得讨论的角度是故事。读过全文后就可以发现，外婆创作的故事中的人物其实就是以她帮助过的人为蓝本制作的，诞生的故事进一步去安抚，帮助那些受伤的心灵（有孩子也有大人）。事实上这里可以发现外婆的故事并不是单单为了爱莎而创作，而是诞生在更早之前，为了那些流离失所的孩子而创作，故事的力量可以在爱莎的经历中窥得一斑。\n故事的力量让我想起来了人类简史(这本书是犹左作品，在构建主义上有一些争议，之后也会在读后感讨论)中提到的故事概念，简单来说，我们人类所创造的一切可以被传递和认同的思维思想造物都可以被称为故事，小至童话，寓言，大至各类主义，意识形态，人类的社会就是由无数的故事构成的，我们以相同的故事彼此认同，进而拼接成为文化，民族，国家，文明。故事的诞生之初，承担着教育启蒙的作用，后来故事开始发展为以讴歌赞颂为主，人们迫切的寻求最浪漫完美，可以被奉为涅槃的故事集。随着人们建设自己精神的力量和欲望日渐强大，也开始催生出无数亚文化。\n对那些经历过战争或自然灾害，在绝望的死土上生活的那些孩子，对那些未来无限迷茫，没有光明，希望，呆滞着的那些孩子，一把火，一段围着火堆不成章法的随情热舞，就足以让他们忘记身前身后的一切烦恼，让他们快乐于此刻，不再为生命的寂寥而担忧。如果有人愿意为他们讲上一个精彩的关于爱，勇气和希望的故事，那么他们就可以在幻想的世界里安静安宁的休息片刻，然后好好的长大。这也是故事的意义之一。和外婆的道歉信相似的故事形式，我能联想到的是东方的幻想乡和海猫的黄金乡（前者是车万越共，后者是在故事中讨论故事）。\n第三个角度是关于守护。俗话说的好：大人的职责就是保卫孩子们的健康成长，简称大保健。孩子身上承担着关于未来无限个可能性的力量，或许会引导他们去实现那缈不可及的理想世界和走向最终的故事。大人的意义就是 大保健 为孩子铺上一些路，种上一些花，留下一些种子。\n登场人物 血缘（6人）：爱莎，外婆，爱莎的妈妈，爱莎的爸爸，继父乔治，爱莎的同母异父弟弟小半\n邻居（9人2狗）：三楼 布里特.玛丽，肯特 黑裙女人\n二楼 莫纳特，莫德，莎曼萨（比熊犬） 阿尔法\n一楼 生病男孩，其母亲 怪物（狼心），呜斯（大狗）\n其他（1人）：山姆（狼心曾经的朋友）\n","permalink":"https://tassel234.github.io/posts/read/%E5%A4%96%E5%A9%86%E7%9A%84%E9%81%93%E6%AD%89%E4%BF%A1%E8%AF%BB%E5%90%8E%E6%84%9F/","summary":"故事梗概 《外婆的道歉信》是瑞典作家弗雷德里克·巴克曼创作的一部长篇小说，讲述了一个关于爱，原谅与守护的温馨故事。这部作品以其幽默、独特的叙事风格和深入浅出的人物描绘，受到了广泛关注。 小说以小女孩爱莎的视角，展示了一个独特、充满想象力的世界。爱莎是一个聪明、机智的小女孩，她与外婆共","title":"《外婆的道歉信》读后感"},{"content":"前言 使用资源 西工大网课(在慕课和b站都可以找到资源)\nBjarne Stroustrup《C++程序设计语言》\n洛谷的一些编程题\n主要以网课为主.\n引言 计算机系统由硬件和软件共同组成。硬件主体为输入输出设备，存储器，运算器，控制器。软件又分为系统软件和应用软件。应用软件就是用户下载的音乐播放器，聊天软件，浏览器的软件。而系统软件是一个计算机系统系统必备的，需要提前安装的软件，比如操作系统，数据库系统和网络系统，此外程序设计语言和语言执行程序也应该属于系统软件，其实应该说以语言编写的代码才是软件的基石。\n计算机编程语言其实和汉语，英语等我们口头表达，纸笔书写的语言没有本质的区别，编程语言其实也是把我们的想法转化为特定的词汇和语法，让我们可以和计算机交流。如果我们想书写美妙的编程诗篇，扎实的语言功底，表达力，逻辑力，想象力，创造力缺一不可。\n数据在计算机内部的样子 计算机只能够理解0和1，所以我们编写的程序最后都会转化为计算机可以理解的01代码，同样我们日常使用十进制数据也要变为二进制。\n进制之间的转化。十进制如何转化为二进制，对于整数部分是除以2取余数，对于小数部分是乘2取整数部分，是0就取0。二进制和八，十六进制的转化，整数高位补0，小数低位补0。\n对于数字类型，一般第一位代表±，以-1的次方计数，0正1负。\n二进制的计算。原码可以比较有效的对正数计算，反码指负数的负号位不变，其他位01互换，补码是在反码的基础上进行加1，利用溢出计算。\n浮点数二进制。先表示为科学计数法，对有效数字进行二进制化，分别塞上符号位，二进制的表示数，二的次方数。\n数据类型 基本数据类型。一个字节八位。\n int4,long int 4,unsigned int 4 ,第一位是符号位，而对于无符号的unsigned代表的正数范围多二倍。 char 1,也代表asc||码，为128个，‘1‘49，A65，a97。   float 4,double 8，一般小数都是double,一般计算有效数字为16位，如果是四字节的浮点数，就要在数字后加f，只可以计算7位有效数字。此外还由布尔类型，空类型。 构造数据类型。包括数组，struct,union,enum枚举,class(类)。  特殊的数据类型，有指针类型和引用类型。 int i,j; char c1,c2; c1=\u0026#39;a\u0026#39;; c2=98; i=\u0026#39;A\u0026#39;; j=66; 字符型还可以进行减法运算。cout\u0026laquo;\u0026lsquo;A\u0026rsquo;-32结果是33;\n常量和变量 字面常量  八进制，十六进制表示，0,0x 浮点型也可以用e表示，即科学计数法f e n,f可以是整数或小数，但n必须是整数。 字符串常量和字符常量  \\ooo和\\xhh称为通用转义字符，其中\\ooo表示可以用1至3位八进制数作为码值表示一个ASCII字符，hh表示可以用1至2位十六进制数作为码值表示ASCII字符。\n如:“\\1234”一“123和4”，”\\128”一\\12和8”，19\u0026quot;一”\\1和9\u0026quot;\n\\9错误，\\0xFE 错误\n由于字符型数据在内存中只占用1个字节，即使按无符号处理其最大值也仅是255(八进制为377)，因此ooo的数值范围为0~377 (八进制)，其他值使得字符型数据溢出。同理，hh的数值范围为0~FF\n字符常量 就是使用宏#define进行定义\n变量 变量需要先声明\nint d=a ，e=a+b; //错误，初值不能是变量或表达式 int m=n=z=5: //错误，不能对变量连续初始化 const int a; 一般在函数中应用比较广，避免因为误操作导致数值改变。\n运算符    int m=4，n; n = ++m; //m先增1，m为5，然后表达式使用m的值，赋值给n，n为5 n = --m; //m先减1，m为4，然后表达式使用m的值，赋值给n，n为4 n = m++; //表达式先使用m的值，赋值给n，n为4，然后m增1，m为5 n = m--;//表达式先使用m的值，赋值给n，n为5，然后m减1，m为4   C++在逻辑表达式求解时，并不一定是所有的运算都被执行，当刚开始求解或求解的中途就可以确定整个逻辑表达式的值时，其余的运算将不再进行。\nint a=1 ，b=2,c=3,d=4,m=n=1，k; k=(m=a\u0026gt;b)\u0026amp;\u0026amp;(n=c\u0026gt;d); //m的值为0，n的值为1，k的值为0 3.三目运算符   int i=3,j=5;k=i++,i+1,j++,j+1;//k为3 (i++的值)k=(i++,i+1j++,j+1); //k为7 (j+1的值) 逗号运算符是双目运算符。\n类型转换 手动类型转化\n(int)x+y //将x转换成整型 (int)(x+y) //将x+y转换成整型 (int)x%3 //x的类型和数据值不变，表达式引用转换成int后的x值 隐式类型转换 (implicit type conversion) 又称自动类型转换，它是由编译器自动进行的。\n(1)将浮点型数据赋给整型变量时，舍弃浮点数的小数部分。 如:int n=6.18;n的值为6。\n(2)将整型数据赋给浮点型变量时，数值不变，但以浮点数形式存 诸到变量中。如:double f=78;将78按78.0处理\n(3)将double型数据赋给float变量时，截取前面7位有效数字存储到float变量。将float型数据赋给double变量时，数值不变，有效数字扩展到16位。\n预处理 文件包含 #include 分为相对路径（.h）和绝对路径（C：/） 用户路径\u0026quot;\u0026quot; 系统路径\u0026lt;\u0026gt;\n条件编译 可以避免重复包含头文件，避免错误 1.\n#ifdef #else #endif   #if #elseif #else #endif 宏  #define 进行替换任意文本 但文本替换带有运算是要用（）括起来，不然可能出现错误 #x转化为字符，作用？ ##连接字符文本，ang  ","permalink":"https://tassel234.github.io/posts/note/c++%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1%E5%BC%95%E8%A8%80%E5%92%8C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","summary":"前言 使用资源 西工大网课(在慕课和b站都可以找到资源) Bjarne Stroustrup《C++程序设计语言》 洛谷的一些编程题 主要以网课为主. 引言 计算机系统由硬件和软件共同组成。硬件主体为输入输出设备，存储器，运算器，控制器。软件又分为系统软件和应用软件。应用软件就是用户下载的音乐播放器，聊天","title":"C++入门学习笔记-1（引言和基础知识）"},{"content":"正值暑假，又热又闷。\n学校的图书馆周日不开放，学习任务也没有完成。\n我今天本该在宿舍在宿舍睡觉吃饭学习，但因为前几周的经历，我意识到宿舍学习的效率是有一点惨不忍睹的。\n考虑之下，我决定去青浦图书馆学习和旅行。\n青浦图书馆坐落于青浦新城区夏阳湖上，有水上博物馆的美称，夏阳湖旁边是就是青浦博物馆。\n哈罗单车覆盖了上海的大部分地方，但是没有青浦图书馆这一片，青浦似乎是有自己的共享单车，但我骑不了。\n青浦图书馆的开放时间是周二至周日9:00-20:30(20:00以后停止入馆)\n百度地图显示青浦博物馆的夜景很好，但因为现在正值暑假，宿管阿姨关门关的早，所以很遗憾的我不能欣赏了。\n早上七点半起床，吃了一碗咖啡燕麦粥和一点苏打饼干，收拾行李，关闭电源。\n八点半出发，经过自行车，公交车，地铁，步行，加上吃午饭的时间终于在十二点抵达青浦图书馆。\n上海的地铁站有一个不成文的规定，坐阶梯式电梯时不赶时间，在电梯停留的人统一靠在电梯右侧，左边的空间留给赶时间，在电梯上走动的人。\n地铁上我看日语发音入门课程消磨时间。\n青浦图书馆不需要预约入场更不需要预约座位，上海图书馆东馆就要提前六天抢座位了。 图书馆不算大，也不算小。我能探索的就只有三层结构。\n图书馆下方有一个图咖，我看到有两个女孩在吃冰淇淋。\n图书馆内部的人真是太多了，我转了半天才在一个杂志阅览室的角落找到可以自习的地方。\n自习的人有很多，不只是考研的大学生，还有很多的工作的青年人和看书的老年人。\n书籍也有很多，宗教学，科学，欧美文学，古典文学等面面俱到，还有影像收藏。\n窗外的景色也很不错，南边的座位可以看到一条青绿色的河，北边的座位可以看到夏阳湖。\n学习时我看吴军博士写的 计算之魂，休息时我看保罗.约翰逊写的 所谓知识分子（书挺升血压的）。\n下午的时候天就阴了。\n五点多，我离开了图书馆，吃了一碗拉面。 因为博物馆那时已经闭馆了（我5点多才知道），所以我也就直接回去了。\n我沿着河畔转了一圈，看到了唱戏的大爷大妈，看到了父亲和女儿，看到男男女女，熙熙攘攘。 然后我就回去了，本来想走到地铁站，结果走一小段发现太累了，就停下来等公交。\n值得一提的是，我早上因为大意穿的是睡衣出门，走到一半才意识到，已经来不及回去换了。\n刚开始在地铁上感觉有点尴尬和不自在，但后来渐渐释怀了。\n我意识到上海是一座很大的城市，他很排外也很包容。\n上海的人都很忙，他们压根没精力去在意你，我怀疑我直接cos星野爱也没多少人在意我，更不用提一件睡衣。\n即使有人多看了你一眼，比起在内心折磨自己，不如直接微笑（恶心他人）来的从容。\n","permalink":"https://tassel234.github.io/posts/life/%E9%9D%92%E6%B5%A6%E5%9B%BE%E4%B9%A6%E9%A6%86%E6%B8%B8%E8%AE%B0/","summary":"正值暑假，又热又闷。 学校的图书馆周日不开放，学习任务也没有完成。 我今天本该在宿舍在宿舍睡觉吃饭学习，但因为前几周的经历，我意识到宿舍学习的效率是有一点惨不忍睹的。 考虑之下，我决定去青浦图书馆学习和旅行。 青浦图书馆坐落于青浦新城区夏阳湖上，有水上博物馆的美称，夏阳湖旁边是就是青浦博","title":"青浦图书馆游记"}]