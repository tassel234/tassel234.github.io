[{"content":"《大模型应用开发技术体系串讲》直播课笔记 直播课地址：http://s.zhihu.com/4_11NVbn\n几个网站的介绍 讲课老师的一个项目，套了好几层壳的gtp.10w+星星，值得一提的是，这个软件是javascript写的，而讲课老师之前从来不会这个语言，是在gtp的帮助下几个月写出来的。\nhttps://github.com/sunner/ChatALL\n下载了一下，使用这款软件还是要翻墙和注册各个gpt的账户才可以使用。\n好处是可以同时和多个ai对话。\nai会出现幻觉，图灵证明了如果机器不会犯错，就无法产生智能。\n因为机器一定会犯错，所以这里套壳开始产生作用，通过问好几个gpt相同的prompt，整合答案来减少犯错概率。\n智能客服 https://siteapt.ai （一个印度小哥创的。这个网站被墙了，似乎还需要收费，99刀普通版每月，999刀至尊版每月，一个可以接入网站的gpt帮助检索信息，实现要求等，也可以设立在博客中）\n智能知识库 https://chat.langchain.com/ （没被墙） 智能助手 https://assistant.kattgatt.com/ （没被墙） 介绍一下某学员的第一个 AI 作品: Sheet Chat - 知乎(zhihu.com)智能数据分析 智能数据分析 https://chat.openai.com/?model=apt-4-code-interpreter （墙了）\n内容 老师的一个观点：微软开发的sk更适合做工程，后续的维护等更方便。而langchain更适合做小的demo，不适合做大的工程。\n讲的还是接近通识 的东西，较为技术一点的公开课是这个。后续会学习，但我首先要实战一些机器学习 的东西。\nhttps://www.zhihu.com/xen/market/training/training-video/1695821407194406912/1695822082997538816?\n","permalink":"https://tassel234.github.io/posts/note/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB%E4%B8%B2%E8%AE%B2%E7%9B%B4%E6%92%AD%E8%AF%BE%E7%AC%94%E8%AE%B0/","summary":"《大模型应用开发技术体系串讲》直播课笔记 直播课地址：http://s.zhihu.com/4_11NVbn 几个网站的介绍 讲课老师的一个项目，套了好几层壳的gtp.10w+星星，值得一提的是，这个软件是javascript写的，而讲课老师之前从来不会这个语言，是在gtp的帮助下几个","title":"《大模型应用开发技术体系串讲》直播课笔记"},{"content":"《纸嫁衣》2部和5部体验 我虽为戏子，却为你做了一回真将军。 世上并无完美之人,只有为爱勇敢者,方会突破束缚,破茧成蝶。 没有来救你的梁少平，但有来救你的荀元丰。 纸新娘陶梦嫣\n纸新娘陶梦嫣高清版\n一代是改编于《倩女幽魂》，二代是改编于《梁祝》，三代的剧情改编自元代宋梅洞的《娇红传》，四代是《西厢记》，五代是《小翠》，一部文言短篇小说，作者是清代小说家蒲松龄，出自《聊斋志异》。\n玩游戏玩的记忆力飙升，开始长脑子了。因为是解密的剧情，非常烧脑子。九成的题都是没有跳过自己解的，六成的题是不看提示和实况视频自己解决的。\n搁着体验民俗恐怖来了。\n纸嫁衣的画风实际和我想时候看的鬼故事杂志的封面图非常相似，很难不让人怀疑是不是美工再就业，不过我也不熟悉绘圈。\n经过2和5部的塑造，我单方面宣布陶梦嫣是塑造的最好的角色。\n梁祝 原著故事 东晋时期，会稽郡上虞县（今浙江省绍兴市上虞区） [4]有一女子祝英台，喜欢吟读诗书，一心想出外求学，但当时女子不能在外抛头露面，于是她乔装成男子，前往会稽郡城（今浙江省绍兴市）读书。途中遇见了会稽郡鄮县（今浙江省宁波市海曙区） [2]书生梁山伯，两人一见如故，遂结伴同行。梁祝同窗三年，梁山伯始终不知祝英台是女儿身，后来祝英台中断学业返回家乡，梁山伯到上虞拜访祝英台时，才知道三年同窗的好友竟是女儿身，欲向祝家提亲，但此时祝英台已许配给鄮县太守之子马文才。之后，梁山伯成为鄮县县令，梁山伯忧郁成疾，不久身亡，遗命葬鄮城九龙墟。祝英台出嫁时，经过梁山伯的坟墓，突然狂风大起，阻碍迎亲队伍的前进，祝英台下花轿到梁山伯的墓前祭拜，梁山伯的坟墓塌陷裂开，祝英台投入坟中，其后坟中冒出一对彩蝶，双双飞去，离开尘世。\n游戏故事 梁少平和祝小红\n在山的那边海的那边，有一个奘铃村，那里人杰又地灵，穷山恶水出刁民。\n我们的女主陶梦嫣小时候生活在奘铃村，作为纸新娘的转世来到这个世界。从出生开始就被村长，大巫贤和村民们指定为祭品。村民们对陶梦嫣的善意来自于这个女孩将会在长大后成为六葬菩萨的祭品，保佑村子的风调雨顺。陶梦嫣的父母带着陶梦嫣逃离这个封建迷信的村庄。但陶梦嫣从小到大一直被一个噩梦所困扰，为了探寻真相来到自己的故乡奘铃村。被村民围困后解密知晓了关于梁少平与祝小红的过往，并依靠聪明才智为梁少平部分魂魄所化的“煞金刚”解除封禁，让五代的荀元丰魂魄开始齐全。\n二代的主角其实更倾向于是梁少平和祝小红，只是借助了陶梦嫣 的视角，五代的主角才是真正意义上的陶梦嫣，五代全片维持在陶梦嫣的悲惨过去，迷茫和那些温暖展开。\n祝小红，陶梦嫣的前世，梁少平的恋人。与梁少平相恋，在被迫成为纸新娘献祭时，梁少平为救小红被刽子手斩下头颅，祝小红绝望之下跳崖殉情，完成了梁祝的be结局。梁少平为救小红被刽子手斩下头颅没有死去，而是化为煞金刚在梦境和现实守护着陶梦嫣，“煞金刚”解除封禁后魂魄补全给了荀元丰。\n小翠（陶荀） 原著内容 王太常[1]，越人[2]。总角时，昼卧榻上。忽阴晦，巨霆暴作[3]，一物大于猫，来伏身下，展转不离。移时晴霁，物即径出。视之，非猫，始怖，隔房呼兄。兄闻，喜曰：“弟必大贵，此狐来避雷霆劫也。”后果少年登进士，以县令入为侍御[4]。生一子，名元丰，绝痴，十六岁不能知牝牡[5]，因而乡党无与为婚[6]。王忧之。适有妇人率少女登门，自请为妇。视其女，嫣然展笑，真仙品也。喜问姓名。自言：“虞氏。女小翠，年二八矣。”与议聘金。曰：“是从我糠覈不得饱[7]，一旦置身广厦，役婢仆，厌膏粱[8]，彼意适，我愿慰矣，岂卖菜也而索直乎！”夫人大悦，优厚之。妇即命女拜王及夫人，嘱曰：“此尔翁姑[9]，奉侍宜谨。我大忙，且去，三数日当复来。”王命仆马送之。妇言：“里巷不远，无烦多事。”遂出门去。小翠殊不悲恋，便即奁中翻取花样[10]。夫人亦爱乐之。 数日，妇不至。以居里问女，女亦憨然不能言其道路，遂治别院，使夫妇成礼。诸戚闻拾得贫家儿作新妇，共笑姗之[11]；见女皆惊，群议始息。女又甚慧，能窥翁姑喜怒。王公夫妇，宠惜过于常情，然惕惕焉，惟恐其憎 子痴[12]；而女殊欢笑，不为嫌。第善谑[13]，刺布作圆[14]，蹋蹴为笑。着小皮靴，蹴去数十步[15]，绐公子奔拾之[16]，公子及婢恒流汗相属。一日，王偶过，圆訇然来[17]，直中面目。女与婢俱敛迹去[18]，公子犹踊跃奔逐之。王怒，投之以石，始伏而啼。王以告夫人，夫人往责女，女俯首微笑，以手刓床[19]。既退，憨跳如故，以脂粉涂公子，作花面如鬼。夫人见之，怒甚，呼女垢骂。女倚几弄带，不惧，亦不言。夫人无奈之，因杖其子[20]。元丰大号，女始色变，屈膝乞宥[21]。夫人怒顿解，释杖去。女笑拉公子入室，代扑衣上尘，拭眼泪，摩挲杖痕，饵以枣栗。公子乃收涕以忻[22]。女阖庭户，复装公子作霸王，作沙漠人[23]；己乃艳服，束细腰，婆娑作帐下舞[24]；或髻插雉尾，拨琵琶，丁丁缕缕然[25]，喧笑一室，日以为常。王公以子痴，不忍过责妇；即微闻焉，亦若置之。 同巷有王给谏者[26]，相隔十余户，然素不相能[27]。时值三年大计吏[28]，忌公握河南道篆[29]，思中伤之。公知其谋，忧虑无所为计。一夕，早寝。女冠带，饰冢宰状[30]，剪素丝作浓髭[31]，又以青衣饰两婢为虞候[32]，窃跨厩马而出[33]，戏云：“将谒王先生。”驰至给谏之门.，即又鞭挝从人，大言曰：“我谒侍御王[34]，宁谒给谏王耶[35]！”回辔而归[36]。比至家门，门者误以为真，奔白王公。公急起承迎，方知为子妇之戏。怒甚，谓夫人曰：“人方蹈我之瑕[37]，反以闺阁之丑，登门而告之。余祸不远矣！”夫人怒，奔女室，诟让之[38]。女惟憨笑，并不一置词。挞之，不忍；出之[39]，则无家：夫妻懊怨，终夜不寝。时冢宰某公赫甚，其仪采服从[40]，与女伪装无少殊别，王给谏亦误为真。屡侦公门，中夜而客未出，疑冢宰与公有阴谋。次日早朝，见而问曰：“夜，相公至君家耶[41]？”公疑其相讥，惭言唯唯，不甚响答。给谏愈疑，谋遂寝[42]，由此益交欢公。公探知其情，窃喜，而阴嘱夫人，劝女改行[43]；女笑应之。 逾岁，首相免[44]，适有以私函致公者，误投给谏。给谏大喜，先托善公者往假万金[45]，公拒之。给谏自诣公所。公觅巾袍[46]，并不可得；给谏伺候久，怒公慢，愤将行。忽见公子衮衣旒冕[47]，有女子自门内推之以出，大骇。已而笑抚之，脱其服冕而去。公急出，则客去远。 闻其故，惊颜如土，大哭曰，“此祸水也[48]！指日赤吾族矣[49]！”与夫人操杖往。女已知之，阖扉任其诟厉。公怒，斧其门。女在内，含笑而告之曰：“翁无烦怒。有新妇在，刀锯斧钺，妇自受之，必不令贻害双亲。翁若此，是欲杀妇以灭口耶？”公乃止。给谏归，果抗疏揭王不轨[50]，衮冕作据。上惊验之，其旒冕乃粱秸心所制，袍则败布黄袱也。上怒其诬。又召元丰至，见其憨状可掬，笑曰：“此可以作天子耶？”乃下之法司[51]。给谏又讼公家有妖人，法司严诘臧获[52]，并言无他，惟颠妇痴儿，日事戏笑；邻里亦无异词。案乃定，以给谏充云南军[53]。王由是奇女。又以母久不至，意其非人。使夫人探诘之，女但笑不言。再复穷问，则掩口曰：“儿玉皇女，母不知耶？”无何，公擢京卿[54]。五十余，每患无孙。女居三年。夜夜与公子异寝，似未尝有所私。夫人舁榻去，嘱公子与妇同寝。过数日，公子告母曰：“借榻去，悍不还！小翠夜夜以足股加腹上，喘气不得；又惯掐人股里。”婢妪无不粲然。夫人呵拍令去。一日，女浴于室，公子见之，欲与偕；女笑止之，谕使姑侍。既出，乃更泻热汤于瓮，解其袍袴，与婢扶之入。公子觉蒸闷，大呼欲出。女不听，以衾蒙之。少时，无声，启视，已绝[55]。女坦笑不惊[56]，曳置床上，拭体干洁，加复被焉。夫人闻之，哭而入，骂曰：“狂婢何杀吾儿！”女冁然曰[57]：“如此痴儿，不如勿有。”夫人益恚，以首触女；婢辈争曳劝之。方纷噪间，一婢告曰：“公子呻矣！”夫人辍涕抚之，则气息休休，而大汗浸淫[58]，沾浃裀褥[59]。食顷，汗已，忽开目四顾，遍视家人，似不相识，曰：“我今回忆往昔，都如梦寐，何也？”夫人以其言语不痴，大异之。携参其父，屡试之，果不痴。大喜，如获异宝。至晚，还榻故处，更设衾枕以觇之。公子入室，尽遣婢去。早窥之，则塌虚设。自此痴颠皆不复作，而琴瑟静好，如形影焉[60]。 年余，公为给谏之党奏劾免官，小有罣误[61]。旧有广西中丞所赠玉瓶[62]，价累千金，将出以贿当路。女爱而把玩之，失手堕碎，惭而自投。公夫妇方以免官不快，闻之，怒，交口呵骂。女忿而出[63]，谓公子曰：“我在汝家，所保全者不止一瓶，何遂不少存面目？实与君言：我非人也。以母遭雷霆之劫，深受而翁庇翼[64]；又以我两人有五年夙分，故以我来报曩恩、了夙愿耳。身受唾骂，擢发不足以数，所以不即行者，五年之爱未盈。今何可以暂止乎！”盛气而出，追之已杳。公爽然自失[65]，而悔无及矣。公子入室，睹其剩粉遗钩，恸哭欲死；寝食不甘，日就赢瘁。公大忧，急为胶续以解之[66]，而公子不乐。惟求良工画小翠像，日夜浇祷其下[67]，几二年。 偶以故自他里归，明月已皎，村外有公家亭园，骑马墙外过，闻笑语声，停辔，使厩卒捉鞚[68]；登鞍一望，则二女郎游戏其中。云月昏蒙，不甚可辨，但闻一翠衣者曰：“婢子当逐出门！”一红衣者曰：“汝在吾家园亭，反逐阿谁？”翠衣人曰：“婢子不羞，不能作妇，被人驱遣，犹冒认物产也？”红衣者曰：“索胜老大婢无主顾者[69]！”听其音，酷类小翠，疾呼之。翠衣人去曰：“姑不与若争，汝汉子来矣。”既而红衣人来，果小翠。喜极。女令登垣，承接而下之，曰：“二年不见，骨瘦一把矣！”公子握手泣下，具道相思。女言：“妾亦知之，但无颜复见家人。今与大姊游戏，又相邂逅，足知前因不可逃也。”请与同归，不可；请止园中，许之。公子遣仆奔白夫人。夫人惊起，驾肩舆而往，启钥入亭。女即趋下迎拜；夫人捉臂流涕，力白前过，几不自容，曰：“若不少记榛梗[70]，请偕归，慰我迟暮[71]。”女峻辞不可。夫人虑野亭荒寂，谋以多人服役。女曰：“我诸人悉不愿见，惟前两婢朝夕相从，不能无眷注耳；外惟一老仆应门，馀都无所复须。”夫人悉如其言。托公子养疴园中，日供食用而已。女每劝公子别婚，公子不从。后年余，女眉目音声，渐与曩异，出像质之，迥若两人。大怪之。女曰：“视妾今日，何如畴昔美？”公子曰：“今日美则美，然较昔日则似不如。”女曰：“意妾老矣！”公子曰：“二十余岁人，何得速老？”女笑而焚图，救之已烬。一日，谓公子曰：“昔在家时，阿翁谓妾抵死不作茧[72]。今亲老君孤，妾实不能产，恐误君宗嗣。请娶妇于家，旦晚侍奉翁姑，君往来于两间，亦无所不便。”公子然之，纳币于锺太史之家[73]。吉期将近，女为新人制衣履，赍送母所。及新人入门，则言貌举止，与小翠无毫发之异。大奇之。往至园亭，则女已不知所在。问婢，婢出红巾曰：“娘子暂归宁，留此贻公子。”展巾，则结玉玦一枚[74]，心知其不返，遂携婢俱归。虽顷刻不忘小翠，幸而对新人如觌旧好焉。始悟锺氏之姻，女预知之，故先化其貌，以慰他日之思云。 异史氏曰：“一狐也，以无心之德，而犹思所报；而身受再造之福者[75]，顾失声于破甑[76]，何其鄙哉！月缺重圆[77]，从容而去，始知仙人之情，亦更深于流俗也！” [1]\n来自百度百科。狐仙报恩的故事。\n游戏内容 纸新娘陶梦嫣第五部高清重置\n五代 接着二代的故事，讲了陶梦嫣和荀元丰再续前缘的故事。\n祝小红一家绝命，屠家世代厄运纠葛，好在陶家似乎过得还可以。\n全剧围绕陶梦嫣的悲惨童年展开，陶梦嫣在二代的形象大体是一个豪爽女侠的形象，但是这只是陶梦嫣表现出来的，其实陶梦嫣的内心相当的孤僻，童年作为纸新娘的那些遭遇带给了陶梦嫣阴影，导致她没办法和别人正常相处，在童年遭受了城市里同班同学的排挤，只爱好读书。说出：我并不是祝小红，梁少平并不会来救我。我是陶梦嫣，是作为纸新娘的替代品来到这个世界上的。\n但是即使没有来救你的梁少平，也有来救你的荀元丰。\n陶梦嫣只有一个好朋友，钟梓萱。钟梓萱的父母因为盗窃都进去过，母亲改过自新抚养钟梓萱长大，但因为父母是小偷的缘故没多少人想和钟梓萱玩，钟梓萱也不想 和他们玩。\n从奘铃村回来后，陶梦嫣又有了一个朋友，荀元丰。荀元丰为了保护爱的人而成长，照应世上并无完美之人,只有为爱勇敢者,方会突破束缚,破茧成蝶。\n然后大战屠老六。\n故事是非常感人的，操作也很好，就是有点费脑子。\n脸被闺蜜抽红的陶梦嫣\n后记 奘铃村也存在一些反抗封建迷信的好人，比如铁匠奚大哥（后代为13号精神病院的主角，13号精神病院比纸嫁衣要残忍的多），陶梦嫣的父母（带着陶梦嫣逃离这个封建迷信的村庄）。\n上海欢乐谷的纸嫁衣鬼屋。\nps,图里的手是p过的，不是真拍到什么阴间东西。 ","permalink":"https://tassel234.github.io/posts/read/%E7%BA%B8%E5%AB%81%E8%A1%A32%E9%83%A8%E5%92%8C5%E9%83%A8%E4%BD%93%E9%AA%8C/","summary":"《纸嫁衣》2部和5部体验 我虽为戏子，却为你做了一回真将军。 世上并无完美之人,只有为爱勇敢者,方会突破束缚,破茧成蝶。 没有来救你的梁少平，但有来救你的荀元丰。 纸新娘陶梦嫣 纸新娘陶梦嫣高清版 一代是改编于《倩女幽魂》，二代是改编于《梁祝》，三代的剧情改编自元代宋梅洞的《娇红传》，四代是","title":"《纸嫁衣》2部和5部体验"},{"content":"komorebi 作曲人：m-taku\n以和弦作品和诗人般的音乐编排创造出各种色彩。m-taku是日本一位音乐人，从声音的制作上使用了“调色板声音”的独特演绎手法表达音乐作品的情感，被誉为“音响设计师”的音乐人。m-taku是一位日本音乐人，从声音的制作上用“调色盘音”这种独特的演绎手法来表达音乐作品的情感，被誉为“声音设计师”的音乐人。这首纯音乐钢琴曲以纯净而单薄的音符开场，下面轻快的混音夹杂着电子乐器的节奏，在旋律中产生了各种色彩，活泼开放、自顾绽放。\n乐曲评价：\n曲风温婉、柔美，意境高远。\n听押尾桑的《Komorebi》，如在一个明媚的午后突然醒来，安静的房间，嘈杂的街道。世界和自己渐渐分离，不再留恋。他们心里怀念的东西一个个都没了。被撕裂的笑容就像窗下阳光下飞舞的尘埃，轻到只有一点风就能吹走。心，像被洗劫过的天空，只有蓝色。\n来自：https://baijiahao.baidu.com/s?id=1727707303995356258\u0026amp;wfr=spider\u0026amp;for=pc\nkomorebi写作日语的话是 木漏れ日，翻译为从树叶缝隙中照射下来的阳光\n评论区摘要：\n“丁达尔效应出现的时候，光就有了形状。”\n\u0026ldquo;你的盛年望不可及，我的江海云淡可添\u0026rdquo;\n为何无人问津，独吾辈对月独酌。笑众人皆醉我独醒，叹此音无人孤自赏。泣国风仙乐无人问，念唐汉琴瑟音不绝。\n⠀我希望正在读这句话的人永远开心⠀ ⠀\n99+前遇到了你。我就像是一个遇到了千里马的伯乐一样开心。\n因为我爱你，所以你走的路，要繁花盛开，要人声鼎沸\n大晚上的想哭，可又不敢哭，怕把电热毯弄湿了给我电死。\nThe Rain 作曲人：久石譲(ひさいし じょう,久石让)。\n1950年12月6日出生于日本中野市，日本著名音乐人、作曲家、钢琴家。毕业于日本国立音乐大学 。\n乐曲评价：\n菊次郎的夏天的变奏曲，个人感觉是所有系列最好听的曲子。\n开始的曲调婉转悠长，像是在慢慢的品味流年岁月，接近结尾的时候随着钢琴的节奏的加快，带给人豁然开朗感觉的小提琴响起，觉得世事欢快且愉悦。\n《菊次郎的夏天》是由日本北野武工作室制作的121分钟喜剧电影。该片讲述的是小男孩正男和隔壁的叔叔菊次郎在暑假冒险旅程的途中发生了一系列搞笑又让人落泪的故事。\n《菊次郎的夏天》是日本导演北野武执导的电影中最为温情、明朗的一部。影片以寻找亲情为主线，讲述了艰难的寻亲路上发生的故事、遇到的形形色色的人以及人与人之间的情义。（《电影文学》评）\n评论区摘要：\n在国外读书，今天下雨，回家路上翻了车，腿和裤子都刮破了，最近过的特别不顺心，每次和妈妈爸爸视频都调整好笑容，报喜不报忧，快过圣诞了，到处都张灯结彩，路上走的每个人看起来都好幸福，好想哭\n这首歌其实叫mother, 北野武剛到東京小有成就時，母親便每月要求他準時給她寄錢。稍晚幾天便會打電話來破口大罵。直到母親逝世。大哥交給他一封信和一本存折，說是母親留給他的遺物。信中寫道，「吾兒，你自幼生性放浪不馴，娘怕你有天会一無所有餓死街頭。你的錢都在這個存折裡，共有一千萬日\n那时候我在暗恋班上的一个小女生。她一直很安静，很奇怪的女孩。那时候是临近高考的初夏，教室外面突然暗下来，沉闷的雷声响起。能闻到夏天暴雨来临的味道。我和她并肩站在阳台上，学校广播里放这首歌。带着湿热，忽冷忽热的风吹在脸上，我们竟说不出话来。高考结束的那天，突然感觉，再也回不去了\n网易云口碑好，也许不是他软件做得好，而是总在评论中找到一个共鸣的一个人,勾起你满满的回忆，或喜\u0026hellip;或忧\u0026hellip;\u0026hellip;.\n在一次去家旁边的水库去洗澡，一个小伙伴抓到一只黄鳝，我们花了一毛钱买了盒火柴，用一堆废柴把黄鳝给烤了，突然有人说到，烤鱼没盐会不会很难吃，于是我飞奔回家，捧了一手盐，就好像捧住了整个童年\n做音乐如是能做得像久石让前辈这样在无觉的干净间不留一点余杂，使多少不同的人产生共鸣。能胜任配乐和独立倾听。也算是拥有了隐世子傲的资本了吧\n长到了可以跟父亲举酒碰杯的年纪，长到了可以跟长辈促膝长谈的年纪，这是一个可以直言不讳说爱的年纪\u0026hellip;.我欣然的接受着这些不习惯，然后呢，我不知道我穿上西装后是否还能看动画片，如果我抽着烟是否还有小朋友跟我玩… 嘿，你看见我的小熊了吗?\nunity 作曲人：TheFatRat\nTheFatRat是来自德国的全球顶尖游戏音乐制作人，他的作品从优美的 Progressive house 到 Trap ，甚至涉猎悦耳的Glitch-hop等多曲风，都对游戏音乐都有着深远的影响。他在YouTube上拥有420万粉丝、全球各大平台总粉丝数破700万。因此，他也是目前同类型音乐人中粉丝增长最快、最吸睛的音乐人。他解除音乐版权限制的超前思维，使他的作品在YouTube上广为内容创作者使用，制作出超过400万支不同题材的视频，其数量首屈一指，累计共计超过40亿次的流量。多年来，他已然成为了最顶尖的DJ，有多首歌曲3年稳居iTunes前50榜单，他甚至把自己的才华展现到了荧屏前，其中包括与可口可乐公司的合作项目，及如Dota2和火箭联盟等电子竞技游戏原声带等。多年来的成长，让他成功跻身于ELS，Dreamhack等电竞品牌音乐人。\n布特纳早于2001年便以自己的名义发行音乐作品，之后他开始为电视节目、广播和广告制作背景音乐。“胖鼠”的名字来自于他的学校时期，当时布特纳较其他男同学矮，因此遭到霸凌。为了防卫自己，他开始学功夫，之后便有人叫他“老鼠”（The Rat）。布特纳在开始玩线上游戏时也采用该绰号，并在该绰号中间加上“胖”（Fat）字。2011年7月，他首次使用“胖鼠”的名义发行音乐，并发行其第一张迷你专辑《做就是了》（Do Be Do Be Do）。\n音乐评价：\n非常好的一首电音，节奏感十足。\n加人声和纯音乐都不错，但我更倾向于不加人声的。\n评论区摘要：\n媳妇怀孕6个月，胎动太频繁，让给放个胎教音乐舒缓一下，我毫不犹豫的打开了unity，然后媳妇不理我了。。\n让同桌听了这首歌，同桌说不好听，然后我就换了个同桌\n这感觉就好像含在嘴中的跳跳糖，甜蜜与动感并存，不焦不燥。\nSomeday we\u0026rsquo;ll live as one family in a sweet harmony 想像有天会迎来共产主义的美好未来 谁翻译的 站出来 给你一个大拇指\n你们换个好耳机仔细听人声就知道了，人声其实能很好地融入这首歌里，和电音的声音很像，人声结尾还有一小段左右声道的不断变幻渐渐走远，和电音的颤音很像，很有魔幻的感觉，而且让整首歌断开，缓冲一下，不至于单纯的电音高潮到乏味，其实人声才是精髓\n各科老师被困在电梯里： 语文老师正在写遗书 数学老师开始计算电梯的长宽高 英语老师开始说起电梯英语单词 物理老师在计算说几小时空气会呼吸完 化学老师在检查这个电梯的材质 生物老师在考虑他们需要的物质比如氧气 地理老师在计算纬度叫人来救她们 历史老师开始感慨 体育老师一脚把门踹开:我们走吧\n","permalink":"https://tassel234.github.io/posts/life/%E9%9F%B3%E4%B9%90%E7%9A%84%E8%AF%84%E8%AE%BA-3/","summary":"komorebi 作曲人：m-taku 以和弦作品和诗人般的音乐编排创造出各种色彩。m-taku是日本一位音乐人，从声音的制作上使用了“调色板声音”的独特演绎手法表达音乐作品的情感，被誉为“音响设计师”的音乐人。m-taku是一位日本音乐人，从声音的制作上用“调色盘音”这种独特的演绎手法来表达音乐","title":"音乐的评论-3"},{"content":"《新.奥特曼》观后感 《新.奥特曼》是一部继承和发展了经典《奥特曼》系列的作品，获得了星云赏（和迪迦同级），是圆谷公司的第五部星云赏作品，前四个是迪迦奥特曼，泽塔奥特曼，《SSSS.古利特》，奥特曼同人小说《奥特曼F》。\n骑士棚的星云赏假面骑士空我还没有补，但是就那句“我再也不想看到人们的眼泪，我想看到大家的笑容”实在让我印象深刻。五代雄介自称拥有1999个技能 得到的第2000个技能是能够变身成能守护他人笑容的超古代战士——空我，而第一个技能是让别人可以绽放笑容，剩余的1999个技能都在为第一个技能服务。在没有变成空我的岁月中，五代雄介旅行世界，为每一个地方的孩子带来笑容。\n该剧的特效和动作场面非常精良，让人目不转睛。每一场奥特战斗都充满了紧张刺激的氛围，特技动作设计独特而精准，展现出超级英雄与怪兽之间的搏斗，令人过目难忘。而且最吸引人的是这些特摄里面的一些关于哲学的思考，人性的探究，这其实是圆谷公司的传统艺能，讽刺政府，讽刺人类，保护环境，反战，宣扬和平，因为毕竟是子供向，不过小孩子看的是主要是打斗，大一些的人才会思考故事内核，后人总结了奥特曼的昭和三大问题作（来自https://baijiahao.baidu.com/s?id=1717297880639328470\u0026amp;wfr=spider\u0026amp;for=pc）让人知道为什么空想特摄属于科幻领域。\n冷战背景下消失的宇航员\n这是一个冷战背景的故事，怪兽贾米拉袭击各国官员，但贾米拉不是怪兽，而是以前被自己国家抛弃的宇航员，他回来是为了复仇，最后初代打败了贾米拉，而他的墓碑上只写了夸赞的词，没有这件事的前因后果，井受队员最后那句“对死者都这样，专挑些赞美词说说罢了。”看的人很有感触。\n尤其是在淤泥里的各国国旗的镜头，直接隐喻了动荡不安的国际背景下，没有哪一个国家可以做到出淤泥而不染，和平只是国家之间粉饰自己的词汇，各国的心已经脏了。据当时的编剧佐佐木表示，剧本创作是处在当时美苏冷战的1966年，其本质含义就是讽刺当时的美苏争霸。而日本处在美国在亚洲的一个战略基地，其所谓的和平也不过是各有所需罢了。\n地球真正的原住民\n这一集《农马尔特的使者》应该是“昭和三大问题作”里面最出名的了。也是那次艾斯吧卧底事件的真实写照，艺术来自生活，生活魔幻于艺术。农马尔特人才是地球的原住民，地球人才是宇宙外来的殖民者。 农马尔特人因为战争被迫到海底，而有科技能量的人类又想开发海底，这就破坏了农马尔特人的居住空间，所以农马尔特人出来和赛文战斗，桐山队长高喊的那句“海洋是我们人类的。”直接揭露了人性。“如果人类真的是侵略者，那作为奥特警备队一员的我就成了人类这群侵略者的帮凶。”\n如果人类才是真正的侵略者呢？原本的农马尔特星人才是无辜的受害者呢？真相究竟是如何，这是连赛文奥特曼都不敢想的东西，当一个人对自己所坚定的东西产生了怀疑，那么他对于这个所谓的问题就已经有答案了。随着世界上最后一个农马尔特星人的消失，这个问题也不再有答案。\n怪兽使者和少年\n梅茨星人到地球救了一个人类小孩，因为梅茨星人的身份，所以村民都不信任他，他们有对未知的恐惧，所以开枪杀了梅茨星人，杰克就怀疑保护地球人是不是对的，后来被一个僧人点醒才打败了怪兽，这影射了原住民与外来者的冲突，还有关于刻板印象的探讨。\n这集可以说是将人性的冷漠，黑暗和恐惧体现的淋漓尽致···那些穿着光鲜亮丽的人，最终不过是一个个欺软怕硬的而已。人类小孩因为帮助梅茨星人被认为是一个怪胎，外星人的走狗，人类的叛徒，然后被昭和刁民小孩各种欺负，埋在地里，撒尿浇头，梅茨星人无法忍受他们对少年的欺负，开始反抗和吓唬，然后事情就一发不可收拾的恶化了，梅茨星人死亡，人类小孩彻底绝望。即便他们觉得少年很可怜但依旧要杀了他，只因为在他们的主观意识中“宇宙人”就一定是坏的。\n但是在这黑暗面中也会有一丝温暖，剧中少年去买面包，但是店家却将少年赶了出来，直到店家的女儿回来才将面包卖给了少年，而同时知道了少年身世的乡也开始帮助少年，或许这就是人性的温暖和人性的善良，也正是这些善良才使得少年能继续下去。\n剧中的人物塑造也非常出色。主角们各具特色，他们的成长历程、内心挣扎和情感纠葛都被细致入微地展现出来。奥特曼利匹亚来到地球，和一个牺牲的人类融合，但是没有继承人类的记忆，所以从零开始进行关于人类的种种学习，这个学习的过程只要是在图书馆看书，了解了人类这个物种的神奇和可贵，下定决心保护这些人类。不过幸好利匹亚没有选择上互联网，不然刷到贴吧或暗网会直接高呼：不用怪兽杰顿动手，我自己来毁灭地球。\n剧集还通过涉及当代社会问题的情节线索，使得故事更具深度和现实意义。它探讨了人类与环境的关系、权力与责任的辩证关系等议题，引发观众对于现实世界中的类似问题的思考。奥特曼对于人类就相当于神，拥有无与伦比的力量，可以视作超越黑暗森林真正打遍宇宙无敌手的存在。而和利匹亚一起出现的是那些强大聪明狡诈的外星人，如扎拉布和美菲拉斯。扎拉布控制电子技术，互联网和可以利用光学进行模仿拟态，对应来说这个家伙是一个造假的好手，还可以控制舆论，实时删除评论，篡改一切电子文档，可以勾结政治家，还可以化为人形质子锁科技，目的是挑拨人类矛盾让人类自我毁灭。美菲拉斯，权谋好手，了解人类，玩弄人心，带来让地球人巨大化且坚硬无比的技术，让人类甘心的臣服，从而制造地球人生物兵器。佐菲，认为地球人的贪婪，好斗又极容易挑拨的特性是宇宙未来的威胁，带来灭星武器杰顿打算炸了地球，这个杰顿利匹亚也打不过。\n扎拉布带来稍微超越一点的科技，但仍在现在世界的科技范围内的东西，主要通过和人类结盟的方式实现目的，让人类内部争斗导致毁灭。美菲拉斯让人类获取到接近于神明的科技，代价是出卖自己的灵魂，向美菲拉斯臣服。利匹亚给了人类超越时代的知识，让人类通过自己的思考找到拯救地球的方法，最终化为掌握自己命运的神明。\n","permalink":"https://tassel234.github.io/posts/read/%E6%96%B0.%E5%A5%A5%E7%89%B9%E6%9B%BC%E8%A7%82%E5%90%8E%E6%84%9F/","summary":"《新.奥特曼》观后感 《新.奥特曼》是一部继承和发展了经典《奥特曼》系列的作品，获得了星云赏（和迪迦同级），是圆谷公司的第五部星云赏作品，前四个是迪迦奥特曼，泽塔奥特曼，《SSSS.古利特》，奥特曼同人小说《奥特曼F》。 骑士棚的星云赏假面骑士空我还没有补，但是就那句“我再也不想看到","title":"《新.奥特曼》观后感"},{"content":"lemon tree 这首音乐对于我有相当特殊的意义，几乎是我半主动接触的最早的歌曲。\n作曲人：愚人花园乐队\n发布时间：1994年12月4日\n歌曲评价：\n属于乡村歌曲，由愚人花园（ fool\u0026rsquo;s garden ）乐队填词谱曲，收录在于愚人花园乐队1995年5月发行专辑《一天的菜》当中，使这支原本不温不火的德国5人乐队一下子红遍欧洲。\n被苏慧伦于1996年翻唱后也开始为国人熟知。\n是写一位大男孩在某个下着太阳雨的星期天下午等着他的女朋友，歌曲将等人时的焦虑不安及胡思乱想的心情表现得淋漓尽致。该曲的创作者、Fool\u0026rsquo;s Garden乐队主唱彼得·弗洛伊登塔勒创作该曲时也正在等待女友的拜访，他午后在德国黑森林北部偶遇了一棵柠檬树后，迸发了灵感，正如歌中描述的一样，彼得的女友最终也没有到来。\nRichard Clayderman改编的纯音乐版本我也很喜欢。\n评论区摘要：\n老师说：把下面几首歌学会，英文时态就清楚1：lemon tree(现在进行时) 2：yesterday once more一般过去 3：you are my sunshine一般现在 4：if I were a boy 过去完成 5：love story过去进行 6：Monsters一般将来 7：seasons in the sun现在完成\n我的门前有两棵树。一颗是柠檬树，另一颗也是柠檬树。——鲁迅\n在英语中有一句谚语：if life give you lemons, make lemonade. 它可以翻译成：如果生命给你酸楚的柠檬，那也不能阻止你用它酿制甘甜的柠檬水。正是生活中的酸甜苦辣让我们的生命充满了惊喜和变数。为之傲然吧，抱着对生命的敬意继续前行，任何的苦难都打不到你。\nAnnie\u0026rsquo;s Wonderland 作曲者：Oliver Schwarz\u0026amp;Arno Hoeddinghaus，班得瑞成员。\n发布时间：1990年\n乐曲评价：\n这首曲子是为了表达作曲者对拥有一个叫Annie的女儿的渴望，可惜现实总是残酷的。于是Oliver处理了情感表达，并融入这一曲《安妮的仙境》中，成为班得瑞之经典。\n《安妮的仙境》是班得瑞乐团音乐系列第一部专辑《仙境》中的第二首音乐，发行于1990年，乐曲柔美而有力度，聆听下来总是给人莫名的感动，以清爽舒适的音调生动的诠释了自然的魅力与天地的风采。\n小小的礼物，足以预支孩子一年内的笑容;他的心小得像芝麻一样，毫不费力就能够将它填满;但是若把你那已经长大的心送给他，也会变得连放都放不进去。孩子要的除了你的呵护之外有时还是希望你能够陪他一起当小孩。\nhttps://m.maigoo.com/citiao/286171.html\n因为太经典了，广州地铁会放，下课铃声会放，甚至英语考试也会放。\n评论区摘要：\n安妮挺有个性的，她的仙境不像爱丽丝那么惊奇不可预测，也不像秘密花园(文学作品)那种寂静的压抑，也不像海蒂那种辽阔原野的纯粹欢乐，只是一种淡然的、像你我这样平凡人的仙境：不要浓郁的红玫瑰，不要孤傲的梅花，也不要文艺清新的蒲公英，只来一两株普普通通的淡紫色牵牛花，清晨静静地绽开。\n700年前一天，北威尔士王子出去打猎，留狗在家看护婴儿。王子回来后，看见 血染被毯，却不见婴儿。而狗呢，正舔着嘴边的鲜血，高兴地望着他。王子大怒，抽刀刺入狗腹。狗惨叫一声，惊醒了睡熟在血迹斑斑的毯子下面的婴儿。这时，王子才发现屋角躺着一条死去的恶狼。很多错误，都是在冲动时做出的。\n向往一个与世无争的小角落，山清水秀、山重水复，色调缤纷，有个茅草房，前面有个老风车。。清晨，和你一起醒来坐在草墩上看朝阳一直到落日。岁月如砂，那般静好……\n最近我深入地研究了微积分、 线性代数和高等数学 发现 “微积分”都是第一声 “线性代数”都是第四声 “高等数学”四声都有 数学真是好奇妙 ：）\n嘿嘿嘿，一听这个就想到了小时候天气预报，里面会有这个音乐。爷爷奶奶都非常关注天气预报，和爷爷抢电视。后来爷爷走了，只有奶奶一个人了。看天气预报的时候，就想到了爷爷。真怀念呢。\n星茶会 作曲人：灰澈。个人简介：独立音乐人。业余选手，做得不好但努力学习中。宁波漂流人口，269岁打工人。梦想是成为一颗最最平凡的螺丝钉。和你一起听音乐真好。\n发布时间：2017.7.22\n乐曲评价：\n非常俏皮可爱和活泼的一首音乐。\n评论区摘要：\n我对星星说：“你真好看w” 然后它闪了闪 这是什么意思啊qwq 我听不懂星星说话啊qvq 闪一闪是在说什么嘛q△q 我听不懂啦q︿q 谁来翻译一下了啦quq\n它说的是，你瞅啥\n它在说：“你也很好看” 但是你不知道呀 于是它再抖了一下 可是你还是歪着头不懂 它着急的跳动着 闪闪的星光在夜空温柔的眼波里跳跃着 算啦 你听不懂也没事 反正你很好看 也很可爱\n星空总是这样明洁，像极了最初的你。\n你能听到我内心的声音吗。 没有微弱的呐喊，甚至连出声的机会都没有。 你知道星空下的海和一望无际的你一样吗？ 像是人心的无底洞，像是被风拂过的绿草。 也不想接受一些记忆的骗局，也不想接受伤害的言语。 就像你一样。正如你一般。 我又何曾想过这些那些，但是很高兴认识你。 很高兴你离开\n小时候，我以为裙子只能夏天穿，冬天就必须把自己裹的像个粽子，我也以为只要自己善良，对待一个人的时候全心全意去对待，就会被对方同样对待。可是后来长大了才明白，原来冬天也能穿裙子，善良的人也会被丢弃\n星空之所以美丽，就是因为在无限的宇宙中，不管黑暗如何蔓延，都有星星的光芒去把它照亮。 世界也是这样，有绝望的地方，就会有希望产生\n","permalink":"https://tassel234.github.io/posts/life/%E9%9F%B3%E4%B9%90%E7%9A%84%E8%AF%84%E8%AE%BA-2/","summary":"lemon tree 这首音乐对于我有相当特殊的意义，几乎是我半主动接触的最早的歌曲。 作曲人：愚人花园乐队 发布时间：1994年12月4日 歌曲评价： 属于乡村歌曲，由愚人花园（ fool\u0026rsquo;s garden ）乐队填词谱曲，收录在于愚人花园乐队1995年5月发行专辑《一天的菜》当中，使这支原本不温不火的德国5人乐队一下子红遍欧洲","title":"音乐的评论-2"},{"content":"音乐的评论 评论主要来源于网易云音乐。我使用网易云音乐的主要原因就是可以在评论区看到很多清新的小故事，而那些评论的文字往往也非常的温和和温柔，不同于大多数社交媒体的戾气。\n城南花已开 作曲人：三亩地\n发布时间：2017.3.26\n创作历程：\n一位喜欢三亩地音乐的朋友私信三亩地，说他得了骨癌晚期还有半年的时间，希望我用他云音乐的ID“城南花已开”写首曲子，他很喜欢他的ID，然后发给三亩地了很多医院的照片怕我不相信。作曲完成后，三亩地写道：送给城南花已开，希望你能听到，一切都好！\n乐曲评价：\n现在已经有了八十万的评论。\n最开始的评论区由城南花已开的抗病日志和无数网友的激励组成，2018年2月25日，城南走了。无数网友默哀，最后没有引发奇迹。城南花已开，花开花落时，只不过君还是食言了，没有带我们去看三月城南的花开。\n直到那天我才明白城南的签名 城南花已开 花开花落时 其实城南已经绽放过一回了，他也早就料到了结局。 一个只属于网易的故事 一个让我惦念了很久的陌生人\u0026hellip;愿十几万的网易云友都能像城南一样坚强。from 王维诗里的灰太狼\n我想网易云音乐评论区向善，人们彼此互相鼓励，温柔相待的基调的奠定有城南花已开这首歌曲的很大贡献。\n然后城南花已开的评论区变成了抗病的评论区，很多身患绝症的人在这个地方受到了陌生人的鼓励，获得了像城南花已开一样抗病的勇气。也有很多人生失意，对生活迷茫的的人发表自己的故事于此地。\n评论区摘要：\n抱歉各位，今天化疗很痛苦中间受不了痛苦就晕了，醒了就一直在看评论，和私息，我就不一一回复，谢谢你们，前几天做的检查结果也下来了，我也做好最坏的打算了！但是我不会放弃！加油自己\n三月的最后一天，我最喜欢的月份即将过去了，希望明年三月我带你们去看城南花开！城南花已开，花开花落时！\n2011年mds，比白血病还牛逼的病，病因不明，国际无特效药，入院后分小组治疗，13人小组，1年后，我走出医院大门时小组里有2个一辈子废人，另外10个户口本注销了，那天我哭的跟个傻逼一样，他们说我是医学上的小奇迹，其实我就是不信我会死，嘿，相信奇迹，嘿，抬头！\n如果4月你醒了我们就去看牡丹花， 如果5月你醒了我们就去看石榴花， 如果6月你醒了我们就去看荷花， 如果7月你醒了我们就去看蜀葵花， 如果8月你醒了我们就去看桂花， 如果9月你醒了我们就去看菊花， 如果10月你醒了我们就去看芙蓉， 如果11月你醒了我们就去看茶花， 如果12月你醒了我们就去看水仙，\n今年七月，检查出左眼生了一种罕见的病，视力一直在下降，很害怕会再也看不见了，但又不想让身边的人感受到。刚一个人在学校操场上散步，看着昏暗的远处，戴上耳机，闭上眼睛，在黑暗中行走，压制那种不安全感。突然之间听到这首歌，点开评论，看哭了，城南花已开，一切都会好，希望我们都快快好起来。\n翻了很多评论，我也是骨癌，从潮州来广州已经整整一个月了，再怎么难熬也过去了一个月，我马上要第三次化疗了，第二次好难受，三天打了10多针，第三次后应该马上手术了吧！初中时学校也有城南二字，学校的花也好看，明年就能自己走去看了，十多次化疗我也相信我会坚持过去的。待来年，重逢城南花开。\n10.16我永远的失去了我的米粒，在无数个夜晚一个人哭到不行，米粒，我的第一个孩子，妈妈爱你。以后如果可以，我还做你妈妈好不好？让我永远的保护你，爱你。\n所念皆星河 作曲人：CMJ\ncmj，又名草莓酱，93年射手座，性别男，一位浙江杭州的师小伙，独立音乐人、获奖第三届硬地围炉夜 2019-2020年度十大歌曲之一《所念皆星河》，2020年与网易云音乐校园合作颁曲“银河赴约”激励高三准备赴考的学子 。钢琴、吉 他、鼓、贝斯、弦乐、中小提琴,低音提琴，铃三角铁， 等元素常出现在他的音乐中，作曲,作词编曲，后期，分轨，混音,母带制 作每样都会些，所以是个人作曲。\n发布时间：2019.8.14\n乐曲评价：\n一首非常温和浪漫的乐曲，引发人们对美好的遐想，同时也激励人们的梦想。\n所爱隔山海,山海皆可平 所念皆星河,星河不可及\nCMJ的作品命名。\n夕岚分彩翠，高树藏莺声。 乍向风中看，花落更分明。 徘徊觉露冷，清宵月影横。 泠泠砭肌发，疑是晓寒生。 一望可相见，一步如重城。 所爱隔山海，山海不可平。 所思隔云端，奈何凡肉身。 愚公不复见，精卫长泣鸣。 天神犹降怜，谁可恨终生。 海有舟可渡，山有路可行。 此爱翻山海，山海俱可平。 这句话最早是littlesen当年发表在北大未名bbs诗词歌赋版，原作发表日期是年5月30日。\n评论区摘要：\n云朵偷喝了我放在屋顶的酒，于是她脸红变成了晚霞\n星星醉酒到处跑，月亮跌进深海里，我以前从未觉得人间美好，直到你来了。\n星河滚烫，你是人间理想 皓月清凉，你是人间曙光 人海冷漠，你是人间炽热 满眼星河，你是清梦满船 万世浮沉，你是人间归途 众人平庸，你是人间星光 世事无常，你是人间琳琅.\n一个简单的自杀方法\n 洗一个热水澡 泡一杯热牛奶，加点蜂蜜 把空调开到舒适的温度 喝下牛奶，躺到床上 等你睁开眼看见太阳升起就是你已经死了并轮回啦，  用新身份新心情去重新活吧 ，嘘——只是孟婆搞错，不小心让你的下一世和上一世有点像而已哦 就这一生，可以快乐就去快乐吧\n答应我，减少上网时间，作业按时写完，听长辈老师的话，把自己置于一个忙碌的环境，作业写完了就背书，不要坐着发呆，要做别人眼里的好孩子，字一笔一划地写，话听进心里，到最后你会发现，真正让你开心的不正是耀眼的成绩和人人的夸赞，这次，我们要打一个翻身战，并且，一定要赢。\nᴳⁱʳˡˢ\u0026rsquo;ʲᵒᵘʳⁿᵉʸ ⁱˢ ᵗʰᵉ ˢᵉᵃ ᵒᶠ ˢᵗᵃʳˢ, ⁿᵒᵗ ᵗʰᵉ ˡᵒᵛᵉ ᵒᶠ ᵗʰᵉ ʷᵒʳˡᵈ.（少女的征途是星辰大海而并非烟尘人间）\n你眼睛很美，有星河，春秋，山川，河流，可我眼睛更美，因为我眼里有你。——余光中\nTassel 作曲人：欧美男歌手Cymophane\n乐曲评价：\n《Tassel》被誉为世上最好听的钢琴曲之一，当缓缓的钢琴旋律在耳边萦绕的时候，静静聆听，便会感觉到恍若空气般透明的情感，伴随着阵阵委婉迂回的旋律，深入心间。\n钢琴曲是指为钢琴而作或为钢琴而改编的作品，有时还配以其它的乐器同时演奏。\n在欧洲，大约14-18世纪之间，曾流行过两种键盘乐器，一种叫击弦键琴，一种叫拨弦键琴，又称大键琴、羽管键琴。这两种乐器都因被认为是钢琴的前身而被我们称为古钢琴。\n许多作曲家都为古钢琴作曲，这时的曲子就是最早的钢琴曲。例如巴赫、享德尔和斯卡拉蒂的钢琴曲，都是为古钢琴的。海顿、莫扎特的大量作品和贝多芬的一些作品，也都是为古钢琴作的。\n另外，古钢琴还有它特有的纤巧的音色。所以，在古钢琴普遍被现代钢琴取代之后，到了十九、二十世纪之交，甚至在当代，又有少数钢琴家重新提倡使用古钢琴。直到现代许多形制的电子琴也都设置古钢琴的音色。\n著名的钢琴曲有，约翰施特劳斯的《维也纳森林故事》，德沃夏克的《幽默曲》等。\nTassel是2019年发行的歌曲。但比较奇怪的是，我分明记得这首曲子是我很小的时候就听到过得，可能是类似的曲子，但是我后续再也没有听过相似的曲子了。我听到总是有种悲伤的感觉，感觉某些往事如雨点落于水洼，窥不见清晰的倒影。\n评论区摘要：\n我理想中的婚姻生活是这样的：两个人有各自热爱的事业，工作结束回家腻歪在沙发上，陪孩子或看电视，一起做饭，一起打扫房间，彼此微笑，晚上抱着睡去，早上彼此吻别去工作，一起旅行，一起看电影，一起逛街，有什么话首先会对彼此说起。简简单单，干干净净，如刚洗过的白衬衫。\n然而爱情却是不断洗不断穿的白衬衫，一段爱情必然会经历各种磨难，苦难之后两人会更加珍惜彼此，然后迎来新的磨难，如同一件心爱的白衬衫，穿穿洗洗晾晾，直到某一天苦难不再来到，白衬衫泛黄，但你依旧观念苦难，白衬衫也不舍扔掉，两人一起经历苦难享受幸福共归黄土，白衬衫发黄放进橱柜。\n喜欢又能怎样，爱都不能轻易说出口，说出来的爱就是责任，就是包容，就是妥协，如果你不确定真爱就是眼前人的时候，放过自己放过那个无辜的人，不要等到爱变成负担，变成怨恨了才说出其实我没那么爱你了，人都很自私，更何况自私的爱，你给不了的爱就放手，成全自己成全彼此。\n五岁的时候，你可以为捕捉一只蝴蝶，而跑到一公里外的田野；十岁的时候，你可以为一个冰淇凌，跑遍商店，小巷、大街；十七岁的时候，你可以为喜欢的人，一个人去陌生的城；二十七岁的时候，你可以只为了生活，而随便就找个人，一辈子过。你说不是我们越来越懒了，而是懒得去爱了。\n那是初二那年一个很普通的下午，阳光洒进教室，我握着铅笔写写画画。同桌女孩扎着马尾，睁大双眼凑过来看，我下意识地挡住。她问，你在画什么？我说，未来。她又问，和谁的未来？我说，我们的。阳光偏了一些，照在脸上，我这辈子都不会忘记那么绚烂的笑容。\n英语老师说过：就算是believe（相信） 中间也藏了一个lie（谎言） 就算是friend（朋友） 还是免不了end（结束） 就算是Lover(爱人) 还可能会over（终结） 就算是Wife（妻子） 心里也夹杂着if（如果） 欣慰的是 即便是forget（忘记） 也曾经get （得到） 转 其实人生就是这样\n上化学课，化学老师说：“滴加，滴加！”于是化学老师变成了光，可惜滴加太多着火了，我拿起盖子大叫：“盖呀！”于是我也变成了光，火势太大惊动了校长，校长说：“哦不，水呢？”于是校长也变成了光，同学指着杯子大喊：“杯里呀！”于是这个同学进入了黑暗至今没出来。\n ","permalink":"https://tassel234.github.io/posts/life/%E9%9F%B3%E4%B9%90%E7%9A%84%E8%AF%84%E8%AE%BA-1/","summary":"音乐的评论 评论主要来源于网易云音乐。我使用网易云音乐的主要原因就是可以在评论区看到很多清新的小故事，而那些评论的文字往往也非常的温和和温柔，不同于大多数社交媒体的戾气。 城南花已开 作曲人：三亩地 发布时间：2017.3.26 创作历程： 一位喜欢三亩地音乐的朋友私信三亩地，说他得了骨癌晚","title":"音乐的评论-1"},{"content":"第三部分 大写的计算 第10章 元胞自动机、生命和宇宙 自然界中的计算 元胞自动机\n元胞自动机（Cellular Automaton，简称CA）是一种离散空间和时间的计算模型。它由一组离散的单元格（cell）组成，这些单元格按照一定的规则进行状态的更新和演化。\n在一个元胞自动机中，每个单元格可以处于不同的状态。时间以离散的步数进行推进，每个步数称为一个时刻（generation）。在每个时刻，单元格的状态根据一定的规则来更新。这些规则通常基于当前单元格及其相邻单元格的状态，以确定下一个时刻各个单元格的状态。\n元胞自动机的规则可以非常简单，也可以非常复杂。最简单的元胞自动机是一维的，每个单元格只有两种状态（例如0和1），并且只考虑自身和相邻单元格的状态来更新。复杂的元胞自动机可以是多维的，单元格的状态可以有多种，并且更新规则可以涉及更广泛的邻域。\n元胞自动机最著名的应用之一是康威生命游戏（Conway\u0026rsquo;s Game of Life），它是由数学家约翰·康威（John Conway）于1970年提出的一种二维元胞自动机。康威生命游戏的规则非常简单，但它展现出了丰富的生命现象，包括静态、周期性和复杂的演化行为，引起了广泛的兴趣和研究。\n元胞自动机在物理、生物、计算机科学以及复杂系统等领域都有广泛的应用。它们被用来模拟和研究各种自然现象和复杂系统的行为，探索它们的动力学特性和规律。元胞自动机也被用于图像处理、优化问题、模式生成等计算领域，提供了一种灵活而强大的建模和计算工具。\n生命游戏（Game of Life）是由英国数学家约翰·康威（John Conway）于1970年提出的一种细胞自动机。它是一种零玩家游戏，意味着玩家不需要进行任何操作，只需设定初始状态，然后观察细胞按照规则进行演化。\n生命游戏基于一个二维的方格网格，每个格子代表一个细胞。每个细胞可以处于两种状态：存活或死亡。初始时，玩家可以设定一些细胞为存活状态，而其他细胞为死亡状态。\n生命游戏按照以下规则进行演化：\n 如果一个存活细胞周围有少于2个存活的邻居细胞，则该细胞在下一个时刻死亡（模拟人口不足）。 如果一个存活细胞周围有2个或3个存活的邻居细胞，则该细胞在下一个时刻继续存活。 如果一个存活细胞周围有超过3个存活的邻居细胞，则该细胞在下一个时刻死亡（模拟人口过剩）。 如果一个死亡细胞周围正好有3个存活的邻居细胞，则该细胞在下一个时刻复活。  根据这些规则，细胞的状态在每个时刻根据其周围细胞的状态进行更新。通过不断迭代演化，生命游戏呈现出丰富多样的模式和行为，包括静态、周期性和复杂的演化。\n生命游戏不需要任何外部干预，它展示了一种简单的规则如何产生出复杂的行为和结构。它被广泛用于计算机科学、数学和物理等领域的研究，作为复杂系统行为和模式生成的模型。同时，生命游戏也成为了一种受欢迎的计算机图形演示和探索工具。\n四类元胞机 沃尔夫勒姆的“新科学”\n第11章 粒子计算 第12章 生命系统中的信息处理 什么是信息处理 免疫系统 蚁群 生物代谢 这些系统中的信息处理\n第13章 如何进行类比(如果你是计算机) 容易的事很难 进行类比 我对类比的认识经历 简化的类比 模仿者 如何做到 模仿者程序 运行模仿者 总结\n第14章 计算机模型 模型是什么 理想模型 对合作的进化进行模拟\n建模的好处 计算机建模注意事项\n第四部分 网络 第15章 网络科学 小世界 网络新科学 什么是网络思维 到底什么是“网络”\n小世界网络（Small-world network）是一种网络模型，用于描述具有高聚集度和短平均路径长度的网络结构。它在图论和复杂网络研究领域中具有重要的意义。\n在小世界网络中，节点（或顶点）之间的连接具有两个重要特征：聚集度（clustering coefficient）和平均路径长度（average path length）。\n聚集度是指在一个网络中，与某个节点相连的节点之间形成连接的概率。一个节点的聚集度越高，意味着它的邻居节点之间越容易相互连接。在小世界网络中，聚集度通常较高，即节点与其邻居节点之间的连接比较密集。\n平均路径长度是指网络中任意两个节点之间的最短路径的平均长度。它反映了网络中信息或物质传播的效率。在小世界网络中，平均路径长度相对较短，即节点之间的距离相对较近。\n小世界网络的特点是在保持较高的聚集度的同时，具有相对较短的平均路径长度。这种结构特性使得小世界网络在信息传播、社交网络、脑网络、互联网等领域中具有广泛的应用。\n小世界网络模型最早由社会学家斯坦利·米尔格拉姆（Stanley Milgram）于1967年的“六度分隔”实验中提出，通过邮件传递的方式探究人际关系网络。后来，数学家沃特·温弗里·斯塔格范（Watts and Strogatz）在1998年提出了一种生成小世界网络的数学模型，称为Watts-Strogatz模型，进一步推动了对小世界网络的研究。\n小世界网络的研究对于理解和分析复杂系统、网络传播、社会网络等具有重要意义，也对网络设计和优化提供了一定的指导。\n无尺度网络 网络稳健性\n第16章 真实世界中的网络 真实世界中的网络\n网络思想的意义 无尺度网络是如何产生的 幂律以及对其的质疑 网络中的信息传播和连锁失效\n第17章 比例之谜 生物学中的比例缩放 一次跨学科合作\n**幂律（Power Law）和分形（Fractal）**是两个在复杂系统和自相似性研究中经常提到的概念。\n幂律是一种数学关系，描述了某个变量的频率或大小与其取值之间的关系。在幂律中，变量的取值呈现出指数级的分布，即在较小取值范围内有大量的小值，而在较大取值范围内有少量的大值。幂律可以用公式表示为：P(x) ∝ x^(-α)，其中 P(x) 是变量取值为 x 的概率密度函数，α 是幂律指数。幂律在各种自然和人工系统中都有广泛的应用，例如城市规模分布、物种丰富度分布、互联网节点度分布等。\n分形是一种几何形状或结构，具有自相似性的特点。自相似性指的是一个对象的部分可以放大或缩小后与整体具有相似的结构。分形可以通过递归或迭代的方式生成，其中较小的部分与整体具有相似的形状和结构。分形的特点是无论在何种尺度上观察，都能发现类似的图形模式。著名的分形图形包括谢尔宾斯基三角形、曼德勃罗集合等。\n幂律和分形之间存在一定的联系。在某些情况下，分形结构可以导致幂律分布。例如，分形几何中的分形维度（fractal dimension）可以与幂律指数相关联。此外，某些复杂系统的行为和属性可能同时呈现出幂律和分形的特征，这反映了系统内部的自相似性和尺度不变性。\n幂律和分形的概念和方法在物理学、数学、计算机科学、生物学等多个领域中得到广泛应用。它们帮助我们理解和描述自然界和人工系统中的复杂性，并揭示了隐藏在数据背后的规律和结构。\n代谢比例理论 理论的应用 争议 幂律的未解之谜\n第五部分 尾声 第18章 进化，复杂化 遗传，复杂化 基因是什么 进化发育生物学 基因调控和考夫曼的“秩序的起源” 对考夫曼的研究的反响 总结\n第五部分 尾声 第19章 复杂性科学的过去和未来 统一理论和一般性原理 复杂系统研究的根源 五个问题 复杂性的未来，等待卡诺\n","permalink":"https://tassel234.github.io/posts/note/%E5%A4%8D%E6%9D%82%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-2/","summary":"第三部分 大写的计算 第10章 元胞自动机、生命和宇宙 自然界中的计算 元胞自动机 元胞自动机（Cellular Automaton，简称CA）是一种离散空间和时间的计算模型。它由一组离散的单元格（cell）组成，这些单元格按照一定的规则进行状态的更新和演化。 在一个元胞自动机中，每个单元格可以","title":"《复杂》读书笔记-2"},{"content":"第12章 谦逊：地球不是绕着你转 在中国，民族主义者会提出不同看法，认为历史是从黄帝和夏商开始，而且不管西方、伊斯兰或印度有什么成就，与中国文明相比都显得有些苍白。印度本土主义者才不相信中国这一派自夸，他们相信就连飞机和核弹都是由印度先贤发明的，土耳其、伊朗和埃及的民族主义者认为即使在穆罕默德之前，自己的国家早就是人性中善的起源。有些人甚至异想天开，以为就连物理定律也是靠着自己这套政治制度和宗教活动才得以维系。\n没有多少人相信是亚伯拉罕发明了瑜伽。但主流犹太教确实认真地认为，(整个宇宙之所以存在，就是为了让犹太教的拉比能够研究神圣的犹太教经典，而如果犹太人不再研究，宇宙就会走上末路。如果是世俗的犹太人，大概会对这个浮夸的主张有点怀疑,但就连他们也相信犹太人是历史的主要中心人物，是人类道德、灵性和知识的根本源头。\n以色列教育系统唯一具备连贯性的历史，就是从希伯来女的《旧约》开始到第二圣殿 ( Second Temple ) 时期，接着谈流亡时期( Diaspora) 的各个犹太群，再到犹太复国主义 ( Zionigm )兴起、犹大人大屠杀( Holocaust )，以及以色列建国。多数学生离开学校的时候，都深信这就是全人类故事的主要情节。\n然而事实就是，在人类物种的编年史上，犹太教的影响并不大。不同于基督教、伊斯兰教或佛教等世界性宗教，犹太教一直就是一种部落信仰。即使他催生了基督教（《旧约》）和伊斯兰教，犹太教的重要性也和弗洛伊德的母亲差不多。\n以色列人认为“三大宗教”为基督教(23 亿信徒 )、伊斯兰教 (18 亿信徒 ) 和犹太教 (1500 万信徒)。 10亿信徒的印度教、5 亿信徒的佛教也排不上列。\n之前的世界\n石器时代的狩猎采集者部落，早在亚伯拉罕之前几万年，就已经有了道德规范。欧洲第一批殖民者在 18 世纪后期抵达澳大利亚的时候，当她原住民部落虽然对摩西、耶稣和穆罕默德一无所知，但早已发展出完善的伦理世界观。\n有社交行为的哺乳动物( 如狼、海豚和猴子)都有其伦理规范，它们会通过进化而不断修正，以促进团队合作。\n在科特迪瓦的从林里，有一只名叫奥斯卡的小黑猩猩失去了母亲，只能自力挣扎求生。其他母黑猩猩都有自己孩子需要照顾，所以并不愿意收养照顾它。奥斯卡的体重逐渐下降,健康和活力也日益衰退。但就在看似绝望的时候，雄性首领弗雷迪“收养了奥斯卡，让它吃得好，甚至还背着它到处走。\n如果是为了拯救一个犹太人的性命，可以允许犹太人不遵守安息日规定;但如果只是要拯救一个非犹太人的性命，就不得亵渎这项规定 [《巴比伦塔木德·赎罪日书》( Yoma) 84:2 ]。\n佛陀与玛哈维拉已经开始要求信众非但不要伤害所有人类也不要伤害任何有知觉的生物，甚至包括昆虫。\n犹太教是否首创一神信仰还存在疑问。一神论几乎不会让人类的道德标准有任何提升。一神论有一点影响是毫无疑问的，那就是让许多人比以前更不宽容，于是导致宗教迫害与宗教战争蔓延肆虐各方。这是不是一个黑锅载体。\n犹太人的buff\n除了爱因斯坦和弗洛伊德这些知名人物科学界所有诺贝尔奖得主约有 20% 是犹太人(虽然犹太人占世界人口的比例不到 0.2%)。此外尼尔斯·玻尔,.摩西,亚罕默德，哥德尔，马克思，海因里希·赫兹，高斯，奥本海默，朗道，约翰·冯·诺伊曼，比尔盖茨，诺伯特·维纳（《控制论》的作者）都是犹太人。\n但这不是犹太人控制世界的论据，因为牛顿不是犹太人，他是正牌盎格鲁撒克逊人，图灵，特斯拉等大佬也不是犹太人，中国的历史也诞生很多的厉害的人，比如墨子，王守仁，现在也在历史的舞台变得越来越耀目。某些程度互联网会认为犹太人控制世界，只是因为某些人对这个大量聪明人汇聚的族群感到畏惧而已。即使那些经济系统和科学理论没有诞生于现在，没有诞生在犹太人之手，也会诞生在其他种群人的手里面，这几乎是历史，人性，社会发展，命运的必然。而那些东西如同军备升级和造核弹一样，为了不落后于人，遭到毁灭的风险，人类的所有群体都要彼此发展，竞争。一旦这些知识产生，所以人都要受到这个事件的波及，传染。但很难说这是一个坏事，因为虽然我们坐着的火药桶越来越大，但我们的社会发展在无比的提速，我们的生活在变好，医疗在发展。\n我在知乎上看过一篇文章，花了几万字的篇幅详细论证犹太人控制世界，获得了1w赞的我还没有详细看，只是收藏了一下，还没看，自从巴以冲突开始想找一找，结果发现被删除了。现在想起来，那个时候危险罪恶的犹太人观念就开始埋在人们的脑海了。\n知识是没有罪的，哪怕我们一次次的罚罪于他们。\n犹太人从前有一个buff是聪明，巴以冲突后他们又加了一个buff,随便就可以成为毁灭世界的恶魔。犹太人控制世界的论点不管这么想都有点离谱，虽然他们很聪明和狡猾，但也达不到这种程度吧，因为太扯了，还不如让我信奈亚拉托提普在暗中操纵世界，然后某一天玩腻了，决定让人类团结统一，至少还有乐子可以看。\n我都能现编一个印度教暗中控制世界的理由：\n古印度文明没有灭亡，而是躲在暗处操纵着世界\n欧洲核子研究中心CERN门口有一个湿婆的雕塑，要知道湿婆跳舞会毁灭世界，奥本海默造出原子弹说《薄迦梵歌》的一句台词，现在我成了死神,世界的毁灭者。为什么这些科学的地方会出现印度教，只能说懂得都懂。\n你想一下我们现在世界的阶级矛盾，在想一想印度教的特点。等级有序，阶级分明，从高到低分别为婆罗门、刹帝利、吠舍以及首陀罗。最早的阶级思想，阶级差异的糟粕就是印度人强行带个我们的，不然我们的世界肯定都是人人平等的。\n还有印度人造出来10进制数，阻止了中国科学的发展，中国讲阴阳，这就是最早的二进制，我们有八卦，如果不是印度教的十进制入侵我们的思想，我们领先世界3000年造出来计算机。\n同时印度神话还渗透中国的世界，带来二郎神，阎王等神明，企图入侵中国人的思想认同。\n反驳也很简单，湿婆神不只是毁灭的化身，祂兼具创造与破坏的双重性格。而湿婆雕像所跳的舞蹈，既是毁灭之舞又是创造之舞，左手持火并以此毁灭世界，右手持鼓并以此创造世界。物理学家则以先进技术来描绘宇宙的舞蹈。10进制数是因为人的十指，阶级在猴子里面也有，印度神又不是克苏鲁神话的不可直视的神（虽然克苏鲁神话很大程度的借鉴了印度神话），不会让人精神污染的。\n犹太人的建国确实非常不厚道，确实该死，但以色列人并不等于犹太人。而建国的事件几乎是历史的累计结果，在二战过后爆发，但就目前我了解的某些事件，犹太人并不是完全的贪婪无情，有很多犹太人坚决反对犹太复国主义，只不过我们思考不了那么多的实体，所以我们把那些人统一归为犹太人，目前全球大约有1500多万犹太人，以色列则以708万高居榜首,约占犹太人总数的50%。美 国：拥有600万犹太人，法 国：拥有55万犹太人，巴勒斯坦：拥有43万犹太人。但现在反以色列莫名变成了反犹太，希特勒都开始被一些人奉为英雄。\n看b站大多数的在弹屏声援希特勒：英雄，强力去油，意犹未尽，人民的力量。虽然我没怎么讨厌希特勒或斯大林，即使有汉堡和Millionka的唐人街事件，一些纳粹人也有属于人类的良知（普里姆，莱茵霍尔德艾格斯）但是人们应该希特勒，讨厌纳粹，至少在公共场合。尤其是在低龄化的b站，那些小孩子可不知道什么是玩梗，什么是真实。说起来小时候我妈告诉过我日本人是最坏的，我问到，那为什么不把它们全杀了呢，我妈说因为日本人里面也是既有好人也有坏人。因为这是纳粹的毁灭带给人们的警醒，别有事没事想着对讨厌的人进行种族大清洗。\n从阴谋论的角度来说，反对犹太人，是美国为了弱化中国马克思主义的手段，先在犹太人上下手脚，未来应该就是具体的犹太人了。控制舆论倒不是什么麻烦的事，选择性隐瞒一些事实就差不多可以了，舆论引发的后果本质上也是一个复杂系统（所以上面的阴谋论当我没说），处于社会范围，甚至遵守乌合之众提到 的降智原则，对于这个复杂的系统如果只是一片混沌，没有任何人可以建模预测倒还好，因为我们所有人都不知道这次的舆论点会对人们的思想产生什么潜移默化的影响，就怕哪一天某个组织知道了一切，世界似乎就真的在他们的掌控之下了。\n“但应该强调的是，这些是个别犹太人自身的贡献，而不能归功于犹太教的宗教或文化。犹太人就是在放弃了犹太初等学校并转向实验室之后，才开始在科学上做出杰出贡献的。\n一直到 19 世纪和 20 世纪，世俗化和犹太启蒙运动让许多犹太人接纳了非犹太人邻居的世界观和生活方式，才产生了巨大的变化。\n1905至1933 年期间，有 10 位德国犹太人获得了诸贝尔化学奖、医学奖和物理学奖，但同一时期没有任何一位极端正统犹太人或者来保加利亚或也门的犹太人能摘下诺贝尔奖桂冠?\n第13章 神：不要妄称神的名 同一种宗教对于一些人激发的是仇恨和偏执，对另一些人激发的是慈爱和同情。\n不该用神的名义来为自己的政治利益、经济野心或个人仇恨找借口。\n虽然基督徒不信印度教的诸多神，但仍会以慈善行事:虽然穆斯林不视基督为神，但仍然重视诚实待人;虽然丹麦和捷克是世俗国家，但也不比宗教国家更加暴戾。\n麦基尔文纳牧师和其他加入的神职人员都很熟悉《圣经》里是到的对同性恋的告诫禁令，但他们认为，比起遵守《圣经》的字面意识忠于基督的慈悲精神更为重要。所以他们加入了加州同性恋权益运动的一份子。\n为人是社交动物，自己幸福与否，在很大程度上取决于与他人的关系。没有爱、没有友谊、没有群体的支持，谁能快乐得起来?如果过着孤独以自我为中心的生活，肯定会感到痛苦。所以，想要快乐，你至少得关心你的家人、朋友，以及所属社群里的其他人。\n世上所有的暴力行为，必然始于一个人心中的暴力欲望，这种欲望早在扰乱他人的平和与幸福之前就已经扰乱了自己的平和与幸福。每当你怒火中烧或满腹妒火，哪能体验快乐与和谐?所以，早在你杀人之前，这份愤怒已经扼杀了你心中的平和。\n第14章 世俗主义：面对你的不完美 真相、同情、亚等、自由、勇气和责任\n对抗偏见及压迫的政权，需要很大的勇气 ( courage )，但要承认自己的无知，并走进未知的领域，则需要更大的勇气。\n犹太人也重视真相，基督徒也重视同情，穆斯林也重视平等，印度教徒也同样重视责任，诸如此类。\n连接\n宗教如果想得到世俗主义社会的接纳，正统派犹太教就必须平等对待非犹太人;基督徒不能把认定为异端的人绑上柱子焚烧;穆斯林必须尊重言论自由:而印度教徒也必须放弃基于种姓的歧视。\n斯大林让我们看到的，是一个没有神却极端教条主义的“斯大林主义”宗教，而他就是该教的先知。许多资本主义者不断重复呼喊着自由市场和经济成长的口号，却无视现实的改变。\n马克思一开始只是认为所有宗教都是压迫性的欺诈，并鼓励追随者自己去调查了解全球秩序的本质。但等到斯大林的时候，苏联共产党的官方说法已经是全球秩序对一般人而言实在太复杂，所以最好永远相信组织的智慧，叫你做什么就去做，就算有牺牲也在所不惜。\n“充满爱的宗教”会被扭曲，马克思的思想怎样异化出了斯大林的劳改营;科学家该想想科学研究计划为何如此轻易就让自己破坏了全球生态系统的稳定;遗传学家更该特别注意，思考一下纳粹如何劫持了达尔文进化论。\n每一种宗教、意识形态和信条都会有自己的阴影，不害怕自己的阴影，原则上也愿意承认自己的错误和盲点。\n更愿意相信那些承认自己无知的人，而不是那些声称自己全知全能的人。\n第四部分 真相 全球所面临的重重困境如果让你觉得困惑而不知所措，那就对了。因为全球的发展已经变得相当复杂，任何个人都难以理解。这样一来，你要怎样才能得知关于这个世界的真相，避免成为媒体宣传和错误信息的受害者？\n第15章 无知：你知道的比你想象的少 权利的黑洞，路西法效应，知识分子的悲剧\n从进化的角度来看，智人相信别人的知识实在是一件再好不过的事。我们之所以会坚持这些观点，是因为对群体的忠诚。\n有些人高谈阔论如何应对气候变化和转基因作物，但其实对于气象学或生物学几乎一无所知;有些人强烈主张该如何解决伊拉克或乌克兰的问题，但其实连这些国家在地图上的位置都找不到。\n人类很少能认清自己的无知，因为他们就是一直待在如同回声室的同温层里，往来的都是思想相近的朋友，接收的都是肯定自己意见的新闻信息，各种信念只是不断增强，鲜少遭到挑战。因为如此，我们才得在周围浪费大把的时间，尽管某些绝妙的革命性见解多半是没有根据的猜测、早被推翻的模型、纯粹信的教条或荒谬可笑的阴谋理论。\n如果待在权力中心，对世界的看法就会极度扭曲:如果勇敢来到周围，又会浪费许多宝贵的时间。\n第16章 正义：人类的道德困境 现代的全球化世界天生就有一个特点: 因果关系高度分化且复杂。\n我可能只是静静地待在家里，从来没伤害过任何人，但对左翼运动人士来说，我完全就是以色列军队和约日河西岸定居点定居者的同谋。在社会主义者眼里，我之所以过着舒适的生活，是因为脚踩第三世界血汗工厂里的童工。动物福利提倡者告诉我，我的生活交织着历史上最丑恶的犯罪事件:野蛮且习以为常地剥削着数亿只家禽家畜。\n当代世界大多数的不公正，并不是来自个人的偏见，而是来自大规模的结构性偏见，\n面对规模如此庞大的道德问题，人类为了理解和判断，有下列4种常用的方法。第一是缩小问题规模:把战争想象成两个人在打架一个是现在的政权，另一个则是反抗分子，一个是好人，另一个是坏人，\n第二是把重点集中在某个感人的故事，用它来代表整个冲突事件。有一项研究，则是请人捐款给 1位或 8位病童。在只有1位病童的情境中，民众捐的钱更多。\n第三种方法是编出各种阴谋论。\n第四种，也是最后一种方法，则是创造出一套教条，全然相信某种号称全知的理论机构或领导，接着便无条件地跟随\u0026mdash;卡密。\n第17章 后真相时代：谎言万世永存 信息的洪流之中，比错误的信息更可怕的是，那些让我们心情糟糕的信息，\n焦虑有个调用，\n在 20世纪初期，犹太复国主义最爱谈的口号就是要让“没有土地的人民(犹太人)回到没有人民的土地上(巴勒斯坦 ）。1969 年，以色列前总理果尔达·梅厄有句名言，说巴勒斯坦人从来就不存在。就算到了今天这种观点在以色列仍然非常普遍。\n如果你想指责脸谱网或那些政客开启了全新而恐怖的后真相时代，请提醒自己，不过几百年前，还有几百万的基督徒把自己锁在一个不断自我强化的神话泡泡里，从来不敢质疑《圣经》在各种事实上是否真实。\n纳粹的宣传用一句话就讲出了自己的诀窍:“谎话说一次仍然是谎话，但说一千次，就成了事实。”希特勒也写道:“即便政治宣传手段再出色，如果没把一项基本原则牢记在心，也无法成功一宣传时必须只锁定几个重点然后不断地一再重复。”就算是现代兜售假新闻的那些人，谁能说得比这更精辟呢?\n苏联的政治宣传机器对真相的操弄也不在话下，大到整场战争，小到儿张个人照片，历史都同样遭到重写。1936 年 6 月29 日，官方媒体《真理报》(Pravda)头版刊出一张照片，斯大林满脸微笑，抱着7岁的小女孩葛丽亚·玛克丽佐娃(Gelya Markizova )。这张照片成了斯大林主义的象征，将斯大林拥为国父，也大打“快乐的苏联童年”这个理想。全国各地印刷厂和工厂开始用这张照片制成数百万份海报、雕塑和马赛克，从苏联的这头到那头都有相关展示品。当时，就像是所有俄罗斯东正教教堂都要有圣母抱子像才算完整，所有苏联学校也都有斯大林爸爸。\n抱着小葛丽亚的画像。但很遗憾，在斯大林的帝国里，名声往往会带来灾难。不到一年葛丽亚的父亲就被诬指为日本间谍、托派分子，遭捕下狱。他在 1938 年被处死，成为斯大林统治时期的几百万受害者之一。葛丽亚和母亲被流放到哈萨克斯坦，母亲也很快就莫名过世。事已至此，但当时全国还是有数不清的画像，画着国父抱着“人民敌人”的女儿，到底该怎么办?这不是什么问题。从那一刻起，葛丽亚·玛克丽佐娃就消失了。这个随处可见的“快乐苏联儿童”，身份变成来自塔吉克的 13 岁女孩玛穆拉卡·那坎葛娃 (Mamlakat Nakhangova )，因为在棉花田里辛勤采收而获颁列宁勋章(如果有人觉得画面里的女孩怎么看都不像13 岁。\n人类合作的力量取决于真相与虚构之间的微妙平衡\n怎样分辨现实与虚构，但这里我想先提供两个重要的黄金法则。第一条黄金法则:如果你想得到可靠的信息，必然要付出昂贵的代价。如果你总是免费得到信息，有可能你才是整个商业世界的产品。第二条黄金法则:如果觉得某些问题似乎对你特别重要，就该真正努力阅读相关的科学文献。\n后真相生物，曾经的谎言，永远的真相\n第18章 未来不是科幻小说：无法逃离的母体 黑客帝国和楚门的世界，母体之外还是母体，我们看过的电影。度过的书\n一开始想象出机器人的那个心智早就属于受各种操控所生成的产品。\n《头脑特工队》一个很优秀的迪士尼电影，乐乐认为自己就是莱莉的真实本质，她会教训所有其他内在情绪，也就干扰了莱莉大脑里的微妙平衡。因为莱莉不只是乐乐、忧忧或其他任何一个角色，而是所有生化角色在冲突和合作中共同产生的一个复杂故事。那些悲伤的情绪也很重要。\n“我年轻的朋友,”穆斯塔法·蒙德打断了他，“现在的文明世界是不需要什么高贵和英雄主义的。因为这类东西不能带来什么政治效率。高贵或英勇只会表现在乱世中，像我们这种合理平和的社会里人是没有机会来表现他的高贵或英勇的。因为高贵和英雄主义只有在战争或派别分化时，或者在抵制诱惑和保卫自己所爱时才会有它存在的意义。但现在我们既没有战争，也没有派别分化，人们更不会为自己所爱有过激的行为。所以我们这儿不需要这个东西。你的条件设置让你愉悦地自然而然地去做你应该做的，也就不存在什么诱惑需要你去抵抗了。即使在出现意外时发生了不愉快的事，你也能用唆麻@来回避，它会让你远离现实，进入一种你想要的虚幻中，这样你就有足够的耐心来承受长期的痛苦，让你能心平气和地对待你的敌人。这在以前，你得付出相当大的努力和多年艰苦的道德训练才能达到这种境界;可现在只需两三粒半克的唆麻就能带你实现了。现在所有的人都可变得高尚，那个瓶子就可以装下你至少一半的道德，你可以带着它去任何地方。没有眼泪的基督教——这就是唆麻。\n“但我觉得眼泪还是必需的。还记得《奥赛罗》里说过: 和煦的阳光总在暴风雨之后，那就让狂风恣意吧，吹醒那死亡。还有一个印第安老人常跟我讲一个有关玛塔斯吉姑娘的故事。那些想娶她的小伙子必须到她的园子里去锄一上午地。这看似简单，但实际是园子里有很多很多带魔法的蚊子和苍蝇。大部分人都会受不了，只有经得住考验的才能得到那姑娘。\n“这是个动人的故事!但在我们的文明世界,”控制者说，“你根本不用这样大费周折就能得到她，也不会有什么苍蝇蚊子，几个世纪以前就被我们彻底消灭了。”\n野蛮人皱起了眉头。“你们只是消灭苍蝇蚊子，消灭所有不愉性 的东西，而不是去学会忍受它们。“默然忍受命运的暴虐的毒箭，或是面对苦海，拿刀做个一了百了。”你们既不是“默然忍受’，也不是。一了百了’，而只是取消了命运的毒箭，这样未免太简单化了。“那里面确实包含很多东西,”控制者说，“男人和女人的肾上隐素需要定期地来刺激一下。”\n“什么 ?”野蛮人听得有点莫名其妙。\n\u0026hellip;..\n“那是为身体健康所设的条件设置之一。我们把接受 V.P.S.治疗规定为一种义务。”\n“VPS.?”\n“就是代猛烈情愫。每月一次，它可以让整个生理系统都弥漫肾上腺素。从生理上来说，它就完全等同于恐怖与狂怒。它让人感受到的效果跟杀死苔丝德蒙娜或被奥赛罗杀死是相同的，但你不会感到丝毫的不适。”\n“但我却更喜欢那种不适。”\n“我们可不喜欢,”控制者说，“我们喜欢一切都舒舒服服地进行。” “我要的不是这样的舒服。我需要上帝!诗!真正的冒险!自由!善!甚至是罪恶!” 实际上你是在要求受苦受难的权利。” 随便你怎么说,”野蛮人挑衅地说，“就算我现在是在要求受苦受难的权利吧。”\n“那你是不是也需要衰老、丑陋、阳痿、梅毒、癌症、饥饿、伤病这些丑陋的东西，甚至你也希望总是在担心明天有不可预知的事发生，或者你还需要遭受种种难以描述痛苦的折磨呢。”接下来是长久的沉默。\n“是的，这一切我都要。”野蛮人终于开口了\n穆斯塔法·蒙德摊开双手耸了耸肩说 :“那就随便吧。\n“事实上,”穆斯塔法·蒙德说，“你要求的是不快乐的权利。”“可以这么说，”野蛮人挑衅地说，“我是在要求不快乐的权利。”“你还没有说要有变老、变丑、变得性无能的权利，要有患上梅毒和癌症的权利，要有食物匮乏的权利、讨人厌烦的权利，要有永远担心明天会发生什么事的权利，要有感染伤寒的权利，要有被一切无以言表的痛苦折磨的权利。”\n说完是一段长时间的沉默\n“我要求这一切的权利。”野蛮人终于打破沉默。\n——《美丽新世界》的片段\n第五部分 生存下去 在这个困惑的年代，旧的故事崩塌，新的故事还无以为继，我们该怎么生存下去？\n第19章 教育：改变是唯一不变的事 2050，谷歌翻译可以让外国人流利的讲中文。\n告诫我们进行认识自己，学会和未知和平相处，不要傲慢，也不要畏惧，应该是敬畏吧。\n“4C”，即批判性思考 ( critical thinking )、沟通 (communication)、合(collaboration)和创意(creativity )。\n不要拒绝改变自己，接受新的事物\n物理的认知结构化为那些大量的数字信息\n第20章 意义：人生不是虚构的故事 早在 1848 年，《共产党宣言》就声称一切坚固的东西都烟消云散了”(all that is solid melts into air )，只不过马克思和恩格斯当时讲的主要是社会和经济结构。而到 2048 年，物理和认知结构或许也会烟消云散，或是散成大量数字信息。\n狮子王辛巴承担草原王子的使命，打败邪恶的刀疤，继承了王位，让草原的王国继续和平和发展。\n草原多少年，那些信仰多少年，在我们持有圣经之前我们就活在这里，不会毁灭\n生命循环可以有各种版本，如果我相信其中任何一种，就代表我相信自己有一种固定、真实的身份，决定了我这一生有何职责。\n自由民和奴隶、贵族和平民、领主和农奴、行会师傅和帮工,一句话，压迫者和被压迫者，始终处于相互对立的地位，进行不断的、有时隐蔽有时公开的斗争，而每一次斗争的结局都是整个社会受到革命改造或者斗争的各阶级同归于尽。\n——共产党宣言\n《共产党宣言》继续解释道，在现代“整个社会日益分裂为两大敌对的阵营，分裂为两大相互直接对立的阶级:资产阶级和无产阶级”这场斗争将以无产阶级的胜利告终，代表着历史的终结，在地球上建立起共产主义的社会，全民公有，而且每个人都享受完全的自由、完全的快乐。\n如果我相信这则犹太复国主义者的故事，我就会认为自己这辈子的使命是增进犹太民族的利益，方法包括维护希伯来语的纯洁，夺回失去的犹太领土，或是生养忠诚的新世代以色列儿童。\n更糟的是，我 13 岁的时候就已经知道宇宙已有几十亿年的历史，而且大概还会再继续存在几十亿年。现实点儿说，我真的能期待以色列存在这么久吗?再过两亿年，还会有智人的小孩，穿着白色衣服，朗通着诗歌吗?这整件事听起来难道不是大有问题吗?\n如果你碰巧是巴勒斯坦人，也不用高兴得太早。再过两亿年，大概也不会剩下任何巴勒斯坦人，甚至很有可能根本不会剩下任何哺乳动物。\n——以色列犹太人作者赫拉利的原话\n纳粹大约有 20% 的区长 (gauleiter，相当于现在的省长或州长)、10%的将军决定自尽，但这也代表有 80%的区长、90%的将军非常乐意继续活下去。至于绝大多数领有党证的纳粹党员，甚至盖世太保的成员，都既没有发疯，也没有自杀，后来成了很好的农夫、教师医生或保险代理人。\n根据佛教的说法，宇宙有三个基本现实:一切事物都会不断改变诸行无常 )，一切事物都没有永恒的本质( 诸法无我 )，没有什么能永远人满意(诸漏皆苦)。就算你能够探索银河系、探索你的身体、探索你的心智，即使你探索得再远，也无法找到永不改变的东西、永恒固定的本质，更无法得到永远的满足。\n没有意义，如果你能使用大数据研究，那些东西都是人类的共性，甚至是生物的共性。\n即使犹太人没有把带来，也会有其他人种带过来\n第21章 重新认识自己：人类心智的奥秘 冥想，内观流，\n“什么都别做，别去控制呼吸，也不要想用什么特殊的方式呼吸。只要观察现在的状况，不管状况如何。吸气的时候，你只是意识到，这股气进来了;呼气的时候，你只是意识到，这股气出去了。而等你不再专注，思绪开始在回忆和幻想中游荡的时候，你只是意识到:现在我的思绪不在呼吸上了。”\n有人会问些人生大问题，他们并不想知道自己什么时候吸气、什么时候呼气，而只是想知道人死之后会怎样。然而，人生真正的谜并不是发生在死后，而是在生前。想懂“死”，就得先懂“生”。\n我从观察自己呼吸所学到的第一件事是:虽然我读了那么多书，在大学上了那么多课，但对自己的心智几乎一无所知，而且根本没什么办法控制心智。无论我怎么努力，还是会想到别的事情，专心观察气息如何进出鼻孔的时间怎样也撑不过 10 秒。\n随着课程进行下去，学生除了要观察自己的呼吸，还要观察整个身体的感觉。这里说的并不是什么特别的幸福或狂喜，而是最普通、最一般的感觉，比如冷热、压力、疼痛等。内观技巧背后的道理，是认为心智的流动与身体的感觉密切相关。我和这个世界之间隔着的是身体的感觉。我真正反应的对象不是外界事件，而是自己身体的感觉。\n观察心智的时候，必须抛开所有二手信息宗教教条和哲学猜想，一心专注于自己的体验和真正遇到的各种现实每天都有许多学生去找他，希望得到指引、得到问题的解答。他房间门口写着:“不要讨论理论或哲学，请把问题集中在与你实际修行相关的事情上。”\n所谓实际修行，就是要运用系统、持续及客观的方式，观察身体的感觉以及心智对这些感觉的反应，据此找出心智的基本模式。有些人会用冥想来追求幸福和狂喜之类的特殊体验。但事实上，意识是宇宙最大的谜团，就算是冷热或痒麻之类最一般的感觉，也和心醉神迷或宇宙合一之类的感觉同样神秘。内观禅修者都会被告诫，千万不要想追求什么特殊的体验，而是要专注于了解自己心智的真实状况，不论这个状况为何。\n近年来，研究心智和大脑的学者对于冥想技巧越来越感兴趣，但多半只是间接使用这种工具。一般来说，科学家做研究的时候并不是自己冥想，而是请有经验的冥想者来到实验室，在他们的头上接上电极感应,再请他们开始冥想，科学家来观察冥想所产生的大脑活动。有些大学和实验室已经开始将冥想作为研究工具，而不只是大脑研究的观察对象。认真的冥想需要严格的纪律。\n工程师打算挖隧道打通一座大山，为什么只从一边挖呢?如果能同时从两边开挖不是更好?如果大脑和心智确实同为一体，这两条隧道迟早都会连通.如果大脑和心智并非一体，那么我们更应该深入研究心智，而不是一心只研究大脑。\n","permalink":"https://tassel234.github.io/posts/read/%E4%BB%8A%E6%97%A5%E7%AE%80%E5%8F%B2%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-3/","summary":"第12章 谦逊：地球不是绕着你转 在中国，民族主义者会提出不同看法，认为历史是从黄帝和夏商开始，而且不管西方、伊斯兰或印度有什么成就，与中国文明相比都显得有些苍白。印度本土主义者才不相信中国这一派自夸，他们相信就连飞机和核弹都是由印度先贤发明的，土耳其、伊朗和埃及的民族主义者认为即使","title":"《今日简史》读书笔记-3"},{"content":"作者：梅拉妮·米歇尔（Melanie Mitchell），波特兰州立大学（Portland State University）计算机科学教授，圣塔菲研究所（Santa Fe Institute）客座教授。师从侯世达（Douglas Hofstadter），即奇书GEB《哥德尔 艾舍尔 巴赫——集异璧之大成》的作者。\n理解复杂系统需要有全新的方法.需要超越传统的科学还原论，并重新划定学科的疆域。借助于圣塔菲研究所的工作经历和交叉学科方法，复杂系统的前沿科学家米歇尔以清晰的思路介绍了复杂系统的研究，横跨生物、技术和社会学等领域，并探寻复杂系统的普遍规律，与此同时，她还探讨了复杂性与进化、人工智能、计算、遗传、信息处理等领域的关系。\n背景和历史 有许多常见的复杂系统存在于各个领域和领域的研究中。以下是一些常见的复杂系统的示例：\n  社交网络：社交网络是由人与人之间的互动关系构成的复杂系统。它涉及到庞大的网络拓扑结构、信息传播、社会影响力等方面的研究。\n  经济系统：经济系统研究了市场、产业、金融等方面的复杂交互关系。它涉及到供需关系、价格变动、投资决策等问题，经济学家使用复杂性理论来解释经济现象。\n  生态系统：生态系统包括生物群落、物种之间的相互作用以及它们与环境之间的关系。生态学家使用复杂性理论来研究生态系统的稳定性、物种多样性、食物网等。\n  大气和气候系统：大气和气候系统涉及到气象、气候变化和全球气候模式等方面的复杂关系。它包括大气动力学、气候模式、气候变化预测等研究领域。\n  神经系统：神经系统研究脑部和神经元之间的复杂连接和信号传递。神经科学家使用复杂性理论来理解记忆、学习、认知等神经过程。\n  交通系统：交通系统涉及城市交通网络、交通流量和交通管理等方面的复杂问题。研究者使用复杂性理论来优化交通流量、降低拥堵等。\n  生产制造系统：生产制造系统涉及到供应链管理、生产流程、资源分配等复杂的运作过程。复杂性理论可以帮助优化生产效率、减少成本和提高质量。\n  这些只是一些常见的复杂系统的例子，实际上，复杂系统存在于我们生活和研究的各个领域中，包括生物学、物理学、化学、社会科学等。蚁群是我们可以直接认知到的一个复杂系统，通过简单的个体和规则形成一个复杂的群落。\n第一章：复杂性是什么 复杂系统的共性\n对复杂系统加以定义：复杂系统是由大量组分组成的网络，不存在中央控制，通过简单运作规则产生出复杂的集体行为和复杂的信息处理，并通过学习和进化产生适应性。\n如果系统有组织的行为不存在内部和外部的控制者或领导者，则称之为自组织（self-organizing）。由于简单规则以难以预测的方式产生出复杂行为，这种系统的宏观行为有时也称为涌现（emergent）。这样就有了复杂系统的另一个定义：具有涌现和自组织行为的系统。复杂性科学的核心问题是：涌现和自组织行为是如何产生的。\n如果人工智能某一天可以产生意识，应该也可以归为涌现的范畴。\n第2章 动力学、混沌和预测 动力一词意味着变化。而动力系统则是以某种方式随时间变化的系统。你想得到的系统几乎都是动力系统。\n十九世纪的科学家普遍认为世界是一个可以由科学和计算确定未来的世界，如拉普拉斯妖怪和希尔伯特的宣言，但实际上后世的发现证明了这个观点的错误。一个是海森堡的“测不准原理”，证明不可能在准确测量粒子位置的同时，又准确测量其动量（质量乘以速度）。对于其位置知道得越多，对于其动量就知道得越少，反过来也是一样。一个就是混沌理论。\n混沌（Chaos）是指一类具有高度敏感依赖于初始条件的非线性动力系统的行为。这些系统可能表现出极其复杂、难以预测和不可重复的行为，即使是微小的初始条件变化也可能导致系统的行为巨大变化。\n混沌系统的行为通常表现为长期的不可预测性、随机性和无规律性。尽管混沌系统的行为在某种程度上是确定性的，但由于其高度敏感的依赖于初始条件，微小的变化可能会导致系统轨迹的分叉和发散，使得长期的预测变得困难甚至不可能。\n混沌的概念最早由美国数学家爱德华·洛伦兹在20世纪60年代初引入，他的洛伦兹系统成为了混沌现象的经典例子。混沌理论在数学、物理学、生物学、化学等多个领域都有应用。例如，气象学中的天气预报、流体力学中的湍流现象、心脏的节律变化等都涉及到混沌系统的研究。\n混沌理论的研究对于我们理解复杂系统的行为模式和预测能力具有重要意义。它揭示了一类非线性系统的内在特性，丰富了我们对自然界中复杂现象的认识。\n第一个明确的混沌系统的例子可能是19世纪末由法国数学家庞加莱。庞加莱是现代动力系统理论的奠基者，庞加莱想先尝试解决三体问题。牛顿已经解决了二体问题，但三体问题要复杂太多了。牛顿发明了微积分，而庞加莱为了解决这个问题也创建了一个新的数学分支——代数拓扑，但最后还是没有解出三体问题，间接导致了《三体》的诞生（雾）。\n逻辑斯蒂映射\n逻辑斯蒂映射（logistic map），它也许是动力系统理论和混沌研究中最著名的方程。事实上，它是能抓住混沌本质——对初始条件的敏感依赖性——的最简单的系统之一。\n逻辑斯蒂映射的形式如下：\nx_{n+1} = r * x_n * (1 - x_n)\n其中，x_n表示时间步为n时的系统状态，x_{n+1}表示时间步为n+1时的系统状态，r是映射的参数，取值范围通常为0到4之间。\n逻辑斯蒂映射的特点是简单且具有丰富的动力学行为。当r取不同的值时，逻辑斯蒂映射可以呈现出多样的行为，包括稳定点、周期点和混沌行为。\n当r的取值较小时（如0到1之间），逻辑斯蒂映射趋向于收敛到一个或多个稳定点。随着r增大，系统可以经历周期倍增的过程，即从稳定点变为周期为2的点，然后是周期为4的点，依此类推。当r超过某个临界值（约为3.57），逻辑斯蒂映射进入混沌状态，系统的状态变得无法预测和周期性。\n逻辑斯蒂映射的混沌行为具有重要的理论和实际意义。它不仅在数学和物理学中被广泛研究，还在其他领域如生物学、经济学和信息科学中有应用。它的简单结构和丰富的动力学行为使其成为研究和理解混沌现象的重要工具。\n混沌的共性\n混沌思想带来的革命\n第3章 信息 信息是什么\n物理学家盖尔曼（Murray Gell-Mann）在讨论复杂系统理论时则说，“虽然它们的物理属性很不相同，但它们处理信息的方式却是类似的。这个共性也许是对它们进行研究最好的起点.\n麦克斯韦妖\n麦克斯韦假设有一个箱子被一块板子隔成两部分，板子上有一个活门。活门有一个“小妖”把守，小妖能测量气体分子的速度。对于右边来的分子，如果速度快，他就打开门让其通过，速度慢就关上门不让通过。\n麦克斯韦自己的回答是第二定律（熵随时间增加）根本就不是一条定律，而是在大量分子情形下成立的统计效应.\n对这些解释提出异议的是希拉德，他认为测量过程需要能量，这样箱子，分子，小妖组成的系统就会遵守热力学第二定律。还有一些假设，比如擦除记忆是不可逆的，擦除的动作就会产生热。\n统计力学提要 微观态与宏观态 香农信息\n香农信息是指由克劳德·香农（Claude Shannon）提出的信息论，它是现代通信和信息处理领域的基础理论之一。香农于1948年发表了题为《通信的数学理论》（A Mathematical Theory of Communication）的经典论文，该论文奠定了信息论的基本原理和概念。\n香农的信息论主要研究信息的量化、传输和编码等问题。他定义了信息的基本单位为比特（bit），表示信息的最小单位。他提出了香农熵（Shannon entropy）的概念，用于度量信息的不确定性和随机性。香农熵越高，表示信息越不确定，反之则越确定。这个概念在数据压缩、数据传输和密码学等领域有着重要的应用。\n除了香农熵，香农还提出了信道容量（channel capacity）的概念，它表示在给定的信道条件下，能够传输的最大信息速率。这个概念对于设计高效的通信系统和编码方案非常重要。\n香农信息理论的应用非常广泛，涉及到通信系统、数据压缩、密码学、网络传输、人工智能等领域。它为信息传输和处理提供了重要的数学工具和理论基础，对现代社会的信息技术发展做出了巨大贡献。\n19世纪的热力学研究就是由改进蒸汽机时遇到的挑战驱使\n1940年，香农改进了玻尔兹曼的思想，以适用于更为抽象的通信领域\n信息论也是密码学和新兴的生物信息学的基础，生物信息学通过分析基因序列的模式测量熵等信息论度量。信息论也被应用到语言和音乐的分析\n第4章 计算 什么是计算？什么可以计算 希尔伯特问题和哥德尔定理\n希尔伯特问题（Hilbert\u0026rsquo;s Problems）：希尔伯特问题是德国数学家大卫·希尔伯特于1900年在国际数学家大会上提出的23个重要问题。这些问题涉及数学的各个领域，包括数论、代数、几何、分析等。希尔伯特希望通过解决这些问题来推动数学的发展。其中一些问题已经在之后的数学研究中得到了解决，而其他问题仍然是开放的研究领域。\n哥德尔定理（Gödel\u0026rsquo;s Theorems）：哥德尔定理是奥地利逻辑学家库尔特·哥德尔在20世纪上半叶提出的两个重要定理。这些定理被称为哥德尔的不完全性定理（Gödel\u0026rsquo;s Incompleteness Theorems）。第一不完全性定理表明，在任何足够强大的公理体系中，总存在无法通过该体系内的公理和推理方法来证明或否定的陈述。第二不完全性定理则表明，如果一个公理体系是一致的，则它无法证明自身的一致性。这些定理对逻辑学和数学基础理论产生了深远的影响，挑战了早期对于形式化系统完备性和一致性的理论观点，并揭示了数学和形式系统的某些局限性。\n哥德尔的不完全性定理和希尔伯特的问题都是数学基础理论的重要研究领域，对于我们理解数学的本质和限制具有重要的启示作用。\n图灵机和不可计算性\n图灵机（Turing machine）是英国数学家艾伦·图灵（Alan Turing）于1936年提出的一种抽象计算模型。它是一种理论上的计算设备，用于描述计算过程的基本原理。\n图灵机由一个无限长的纸带、一个读写头和一组指令集合组成。纸带可以看作是一个线性的存储器，被划分为一系列格子，每个格子上可以写入符号。读写头可以在纸带上移动，并读取或写入符号。指令集合定义了图灵机的操作规则，包括读写头的移动、符号的改变和状态的转换等。\n图灵机在理论计算机科学中起到了重要的作用。图灵提出了图灵机的概念来解决一个基本问题：判断某个问题是否可计算。他证明了存在一些问题，即图灵不可计算问题，没有任何算法可以解决。\n不可计算性理论是研究哪些问题是无法通过任何算法解决的领域。图灵不可计算问题指的是无法用图灵机算法解决的问题。这些问题通常涉及到对所有输入的所有可能性进行枚举，但没有一种通用的算法可以在有限时间内给出正确的答案。\n图灵不可计算性的一个著名例子是停机问题（Halting problem）。停机问题是指判断一个给定的图灵机程序在给定输入下是否会停止运行。图灵证明了不存在一种通用的算法，可以判断任意图灵机程序是否会停机。\n图灵不可计算性理论对计算理论的发展和计算机科学的基础研究产生了深远的影响。它帮助我们理解计算的局限性，并揭示了某些问题的困难性。\n定义为图灵机的明确程序\n图灵对判定问题的解决 哥德尔和图灵的命运\n第5章 进化 达尔文之前的进化观念 达尔文理论的起源 孟德尔和遗传律\n对于突变学说，达尔文有一句著名的驳斥，“Natura non facit saltum（自然不会跳跃）。达尔文主义者和孟德尔主义者相互论战了多年。虽然双方都有实验证据支撑他们的立场，但当时却还没有成熟的概念体系（例如多个基因控制性状）和数学能将双方的理论融合到一起。\n必须发展出一套全新的数学工具。这套工具到20世纪20—30年代才由数学生物学家费希尔提出：数学框架——群体遗传学（population genetics）——用来理解在孟德尔遗传学和自然选择作用下演化种群的等位基因的动力学。达尔文理论和孟德尔遗传学，再加上群体遗传学，共同形成了后来所谓的“现代综合（the Modern Synthesis）”。\n对现代综合的挑战\n在（相对）很短的时间里形态却出现了剧烈变化，并产生出新的物种。这个特点被称为间断平衡\n间断平衡在验证进化论的实验和进化计算机模拟中已被广泛观察到了。\n虽然古尔德和埃尔德雷奇等人挑战了现代综合的信条，但他们却同所有生物学家一样，仍然拥护达尔文主义的基本思想：进化在过去40亿年的生命史中一直存在，在未来也将继续存在；所有现代物种都是起源于共同的祖先；自然选择在进化中扮演了重要角色；并不存在“智能”引导了生物的进化或设计。\n第6章 遗传学概要 介绍的比较简单，只是高中生物的水平。\n第7章 度量复杂性 度量一个事物或过程的复杂性的三个维度：\n描述它有多困难？\n产生它有多困难？\n其组织程度如何？\n劳埃德列出了40种度量复杂性的方法，这些方法分别是从动力学、热力学、信息论和计算等方面来考虑这三个问题。下面是一些比较常见的方法。\n 用大小度量复杂性 用熵度量复杂性 用算法信息量度量复杂性 用逻辑深度度量复杂性 用热力学深度度量复杂性 用计算能力度量复杂性 统计复杂性 用分形维度量复杂性 用层次性度量复杂性  第二部分 计算机中和生命和进化 第8章 自我复制的计算机 生命是什么 计算机中的自我复制 自我复制程序的深层意义\n自我复制程序的深层意义是与生命、进化和复杂系统的本质相关。自我复制程序是一种能够复制自身的计算机程序，类似于生物体能够通过生殖产生后代。虽然自我复制程序是在计算机领域中研究的概念，但它们提供了对生命和自我复制系统的理解的有益模型。\n以下是一些关于自我复制程序深层意义的观点：\n  生命的起源和进化：自我复制程序可以被看作是模拟生命起源和进化的一种方式。它们展示了自我复制系统的基本特征和原则，例如遗传信息的传递、变异和选择。通过研究自我复制程序，我们可以更好地理解生命起源的可能机制以及进化过程中的基本原理。\n  复杂系统的自组织性：自我复制程序展示了自组织性的特征。它们能够在没有外部指导的情况下产生新的副本，并且能够适应环境变化。这与复杂系统中的自组织现象相关，例如生物群体的集体行为、城市的发展和经济系统的演化。自我复制程序提供了一种研究复杂系统自组织性的简化模型。\n  人工智能和自主系统：自我复制程序对于人工智能和自主系统的研究也具有重要意义。它们是构建自我学习和自适应系统的基础。通过自我复制，程序可以生成多个副本并进行并行演化，从而提高系统的适应性和智能水平。自我复制程序的研究有助于开发具有自主性和自主决策能力的人工智能系统。\n  总之，自我复制程序的深层意义涉及到生命起源和进化的理解、复杂系统的自组织性研究以及人工智能和自主系统的发展。它们为我们提供了一种探索和理解自我复制系统本质的有益模型。\nDNA的自我复制 冯·诺依曼的自制自动机\n冯·诺依曼的自制自动机（Von Neumann Universal Constructor）是由匈牙利数学家冯·诺依曼于1950年提出的一种理论构想，旨在描述一种能够自我复制和执行任意计算任务的机器。\n冯·诺依曼的自制自动机基于图灵机的概念，但与传统的图灵机不同，它具备了自我复制的能力。该自动机由以下几个核心组件构成：\n  存储器（Memory）：自制自动机包含一个存储器，用于存储程序和数据。存储器可以被访问和修改。\n  控制单元（Control Unit）：控制单元负责执行指令和控制整个自动机的操作。它根据指令集和程序计数器来决定下一步的操作。\n  输入/输出设备（Input/Output Devices）：自制自动机可以与外部世界进行交互，通过输入设备接收输入数据，通过输出设备输出计算结果。\n  自复制机制：自制自动机具备自我复制的能力，即能够生成与自身相似的副本。它可以复制自己的存储器中的程序和数据，并将其保存到新的存储器中。\n  冯·诺依曼的自制自动机是一种理论构想，旨在展示计算机系统的自我复制和通用计算能力。尽管目前还没有完全实现冯·诺依曼的自制自动机，但这个概念对于研究自复制系统、自我复制算法和人工生命等领域具有重要的影响。它揭示了自我复制和通用计算在计算机科学和生命科学中的潜在意义，以及构建自复制系统的理论和实践基础。\n冯·诺依曼\n第9章 遗传算法 这部分内容之前的博客已经写的比较多了。\n","permalink":"https://tassel234.github.io/posts/note/%E5%A4%8D%E6%9D%82%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-1/","summary":"作者：梅拉妮·米歇尔（Melanie Mitchell），波特兰州立大学（Portland State University）计算机科学教授，圣塔菲研究所（Santa Fe Institute）客座教授。师从侯世达（Douglas Hofstadter），即奇书GEB《哥德尔 艾舍尔 巴赫——集异璧之大成","title":"《复杂》读书笔记-1"},{"content":"目前学习极简主义的资源主要定为乔舒亚和瑞安的《极简主义》和《极简关系》，还会依赖一些互联网的资源，后续会在本专题写阅读极简学习法和整体学习法，提高做事的效率，然后再学上一些极简逻辑学和极简葡萄酒（开玩笑）。\n我开始接触极简主义是因为我开始觉得我的生活有些变得怠惰和混乱，从我由日更的博客到两周不更新博客可以看出，我也渐渐开始变得麻木又惶恐，由我的生活，学习所引起，作息不慎规律，表现的失误，老师的看轻，互联网引发的一些焦虑，争吵。\n我需要一些方法论的帮助来改善我的生活，所以我选择了极简主义，同时也在通过一些统计和控制变量提高我对自己的认知。我早年已经接触了和极简主义相关的一些思想，比如断舍离，奥卡姆剃刀原理，节能主义（出自冰菓），还有佛系，佛教或者更广泛一些的宗教。我比较喜欢把极简主义描述为不信神的宗教（其实也可以信），改变自己的行为，摆脱内心的混乱，舍弃生活的杂音，世俗的呢喃，消费主义的陷阱，信仰快乐与幸福，追求对自己真正重要之物的宗教。\n基本描述 极简主义（Minimalism）是一种生活哲学和设计理念，强调简化、精简和去除多余的元素，以达到简洁、清晰和实用的目标。极简主义追求简约、纯粹和功能性，主张摒弃多余的装饰和复杂性，让事物回归本质。\n实现极简主义可以在多个方面展现，包括生活方式、空间设计、物品选择等。以下是一些常见的实现极简主义的方法：\n  精简物品：去除多余、不必要的物品，只保留真正有用和重要的物品。通过减少拥有的物品数量，可以创造简洁、整洁的环境。\n  简化空间：简化室内空间的布局和装饰，避免过多的家具和装饰品。保持空间的整洁和开阔，让环境更加清爽和宁静。\n  减少噪音和视觉干扰：避免过多的噪音和视觉干扰，例如减少电视、电子设备和装饰品的使用，创造一个宁静和平静的环境。\n  简化日常活动：简化日常活动和流程，避免复杂的安排和繁琐的操作。专注于重要的事情，减少无意义的琐事。\n  专注于功能性：追求物品和设计的功能性，注重实用性和效率。选择简单、耐用、高效的物品和工具。\n  清理和整理：定期进行清理和整理，摆脱不需要的东西，保持整洁和有序。保持物品井然有序可以减少混乱和压力。\n  关注质量而非数量：更加注重物品的质量和价值，而非数量的多少。选择高质量的物品，避免浪费和不必要的消费。\n  实现极简主义需要个人的意识和努力，可以根据自己的需求和喜好进行调整和实践。极简主义的核心是追求简洁、纯粹和实用，通过减少多余和冗杂，创造出更加清晰、轻松和有意义的生活方式。\n奥卡姆剃刀定律 奥卡姆剃刀定律（Occam\u0026rsquo;s Razor, Ockham\u0026rsquo;s Razor）又称“奥康的剃刀”，它是由14世纪英格兰的逻辑学家、圣方济各会修士威廉•奥卡姆（William Ockham，约1285年至1349年）提出。这个原理称为“如无必要，勿增实体”，即“简单有效原理”。\n社会影响 公元14世纪，维廉·奥康（William of Ockham）对当时无休无止的关于“共相”“本质”之类的争吵感到厌倦，于是著书立说，宣传只承认确实存在的东西，认为那些空洞无物的普遍性要领都是无用的累赘，应当被无情地“剃除”。\n他所主张的“思维经济原则”，概括起来就是“如无必要，勿增实体。”因为他叫威廉，来自奥卡姆，人们为了纪念他就把这句话称为“奥卡姆剃刀”。\n这把剃刀出鞘后，剃秃了几百年间争论不休的经院哲学和基督神学，使科学、哲学从宗教中彻底分离出来，引发了始于欧洲的文艺复兴和宗教改革，科学革命，最终使宗教世俗化，形成宗教哲学，完成世界性政教分离，成果表明无神论更为现实。同时，这把剃刀曾经使很多人感到威胁，也被认为是异端邪说，威廉本人也受到伤害。然而，这并未损害这把刀的锋利，相反，经过数百年越来越快，并早已超越了本来狭窄的领域而具有广泛的、丰富的、深刻的意义。\n应用领域 实际上奥卡姆剃刀原理不只是应用于管理学，经济学，社会学等，这个原理的思想也是科学的基石之一。\n科学思维 对于科学家，奥卡姆剃刀原理还有一种更为常见的表述形式：当你有两个或多个处于竞争地位的理论能得出同样的结论，那么简单或可证伪的那个更好。这一表述也有一种更为常见的强形式：如果你有两个或多个原理，它们都能解释观测到的事实，那么你应该使用简单或可证伪的那个，直到发现更多的证据。对于现象最简单的解释往往比较复杂的解释更正确。如果你有两个或多个类似的解决方案，选择最简单的。需要最少假设的解释最有可能是正确的（或者以这种自我肯定的形式出现：让事情保持简单！）。注意这个原理是如何在上述形式中被加强的。严格的说，它们应该被称为吝啬定律（Law of parsimony），或者称为朴素原则。最开始的时候我们使用奥卡姆剃刀区分能够做出相似结论的理论。我们试图选择做出不同结论的理论。这不是奥卡 姆剃刀的本意。我们不用检验这些结论吗？显然最终不是这样，除非我们处于理论的早期阶段，并且还没有为实验做好准备。我们只是为理论的发展寻求一种指导。\n这个原理最早至少能追溯到亚里士多德的“自然界选择最短的道路”。亚里士多德在相信实验和观测并无必要上走得太远。朴素原理是一个启发式的经验规则，有些人引用它，仿佛它是一条物理学公理。它不是。它在哲学和粒子物理中使用的很好，在宇宙学和心理学中就不是特别好，这些领域中的事务往往比你想象的还要复杂。或许引用莎士比亚的一句话要胜过引用奥卡姆剃刀：“天地之大, 赫瑞修,比你所能梦想到的多出更多”。\n许多科学家接受或者（独立的）提出了奥卡姆剃刀原理，例如莱布尼兹的“不可观测事物的同一性原理”和牛顿提出的一个原则：如果某一原因既真又足以解释自然事物的特性，则我们不应当接受比这更多的原因。奥卡姆剃刀以结果为导向，始终追寻高效简洁的方法，600多年来，这一原理在科学上得到了广泛的应用，从牛顿的万有引力到爱因斯坦的相对论，奥卡姆剃刀已经成为重要的科学思维理念。\n企业管理和策略投资 奥卡姆剃刀不断在哲学、科学等领域得到应用，使它进一步发扬光大，并广为世人所知的，则是在近代的企业管理学中。好的理论应当是简单、清晰、重点突出，企业管理理论亦不例外。在管理企业制定决策时，应该尽量把复杂的事情简单化，剔除干扰，抓住主要矛盾，解决最根本的问题，才能让企业保持正确的方向。对于现代企业而言，信息爆炸式的增长，使得主导企业发展的因素盘根错节，做到化复杂为简单就更加不易。企业管理是系统工程，包括基础管理、组织管理、营销管理、技术管理、生产管理、企业战略，奥卡姆剃刀所倡导的简单化管理，并不是把众多相关因素粗暴地剔除，而是要穿过复杂，才能走向简单。通过奥卡姆剃刀将企业最关键的脉络明晰化、简单化，加强核心竞争力。\n投资需要策略，在投资市场，太保守不行，太冒险也不行。投资市场是复杂的，不少投资者整天在忙忙碌碌地分析、研究和频繁操作，投入了大量精力，却依然难以应付市场中庞杂的信息。 面对复杂的投资市场，应拿起奥卡姆剃刀，把复杂事情简单化，简化自己的投资策略，对那些消耗了大量金钱、时间、精力的事情加以区分，然后釆取步骤去摆脱它们。\n生活理念 作为一种思维理念，当然并不仅仅局限于某一些领域，事实上，奥卡姆剃刀在社会各方面已得到越来越多的应用。 奥卡姆剃刀同时也是一种生活理念。这个原理要求我们在处理事情时，要把握事情的本质，解决最根本的问题。尤其要顺应自然，不要把事情人为地复杂化，这样才 能把事情处理好。 爱因斯坦说：“如果你不能改变旧有的思维方式，你也就不能改变自己当前的生活状况。”当你用奥卡姆剃刀改变你的思维时，你的生活将会发生改变。 在运用奥卡姆剃刀时应牢记爱因斯坦的一句著名的格言：万事万物应该都应尽可能简单，但不能更简单。如果将这一理念与中国儒家的《中庸》思想结合起来，那么会使我们的行为更趋于完美。\n","permalink":"https://tassel234.github.io/posts/life/%E6%9E%81%E7%AE%80%E4%B8%BB%E4%B9%89%E7%90%86%E8%AE%BA-1/","summary":"目前学习极简主义的资源主要定为乔舒亚和瑞安的《极简主义》和《极简关系》，还会依赖一些互联网的资源，后续会在本专题写阅读极简学习法和整体学习法，提高做事的效率，然后再学上一些极简逻辑学和极简葡萄酒（开玩笑）。 我开始接触极简主义是因为我开始觉得我的生活有些变得怠惰和混乱，从我由日更的","title":"极简主义理论-1"},{"content":"工业大数据建模理论和案例-1 前言 使用资源：\n智能制造标准案例集(20w)：这本书的内容很全面，广度很大，深度也不小。目前只针对这本书大致了解工业大数据的理论应用。\n工业大数据分析实例（21w）\n工业大数据技术与应用实践（5.5w）\nchatgpt\n概论和方法 随着传感器和物联网技术的发展，对物理过程的感知变得更加实时和密集，系统可以得到实时反馈。将这些数据有效应用到实际控制过程中，从而进一步提高设计水平、控制水平、系统可靠性和运行效率，是近期物理信息系统(Cyber-PhysicalSystem，CPS)、数字季生 (Digital Twin)等提法的基本出发点。基于这些海量数据的数据分析是工业企业数字化转型的关键技术。\n美国企业在大数据科技发展方面的关键驱动因素: 分析运营和交易数据的能力;洞察用户的线上消费行为，以向市场提供新的定制化产品;对组织中的机器和设备进行更加深入的感知等。德国于2015年4月提出“工业4.0”战略，重点强调了信息互联网技术与工业制造技术的融合。\n现代科技进步的意义，是让人的生活变得更好，技术应该服务于人。过去我们在面对灾害只能采取大量的人力和极其少量的物力，现在我们可以使用生命勘探设备，大型器械，未来还可能使用机器人抢险救灾。地震中伤害人的不是晃动，而是建筑，从这一点上看建筑科学（土木工程），材料科学还有很长的路要走。\n工业大数据的 特点：\n 工业大数据具有多样、多模态、高通量和强关联等特性 工业数据资源并不丰富 工业数据有丰富的上下文信息（Context） 工业大数据的人才体系是二分的  一些解释：\n多数工业系统被设计为具有高可靠性且严格受控的系统，绝大多数时间都在稳定运行，异常工况相对稀缺(对于数据分析来说具有“高价值”)，有标记的异常样本更是难得。全维数据集的有效关联往往很难实现，在时间或空间序列上也常常存在数据缺失，导致当前获取的数据不能完整勾画真实的物理过程。\n工业是一个强机理、高知识密度的技术领域，工业大数据分析通常会隐性或显性地利用大量行业知识(包括而不限于问题定义、数据筛选、特征加工、模型调优等环节 )。工业系统涉及物理域 ( Physical，物理世界的运行规律)、业务域 ( Business，业务经营与管理 ) 和数字域( Cyber，信息领域的刻画)。\n工业大数据的价值变现通常需要将统计学习模型和机理模型融合，而这两个模型属于不同技术门类，数据分析师对工业过程缺乏深入了解，而业界人员对数据分析的了解相对缺乏。\n除了数据驱动的机器学习工程方法，还有专家规则开发的工程方法，这种工程方法将隐性研判逻辑显性化、形式化、定量化，形成切实可行的经验模型，加快知识的传播与传递，整体拉平大家的认识水平(并让知识变得可积累、易传承)。将烦琐、频发但明确的逻辑自动化，能够将部分业务人员从低价值劳动中解放出来。\n所需各专业知识 应用工业大数据需要多个专业领域的知识和技能。以下是一些关键的专业知识领域，对于应用工业大数据具有重要意义：\n（1） 计算机科学：\n 数据科学与分析：数据科学和分析是应用工业大数据的核心领域。这包括数据采集、数据清洗、数据建模、数据挖掘、统计分析和机器学习等技术。数据科学家需要掌握统计学、数据建模、算法和编程等方面的知识。 信息技术与数据管理：信息技术和数据管理是支撑工业大数据应用的关键领域。这包括数据库管理、数据存储和处理、数据安全和隐私保护、云计算和分布式计算等技术。对于大数据平台和工具的了解和应用能力是必要的。 信息安全能力，工业大数据蕴含工业生产的详细情况及运行规律，承载了市场用户、供应链等重要信息，是工业企业的核心机密，也是工业互联网的核心要素。可以设计和实施安全措施，如数据加密、身份验证和访问控制，以确保工业大数据的机密性和完整性。此外伊朗核设施被黑客攻击遭受重大安全事故的事件也值得我们警醒。 数据可视化与用户界面：可以设计和开发数据可视化和用户界面，使工业大数据更加易于理解和使用。  管理科学：\n工业工程和运营研究领域涉及到工业生产和运营过程的优化和改进。应用工业大数据需要对生产过程、供应链管理、质量控制、设备维护和运营决策等方面有深入的了解。\n  数据驱动的决策：管理专业可以利用工业大数据来支持决策制定过程。通过收集和分析大量的业务数据和市场数据，管理专业可以获取洞察力，了解市场趋势、客户需求、竞争情况等。这些数据可以帮助管理专业做出更准确、更有根据的决策，提高业务绩效和竞争力。\n  供应链管理与优化：管理专业可以利用工业大数据来管理和优化供应链。通过监控和分析供应链中的数据，如库存水平、交货时间、运输成本等，管理专业可以实时跟踪供应链的运作情况，并进行需求预测和库存优化。工业大数据还可以帮助管理专业优化供应商选择、物流规划和供应链协同，提高供应链的效率和灵活性。\n  风险管理与预测：管理专业可以利用工业大数据来进行风险管理和预测。通过收集和分析市场数据、供应链数据、产品质量数据等，管理专业可以识别和评估潜在的风险因素，并制定相应的风险管理策略和措施。工业大数据还可以帮助管理专业进行风险模型的建立和预测，提高企业对未来风险的应对能力。\n  绩效管理与业绩评估。\n  客户关系管理。\n  （2） 领域知识与工业经验也很重要。工业大数据的人才体系是二分的，工业大数据的价值变现通常需要将统计学习模型和机理模型融合，而这两个模型属于不同技术门类，数据分析师对工业过程缺乏深入了解，而业界人员对数据分析的了解相对缺乏。\n理解特定行业或领域的知识和经验对于应用工业大数据至关重要。不同行业有不同的数据特征和业务需求，因此需要具备相关行业知识，如制造业、材料，能源、交通等。\n电子信息专业：\n  传感器技术与数据采集：电子信息专业可以设计和开发各种传感器技术，用于采集工业设备和系统的数据。他们可以选择合适的传感器类型、接口和通信协议，确保高效、准确地采集工业大数据。\n  通信与网络技术：电子信息专业可以负责建立数据通信和网络基础设施，实现工业大数据的传输和交换。他们可以设计和配置网络架构、选择合适的通信协议和设备，确保数据在企业内部和外部的安全和高效传输。\n  智能制造与优化：电子信息专业可以利用工业大数据技术，实现智能制造和优化。通过分析工业设备和生产过程的数据，他们可以优化生产调度、改进生产效率、减少能源消耗和优化产品质量，从而提高企业的竞争力。\n  物联网与智能化系统：电子信息专业可以结合物联网技术，构建智能化的工业系统。他们可以将传感器、设备和系统进行联网，实现实时数据采集、远程监控和控制，并利用工业大数据进行智能决策和优化。\n  机械：\n  故障诊断与预测维护：通过采集和分析机器设备的传感器数据，可以实时监测设备状态，并进行故障诊断和预测维护。机械专业可以利用工业大数据技术来分析设备的振动、温度、压力等数据，检测设备的异常行为，并预测设备故障和维护需求，以提高设备的可靠性和降低维护成本。\n  资产管理与优化：通过工业大数据技术，机械专业可以对工厂或企业的机械设备进行全面的资产管理与优化。通过采集设备的运行数据和性能参数，结合大数据分析和机器学习算法，可以实现设备的运行状态监测、设备寿命预测、设备利用率优化等功能，从而提高设备的利用效率和生命周期管理。\n  生产过程优化：机械专业可以利用工业大数据技术对生产过程进行优化。通过采集和分析生产线上的数据，如生产速度、质量参数、工艺参数等，可以识别生产过程中的瓶颈和优化空间，并提出改进措施，以提高生产效率、降低生产成本和改善产品质量。\n  产品设计，改进和创新：通过采集和分析产品的性能数据和用户反馈数据，机械专业可以用工业大数据技术来改进产品设计和优化产品性能。通过分析产品在实际使用中的数据，可以了解产品的使用情况和问题，并提供数据支持的决策，以改进产品设计、提高产品质量和用户满意度。可以通过对异常数据的分析进行产品的创新设计。\n  材料专业：\n  材料性能预测与优化：通过采集和分析大量材料测试数据和性能参数，材料专业可以利用工业大数据技术来预测材料的性能。通过建立材料性能模型和应用机器学习算法，他们可以优化材料配方、改进材料工艺，并预测材料性能在不同环境和应力条件下的表现。\n  材料设计与开发：材料专业可以利用工业大数据技术来辅助材料的设计和开发。通过分析历史材料数据、文献资料和仿真模拟结果，他们可以识别材料的优势和局限性，并提出新的材料设计思路。工业大数据还可以提供有关材料合成、加工和性能的宝贵信息，加快新材料的研发和商业化进程。\n  品质控制与过程优化：材料专业可以利用工业大数据技术来进行品质控制和过程优化。通过采集和分析材料生产过程中的数据，如温度、压力、湿度等参数，他们可以识别生产过程中的变异和异常，改善生产过程的稳定性和一致性，提高产品质量和生产效率。\n  材料寿命评估与维护规划：材料专业可以利用工业大数据来评估材料的寿命和性能退化情况。通过监测和分析材料在实际使用中的数据，如应力、应变、腐蚀速率等，他们可以预测材料的寿命和损伤机制，并制定相应的维护规划和修复措施，提高材料的可靠性和使用寿命。\n  材料循环利用与可持续性：材料专业可以利用工业大数据来推动材料的循环利用和可持续性发展。通过分析材料的生命周期数据，他们可以识别材料的再利用和回收潜力，降低资源消耗和环境影响。工业大数据还可以提供关于材料供应链和材料可持续性的信息，帮助企业制定可持续发展战略和决策。\n  纺织专业：\n  生产过程控制与优化：纺织专业可以利用工业大数据来控制和优化生产过程。通过采集和分析生产过程中的数据，如温度、湿度、压力等参数，纺织专业可以实时监测和调整生产过程，提高产品的一致性和质量。工业大数据还可以帮助纺织企业进行生产能力规划、生产调度和资源优化，提高生产效率和降低成本。\n  质量控制与产品检测：纺织专业可以利用工业大数据来进行质量控制和产品检测。通过采集和分析产品质量的相关数据，如纱线强度、织物密度、颜色一致性等，纺织专业可以及时发现和纠正产品质量问题，提高产品合格率和客户满意度。工业大数据还可以帮助纺织企业建立质量预测模型和质量分析系统，实现质量管理的智能化和预测性。\n  环境：\n能源管理与优化：机械设备在工业生产中消耗大量能源。通过工业大数据的采集和分析，可以对能源使用情况进行监测和优化。通过分析能源消耗模式和设备的能效指标，可以识别能源浪费和优化的潜力，并提出相应的改进措施，以降低能源成本和环境影响。\n工业大数据应用模型 PHM 工业大数据PHM（Predictive Maintenance and Health Management）是一种利用大数据和分析技术对工业设备和系统进行预测性维护和健康管理的方法。PHM可以提高设备的可用性、可靠性和安全性，降低维护成本，从而提高生产效率和盈利能力。\n工业大数据PHM主要包括以下几个步骤：\n  数据采集：从工业设备和系统中收集各种数据，包括传感器数据、控制系统数据、维护记录等。\n  数据预处理：对收集到的数据进行清洗、标准化和归一化等处理，以便于后续分析。\n  特征提取：从预处理后的数据中提取关键特征，如设备状态、运行参数、故障模式等。\n  模型建立：利用机器学习、深度学习等方法建立预测模型，如残差神经网络、支持向量机、随机森林等。\n  模型验证：使用历史数据对建立的预测模型进行验证，以确保模型的准确性和可靠性。\n  模型部署：将验证通过的预测模型部署到工业设备和系统中，用于实时监控设备和系统状态，预测潜在故障，并采取相应措施预防和排除故障。\n  持续优化：根据实际运行效果和反馈，不断调整和优化预测模型，以提高其预测准确性和适用性。\n  PQM 工业大数据PQM（Predictive Quality Management）是一种利用大数据和分析技术进行产品质量管理的方法。PQM可以帮助制造商提高产品质量、降低废品率和成本，从而提高生产效率和客户满意度。\n工业大数据PQM主要包括以下几个步骤：\n  数据采集：从生产过程中收集各种数据，包括原材料质量、生产工艺参数、设备状态、产品检测结果等。\n  数据预处理：对收集到的数据进行清洗、标准化和归一化等处理，以便于后续分析。\n  特征提取：从预处理后的数据中提取关键特征，如产品质量指标、生产工艺参数、设备状态等。\n  模型建立：利用机器学习、深度学习等方法建立预测模型，如回归模型、支持向量机、随机森林等。\n  模型验证：使用历史数据对建立的预测模型进行验证，以确保模型的准确性和可靠性。\n  模型部署：将验证通过的预测模型部署到生产过程中，用于实时监控产品质量，预测潜在质量问题，并采取相应措施预防和纠正质量问题。\n  持续优化：根据实际运行效果和反馈，不断调整和优化预测模型，以提高其预测准确性和适用性。\n  通过实施工业大数据PQM，制造商可以更好地了解生产过程中影响产品质量的因素，从而采取有效措施改善产品质量，提高生产效率和客户满意度。\nPEM 工业大数据PEM（Predictive Energy Management）是一种利用大数据和分析技术进行能源管理的方法。PEM可以帮助工业企业提高能源利用效率、降低能源成本、减少碳排放，实现可持续发展。\n工业大数据PEM主要包括以下几个步骤：\n  数据采集：从各种能源消耗设备和系统中收集能耗数据、设备状态数据、环境数据等。\n  数据预处理：对收集到的数据进行清洗、标准化和归一化等处理，以便于后续分析。\n  特征提取：从预处理后的数据中提取关键特征，如能耗数据、设备状态、环境条件等。\n  模型建立：利用机器学习、深度学习等方法建立预测模型，如回归模型、支持向量机、随机森林等。\n  模型验证：使用历史数据对建立的预测模型进行验证，以确保模型的准确性和可靠性。\n  模型部署：将验证通过的预测模型部署到能源管理系统中，用于实时监控能源消耗，预测能源需求，并采取相应措施优化能源管理。\n  持续优化：根据实际运行效果和反馈，不断调整和优化预测模型，以提高其预测准确性和适用性。\n  通过实施工业大数据PEM，企业可以更好地了解能源消耗模式和趋势，从而制定更加高效和可持续的能源管理策略，降低能源成本，减少碳排放，提高能源利用效率。\n","permalink":"https://tassel234.github.io/posts/note/%E5%B7%A5%E4%B8%9A%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1%E7%90%86%E8%AE%BA%E5%92%8C%E6%A1%88%E4%BE%8B-4/","summary":"工业大数据建模理论和案例-1 前言 使用资源： 智能制造标准案例集(20w)：这本书的内容很全面，广度很大，深度也不小。目前只针对这本书大致了解工业大数据的理论应用。 工业大数据分析实例（21w） 工业大数据技术与应用实践（5.5w） chatgpt 概论和方法 随着传感器和物联网技术的发展，对物理过程的感","title":"工业大数据建模理论和案例-4"},{"content":"我知道命如蜉蝣，死亡如影随形。但我依旧祈祷， 哪怕只是再多一年再多一天，再多一时我们也想要活下去。 你以后也会喜欢上别人，也会遇到许多很喜欢你的人。 虽然你现在可能觉得一片黑暗，但早晨总是会来临。 你会在阳光之下长大成人未来一定会是这样的，因为那已经是注定好的事了。 铃芽之旅讲了铃芽的 人生之旅，铃芽小时候经历了由地震引发的海啸,家乡被毁，母亲失踪，哭泣的铃芽于风雪中误入了一片梦幻 的草原，见到了长大后的自己，小铃芽哭泣着不愿意承认母亲的离去，大铃芽说不管你曾经多么伤心，多么心碎，最终都一定会更坚强的活下去，遇见很多喜欢自己的人和自己爱的人，长大成人，未来并不可怕，灾难后的人们会在阳光下长大成人。 那个椅子虽然残破，确是足以抚慰人心的存在。而即使是残破 的椅子，和心理创伤过的人，也可能会成为别人的重要之物。\n小铃芽带着椅子回 到了冰天骂的世界中，打开门时残酷的现实 和幻境中的美好对比，那个故事那个美好的地方并没有消失，而是在小玲芽的心中支持着她走过难熬的时光和现实。\n走出门的小玲芽抱着椅子谁在冰天雪地中，环阿姨赶了过来抱住你玲芽，说，从今往后我们就一起生活了。\n环阿姨为了照顾玲芽付出了很多，牺牲了自己的很多幸福，为了照顾玲芽的感受，不请人到家里，没有结婚，因为没有人会要一个带着孩子的女人，“把我的人生还给我”，环阿姨在和玲芽的争吵中这样说。许多父母都曾有过“如果没有这孩子，我可能可以做这个做那个”的想法。铃芽的姑姑因为姐姐在地震中去世，不得不抚养铃芽长大，也曾经有过这样黑暗的想法。那份困难和不美好确实存在，但环阿姨和玲芽相处的那些美好的过往也是存在的。自然灾害，地震海啸是无情的，如果人们无法牵着彼此的手，共同的去面对，彼此去慰藉对方的心灵，那这个世界可真的会很糟糕。\n地震中伤害人的不是晃动，而是建筑，从这一点上看建筑科学（土木工程），材料科学还有很长的路要走。现代科技进步的意义，是让人的生活变得更好，技术应该服务于人。科学技术的出现，不只是作为国家之间进行国力竞争的武器，还是让我们人类可以对抗这疯狂混乱残酷世界的最强的力量，过去我们在面对灾害只能采取大量的人力和极其少量的物力，现在我们可以使用生命勘探设备，大型器械，未来还可能使用机器人抢险救灾。在古代的欧洲、亚洲、非洲和美洲的各种医疗实践当中，唯一的共同点就是至少有 1/3 的儿童无法活到成年，人们的平均预期寿命也远低于 50 岁。现在核磁共振技术和抗生素药品的出现，都代表了人类科学的成就。也是我们不能放弃科技发展的原因。\n","permalink":"https://tassel234.github.io/posts/read/%E9%93%83%E8%8A%BD%E4%B9%8B%E6%97%85%E8%A7%82%E5%90%8E%E6%84%9F/","summary":"我知道命如蜉蝣，死亡如影随形。但我依旧祈祷， 哪怕只是再多一年再多一天，再多一时我们也想要活下去。 你以后也会喜欢上别人，也会遇到许多很喜欢你的人。 虽然你现在可能觉得一片黑暗，但早晨总是会来临。 你会在阳光之下长大成人未来一定会是这样的，因为那已经是注定好的事了。 铃芽之旅讲了铃芽的 人生","title":"《铃芽之旅》观后感"},{"content":"第二部分 政治挑战 信息技术和生物技术的融合，会对自由和平等这两种现代核心价值观造成威胁。想要解决这项科技挑战，必然需要全球合作。然而，民族主义、宗教和文化让人类分裂为彼此敌对的阵营，于是全球合作难于登天。\n第5章 社群：人类身体的价值 人类一旦与身体、感官和真实环境越来越疏离，很可能就会感觉孤单、迷失方向。很多权威评论人士把这种疏离感归咎于宗教和国家的凝聚力式微，但或许和你的身体失去联系才是更重要的原因。曾有几百万年的时间，人类没有宗教，也没有国家，但还是过得开开心心。\n扎克伯格有一点说得对:只是把众人联系起来让他们聆听不同意见，还不足以解决社会分歧，因为“相反论点的文章实际上会让人觉得其他观点非我族类，反而会强化两极分化。因此扎克伯格认为，“改善对话的最佳方式，可能就是要认识对方整个人，而不是只知道对方的意见。对此，脸谱网义不容辞。\n剑桥分析丑闻中，8700万Facebook用户数据被不当泄露给政治咨询公司剑桥分析，用于在2016年总统大选时支持前美国总统特朗普。美国联邦贸易委员会认为，Facebook没能保障这些用户数据的安全，违反了平台此前承诺保护用户隐私的协议。随后，美国联邦贸易委员会对Facebook开展调查，关注Facebook当时是否能够做更多事情来阻止剑桥分析事件发生。\n150人邓巴数。\n强化社会组织，让人类更加团结。\n第6章 文明：世界的大同 西方想把民主、人权引进伊斯兰国家，于是引发伊斯兰世界的激烈反抗。而一波穆斯林移民潮加上伊斯兰恐怖袭击，则让欧洲选民放弃多元文化的梦想，转而支持排外的地方认同。\n文明冲突论\n人类一向就分成不同的文明，不同文明的成员会有不同的世界观，无法兼容。有了这些不兼容的世界观，文明之间的冲突也就不可避免。就像在自然界，不同物种依照自然选择的无情法则，为生存而战，所以纵观历史，文明之间一再发生冲突，唯有适者能够幸存讲述故事。如果有人忽略这个残酷的事实(不论是自由主义的政治人物还是不食人间烟火的工程师 )，就得付出代价。\n文明冲突论的政治影响十分深远。支持者认为，试着调和西方与伊斯兰世界，注定会失败。伊斯兰国家永远不会采用西方的价值观，而西方国家也永远无法成功吸纳这些穆斯林移民。根据这种想法，美国就不该接收来自叙利亚或伊拉克的移民，欧盟则应该放弃多元文化的谬论堂堂正正展示自己的西方认同。\n2011 年，总部位于纽约布鲁克林的犹太极端正统派刊物《日志》爆出丑闻。《日志》刊出了一张美国总统偕高层观看美军突袭本·拉登的照片，却用修图软件把所有女性抹去，其中包括国务卿希拉里。该报解释，根据犹太教的“庄重法则”，不得不这么做。类似的另一则丑闻，则是在《查理周刊》遭遇恐怖袭击之后，多国领导人在巴黎参加了一场反恐大游行，但以色列《预兆报》(HaMevaser)所刊出的照片也用修图软件抹去了德国总理默克尔，希望避免她的影像让虔诚的读者心中生起任何淫念。另一家极端正统派报纸《通信报》的发行人也声援这种做法，解释这种做法的背后是“数千年的犹太传统”。\n扭曲古代传统的情况，其实所有宗教皆然。“伊斯兰国”夸口自己要回归纯正的伊斯兰教，但事实上是对伊斯兰教提出自己全新的诠释。没错，“伊斯兰国”会引用许多古老的文本，但在选择要引用哪些、忽略哪些，又要怎么诠释的时候，却有很大的自由裁量权。事实上，仅是他们要教徒“自己解经”的态度，就非常现代。传统上，只有学识丰富的阿匐才有权解经。阿匐都是学者，也必须先在如开罗的爱资哈尔清真寺等知名机构研读伊斯兰律法及神学。然而，“伊斯兰国”的领导人很少拥有这样的资格，目前最受尊敬的阿匐也严压“伊斯兰国”首领巴格达迪 等人只是无知的罪犯。\n有些人会说“伊斯兰国”已经“非伊斯兰”甚至“敌伊斯兰”，但事实并非如此。有一点格外讽刺，我们看到居然是像奥巴马这样信仰基督教的领导人站了出来，想要教教像巴格达迪这样自称为“穆斯林”的人，到底什么是穆斯林。\u0026lsquo;各方激烈争论伊斯兰文明的本质是什么，但这根本毫无意义伊斯兰文明没有一定的 DNA，只要是穆斯林创造的，就是伊斯兰文明。\n战争创造的人类连接就无比强大。在传播思想、科技和人员流动方面，战争的效率比商业高多了。\n确实有许多游击队和恐怖组织成功建立了新的国家或征服了现存的国家，但它们之所以能成功，仍然是因为它们遵守着全球政治秩序的基本原则。就连塔利班也希望得到国际认可，承认它们是阿富汗主权国家的合法政权。\n等到观看 2020 年东京奥运会的时候，请记住，虽然这看似是国与国之间的竞争，但实际上是世界各国达成了极为了不起的协议。每当有代表团获得金牌、看着国旗升起而深感民族自豪的时候，别忘了我们更有理由为全人类有能力组织这样一场盛会而深感荣耀\n“伊斯兰国”占领叙利亚和伊拉克的大片国土后，杀害了数万人，炸毁了历史遗迹，推倒了雕像，有系统地毁掉了过往政权和西方文化影响的符号象征。13 但当“伊斯兰国”的士兵走进当地银行，看到美元上有美国总统的肖像、用英文写着赞颂美国政治与宗教理想的语句时，却不会烧毁美国的这一象征。因为美元超越了政治和宗教分歧，得到了世界的广泛认可。\n不管是中国的郎中、西伯利亚的萨满巫医、非洲巫医还是美洲印第安巫医，每个帝国、王国和部落都有自己的传统和专家各自对人体和疾病的本质持有不同的观点，也都各自有着全套的仪式药剂和疗法。其中有些疗效惊人，但也有些几乎一出手就等于必死无疑。在欧洲、亚洲、非洲和美洲的各种医疗实践当中，唯一的共同点就是至少有 1/3 的儿童无法活到成年，人们的平均预期寿命也远低于 50 岁。\n第7章 民族主义：无法解决全球性问题 美国、俄罗斯和许多其他群体却走向孤立?\n民族主义并不是人类心理自然而永恒的一部分，也并非根植于人类生物学。人类很容易对小型、亲密的群体 (如小部落、步兵连、家族企业 )产生忠诚感，但要让人类对几百万个陌生人产生忠诚感是不自然的。这样大规模的忠诚在近几千年才出现(从进化论的角度看，几乎就是昨天早上的事 )，而且需要社会建设的巨大努力。对模糊群体的概念的忠诚，相比于蚂蚁，是人类的奇迹。\n没了民族主义，我们更可能面临部落割据、一片混乱。例如，瑞典、德国与瑞士等和平、繁荣及自由的国家的人，都有强烈的民族主义意识。缺少民族主义的国家则包括阿富汗、索马里、刚果，以及大多数失败国家。\n容易出现暴力冲突。几个世纪以来，对民族主义最基本的批评就是民族主义会导致战争。\n虽然民族主义造成前所未有的骇人冲突，但现代国家也建立了大型的医疗、教育和福利制度。有了公立的医疗服务，似乎帕斯尚尔战役和凡尔登战役也值得了。\n原子弹 的用途，而是真正有可能导致我们所有人都死去，全球社群超越了单个国家\n1964古巴导弹危机过去两年，约翰逊向公众高声说道:“这就是可能的代价。我们要创造的世界，是要让上帝所有的孩子都能活下去，还是要让他们落人黑暗? 我们必须彼此相爱，否则就必定死亡。”我们谈到“要爱，不要战争”( make love, not war) （兼爱非攻）这句口号，\n冷战期间，国际政治走向更为全球化的方向，民族主义被打入冷宫。冷战结束后，全球化似乎已经成为无法阻挡的浪潮。当时人们普遍认为人类将完全抛弃民族主义政治，视之为原始的时代废墟，民族主义顶多只能吸引一些发展中国家教育落后的民众。但近年来的事实证明，民族主义就算对欧洲和美国的民众也仍然深具魅力，俄罗斯、印度和中国更是如此。各地民众开始觉得全球资本主义冷酷无情，令人感到孤立无援，再加上担心未来国家健康、教育和福利制度无以为继，于是又投入民族主义的怀抱来寻求安慰和意义。\n事实上，人类成功地处理了这场核桃战美国、苏联、欧洲和中国改变了行之千年的地缘政治，让冷战在几平没有流血的情况下结束，建立了新的国际主义世界秩序，人类进入前所未有的和平时代\n核挑战，美、俄近来又展开了新的核军备竞赛.开发新型的世界末日武器，可能会让过去几十年得之不易的成果一笔勾销，把我们重新带到核毁灭的边缘。18年此书\n生态挑战\n复杂的农业，城市，社会出现在在1万年以内。\n我们生活在全新世的地质年龄，也生活在小小的1万年里面。生态的改变可能是悲剧的开始。\n上海，东京，香港被淹没\n“人造肉”(clean meat)应该大有可为。目前，肉类产业不仅给数十亿动物造成无尽的苦难，同时也是全球变暖的主要原因;肉类产业大量使用抗生素和有毒物质，是污染空气、土地和水资源的一个元凶。根据英国机械工程师协会(Institution of Mechanical Engineers )2013 年的报告，每生产1千克牛肉需要 15000 升淡水，而生产1千克马铃薯只需要 287 升淡水。经过4年的研发，价格已经降至单价 11美元。再过10年，工业生产的人造肉预计会比屠宰肉更便宜。这项技术有可能拯救数十亿动物的生命，养活数十亿营养不良的人口，同时还有助于避免生态崩溃。\n尽管中国、日本和基里巴斯等国都希望尽快减少全球碳排放但俄罗斯和伊朗等国的积极程度可能低得多。就算像美国这种已经开始因为全球变暖而蒙受巨大损失的国家，也可能因为民族主义者目光短浅自私自利，而不能看清风险。2018 年1月，就有一个足以由小见大的例子，美国对外国制造的太阳能板和太阳能设备征收高达 30% 的关税，宁可拖延转换再生能源的时间，也要保护美国的太阳能设备生产者。\n科技挑战，吐血的马拉松\n就算美国这样的超级大国也不能单独限制科技发展。即便美国政府禁止对人类胚胎进行基因改造，中国科学家也不会受到任何影响,而且，如果相关研发让中国取得了重要的经济或军事优势，美国就很有可能撤销禁令。在这样一个充满无情竞争的世界，落后的代价谁都承受不起，所以只要有一个国家选择走上高风险、高回报的科技之路，其他国家就会被迫跟进。为了避免这样的向下竞争，人类需要某种全球性的认同和忠诚。\n核战争和气候变化威胁的只是人类的生存，但破坏性创新的科技却可能改变人类的本质，从而与人类最深层的伦理道德和宗教信仰产生纠缠。\n第二次世界大战，把谨慎和经济的考虑完全抛弃，投入巨大的资源，科技一飞冲天。同样，面临气候灾难的国家有可能孤注一掷，不顾一切来一场科技豪赌。出于理性，人类对人工智能和生物工程会有诸多疑虑，然而一旦面临危机，人类就会愿意冒险。不论你现在觉得应该如何管制颠覆性科技，请自问，如果气候变化已经造成全球粮食短缺、城市被洪水吞没、数亿难民流离失所跨越国界，你能否坚持这些管制措施?\n奥本海默，原子弹和大气层。上帝可以在下一次原子弹爆炸毁灭所有人。\n民族创建国家，能完全抛弃民族，只见过苏联\n第8章 宗教：神祇只是为国家服务 科学成为世界的蒙板，可以使用圣经捍卫自己的立场，但真正的分歧在于科学理论和政治运动。\n技术问题\n各种神圣历法会告诉你什么时候该播种，什么时候要收获。另外配合寺庙仪式，祈求风调雨顺、害虫不兴。如果发生干旱或蝗虫肆虐农业灾害，农民就会请祭司或牧师等神职人员来和众神交涉。此外，学也属于宗教的领域。几乎所有的先知、大师和萨满巫师都兼任医生，耶稣也花了不少时间为患者治病，\n如果某位虔诚的印度教徒的孩子患上了严重的麻疹，这位父亲会向医神县梵陀利祈祷，也会在当地的寺庙供上鲜花和甜点;但首先，他得先把孩子送到最近的医院，交给那里的医生医治。即便精神疾病这个宗教治疗师的最后据点，也正逐渐转移到科学家手中。原本的恶魔学改成了神经学，驱魔术改成了百忧解。\n传统宗教之所以输掉这么多地盘，老实说就是因为它在农业或医疗保健上的表现实在不好。\n正是因为宗教人士太注重诠释，一旦面对科学，就会处于劣势。虽然科学家也会投机取巧和扭曲证据，但说到底，科学的真正意义还是在于愿意承认失败、尝试不同的方法。\n政策问题 确实，在以色列或伊朗这样的国家，拉比和阿亚图拉（伊朗伊斯兰什叶派领袖的称号)确实能直接影响政府的经济政策。即在美国和巴西等比较世俗的国家，宗教领袖也会针对税收、环境法规问题，影响公众舆论。 当决定要提高利率降低税负、将国营企业民营化或签署国际关税协议时，哈梅内伊再运用其宗教知识和权威，把科学包装进这段或那段经文里。但不管怎么包装意义并不大。只要比较一下就会发现，不管是什叶派的伊朗、逊尼派的沙特阿拉伯、犹太教的以色列、印度教的印度、基督教的美国，经济政策都大同小异。\n在 19 世纪和 20 世纪，伊斯兰教、犹太教、印度教和基督教思想家达伐现代物质主义，反对缺少灵魂的资本主义，也指责官僚制国家大而无当。\n基督教也是如此。基督徒既可能支持社会主义，也可能支持资本主义，而且虽然耶稣说的某些内容与共产主义相似，但在冷战时期，美国的资本主义者还是继续读着“登山宝训”而没有觉得有什么不对。总之,就是没有“基督教经济学”“伊斯兰教经济学”“印度教经济学”这样的东西。\n由于历史上的各种意外，北爱尔兰的上层阶级主要是新教徒，下层阶级则主要是天主教徒。因此，乍看这场冲突似乎是关于基督本质的神学之争，实际上则是典型的贫富斗争。\n身份定义问题 纳粹曾经尝试用科学将人类分为不同的种族和阶级，但已经被证明那只是危险的伪科学在那之后，科学界一直很不愿意再协助找出人类究竟有什么“自然”的身份定义。\n什叶派伊朗、逊尼派的沙特阿拉伯，还是犹太教的以色列，实际上的差异都)大，都是官僚组织的民族国家，多少都奉行资本主义政策，都让儿童按种脊髓灰质炎灭活疫苗，也都靠化学家和物理学家制造炸弹，没有什叫派官僚组织、逊尼派资本主义或犹太教物理学这种玩意儿。\n人类就像一片不断变动的沙地，为了画出彼此明确的界线，宗教用的就是各种仪轨、仪式和典礼。什叶派、逊尼派和正统派犹太教穿着不同的衣服，唱着不同的祷歌，遵守着不同的禁忌。这些不同的宗教传统往往让日常生活充满美，也鼓励人类更加亲切和慈爱。每日 5 次，在集市、办公室和工厂的一片嘈杂声中，宣礼员 (muezzin ) 悠扬跌宕的声音会再次响起，呼唤穆斯林暂时放下世俗追求的喧嚣扰攘，让自己触碰耶结永恒的真理。印度教信徒则靠普迦( puja) 仪式和吟唱真言，达到相同的目标。每周五晚上，犹太教信徒全家人会共进晚餐，享受着特别的欢乐、感恩和团聚。周日早上，则有基督教福音合唱团为数百万人的生活带来希望，希望培养信任和情感，让社群的关系更紧密。\n有些宗教传统给世界带来许多丑陋，让人们表现得既刻薄又残酷举例来说，宗教造成的厌女症或种姓歧视就绝非好事。无论带来的是美丽，还是丑陋，这些宗教传统都是让某些人团结起来并觉得与他人有所不同。在外界看来，宗教传统区分彼此的标准常常只是一些芝麻小事弗洛伊德将人类对区分此类细节的痴迷，戏称为“对微小差异的自我陶醉”。教派，对于那些小的差异愿意杀人甚至被杀。\n1853 年，美国舰队逼迫日本向现代世界敞开大门，日本开始了迅速且极其成功的现代化进程。日本并没有盲目复制西方的蓝图，而是坚决维护其独特的身份认同，希望让现代日本人仍旧忠于日本，而不是忠于科学、现代性或意义模糊的全球社群。只要有助于巩固国家忠诚，佛教、儒学或武士封建习俗元素一律采纳。最重要的一点，国家神道的最高原则就是要崇敬日本天皇，\n这套制度完全发挥了神效。日本现代化发展的速度十分惊人同时也使国民对国家极度忠诚。能够证明国家神道成功的最知名的例子就是日本比其他国家更早地研制出自己的精确制导炸弹，击沉了数十艘盟军舰艇。这比美国的智能炸弹早了几十年，\n第9章 文化认同：开放与宽容 在这样一个全球化的世界里，人人都对全人类有道义责任。如果推卸这些责任，就是只想着自己甚至就是种族主义者。\n许多支持移民主义的人强调，想彻底阻止移民是不可能的事不管砌了多少高墙、修筑了多少隔离栏，绝望的人都能找到办法跨越边界。所以与其把这一切逼到暗处，成为充斥人口贩运、非法劳工和流浪儿，不如摆在明面上。\n瑞典人依靠过往的辛勤工作及无数牺牲才建立繁荣的自由民主政体。如果叙利亚人没有选择这么做，产生的问题可不能强加到瑞典人头上。\n今天，美国的反犹太主义者说，“我们在 1910 年帮了你的曾祖母一个大忙，让她进入这个国家，所以我们现在想怎样对你都行”，这是绝对说不通的\n这个讨论的根本问题，在于个人和整体对于时间长短的感受不同从人类整体的角度来看，40 年并不长。想要期望社会在几十年内完全吸收并接纳某些外来的群体，无异于缘木求鱼。历史上确实有一国文明将外国人同化、视之为平等公民的例子，例如，罗马帝国、伊斯兰哈里发中国和美国，但这些转型都花了几个世纪，而不是短短几十年。\n你拿了一颗澳大利亚尤加利种子，种在了法国。如果不用法国的水去灌溉，它就会枯萎如果把它挖出来，会发现这棵树已经深深扎根于法国的土壤中，和当地的栋树和松树别无二致。\n在 19 世纪90 年代或 20 世纪 30 年代，英国、澳大利亚和美国等国家普遍认为，某些可遗传的生物特质让非洲人和中国人天生就不如欧洲人聪明、奋进有道德。问题出在他们的血液里，无法解决。\n生命科学家(特别是遗传学家 )提出了极有力的科学依据，证明欧洲人、非洲人、中国人和美洲原住民之间的生物学差异小到可以忽略不计。但几乎所有人都会承认文化主义的存在。文化主义的科学基础比种族主义更为稳固，就连人文社会科学领域的学者，都无法否认文化差异的存在和重要性。\n当特朗普总统把海地、萨尔瓦多和非洲某些地区称为“屎洞国家”的时候，显然要大家思考的是这些地方的文化，而不是这些地方人的基因组成。\n人类思考和做事的方式可能有所不同，但我们应该欣赏这种多元性，并认为所有信仰和行为一律平等。不幸的是，这种宽容的态度在现实中行不通。如果面对的是美食、诗歌，那么人类确实能够接受多元化;但如果面对的是烧死女巫、杀死婴儿或奴隶制度，大概很少有人会说这些也是人类迷人的多样性，应该受到保护，不该受到全球资本主义和可口可乐殖民主义的侵扰。\n冷国人在热国就之后，很快就被认为态度冷冰冰、自以为了不起，几乎交不到任何期 内向有。热国人觉得他要么不真诚，要么缺少基本的人际关系技巧。内向和外向\n第三部分 绝望与希望 虽然各式挑战前所未有、各方歧异激烈紧张，但只要我们控制恐惧的程度、虚心面对自己的想法，必能成功应对。\n第10章 恐怖主义：切忌反应过度 1916年索姆河战役，第一天打死1.9万人。\n与索姆河战役相比，恐怖主义简直不足挂齿。2015 年 11 月，巴黎恐怖袭击事件，造成 130余人死亡;2016 年3 月，布鲁塞尔爆炸事件，造成 35 人死亡;2017 年 5 月，曼斯特体育馆爆炸事件，造成 22 人死亡2002 年，巴勒斯坦针对以色列的恐怖活动达到高峰，公交车和餐厅几乎天天遭到炸弹袭击，当年造成451名以色列人死亡;5但在同年，有 542名以色列人死于车祸。°只有少数恐怖袭击造成的死亡人数达上百人，例如，1988 年泛美航空公司 103 航班在苏格兰洛克比上空爆炸，造成数百人死亡。“9·11”恐怖袭击则创下新纪录，造成近 3000 人丧命。”然而,这和传统战争相比，仍然是小巫见大巫。即便把 1945 年以后欧洲所有恐怖袭击事件造成的伤亡人数加总( 包括所有民族主义者、宗教分子、左派和右派团体的受害者 )，这个数字也远远不及第一次世界大战中任何一场不那么出名的战役中的伤亡人数，如第三次埃纳河战役。\n几个伊斯兰教徒在耶路撒冷杀害了几个平民，要求基督教军队离开圣城，非但不会让人觉得恐怖，反而会招来耻笑。\n虽然现在的恐怖主义多半只是做戏，但未来的核恐怖主义网络恐怖主义或生物恐怖主义威胁将更为严重，政府也必须做出更强烈的回应。\n第11章 战争：永远不要低估人类的愚蠢 在 1914 年，战争对全球各地的精英其实是很有吸引力的选项，因为当时有许多具体实例证明，如果能打一场成功的战争，就能促进经济发展，提升政治实力。相较之下，2018 年，成功的战争简直成了濒危物种。\n以色列也是如此。以色列最后一场成功的战争发生在 1967年。在那之后，虽然以色列日益繁荣兴盛，但在这个过程中发生的诸多战争绝非助力，而是负担。多半时候，虽然它扩张了领土，却让自己背上沉重的经济负担、束手束脚的政治责任。以色列的情形很像伊朗，其地缘政治地位的提升，并非通过发动成功的战争，而是通过避免贸然发动战争。于是，虽然在伊拉克、叙利亚和利比亚的战争让以色列过去的敌方元气大伤，但以色列只是保持冷眼旁观。没有卷入叙利亚内战，可以说是以色列总理内塔尼亚胡(Benjamin Netanyahu)最伟大的政治成就(至少到2018 年 3 月为止 )。只要有决心，以色列国防军短短一周就可以夺下大马士革，但这对以色列到底有什么好处? 如果以色列国防军真想占领加沙、推翻哈马斯政权，更是轻而易举，但以色列也一再拒绝这个选项。虽然以色列政客手中的军事实力十分强大，也总会发表鹰派言辞，但他们心知肚明，发动战争几乎无利可图。正像美国、中国、德国、日本、伊朗等国，以色列似乎也了解，到 21 世纪，最成功的策略就是作壁上观，让其他人为自己打仗。\n到目前为止，21 世纪强权成功的唯一例子，就是俄罗斯得到克里米亚。2014 年 2 月，该地并人俄罗斯联邦。\n普京既不是成吉思汗，也不是斯大林。他似乎比谁都知道，军力在 21 世纪的作用有限，而且一场成功的战争必定是一场懂得克制的战争。就算在叙利亚，虽然俄罗斯空袭轰炸毫不留情，但普京一直尽量减少派出地面部队，把近距离交战留给别人，而且避免战火蔓延到邻国。\n事实上，从俄罗斯的观点来看，近年来的种种举动虽然看似侵略但并非打算开启新一轮全球战争，只是想加强自己目前薄弱的防御。俄罗斯大可指出，在 20 世纪 80 年代末和 90 年代初签订和平条约之后，俄罗斯就被视为“战败国”，美国和北约趁俄罗斯国力较弱，便无视承诺,将北约版图扩大到东欧乃至之前苏联的一些加盟共和国。\n我们有理由相信，俄罗斯在克里米亚、格鲁吉亚和乌克兰东部的军事行动应该只是独立事件，而非开启新的战争时代的前兆。\n","permalink":"https://tassel234.github.io/posts/read/%E4%BB%8A%E6%97%A5%E7%AE%80%E5%8F%B2%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-2/","summary":"第二部分 政治挑战 信息技术和生物技术的融合，会对自由和平等这两种现代核心价值观造成威胁。想要解决这项科技挑战，必然需要全球合作。然而，民族主义、宗教和文化让人类分裂为彼此敌对的阵营，于是全球合作难于登天。 第5章 社群：人类身体的价值 人类一旦与身体、感官和真实环境越来越疏离，很可能就会","title":"《今日简史》读书笔记-2"},{"content":"前言 使用资源 今日简史（赫拉利）\n奇点将至\n吟游诗人基德（b站up主）\n引言 虽然比较用心的制作了目录，但是这样的方式写读后感效率确实有点低，我把几乎所以内容都搁置到读后感区域，目录不打算撤回，以后可以看着目录慢慢思考。\n传统的历史书是按照一个时间年表按顺序进行书写，在书写的过程中发表一些评论。但赫拉利的三部简史（人类简史，未来简史，今日简史）是以不同的议题开始，然后广泛的引用历史知识，论证结论。前者的偏向性不小，但后者的偏向性更大，大上约一成左右吧。值得一提的是，中国的二十四史是通过书写人物来反映时代的事件和变迁。\n在阅读今日简史之前应该知道下面这句话：\n认真思考，笑着面对\n世间的坏事和好事都足够占据你大脑的150个槽位，在某些情况下，事实唯一的情况下，事物的好坏与否在于你相信着什么。\n凭借戏谑的观众的心态，凭借找寻乐子的人的心态，或者严肃一点说是即使面对现实的残酷和黑暗依然愿意微笑，如同塔罗牌的小丑一般的心态，对接下来非常重要。\n读后感 该书介绍了一些现在的问题。包括但不限于：\n非伟大高尚意识形态的虚无主义意识形态的崛起，政府控制媒体修改真相，转移矛盾，世界步入后真相时代，人们在网络上被网购商店和互联网巨头窃取的信息和数据，宗教，民族主义，意识形态，文化认同，科学带来的颠覆，以及人类心智的秘密。\n当然上面的内容都有可能是邪恶的犹太人企图分裂我们的意识形态所做出的阴谋，背后是更加邪恶的美国人在暗中操作的结果，好吧，开个玩笑，不要当真。(这段话写在10.6之前)\n关于人工智能没有创造力，至少现在的人们对创造力的来源和底层都知之甚少，关于我们人的很多东西硬解释起来都是玄学，比如灵感，潜意识，执行力等。而巧合的是我们对人工智能的底层也知之甚少。这多巧啊，但这不是接下来要说的东西，我想讨论的是人工智能的创造力：暗知识。\n暗知识，指通过学习的机器已经掌握的但人类还不明白的一些知识。这类知识既不可表达又不可感受但机器能明白。暗知识与过去可以表达的知识（即“明知识”或“显知识”）、不可表达但可以感受的知识（“潜知识”或“默知识”）不同。“暗知识”的出现，使知识维度得到增加，并大大扩充了人类的视野。来自https://baike.baidu.com/item/%E6%9A%97%E7%9F%A5%E8%AF%86/58247201\n谷歌的 AlphaZero 程序击败了 Stockhsh 8 程序。Stockfsh 8 是 2016 年的全球计算机国际象棋冠军，运用的是几百年来累积的人类国际象棋经验，再加上几十年的计算凯象棋经验，每秒计算 7000 万次走法。\nAlphaZero 从零开始学习国际象棋，用了多久才准备好与Stockfish 8 的对局，而且发展出天才般的直觉? 答案是 4小时。你没看错，就是 4小时。千百年来，国际象棋一直被认为是人类智慧的绝顶展现。但 AIphaZero 只花了 4 个小时，完全没有任何人类指导协助，就从无所不知变成创意十足的大师。\n2020年11月30日，DeepMind公司的一个人工智能程序AlphaFold 2 [2] 在蛋白质结构预测大赛CASP 14中，对大部分蛋白质结构的预测与真实结构只差一个原子的宽度，达到了人类利用冷冻电镜等复杂仪器观察预测的水平，这是蛋白质结构预测史无前例的巨大进步。这一重大成果虽然没有引起媒体和广大民众的关注，但生物领域的科学家反应强烈。\nhalicin，是麻省理工学院研究人员使用AI系统发现一种超强抗生素。这项突破性的研究成果于2020年2月20日发表在国际顶尖学术期刊《细胞》杂志上，并登上了当期杂志封面。 halicin是首个由人工智能发现的抗生素 。研究人员为致敬经典科幻片《2001太空漫游》，将该分子命名为“halicin”（电影里的人工智能系统名为HAL 9000）。\nhalicin的化学特征是人类无法理解的，人工智能提取了某些特征，我们无法知道那些特征是什么，因为真相藏在黑盒子中，由一串串的数据构成,而生物学家在探索过的总结过的那些规律无法预知halicin的能力。Alphazero使用4个小时，生成历史上人类棋手从来未曾想过的诡异走法，当然，这些走法可以通向胜利。\n某些意义上，世界就是一片一片的数据和数据构成的，因为我们的大脑就是这麽接受他的。那人工智能理论上也是这麽接受这个世界的，没理由人工智能不能做到和人类相同的发现的事情。事实上，人工智能已经认知到了一些人类没有发现的暗知识，全新的抗生素，人类从来没有想到的围棋方法，这些都发生在人工智能的黑盒中，或许关于意识的真相已经埋在了那些黑盒子里面。\n你认为存在的东西，它在，你认为它不存在，它还在，那它就客观存在。\n在目前的技术水平下，人工智能还不可能具有人的意识。但是，随着科学技术的进步，随着人类对意识的理解和探索，未来是有可能创造出具有人类意识的人工智能。\n马克思主义哲学认为，意识是人脑的机能，是客观存在的主观映像。意识是一种高度组织起来的物质——人脑的机能，它是人对客观世界的反应，是人脑对客观世界的反映。\n意识是人脑对客观世界的反映，而人工智能可以通过对大量数据的学习和处理，逐渐形成类似于人类意识的思维能力。\n一些人认为人工智能永远不可能具有人的意识，因为意识是人脑特有的功能，而人工智能只是机器，它没有生命，没有情感，没有欲望，因而不可能具有人的意识。人工智能的底层和人脑一样就是一个黑箱，深度学习就是炼丹的过程，我们无法理解人脑是怎么通过神经元的协作产生意识，也不能笃言人工智能无法产生意识。\n人工智能是一种通过机器来模拟人类的智能的技术。目前，人工智能已经在一定程度上展现出了类似人类的智能行为，例如学习、理解、推理等。尤其是gtp的产生已经超规格的通过了图灵检验，恶意的人创造的恶意的gpt会成为舆论战的破坏性武器，而我们无法辨别。而如果这样的gtp产生意识可真是糟糕，修改真相，扭曲事实，混淆视听，激化矛盾和对立，但我们不应该说人已经这样了吗。如同克苏鲁神话的奈亚拉托提普一样，乐子人，愚弄众生，挑拨战争（当然这是猜的，造核武器和你今天踩到狗屎都可以说是奈亚干的，奈亚真的什么锅都背）。\n此外，保持敬畏对我们来说还是有好处的。\n人工智能要发展出人类水平的意识能力，还需要在以下几个方面进行突破：首先，需要进一步提高人工智能的感知能力和交互能力，使其能够更好地理解和处理复杂的信息；其次，需要加强人工智能对主观世界的模拟，使其能够具有情感、欲望和自我意识等主观体验；最后，需要推动人工智能技术与脑科学、心理学等学科的交叉融合，以更好地了解人类意识的本质和机制，并为人工智能技术的发展提供指导。\n数学的发展已经非常艰深了，那些数学的分支，枝丫数不胜数，而且大多数是几乎没人可以理解的东西，天才把我们对世界的认知推着往前走，大众的智力却限制了人们无法理解他们。\n某些角度数学确实进展缓慢，但这是全世界最聪明的大脑们被分散到极其琐碎极多分支的进程所付出的代价。而且那些纯数学的内容过于难以理解，而且大多数是还没发现应用价值，少数也是应用到非常高科技的地方，导致人们的认知出现偏颇。\n那么纯数学数学就没有用吗，我们为什么还要研究，因为我们在为我们的后代使用时间的成本进行证明，我们用了300多年证明费马大定理。霍奇猜想与费马大定理和黎曼猜想成为广义相对论和量子力学融合的m理论结构几何拓扑载体和工具，ps霍奇猜想和黎曼猜想都是还没有被证明的千禧年问题。之后会就千禧年七大问题写写博客。M理论是作为“物理的终极理论”而提议的理论，M理论希望能藉由单一个理论来解释所有物质与能源的本质与交互关系。其结合了五种超弦理论和十一维空间的超引力理论。不得不说这个假设简直是数论问题和纯数学问题的春天。电影星际穿越也写到一个万能公式可以帮助人类摆脱毁灭的命运，虽然是电影的艺术成分，但我确实相信万能公式和大统一理论可以办到这些事。\n黎曼曲面在创建之初应该是没什么应用的，黎曼1854年发表《论作为几何学基础的假设》一文，创立了黎曼几何。然后爱因斯坦在1915年应用了它，描述相对论，“物质告诉时空如何弯曲，时空告诉物质如何移动”。\n爱因斯坦对黎曼的贡献赞不绝口：\n物理学家仍然远离这种思维方式：对他们来说，空间仍然是一个刚性的、同质的东西，不受任何变化或条件的影响。只有天才的黎曼，孤独而不被理解，已经在上世纪中叶提出了一种新的空间概念，在这个概念中，空间被剥夺了它的刚性，它参与物理事件的力量被尽可能地认识到。 而且我现在还不知道数论除了密码学到底还有什么用，密码学到底产生于人类勾心斗角的地方，而那近乎完美巧合的数论大厦到底在代表着什么，揭示着什么，又有什么应用。那些巧合有趣又艰深的数学会有什么应用呢。\n第一部分 科技颠覆 近几十年来，全球政治一直是由“自由主义”独霸，但就在生物技术与信息技术结合、形成人类历史上最大挑战的同时，人类也对自由主义失去了信心。\n第1章 理想的幻灭：从旧故事到新故事 这部分的内容同人类简史。\n第2章 就业：等你长大，可能没有工作 卢德分子\n人工智能医生，核磁共振设备，\n机械里面 的莫扎特，对于人们生化算法的理解，统计库 音乐。\n人类之所以喜欢艺术，是因为人们在艺术里看到了自己。\n无人机取代了飞行员，也在维修，远程控制，数据分析和网络安全带来了很多的工作机会。\n19 世纪工业革命兴起之后，当时的社会、经济和政治模式都无法应对相关的新情况和新问题。狄更斯笔下的煤矿童工、第一次世界大战和 1932-1933 年的与克兰大饥荒，都只是人类付出昂贵学费的一小部分。\n人体农场，贩卖器官\n过渡期\n很多的工作就是苦差事，该淘汰。\n现在已经有计算机和算法不再只是生产者，还同时扮演起了客户的角色。例如在证券交易所，算法正成为债券、股票和期货的最重要买家。同样，广告业最重要的客户也是算法:谷歌搜索算法。\n免费的医疗，交通，教育，房子，共产主义的远景\n鉴于人类驾驶员每年造成超过 100 万人因车祸死亡算法要表现得比人类好并不是什么太难的事。\n问他们会不会买一部设定为“牺牲车主、顾全整体利益”的车时，大多数人都说“不”。如果涉及自身，他们还是比较喜欢特斯拉“保护自我”款。\n幸福，快乐\n第3章 自由：数据霸权与社会公平 公投爱因斯坦的代数是否正确\n如果有相关的技术可以操纵人心，那么民主政治只是一个木偶戏\n我们通常不会意识到各种感受是出于运算，原因在于这些快速的运 算远不在我们的意识闽值范围内。我们感觉不到大脑里几百万个神经在怎样运算着生存和繁殖的可能性，于是就有了一种错误的想法，以为我们对蛇的恐惧、对伴侣的选择或对欧盟的看法是出于什么神秘的“自由意志”。\n生物学家正在揭开人体(特别是大脑和人类感受的种种奥秘;另一方面，计算机科学家也让我们获得前所未有的数据处理能力。\n每年都有几百万名年轻人要决定大学读什么专业。这是个既重要又闲难的决定。父母、朋友和师长各有想法，让你深感压力，而且，你还有自己背负的恐惧和想象。你的判断力受到各种好莱坞大片、垃圾小说和高明的广告活动的笼罩和操纵。要做个明智的抉择真的很难，尤其是根本不知道想在不同的行业出人头地，到底需要什么条件。而且，你的清楚自己的长处和短处吗?优秀的律师要具备什么条件?我能面对压力吗?我有团队合作精神吗?\n一个学生之所以去学法律，有可能是因为对自己的能力不够了解甚至可能是因为对律师工作有错误的想象。为了实现童年的梦想？\n一旦人工智能比我们自己更清楚该选择哪个职业，甚至怎样处理人际关系，我们对人性和生命的概念将不得不改变。\n1970年 12月，有一场社科史上相当令人不悦的实验，那是在普林斯顿神学院，实验对象是一群受训要成为长老教会牧师的学生。当时实验人员叫所有学生立刻赶往远处的一个演讲厅，就“好撒玛利亚人(Good Samaritan)这个寓言发表演说。这个寓言讲的是有个犹太人要耶路撒冷前往耶利哥，但遭到强盗抢劫和殴打，被丢在路边等死。过了一会儿，有一个祭司和一个利未人经过并看到了他，但两人都未停下脚步。后来有一个撒玛利亚人(犹太教相当鄙视这个教派 )路过，立刻停下来照顾他，救了他的命。这个寓言告诉我们，人是好是坏，应该由实际行为来判断，而不是由所属宗教来判断。\n这些年轻的神学院学生一心想赶往演讲厅，路上想的都是怎样才能解释好撒玛利亚人的道德寓意。然而，实验人员在路上安排了一个人，穿得破破烂烂地坐在门口，低着头，闭着眼睛。每个没起半点儿疑心的学生经过时，这个“受害者”都会咳嗽并发出痛苦的呻吟声，但绝大多数学生完全没有停下脚步来关心一下他，更别说提供任何帮助了。要赶去演讲厅所造成的情绪压力，已经压过了他们想帮助受难陌生人的道德责任。\n有多少基督徒真能把脸转过去，有多少佛教徒真能超脱利己的执念，又有多少犹太人真能爱邻如己? 我们所表现出的，不过就是自然选择把智人塑造成的样子\n决策\n赫拉利，21岁才意识到自己是同性恋\n很多人之所以害怕人工智能，是因为他们不相信人工智能会一直听话顺从。已经有太多描写机器人反抗人类主人，在大街上四处乱窜、恣意屠杀的科幻小说和电影。然而，机器人可能带来的问题其实恰恰相反我们是该害怕机器人，但原因是它们永远只会服从主人，绝不反抗。\n当然，盲目听从没有什么问题，但前提是主人得是个好人。在战场上，如果交战双方全用杀手机器人上场，就能确保这是历史上第一次真正遵守战争法的战役。人类士兵可能一时受到情绪影响，就犯下谋杀强盗、强奸等违犯战争法的罪行。讲到情绪，我们通常想到的是爱心同情心和同理心，但在战场上，控制着人的情绪的往往是残酷、仇恨和恐惧。由于机器人没有情绪，就能放心地相信它们会一字一句遵守所有军事规章，永远不受个人恐惧和仇恨的影响。\n1968 年 3 月 16 日，一群美国士兵在越南南部的美莱村的行动变调他们陷人疯狂，屠杀了大约 400 名平民。这起战争罪行的起源，是当时-兵已经打了好几个月的丛林游击战，他们自行在当地做了这个决定这个行动没有任何战略目的，同时违犯了美国的法律规定与军事政策这是一场出于人类情绪影响的错误。2 如果美国当时在越南派的是机器杀手，美莱村大屠杀就绝不可能发生。\n如果美国在越战时有机器人杀手，虽然可能不会发生美莱村大屠杀，但越本身却可能要再拖上更多年，因为美国政府不用再烦恼士兵士气低，国内出现大规模反战游行，或者“退役机器人反对战争”活动。(虽然分美国公民仍然可能反对战争，但既然不用担心自己被征召，自己没犯下暴行的记忆，也无须承受失去亲人的痛苦，反战游行的人数大概锐减，反战决心也不会那么坚定。)\n1995 年 7月，前波斯尼亚的塞尔维亚族部队在斯雷布雷尼察镇周围屠杀超过 8000 名信奉伊斯兰教的波斯尼亚人。美莱村大屠杀属于无计划屠杀，斯雷布雷尼察屠杀则历时持久，组织严密，反映出塞军的政策是对波斯尼亚境内的穆斯林进行种族清洗。24如果塞军在 1995 年便拥有机器人杀手，整场暴行只会更糟，因为任何机器人都只会毫不犹豫地执行接到的命令，也绝不会因为同情、对自己的行为感到厌恶，或者单纯因为过于疲累，就饶过哪个儿童穆斯林的性命。\n数字独裁，老大哥\n在好政府的手中，强大的监控算法可以是人类历史上发生过的最大的好事。然而同样一套大数据算法也可能养出未来的“老大哥”，最后出现奥威尔笔下的那种监控政权，所有人无时无刻不遭到监控。如果你看到一张该国领导人的照片，而生物传感器发现你出现愤怒的迹象(血压升高、杏仁核活动增加 )，大概明早你就会被抓进监狱。\n以色列有“新创企业之国”的美名，高科技产业部门极度活跃，还有尖端的网络安全产业。所以虽然西岸巴勒斯坦人口有大约 250万，但只要用少得惊人的以色列士兵，就可以有效控制那里。\n2017 年 10月曾有一起悲哀而荒谬的事件，一名巴勒斯坦工人在自己的脸谱网账号发了一张在工地的自拍照，就站在一台推土机前面在照片旁边，他用阿拉伯文写了一-“早安!”但算法自动翻译这些阿拉伯文字的时候出了错，把意为“早安”的“Ysabechhum”误判成“Ydbachhum”，意思就成了“杀光他们”。以色列安全部队怀疑这名男子是恐怖分子，打算用推土机冲撞碾压人群，于是立刻将他逮捕。直到他们发现是算法出错，这名男子才得到释放。然而，那则叫人紧张的脸谱网发文还是被删除了，毕竟小心驶得万年船啊。2 巴勒斯坦人今天在西岸的状况大概只是个简单预告，未来或许全球几十亿人终将出现同样的局面。\n鉴于 20世纪的科技水平，把太多信息和权力都集中在一个地方并不是有效率的做法。在当时，没有人能够及时处理完所有信息，并做出正确决定。这也就成了苏联做出的决策水平远低于美国，苏联经济远远落后于美国经济的部分原因。\n然而，人工智能很快就会让钟摆摆向相反的方向。因为机器学习在分析越多信息之后效果越好，所以人工智能可能会让集中式系统比分布式系统效率更高。一心想把信息集中，在20 世纪曾是专制政权的主要弱点，但到了 21 世纪却可能成为决定性的优势。\n路易十四也是个集权的独裁者，但当时并没有足以建立现代极权主义国家的科技。虽然他的统治并未受到抵抗，但当时既没有收音机，也没有电话和火车，他也就很难掌控布列塔尼某个偏远乡村的农民甚至巴黎市中心市民的日常生活\n当时不论在意愿还是能力上，他都不可能建立群众政党、全国青年运动组织或国家教育体系。”是因为 20 世纪出现了新科技，信息技术，才让希特勒有了做这些事的动机和能力。二战时期，德国人研制了密码发报机恩尼格玛密码机，也是图灵的成名之战。\n算法歧视你，并非因为你是个女性或黑人，而是因为你就是你。就是有些什么关于你的特质，算法不喜欢。\n我们对意识所知太少，短时间内似乎并不可能设计出有意识的计算机。根本无从得知人类的最大潜能是什么，\n自由主义的价值除了自由之外，也很重视平等。自由主义一直强调政治上的平等、经济上的平等几乎同样重要。如果没有社会安全网的机制与一定的济平等，自由就毫无意义。然而，正因为大数据算法可能会抹去自由的同时也就可能创造出历史上最不平等的社会，让所有的财富和权力集中在一小群精英手中。大多数人类的痛苦将不再是受到剥酬、而是更她的局面:再也无足轻重。\n这些机器人能够找出我们最深层的恐惧、仇恨和渴望，再用它们来对付我们。从最近全球的选举和公投就可以预见未来:黑客通过分析选民数据，运用选民现有的偏见，就能知道怎样操纵单个选民。科幻惊悚片常常上演的是烈火浓烟、轰轰烈烈的末日景象，但实际上，末日景象可能是在一次又一次的点击当中悄悄而且平凡地来临。\n第4章 平等：谁该拥有数据 很多话说的好听，如果碰到了人们切实的利益，或者是处于那些非常极端危急的情况，还不是会遵从自私的本性和野性的冲动，对于那些不变的的人，文学作品叫做浪漫，现实中叫做愚者。\n成了多余的人，是件非常危险的事。这时候，民众的未来只能依赖一小群精英能否心存善意。就算这种善意能维持几十年，但只要遭逢危难(例如气候突变 )，要把多余的人抛到脑后实在太诱人，也太简单。\n基因工程，富人真的可能比贫民更有天赋，创意和聪明\n我们不是用户，而是商品\n生命深层次的秘密，选择和操纵我们，\n","permalink":"https://tassel234.github.io/posts/read/%E4%BB%8A%E6%97%A5%E7%AE%80%E5%8F%B2%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-1/","summary":"前言 使用资源 今日简史（赫拉利） 奇点将至 吟游诗人基德（b站up主） 引言 虽然比较用心的制作了目录，但是这样的方式写读后感效率确实有点低，我把几乎所以内容都搁置到读后感区域，目录不打算撤回，以后可以看着目录慢慢思考。 传统的历史书是按照一个时间年表按顺序进行书写，在书写的过程中发表一些评","title":"《今日简史》读书笔记-1"},{"content":"黄浦江 国庆期间第二次来到黄浦江外滩，上一次是跟着旅行团来的，坐了一个比较豪华的游轮，看了《上海滩》实地取景的那座桥，是老爹老妈之前约会来过的地方，还到了金茂大厦的顶楼，目前的上海最高，还有卖bilibili娃娃的机器。\n这一次是和同学一起来的，人巨多，一个绿灯走不完的那种，都快把红灯都熬走了。算是比较受罪的，主要穿着拖鞋来的，走了两万步。\n比较有意思的是渡轮竟然也是也算公交，仔细一想好像又没有什么毛病，可以用上海公交码扫2块钱坐到江对岸。\n","permalink":"https://tassel234.github.io/posts/life/%E9%BB%84%E6%B5%A6%E6%B1%9F%E6%B8%B8%E8%AE%B0/","summary":"黄浦江 国庆期间第二次来到黄浦江外滩，上一次是跟着旅行团来的，坐了一个比较豪华的游轮，看了《上海滩》实地取景的那座桥，是老爹老妈之前约会来过的地方，还到了金茂大厦的顶楼，目前的上海最高，还有卖bilibili娃娃的机器。 这一次是和同学一起来的，人巨多，一个绿灯走不完的那种，都快把红","title":"黄浦江游记"},{"content":"计划 之前我规划过要把博客进行日更，也是计划把github的提交日志给完全点亮。\n但之后我总是会在某些时间里面懈怠而不想学习和写博客，于是我就把之前在暑假写的（存放着的较为完整的）学习笔记也提交了，但是也已经快提交殆尽了，还剩下的一些笔记是拿不出手的未完成的部分。\n比如说阅读笔记，所谓知识分子，读是读完了，但写是真的难写，因为我计划写出的是那十几位人物的综合评价，是怀着那些最高尚的理想的，却被人类最低劣欲望所困扰的一个个伟大的人也是普通人的故事。再比如史记晋书的阅读笔记：太散了，完全不知道怎么写。现在想出的解决方法也只能是以人为单位计量 ，按照纪传体的格式通过攒一定 的人头数来发表笔记，古书也明白历史来自人民嘛。至于历史的脉络，明朝的那些事的博文格式只能以后有时间再写了。\n当然还有很多笔记是纯粹因为我懈怠了才迟迟没有写。\n接下来的时间里面只能 更加的勉励自己保持清醒，保持对未知事物的热情，保持探索和前进。\n我会另开一个笔记区，显示接下来应该要书写的博客，作为一种计划和指导。\n此外我还计划增加下面的一些笔记。\n历史区：\n中国古代历史的一些思考，思考中国古代的那些科学和科学家们。\n中国古代的一些人物，人类多样性，中华民族的文化内涵，今人从古人遗传到什么特性，那些利与弊。\n中国古代历史的一些思考，思考中国古代的那些科学和科学家们。\n中国历史我打算较为仔细的读三段.同时我也打算同时对标带英，阿美，苏这三个世界强国进行阅读。\n 上至上古传说中的黄帝时代，下至汉武帝太初四年间共3000多年的历史。我打算同时读英国史，对标科技发展（铜器和铁器时代，工业革命时代），国家从无到有，逐渐成为一方最强之国的必要条件，以及那些兴衰的历史。 上起于三国时期司马懿早年，下至东晋恭帝元熙二年（420年）刘裕废晋帝自立的晋书以及拓展读一些北史和南史，代表了中国历史上较为罕见的尊重个人的自由，性格，发展的360年的魏晋南北朝时代（ 《晋书》《宋书》《南齐书》《梁书》《陈书》《魏书》《北齐书》《周书》《南史》《北史》十本书魏晋南北朝时代的那些弔事 的，快占24史的一半了，实在读不完），同时这也是中国民族大融合的时代。那些荒诞混乱的岁月对标美国，作为由无数外来之人彼此碰撞交流构建的新国家，作为各种离奇古怪之人生活之所。以及我需要找寻一个问题的答案，尊重个人的自由和发展，是否是科学创造的源泉（基于一些统计观察的方法，尊重个人的发展，是科学创造的源泉，还是这只是鼓吹自由主义的一种手段而已。）。这个论调最开始出现在知乎，论据是文艺复兴带来的科技井喷，美国的科技繁荣。同时魏晋南北朝的历史也出现了一位数学大能:祖冲之，圆周率遥遥领先世界一千年。 时间跨度从1344年到1644年的明朝的那些事（明史也长的要命，懒得读了）。对标苏联历史。其实苏联的历史和明朝的历史对标性不大（某些议题上苏联的历史更接近晋史），对标仅仅是因为我很想读传播极广的，豆瓣9.3分的佳作明朝的那些事，以及那个红色巨人从崛起到倒下的历史。  音乐鉴赏专题：\n我之前有一个怪癖，就是把喜欢的歌曲都下载到sd卡然后把歌名都腾到笔记本上，然后记住它。sd卡的习惯是小学就开始养成的，那时候的最常用最便宜的mp3是一个方夹子盒子，没有数据显示屏，没有内置内存，插sd卡使用，使用寿命在我手里是平均6个月坏一次。抄歌词记歌名的习惯是接近高中的时候养成的，抄了6，7轮后接近大学了就放弃了，记忆了几百首歌曲也难得记忆了，一部分原因是歌曲的收集渐渐变得网红歌曲化了，远没有前七轮收集的歌曲经典。\n而我收集的歌曲品类确实比较杂，纯音乐，摇滚，acg神曲，儿歌，姬霓太美，山歌民谣，少量的古典音乐。我正儿八经的听过的一次古典音乐演奏会是小学时候在家里面的长辈带着在广州某个剧院欣赏过一次，我记得长辈说是巴赫的什么ABG曲子，除了一些震撼的感觉，我其实完全没办法从里面了解到什么奥妙之处。初中的时候，有一段时间网上说某些古典音乐可以提高人的记忆能力，然后我稀里糊涂的下载了不少古典的曲子，比如G弦上的咏叹调，然后发现效果稍微。。。我学过一小段时间的吉他，然后看动漫孤独摇滚看的又搂起吉他来学习了一阵，但直到今天还是没有达到把吉他带到学校来的水平。。。\n 乐理的网课学习 关于音乐对人的记忆力的影响，对脑电波的影响 频谱学习和分析。不同音的数学组合会带给人不同的感受。音乐重要的是建构、塑造一种音与音的关系，某些音乐艺术手法可以让平淡的音符组合在音乐中也变得让人不适或让人欢愉。这些音符带给人的感觉是世界各个国家都通用的。 考据音乐 的作者和创作历程 感受音乐中附加着的情感以及大众对歌曲的感受（网易云评论区，话说这些评论区真的有各种各样的小清新的故事），每一个人一生都应该有一个本命神曲，那是在你困难的时候激励你继续前进的存在，是最珍贵和重要的伙伴，我认识的某些人有的本命神曲是you raise me up,有的是骄傲的少年，赤子的骄傲，我的则是lemon tree\u0026hellip;is just a yellow lemon-tree~~~  此外还有更高深的东西。\n比如我在B站见过用python写一把吉他的存在，但我并不是太想干这种事。现在的合成音产业很发达，心兰相随都是使用合成音搞得，电音也及其发达，可以足不出户的进行音乐的创作。\n种种亚文化考察的专题：\n“玩这个能当饭吃吗？”的都是亚文化\n“虽然可能其他人能赚钱虽然是国家提倡的但是你天天捣鼓这个并且赚不到钱”那也是亚文化\n例如二次元（acg圈），幻想乡，特摄，神秘学，克苏鲁神话，赛博朋克，玄学等。\n我是没有想到有一天我年少时捣鼓的那些亚文化玩意竟然有一天可以在写博客上用到。\n课程学习和拓展笔记：\n比如微机原理我可以再深入学习汇编等\n机械可以学习生活中常用机械的构造，\n制图学习绘画\n杂谈 写博客的过程也是一种探索自我的过程。\n在未来的时代如何生存，\n基因到底多大的程度书写了我们的命运。\n我常年在B站，知乎，抖音，微博，贴吧，小红书，混迹，见证了很多人类多样性，但B站给我的割裂感是最强的。\n之前B站接入了阿瓦隆系统，我了解不多，只是大致知道这些东西是自动管辖评论的沉浮和之前已经存在的机器人信息。之前的秀才事件让人们知道老年人和年轻人的推荐信息，甚至评论内容都是不同的。信息茧房在我们每一个人身边展开，封闭了我们对外界正确的认识，让我们存在于让自己最舒服的幻想乡中，通俗一点叫养号。其实和古代某些皇帝被周围的信臣迷惑，失去对世界的察觉，以为外界一切安好，实则百姓民不聊生。不同 的信息茧房封闭，各种对上加对的思维形态正在形成，各种小圈子的形成（我主要是乐子人和成分复杂之人），各种观点的碰撞，类似百家争鸣，但似乎也有人称为互联网大撕裂时代。破除的勇气，面对真相的勇气。而我也不能确定自己是否也被信息茧房限制住了。多读书，多看报，少吃零食多睡觉。\n还有一群弔人整天总是想着评价国家，键盘政治，以为自己扛个键盘就是伟人了是吧，伟人模拟器不是这麽玩的，你评价一个东西好歹有一个了解吧，科学的精神懂不懂，现在的很多年轻人都追求标新立异。与众不同，反抗权威确实也是科学的遗留精神之一，但好歹先尊重一下事实吧。\n主要是B站的一些弹屏确实非常逆天，比如在天才简史介绍墨子和祖冲之的视频中，儒家害了中国，批孔，百无一用是儒生的弹幕论调贯彻始终。批判儒家的等级观念是中国发展缓慢的罪魁祸首，但即使没有儒家这个世界的等级都是存在的，而且这难道不是你们选择的和想要的结果吗。富则资本主义，穷则共产主义感觉才是他们的真实想法。共产主义是始终在为了实现人们的平等而不断努力的理想主义，但却败给了现实。自由在最初的语境也是非常高尚的美好的存在，但自由主义也成为了大国政治目的的手段之一。有时候觉得人们的斗争并不是在为了某些真理和主义而进行，也不是神明的斗争在人间投射下来的映射，而是从始至终都是人和人在对抗。\n今人并不一定比古人聪明，古人并不一定比今人愚昧。\nhttps://www.bilibili.com/video/BV18a411B7w2 阎学通，当年一片绝望时要我们自信的人 所以狂热化来泼冷水也正常 ，人家要的是不骄不躁。 但凡百度一下这个教授经历都说不出50W，老公知这些话。不过老爷子犯了他们年龄段的一个习惯错误就喜欢把人按某种属性（年龄，性别，地域）分类然后总结，就是贴标签，殊不知现在观众是细分化的市场，而且普遍厌恶贴标签。只能说人人不同，符合他所说的00后有，但不符合他说的00后也很多。\n 给青年讲道理要谨慎，原因有二：\n一，青年在少不经事前就被塞入一堆似懂非懂的道理，反而促使他们形成一种玩弄文字的习惯，自以为成熟，对所有事情都爱争辩，总不服气。\n二，给青年讲道理，其实是将他们无法理解的义务强加给他们，为了获得奖励或者逃避惩罚，他们会选择用虚伪、撒谎的方式，用表面行为掩饰内心动机，假装明白，用空洞搪塞你。\n——卢梭\n 现在我还没有写我的博客的关于部分，这是一个对我博客所传达之物的介绍和我相信之物的精粹。我实际有非常大的理想主义和怀疑主义的成分在，同时我也拥有很多人性中最低劣的部分。\n如果但就结果来看，即使是走向一条错误的路也比现在还在迷茫的寸步不前的自己要强。但即使如此，我依然不知道我应该选择何种道路，有何种道心。\n","permalink":"https://tassel234.github.io/posts/life/%E4%B8%8B%E4%B8%80%E4%B8%AA%E9%98%B6%E6%AE%B5%E7%9A%84%E5%8D%9A%E5%AE%A2%E8%AE%A1%E5%88%92/","summary":"计划 之前我规划过要把博客进行日更，也是计划把github的提交日志给完全点亮。 但之后我总是会在某些时间里面懈怠而不想学习和写博客，于是我就把之前在暑假写的（存放着的较为完整的）学习笔记也提交了，但是也已经快提交殆尽了，还剩下的一些笔记是拿不出手的未完成的部分。 比如说阅读笔记，所谓","title":"下一个阶段的博客计划"},{"content":"人类生于地球，绝不意味要死在这里。 Mankind was born on Earth. It was never meant to die here. 人类进化还没法超越这个简单的障碍，我们能够深切地无私地关心自己身边的人，可换成陌生人我们却做不到。 爱是一种力量，让我们穿越时空感受它的存在。 Love is the one thing that transcends time and space. 本片讲了一个父亲为了拯救女儿顺便拯救了人类的故事（雾）。\n近未来的地球黄沙遍野，小麦、秋葵等基础农作物相继因枯萎病灭绝，人类不再像从前那样仰望星空，放纵想象力和灵感的迸发，而是每日在沙尘暴的肆虐下倒数着所剩不多的光景。在家务农的前NASA宇航员库珀接连在女儿墨菲的书房发现奇怪的重力场现象，随即得知在某个未知区域内前NASA成员仍秘密进行一个拯救人类的计划。多年以前土星附近出现神秘虫洞，NASA借机将数名宇航员派遣到遥远的星系寻找适合居住的星球。在布兰德教授的劝说下，库珀忍痛告别了女儿，和其他三名专家教授女儿艾米莉亚·布兰德、罗米利、多伊尔（搭乘宇宙飞船前往目前已知的最有希望的三颗星球考察。 他们穿越遥远的星系银河，感受了一小时七年光阴的沧海桑田，窥见了未知星球和黑洞的壮伟与神秘。在浩瀚宇宙的绝望而孤独角落，总有一份超越了时空的笃定情怀将他们紧紧相连。（来自豆瓣简介）\n全片最让我感动的是父亲在五维空间里面对着女儿声嘶力竭叫喊，希望改变过去让自己留在女儿身边的画面。演员的情绪张力是非常到位。虽然父亲有着拯救人类，拯救女儿的任务在身，但在最后却希望一开始就陪着女儿身边。\n还有一个感动的点，是壮年的父亲看望百岁将死的女儿。父亲的孙辈满堂，女儿老矣，自己却仍然年轻（嗅到一丝二次元寿命论的味道），长期的太空旅行让父亲的时间比女儿慢上很多，父亲曾经承诺当女儿和自己同岁的时候自己就可以回来了，但却违约了这么多年。\n技术的进步在帮助我们前进，让我们的生活更加的便捷，在拯救更多的人 ，也在毁灭更多的人。 核磁共振帮助我们诊断疾病，原子弹会带来毁灭。 基因的研究可以治疗疾病，但生化武器会带来很大的伤亡。 微波炉和冰箱在方便我们的生活。\n科学的信仰\n特斯拉，科学家，那些人的人生是否与众不同绚烂多彩，是否经历坎坷依然爱着生活那斑驳的色彩。\n让男主坚持走下来的是是自私的爱，而不是卢梭口中的那分博爱，人类大爱，为了集体的爱，爱着人类的爱。 为什么，因为就大多数人是绝对没有信心可以在实际所做所为中爱着所有人，或至少会因为是虚晃的概念而无法前进。 我们爱着守护着身边的亲近之人就是要费尽全力，有资格守护亲族之人更是凤毛麟角。 爱着天下之人，在很多时候就是一句大话而已。 但我们总是为了那些无法实现的东西而努力。\n但那份对于无法实现的事物的追寻必须要存在，我们无法预知最后的结果，只知道如果不去做的话我们永远看不到未来的结果。\n","permalink":"https://tassel234.github.io/posts/read/%E6%98%9F%E9%99%85%E7%A9%BF%E8%B6%8A%E8%AF%BB%E5%90%8E%E6%84%9F/","summary":"人类生于地球，绝不意味要死在这里。 Mankind was born on Earth. It was never meant to die here. 人类进化还没法超越这个简单的障碍，我们能够深切地无私地关心自己身边的人，可换成陌生人我们却做不到。 爱是一种力量，让我们穿越时空感受它的存在。 Love is the one thing that transcends time and space. 本片讲了一个父亲为了拯救女儿顺便拯救了人类的故事（雾）。 近未来","title":"《星际穿越》观后感"},{"content":"对象数组和对象指针 （1）对象数组的定义和使用 可以简单的理解类就是我们自定义的数据类型，而对象就是类的实例，因此我们也可以构造对象数组和对象的指针。\nPoint points[100]; //表示100个点 （2）指向对象的指针 class Time { public: Time(int h=0,int m=0,int s=0): hour(h),minute(m),second(s) { } void set(int h=0,int m=0,int s=0) { hour=h,minute=m,second=s; } int hour,minute,second; }; Time now(12,0,0), *pt; //指向对象的指针变量 pt=\u0026amp;now; //指向对象  pt-\u0026gt;set(13,13,0); pt-\u0026gt;hour=1; 可以通过对象指针访问对象和对象的成员。\n（3）类成员指针 int *ptr=\u0026amp;now.hour; //指向对象数据成员的指针变量 成员指针与类的类型和成员的类型相关，它只应用于类的非静态成员。\n定义数据成员指针的一般形式为：\n数据成员类型 类名::*指针变量名=成员地址初值\nString Data::*ps=\u0026amp;Data::content; //指向Data::content的成员指针 定义成员函数的指针\n返回类型 (类名::*指针变量名)(形式参数列表) const =成员地址初值\nconst限定可以没有。\n也通过对象成员指针引用（.*）可以从类对象或引用及成员指针间 接访问类成员，或者通过指针成员指针引用（-\u0026gt;*）可以从指向类 对象的指针及成员指针访问类成员。\n（4）this指针 每个成员函数都有一个额外的、隐含的形参 this。在调用成员函数时，编译器向形参this传递调用成员函数的对 象的地址。\n类作用域、对象生命期、const限定 （1）类的作用域 每个类都定义了自己的作用域和唯一的类型。在类体内声明 类成员，将成员名引入类的作用域中。两个不同的类具有两个独立 的类作用域。\n在类作用域之外，成员只能通过对象、指针或引用的方式 （使用成员访问操作符“.”或“-\u0026gt;”）来访问。\n静态成员、类中定义的类型成员需要直接通过类作用域运算 符“::”来访问。\n（2）对象的生命期 ►按生命期的不同，对象可分为如下四种：\n►（1）局部对象。\n►局部对象在运行函数时被创建，调用构造函数；当函数运行结束时 被释放，调用析构函数。\n►（2）静态局部对象。\n►静态局部对象在程序执行函数第一次经过该对象的定义语句时被创 建，调用构造函数。这种对象一旦被创建，在程序结束前都不会撤 销。即使定义静态局部对象的函数结束时，静态局部对象也不会撤 销。在该函数被多次调用的过程中，静态局部对象会持续存在并保 持它的值。\n►静态局部对象在程序运行结束时被释放，调用析构函数。\n►（3）全局对象\n►全局对象在程序开始运行时，main运行前创建对象，并调用构造函 数；在程序运行结束时被释放，调用析构函数。\n►（4）自由存储对象\n►用new分配的自由存储对象在new运算时创建对象，并调用构造函 数；在delete运算时被释放，调用析构函数。自由存储对象一经 new运算创建，就会始终保持直到delete运算时，即使程序运行结 束它也不会自动释放。\n（3）常对象、常数据成员、常成员函数 常对象中的数据成员均是const的，因此必须要有初值。无论什么 情况下，常对象中的数据成员都不能被修改。\nconst 数据成员类型 数据成员名列表; //常数据成员声明 const int data;//常数据成员声明 在定义成员函数时使用const限定，称它为常成员函数。\n（4）指向对象的常指针、指向常对象的指针、对象的常引用 其含义是这样的指针始终保持其初值，程序中不能修改其指向。如：\nData d(10,20,100), d1; Data *const p=\u0026amp;d; //定义指向对象的常指针 p=\u0026amp;d1; //错误，不能修改常指针的指针值 const Data *p; //指向常对象的指针变量 const 类名 \u0026amp; 引用变量名 静态成员和友元 （1）静态数据成员 可以定义类的静态成员，能够实现同类的多个对象之间数据共享。 使用类的静态成员的优点是：\n►①静态成员的名字是在类的作用域中，因此可以避免与其他类的成 员或全局对象名字冲突；\n►②静态成员可以实施封装，可以是私有成员，而全局对象不可以。\n►③静态成员是与特定类关联的，结构清晰。\nclass Data { //Data类定义 public: static int count; //静态数据成员 int maxlevel; //非静态公有数据成员 Data(int i=0){ …… , count++; } //构造函数 private: int level; //非静态私有数据成员 }; int Data::count=0; //静态数据成员定义且初始化  通常，非静态数据成员存在于类类型的每个对象中，静态数 据成员则独立于该类的任何对象，在所有对象之外单独开辟空间存 储。在为对象所分配的空间中不包括静态数据成员所占的空间。\n（2）静态成员函数 和静态数据成员一样，静态成员函数是类的一部分，而不是对象的 一部分。如果要在类外调用公有的静态成员函数，可以类作用域运 算符（::）和通过对象名调用静态成员函数。\nclass 类名 { //类体 … static 返回类型 函数名(类型1 参数名1,类型2 参数名2,…); … }; （3）友元函数 C++提供友元（friend）机制，允许一个类将其非公有成员的访问 权授予指定的函数或类。友元的声明只能出现在类定义的内部的任 何地方，由于友元不是授予友元关系（friendship）的那个类的成 员，所以它们不受访问控制的影响。通常，将友元声明放在类定义 的开始或结尾。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; class Point { //Point类  public: Point(int _x=0,int _y=0) : x(_x), y(_y) { } private: int x, y;//私有数据成员  friend double distance(Point\u0026amp; r1, Point\u0026amp; r2); //友元函数  }; double distance(Point\u0026amp; r1, Point\u0026amp; r2) //计算两个点的距离  { double x = r2.x\u0026gt;r1.x ? r2.x-r1.x : r1.x-r2.x; //访问Point 类私有成员 double y = r2.y\u0026gt;r1.y ? r2.y-r1.y : r1.y-r2.y; //访问Point 类私有成员 return sqrt(x*x+y*y); } int main() { Point a(1,1),b(5,5); //定义两个点  cout\u0026lt;\u0026lt;distance(a, b); //输出它们的距离  return 0; （4）友元类 不仅可以将一个函数声明为友元，还可以将一个类（如B）声明为 另一个类（如A）的友元，这时类B就是类A的友元类。友元类B中 的所有成员函数都是A类的友元函数，可以访问A类中的所有成员。\nclass 类名 { //类体 … friend 友类名; }; class 友类名 { //类体 … }; ","permalink":"https://tassel234.github.io/posts/note/c++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1-2/","summary":"对象数组和对象指针 （1）对象数组的定义和使用 可以简单的理解类就是我们自定义的数据类型，而对象就是类的实例，因此我们也可以构造对象数组和对象的指针。 Point points[100]; //表示100个点 （2）指向对象的指针 class Time { public: Time(int h=0,int m=0,int s=0): hour(h),minute(m),second(s) { } void set(int h=0,int m=0,int s=0) { hour=h,minute=m,second=s; } int hour,minute,second; }; Time now(12,0,0), *pt; //指向对象的指针变量 pt=\u0026amp;now; //指向对象 pt-\u0026gt;set(13,13,0); pt-\u0026gt;hour=1; 可","title":"C++学习笔记-2（类和对象-2）"},{"content":"《艾迪芬奇的记忆》体验 前言 使用资源：百度百科\n艾迪芬奇的记忆被称为游戏版的百年孤独，芬奇家族在四百年以来（甚至更久）都受到的死亡命运的诅咒，这个诅咒最终夺取了这个家族几乎所有人的性命，只留下一个小女孩还活着，她就是玩家操作的主角，艾迪芬奇。多年之后，为了揭露这个萦绕在芬奇家族头上关于死亡的诅咒，我们的主角艾迪芬奇回到了发生了诸多不幸的故居，并在故事中见证了非常多离奇的死亡方式。\n到底什么样的家族会在建造房子之前先建造墓地 我们习惯了死亡 欣然接受所有这奇怪而短暂的一切 游戏体验 1st 刚才使用了一个半小时体验了几个芬奇家族人员的奇妙死法。\n出现幻觉变成各种奇妙动物的非常饥饿的吃鸟，吃兔，吃海豹的Molly。有美漫故事模式的被怪物粉丝吃掉而死的Barbara（故事中是这样），实际上应该是被杀人犯杀死的。荡秋千，飞起来死的Calvin，被恐惧吓倒，最后决心对抗命运，面对诅咒的时候被命运火车创死的Walter。\n一个猜测，死亡的命运无可避免，曾祖母Edie修饰了孩子们的死法，让这些死亡的命运对于活着的人不再是残酷，而是荒诞,以此维持这个家族的延续。也不妨是一个奇迹。\n而按照这个趋势来说，我们的主角艾迪芬奇最后恐怕难逃一劫，不过这个被命运诅咒四百年甚至更久的家族还能活到现代简直是不可思议，可能最后有奇迹发生，但却只是短暂的挣脱，命运的诅咒还会笼罩在这个不幸的家族上，当然如果最后是百年孤独式的“赐予这个被诅咒的家族永恒的孤独”的结局，我也没话说。总之故事确实很奇幻和吸引人，不过还有作业要写，之后再玩。\n冬青的特点是其叶子具有刺，这些刺通常呈现为锐利的尖端，有些物种的刺甚至可以带有毒性。冬青的叶子一般呈现为暗绿色，有些品种的叶子也可能具备其他颜色，如红色或黄色。另外，冬青在秋季和冬季通常会结出醒目的浆果，这些浆果是红色或黑色的。\n需要注意的是，有些冬青的浆果或其他部分可能对人体有一定的毒性，造成恶心,腹泻,呕吐甚至死亡。不过没有说出现幻觉，关于Molly的死亡仍然存疑，比如她是怎么在后来把故事写下来的，怪异程度相当于你知道某个人是在梦中被杀死的。我个人感觉应该是曾祖母Edie修饰了孩子们的死法，创造了一个又一个的故事。\n还有一种植物，叫颠茄，是我在另外的一本书了解到的，是一种剧毒的植物，可以让人产生幻觉和造成人的死亡。\n颠茄有毒，颠茄的根和根茎毒性是最强的，其中毒症状和解毒方法如下：\n1、颠茄中毒后极度口渴，咽喉干燥、充血，瞳孔放大，皮肤发干、发红，有时可出现红疹、黏膜出血点。鼻出血，偶尔有出血性胃炎。\n2、重度中毒可出现脉搏加速而微弱，体温可增高至40℃以上，以后可出现幻觉、谵妄、不安、强直性或阵挛性惊厥。随着进展，可出现昏迷、呼吸浅表等危重征象。\n3、瞳孔扩大、偶有发生黄视、复视、眼球结膜充血、视物模糊、斜视、青光眼、视力和听力障碍。\n查了一下，原来这东西就是颠茄，我老家一抓一大把，小时候还把他当成一种染色剂，不过还好没因为好奇误食。\n不过我对植物学的了解很少，是其他相似无毒的物种也是有可能的，此外冬青浆果和颠茄貌似在中医里都可以药用（本草纲目的神奇），似乎某些成分还可以合成一些西医药品。\n2 nd 刚才又使用了一个半小时通关了艾迪芬奇的记忆。\n通过照相的模式进行了Sam被鹿创死的过程。操作青蛙玩具导致了Gregory的溺水死亡。Gus放台风里面风筝被卷起来物品创死，Milton，天赋横溢的画家，他似乎是了解到了家中的诅咒，在2003年的某一天离家出走，生死不明，也就是说并不一定死去了，如果有第二部揭露诅咒的主线应该会有milton的故事。房子落灰的情况并不严重，怀疑可能和milton，当然落灰的情况可能压根是制作组懒得或不想加。\nLewis，Dawn的长子、Edith的大哥。他是一个关心家人的人，告诉Edith很多家中的秘密通道。他在一家鱼罐头厂工作，最后似乎是被切鱼的到砍掉头颅而死（路易16模拟器）。在Lewis的幻想中，芬奇家族的诅咒似乎可以具象，或者说来自于一个巨大的怪物，杀鱼的大哥的想象中窥得这个怪物的骨头像。这个游戏的扮演左手操作幻想绚丽的世界，右手机械单调的杀鱼。\n最后edie享年93岁，死亡。母亲dawn因为疾病，死亡。\n最后只剩下Edith，的儿子还明确活着。因为Edith似乎最后也死亡了，原因似乎是难产而死。\n果然像我猜的那样，艾迪芬奇最后恐怕难逃一劫，不过最后没有百年孤独，家族消亡，芬奇家族还是有后裔的，400年的诅咒恐怕故意留给这个家族一口气，真是恶趣味的恶魔呀。\n出场人物 Molly（1937-1947） Edie的长女。\n喜欢动物，养了一只仓鼠和一条金鱼，还喜欢观察蚂蚁。\n在她十岁的某一天晚上，Molly没吃晚饭就被母亲要求上床睡觉。十分饥饿的她吃了仓鼠的食物、牙膏和窗台上的冬青树浆果，这可能导致她食物中毒并产生了幻觉，感觉自己变成猫、猫头鹰、鲨鱼和怪物进行捕食。最终可能为食物中毒而死。\nBarbara（1944-1960） Edie的次女。\n电影童星，曾以其尖叫声而出名，然随着长大后声音逐渐变化而过气。\n在16岁生日时，由于父母前往医院，家中只有她、男朋友Rick、弟弟Walter，当地杀人魔潜入家中杀害了Barbara和他的男朋友。还有可能确实如同故事那样，Barbara是被簇拥着她的狂热粉丝杀死的，不过可能性很低，因为Barbara已经过气了，但是即使如此祖母仍然希望Barbara是在簇拥下是在在粉丝的喜爱下死去的。\nCalvin（1950-1961） Edie 的双胞胎儿子之一。\n他喜欢宇宙、飞船，想成为宇航员。在姐姐Barbara死去后，他愈发觉得自己的理想无法实现。\n在某一天午后，他在房子外荡秋千，妈妈喊他回家吃饭他也不管不顾，秋千越荡越高，最终他被甩飞了出去，掉入了海中死去。\nOdin（1880-1937） 芬奇家族原本定居于挪威，500年来因其财富及不幸而闻名。\nOdin在埋葬了他的妻子和儿子后，为摆脱诅咒而带着女儿Edie、女婿Sven、外孙女Molly以及房子启航出海，但在遭遇海浪后Odin与房子共同坠入海中，Odin不幸溺亡。\nWalter（1952-2005） Edie的小儿子。\n在8岁时，由于目睹姐姐Barbara遇害而留下了极深的心理阴影。后又因父亲Sven在他12岁生日不幸死去而十分内疚，并由此惧怕“诅咒”。\n16岁后搬进了家宅的地下室生活，并开始了长达30余年的生活，每日以桃子罐头为生及火车驶过的声响而活。2005年，由于火车连续一周没有经过，心怀不安的他克服恐惧离开地下室，在铁轨仰望阳光时火车驶过而去世。\nEdith（1999-2017） Dawn的女儿、故事开始时Finch家族中唯一可能活着的人。\n在母亲去世后，她回到家中的探索家族的秘密，她将家族各成员的死亡故事写进她的笔记本并留给了她的儿子Christopher。\n在她18岁生日前的一个月，她可能因早产或早产引发的并发症而去世。\nEdie（1917-2010） Edith的曾祖母、Odin的女儿。\n1937年，20岁的她跟随父亲Odin乘船来到美国，途中她的父亲死去，她和她的丈夫Sven将Odin葬在岸边，也将她们的房子建在此处，除了 Molly 外他们又生下了四个孩子（Barbara、Calvin、Sam、Walter）。\n之后家族成员们陆续死亡，她为了纪念死去的家人，保留他们各自房间的样子。并在房子上面建造新的房间给新出生的孩子们居住。当整个 Finch 家族只剩下她、她的孙女Dawn、曾孙女Edith三人时，她也不避讳诅咒的事情，反而将这些故事讲给Edith听。\n在Lewis丧礼结束的第二天，Dawn为了不让Edith被“诅咒”牵连，带着Edith离开了祖宅，并准备将Edie送往养老院。当第二天养老院的工作人员来接Edie之时发现她已经去世了，享年93岁。\n在Dawn和Edith离开的前一天晚上Edie喝了一些酒，Dawn说这会影响Edie药物的效果，Edie可能因此而病逝。\nSam（1950-1983） Edie 的双胞胎儿子之一，Edith 的祖父。\n军人，曾参加过多次军事行动，喜欢摄影与狩猎。与第一任妻子Kay育有 Dawn、Gus、Gregory 三个孩子。在Gregory去世后，Kay因内疚与Sam协议离婚，Sam 迎娶了他的第二任妻子，与第二任妻子之间未有子嗣。\n在一个周末，他和女儿Dwan外出打猎，Dawn 打中了一头鹿，可那只鹿没有完全断气，当Sam想要和鹿合影时，鹿将他顶下了悬崖，而这一瞬间也被相机拍了下来。\nDawn（1968-2016） Sam的长女、Edith的母亲。\n她离开家与印度人Sanjay结婚生下了 Lewis、Milton、Edith。在他的丈夫不幸去世后带着她的三个孩子回到家中生活。\n她亲眼见证了家族中许多人死去，包括她的父亲 Sam、她的孩子Lewis。而她的另一个儿子Milton也神秘失踪，直至家中只剩下她和她的女儿Edith、她的祖母Edie，可Edie还不断给Edith讲家族中有关“诅咒”的故事，这让她十分愤怒又不安。\n在Lewis葬礼结束的第二天，她决定所有的Finch家族成员都必须离开这所房子。她将Edie托付给养老院，带着Edith离开了房子，之后她的病情不断反复，最终不幸病逝。\n在她去世之前，她将祖宅的钥匙留给Edith想让Edith自己调查家族的秘密。\nGus（1969-1982） Sam的儿子。 Gus对父亲离婚与其他女人结婚的行为十分不满，在父亲的结婚典礼上，他也只自顾自地放风筝。\n这一天天气不好，狂风不止，将户外的帐篷吹起砸死了Gus。\nGregory（1976-1977） Sam最小的儿子。\n只有一岁大的Gregory中在浴缸中边洗澡边玩着各种小玩具，他的母亲将浴池中的水放完了之后接到了Sam打来的电话便离开了。Gregory自己却打开了水龙头，而他的小玩具正好堵住了出水口，他因此不幸溺死。\n因为这件事，他的母亲Kay十分内疚，选择和Sam协议离婚。\nLewis（1988-2010） Dawn的长子、Edith的大哥。\n他是一个关心家人的人，告诉Edith很多家中的秘密通道。\n他在一家鱼罐头厂工作，每天只完成一些切掉鱼头、把剩下的鱼肉放上流水线的重复性劳动。\n他在工作时会一边工作一边幻想自己在冒险，起初他是能够意识到自己在幻想的，但因为他滥用药物，他逐渐沉浸在自己的幻想中无法自拔，被切鱼头的机器所伤而死亡。\nMilton（1992-2003） Dawn的次子、Edith的二哥。\n天赋横溢的画家，他似乎是了解到了家中的诅咒，在2003年的某一天离家出走，生死不明。\n他的母亲Dawn找了他三个月也没有找到，她因此把家中所有房间都封了起来，但Edie还是在每个房间上留了一个探视孔。\n感悟 《活着》是把生命的死亡和苦难写成了悲哀震撼的文学作品。\n而《艾迪芬奇的记忆》是把生命的脆弱写成了忧伤奇幻的第九艺术作品。\n我之前听说过那个男作者的创作灵感似乎来自于生活，啊。。。\n最后滚动的真人头像我也感觉到事情开始有一点不对劲，然后滚出来似乎是死亡名单的30来人，我就已经开始感叹作者的命运多舛了，不过后来转念一想，那些人的姓都不一样，果然作者应该是参考了很多人离奇的自然死亡，然后汇总到故事中的这个家族。不过能把死亡写的这么小清新的作者，我还是觉得照片的某些人确实是作者认识的，他的家族可能也经历过一些离奇死亡，而他的妈妈修饰了那些残酷的故事，变成了离奇奇幻甚至有趣的故事，来安抚作者的心灵。母亲就是Edie和Edith，最后的故事中活下来的男孩子就是作者（我猜的）。\n我看了作者的背景故事，上面的很多猜测都不对。我为我的猜测忏悔，但还是保留了它。\n针对这些故事，网上还有一些关于游戏的猜测，比如Edie是变态杀人狂，神经疾病（梦回雏见泽）之类的。。。我觉得这些猜想有点类似于海猫的黑山羊了。虽然我们很多时候只相信自己愿意相信的事情，但这并不一定是一件坏事。\n八大艺术，主要指用形象来反映现实但比现实有典型性的社会意识形态，包括文学、音乐、舞蹈、绘画、雕塑、戏剧、建筑、电影八大类别。 笑死，科学什么时候才能站起来。 而游戏就被称为第九艺术，从现在的发展上来看，确实是。在有记录的历史上，公认世界最早的一部电影是于1888年由法国导演普林斯所拍摄的《朗德海花园场景》。最早有记录的电子游戏诞生于1952年，为井字棋游戏（Tic-Tac-Toe），运行于真空管计算机上。可以说电子游戏是非常年轻的了。电子游戏主体和文学，戏剧、电影，音乐很类似，都是创作故事然后让人们欣赏故事，而游戏是是让人们实际参与进来的一种很高级的叙事方式，再加上vr的发展，游戏确实成为了现代人们消遣的重要方式。\n","permalink":"https://tassel234.github.io/posts/read/%E8%89%BE%E8%BF%AA%E8%8A%AC%E5%A5%87%E7%9A%84%E8%AE%B0%E5%BF%86%E4%BD%93%E9%AA%8C/","summary":"《艾迪芬奇的记忆》体验 前言 使用资源：百度百科 艾迪芬奇的记忆被称为游戏版的百年孤独，芬奇家族在四百年以来（甚至更久）都受到的死亡命运的诅咒，这个诅咒最终夺取了这个家族几乎所有人的性命，只留下一个小女孩还活着，她就是玩家操作的主角，艾迪芬奇。多年之后，为了揭露这个萦绕在芬奇家族头上关","title":"《艾迪芬奇的记忆》体验"},{"content":"《深度学习的数学》读书笔记-2 前言 额外使用资源：\n卷积神经网络介绍\n卷积神经网络 卷积的概念 不稳定输入 稳定输出，求系统存量。可以使用吃东西消化和例子进行理解。\n卷积神经网络中的卷积 感觉上像是推广到二维的数据了。\n通过3x3的数字方格（卷积核），把中心的点扣在待处理图像的每一个像素点上（边缘处可以添加数值为0的像素点以完成3x3的卷积处理，不加也行，减少要卷积的个数），完成卷积操作。简而言之了解周围像素点如何产生影响。\ng是卷积核，f是在变化的像素点。\n3x3的方格如果数字都是1/9，相当于把像素点求平均，把这个操作称为平滑卷积操作，可以让图像变得更朦胧。\n而对于不同数字的卷积核，卷积的神奇之处开始展现出来，比如下面的图像经过处理可以提取横向和纵向的特征。\n使用excel体验神经网络 excel的文件也可以在书中找到。\n普通的神经网络excel也求解不了，下面的例子都是非常简单神经网络的例子，使用excel可以非常直观的观察变化情形，算是优点之一吧。还有两个比较邪门的例子：excel最新版本微软把python嵌入到里面了，从前有一个美赛队伍只用excel就拿了o奖。\n梯度下降法 学习率，也就是步长，通过乘以偏导数的值进行函数向极值点的移动，最终位移向量趋近于0.\n神经网络求解器 初始权重和偏置的设定是通过正态分布随机数进行的。\n然后计算隐藏层的输入，使用sigmod函数输出值。\n盘了半天，好像是这本书数据出现了问题，数据直接给出最后的结果而没有给学习的过程。似乎初始权重和偏置和最终的权重和偏置位置搞反了，导致使用计算出来的结果非常接近0或者1，sigmod函数出现截断，最后的值要么是0要么是1，也可以对数据鼠标右键，设置单元格格式，修改精度，下面是改为了15位的结果。\n把数据的顺序改一下就可以实现和书中写的一致的结果。\n规划求解器的加入可以参考下面的文章。\nhttps://jingyan.baidu.com/article/64d05a0269c01c9f55f73bbd.html\n最后执行成功果然改成了最优解的值，就是只显示01的那个情况。\n误差反向传播法 这个例子的长度和宽度都太吓人了，只截取第一次的学习作为例子。\n梯度\t∂CT/∂w\t∂CT/∂b 隐藏层\t1\t0.040 0.068 -0.022 0.082 -0.015 0.103 -0.013 -0.014 0.093 -0.022 0.000 0.080 -0.011 2\t-0.019 0.193 -0.295 0.121 -0.481 0.589 -0.394 -0.534 0.645 -0.413 -0.287 0.187 -0.396 3\t-0.491 -0.794 0.037 -0.932 0.016 -0.959 -0.086 0.016 -0.922 -0.129 -0.117 -0.889 -0.163 输出层\t1\t0.542 -1.939 -0.135 -2.491 2\t-1.158 -2.106 -1.028 -3.263 1次\tCT\t20.255 上面的结果是处理完64副图片得到的汇总（相加）值。以这些值对第二次的数据进行梯度下降处理。\n不断更新，让误差变小。\n","permalink":"https://tassel234.github.io/posts/note/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-2/","summary":"《深度学习的数学》读书笔记-2 前言 额外使用资源： 卷积神经网络介绍 卷积神经网络 卷积的概念 不稳定输入 稳定输出，求系统存量。可以使用吃东西消化和例子进行理解。 卷积神经网络中的卷积 感觉上像是推广到二维的数据了。 通过3x3的数字方格（卷积核），把中心的点扣在待处理图像的每一个像素点上（边缘","title":"《深度学习的数学》读书笔记-2"},{"content":"excel操作入门-1 前言 使用资源：官方excel教学文档\n添加 键入 =SUM(D4:D7)， 然后按 Enter。\n按alt和=，然后按“Enter”，可以快捷求和。\n在本工作表顶部，我们还向你展示了 SUMIF 函数。SUMIF 函数根据条件求和。如果 SUMIF 函数进行解释，应会是： 自动填充单元格以节省时间 将光标置于单元格的右下角，直到它变为十字形，拖拽或者双击（双击代表自动）。\n或者直接选择框，然后control+D (向下)，加R代表向右填充。\nExcel 可基于序列自动填充一些单元格。例如，可在某单元格键入 1 月，然后在其他单元格中填充 2 月、3 月等。\n拆分数据 Ctrl+E 是“快速填充”的快捷方式。 似乎excel会自动识别模式帮助我们填充。\n基于分隔符拆分列\n快速填充非常方便。但是如果想要将数据一次拆分到多个列，则它不是此作业的最佳工具。在此情况下，尝试使用”分列”\n单击并拖动，选择从”Nancy“到“Yvonne”的单元格 在“数据”选项卡上，单击”分列”。请确保选择了”分隔符号”，然后单击”下一步”\n在“分隔符”下方，确保只选中“逗号”复选框，然后单击”下一步”\n单击”常规”选项\n最后，单击”目标区域”框，键入$D$32。然后单击”完成”\n通过转置来变换数据位置 先选中复制，然后粘贴，在“开始”选项卡上，单击“粘贴”按钮下的箭头。单击“选择性粘贴”，然后在底部，单击“转置”复选框。单击“确定”。\n快捷一点是control直接点T。\n排序和筛选 可以单点一个，对其同列的相同类型的数据进行按照大小排序。“开始” \u0026gt; “排序和筛选” \u0026gt; “降序”。\n同时单点一个可以右键选择筛选，选择相同的内容。现在清除筛选，单击“部门”的筛选按钮 ，然后单击“清除筛选”。\n同时还可以根据颜色进行筛选和排序。\n同时一些表格还提供筛选按钮，可以在这个中进行高于平均值等属性的筛选。\n表格 单击右侧的数据，然后单击上面的“插入” \u0026gt; “表格” \u0026gt; “确定”。\n也可以轻松创建新行。在最下列下方的空单元格中，键入一些文本，然后按 Enter。表格将出现一个新行。创建新列也是同理。\n表格为你提供方便的一个示例：计算列。输入公式，表格将会自动填充。alt加=\n单击表格内部，然后按 Ctrl+Shift+T。汇总行。不同于键入 SUM 公式，Excel 可轻松进行总计。在 Excel 窗口顶部将出现“表设计”选项卡。 在该选项卡上，单击“汇总行”。最后生成的统计数据也有一个向下箭头符号，可以进行平均值的求解。\n下拉列表 在“数据”选项卡上，单击数据工具的“数据验证”。在“允许”下，单击“序列”。\n在“来源”框中，键入“农产品, 肉类, 烘焙品”。请确保在它们之间输入逗号。完成后，单击“确定”而且这个逗号是英语的逗号，中文的逗号会让下拉菜单连成一坨。\n在“数据”选项卡上，单击“数据验证”。在“允许”下，单击“序列”。\n在“来源”框中单击，然后单击向上箭头按钮。单击并拖动，仅选择 F 列中的“农产品”、“肉类”和“烘焙品”单元格。然后单击向下箭头按钮 。单击“确定”。现在，单击下拉箭头。只显示三个部门：农产品、肉类和烘焙品。但如果在“烘焙品”下方的 F 列内添加新部门，新部门将会更新在下拉菜单中。\n分析和图表 在出现的面板上，单击右下角的“数据条”。control加q是快捷键，可以直接选择和打开面板，选择“簇状柱形图”进行图的绘制。\n点击上方的插入也可以进行绘图，选择推荐使用的图表可以直观的看到想要使用的图表效果，而且还有组合图。\n也可以创建数据透视表，点击数据透视表的各个选项可以进行筛选。\n","permalink":"https://tassel234.github.io/posts/note/excel%E6%93%8D%E4%BD%9C%E5%85%A5%E9%97%A8-1/","summary":"excel操作入门-1 前言 使用资源：官方excel教学文档 添加 键入 =SUM(D4:D7)， 然后按 Enter。 按alt和=，然后按“Enter”，可以快捷求和。 在本工作表顶部，我们还向你展示了 SUMIF 函数。SUMIF 函数根据条件求和。如果 SUMIF 函数进行解释，应会是： 自动填充单元格以节省时间 将","title":"Excel操作入门-1"},{"content":"更新中\n前言 使用资源：\n工业4.0(6.1w)\n中国制造2025蓝皮书(主要看领域篇)\n图解中国制造2025（国家和地区）\n百度百科\n工业4.0 工业4.0是基于工业发展的不同阶段作出的划分。按照共识，工业1.0是蒸汽机时代，工业2.0是电气化时代，工业3.0是信息化时代，工业4.0则是利用信息化技术促进产业变革的时代，也就是智能化时代。\n2013年的汉诺威工业博览会上正式推出，其核心目的是为了提高德国工业的竞争力，在新一轮工业革命中占领先机。随后由德国政府列入《德国2020高技术战略》中所提出的十大未来项目之一。该项目由德国联邦教育局及研究部和联邦经济技术部联合资助，投资预计达2亿欧元。旨在提升制造业的智能化水平，建立具有适应性、资源效率及基因工程学的智慧工厂，在商业流程及价值流程中整合客户及商业伙伴。其技术基础是网络实体系统及物联网。\n德国所谓的工业4.0是指利用物联信息系统（Cyber—Physical System简称CPS）将生产中的供应，制造，销售信息数据化、智慧化，最后达到快速，有效，个人化的产品供应。\n“中国制造2025”与德国“工业4.0”的合作对接渊源已久。2015年5月，国务院正式印发《中国制造2025》，部署全面推进实施制造强国战略。\n第一章 为何是4．0？ 智能制造中的生产设备具有感知、分析、决策、控制等功能，是先进的制造技术、信息技术的集成和深度融合。在智能生产过程中，传感器、智能诊断和管理系统通过网络互联，使得由单一、分散的程序控制上升到综合智能控制，从而制造工艺能够根据制造环境和制造过程的变化，进行实时优化，提升产品的质量和生产效率。\n德国“工业4.0”与美国第三次工业革命的共同点是都基于互联网，互联网技术带给我们许多创新和意想不到。\n美国提出的第三次工业革命实质上是将互联网技术应用到新能源领域，将新能源资源的分散化、分布式配置，结合互联网技术实现能源的按需供给和双向买卖，产生智能电网，带动第三次工业革命。它本质上是推动互联网技术在新能源领域的深度应用，是新能源与互联网相融合的新一次工业革命。\n在德国，“工业4.0”的概念被认为是以智能制造为主导的第四次工业革命，旨在通过深度应用信息技术和网络物理系统等技术手段，将制造业向智能化转型。\n自动化只是单纯的控制，智能化则是在控制的基础上，通过物联网的传感器采集海量生产数据，通过互联网汇集到云计算数据中心，然后经过信息管理系统对大数据进行分析、挖掘，从而制定出正确的决策。\n在传统制造业时代，材料、能源和信息是工厂生产的三个要素。\n工业4.0实现的是生产智能化，设备智能化，能源智能化，供应链管理智能化。\n第二篇 “工业4．0”的科学发展观 “工业4.0”是一个发展的概念，体现出科学的发展观。工业4.0本质是基于“信息物理系统”实现“智能工厂”，是以动态配置的生产方式为核心的智能制造，也是未来信息技术与工业融合发展到新的深度而产生的工业发展模式。通过“工业4.0”可以实现生产率大幅提高，产品创新速度加快，满足个性化定制需求，减少生产能耗，提高资源配置效率，解决能源消费等社会问题。从最终用意来看，“工业4.0”将全面推动标准化体系建设，进一步巩固德国制造业优势，抢占新一轮产业竞争的制高点。\n第三篇 “工业4．0”背后的秘密 “工业4．0” 最开始源于德国，德国是一个以机械行业为支柱的制造业大国。工业4.0一定上反映了德国在制造业上对美国的竞争意识。\n第四篇 中国版“工业4．0”畅想 我国制造业“大而不强”，与制造业强国仍有较大差距。我们最欠缺的是高端制造业。\n第五篇 对未来制造业的探讨 工业软件充斥整个制造业\n一种是植入类用于达到自动化、智能化的控制、监测、管理各种设备和系统运行的目的。分为操作系统、嵌入式数据库，开发工具，应用软件等。还有一类是如辅助设计（CAD）、辅助制造（CAM）、辅助分析（CAE）、辅助工艺（CAPP）、产品数据管理（PDM）等实现生产和管理过程的智能化、网络化管理和控制等工程软件。\n大数据驱动制造业迈向智能化\n网络信息安全同样影响工厂\n对控制系统进行网络攻击的最著名案例是，2010年9月伊朗纳坦兹的铀燃料浓缩施设被称为“Stuxnet”的超级工厂的病毒进行了网络攻击。Stuxnet是一个强大的、旨在攻击西门子制造的工业控制系统的计算机病毒。该病毒会传播到插入电脑USB接口的设备中，并从中窃取数据机密。这是黑客首次尝试入侵大型工业控制系统的电脑病毒攻击\n该攻击中，Stuxnet利用了德国西门子开发的Step 7控制系统软件中的漏洞，进行干扰控制浓缩铀的离心分离机的运行速度以及状态，妨碍铀浓缩过程。事件破坏了伊朗核设施，震惊了全球。\n制造业将成为信息产业的一部分\n中国制造2025 现在是2023.9.23中国的该十年计划已经接近尾声，再过一年多就是中国制造2035的开始了。接下来的文字主要是中国制造2025蓝皮书（18年版本）的观点，观点可能有些老旧。\n上海在中国制造2025规划中承担的重点领域的任务（实际上现在已经耳熟能详了）：\n高档数控机床和机器人 高档数控机床的产品接口大多来自海外，产品的质量可靠性不高，国产机床的平均无故障时间仅为800小时，而国外机床已经达到了2000小时甚至更高（18年数据）。\n关键部件的发展滞后，各种精密设备依赖进口，高档产品90%以上依靠进口，高端数控系统受制于人，75%数控系统需要从国外进口。\n对于高档数控机床我们应该像向高速化、精密化、智能化方向发展。\n机器人是具有感觉、思维、决策和动作功能的智能机器。机器人集新型材料技术、现代制造技术和信息控制技术为一体，其研发、制造、应用成为衡量一个国家科技创新和制造业水平的重要标志。机器人可以在一些危险的地方代替人工。\n我国采用的机器人精密减速器约75%由日本进口.伺服电机和驱动超过80%依赖进口.\n加大技术研发力度，一是结合应用需求明确发展重点，开展工业机器人全生命周期可靠性和制造工艺技术研究，攻克伺服电机、减速器、驱动器和控制器等机器人关键零部件核心技术，开展国产关键零部件的集成化研究。二是充分利用和整合现有创新资源，形成一批工业机器人技术研发实验室、工程中心、企业技术中心，促进制造企业和应用单位的合作，加强协同攻关，突破产业发展瓶颈。三是建设人工智能、感知、识别、驱动和控制等下一代技术研发平台，同时关注没有被现有机器人技术体系所纳入的如能源、大数据、安全和材料等领域的技术创新。\n此外应该完善标准检测认证体系。\n集中突破重点产品。重点发展弧焊机器人、真空（洁净）机器人、全自主编程智能工业机器人、人机协作机器人、双臂机器人、重载工厂用物流机器人、消防救援机器人、手术机器人、智能型公共服务机器人、智能护理机器人等十种标志性产品。\n航空航天装备 航空航天制造业的发展需要综合利用各类高新科技，是集机械、能源、电子、光学、信息、材料、管理等学科最新成就为一体的新技术与新兴工业的综合体，集现代科学技术成果之大成，属于多学科交叉、技术密集的高科技领域，引领整个装备制造业的发展，其发展水平是一国顶尖制造技术水平的标志。\n航空航天装备的设计、制造、测试和运行需要解决多种独特的技术挑战，如空气动力学、推进技术、材料科学、航空电子设备、卫星通信等。\n航空航天装备主要包括以下种类：\n 民用飞机：包括客机、货机、公务机等，用于商业航空运输。 军用飞机：包括战斗机、轰炸机、侦察机、运输机等，用于军事任务。 无人机（UAV）：用于执行侦察、监视、攻击等任务的无人驾驶飞行器。 直升机：具有垂直起降和悬停能力的飞行器，适用于搜索救援、运输、巡逻等任务。 卫星：用于通信、导航、遥感、科研等多种用途的人造地球卫星。 航天器：包括载人飞船、空间站、深空探测器等，用于探索太空和科学研究。 火箭：用于发射卫星、航天器等载荷到太空的运载工具。  受益于经济发展强劲、“一带一路”战略的深入推进，以中国为首的亚太地区是近年全球航空业表现最好的市场。\n卫星应用主要涉及通信、遥感、导航三方面，卫星通信是率先实现商业化发展的领域，我国目前开发尚不成熟，存在补偿式发展空间。\n卫星遥感商业应用需求广泛，是新兴国家进军商业航天的首选领域，“一带一路”沿线国家需求巨大，到2025年，或将突破百亿元市场规模。\n接下来的重点仍然是突破核心关键技术。 我国工业发展过程最深刻的经验之一就是核心技术必须掌握在我们自己手中。\n海洋工程装备及高技术船舶 海洋工程装备及高技术船舶是指用于海洋资源开发、海洋工程建设、海洋调查研究等活动的特种船舶和装备，以及具有高科技含量、高附加值的船舶和设备。这些装备和船舶在设计、建造和使用过程中需要解决众多技术难题，如海水腐蚀、海洋环境监测、水下工程作业等。\n海洋工程装备主要包括以下种类：\n 石油钻井平台：用于开采海底石油和天然气，具有很高的技术复杂性和工程难度。 海上风力发电机：将风能转化为电能，是一种可持续的能源开发方式。 海洋工程船舶：如起重船、铺管船、潜水支持船等，用于支持海洋工程建设和海底资源开发。 海洋调查船：用于海洋科学研究、海洋资源勘查等活动，通常配备先进的调查设备和仪器。 无人船舶  高技术船舶则包括以下种类：\n 液化天然气（LNG）运输船：用于运输低温液化天然气，具有极高的安全要求。 豪华游轮：集旅游、休闲、娱乐等功能于一体，设计豪华、设备先进。 集装箱船：用于运输集装箱货物，具有高效率、低成本的特点。  此外还有还有国家重点 的海洋矿产资源装备制造和海洋生物资源装备制造。\n海洋为我们提供了种类繁多的生物资源，其中鱼、虾、贝、藻是人类最主要的海洋生物资源。近年来，我国沿海已经受污染很严重，沿海的水产养殖局部富营养化的问题已经非常严重，提供的产量仍然非常有限。从长远来看，开拓深海养殖空间是未来中国海上渔业的发展方向。我们可以利用海洋建立智能牧场和智能渔场，全球海上渔场设备的进步也是加快一带一路建设的推动力之一。\n随着人类对资源需求的不断增加及陆上资源的枯竭，开采蕴藏在深海海底的矿产资源成为未来世界解决能源问题的一个方向。目前，深海中有商业开采价值的矿产资源包括多金属结核、富钴结壳、热液硫化矿等。海洋矿产资源装备制造仍然是重中之重。\n海洋工程装备和高技术船舶行业属于技术密集型行业，需要不断研发创新，以提高装备的性能和可靠性。同时，该行业也面临着市场竞争激烈、法规政策变化、环境保护要求严格等挑战。\n2018年，全球海工建造市场焦点仍将集中在浮式生产平台、海上风电场建设运维装备以及LNG相关装备等。\n浮式生产平台是能源开采的重要组成部分。\nLNG（液化天然气）装备是指用于LNG的生产、储存、运输和利用的相关设备。LNG是一种清洁、高效的能源，因其燃烧效率高、排放污染物少，广泛应用于电力、供热、交通等领域。以下是一些典型的LNG装备：\n  LNG液化设备：用于将天然气冷却至零下162摄氏度，使之凝结为液体。LNG液化设备包括压缩机、换热器、膨胀机等部件。\n  LNG存储设备：如低温储罐，用于在低温环境下储存LNG。LNG储罐具有高强度、耐腐蚀、耐低温等特点，保障了LNG的安全存储。\n  LNG运输设备\n  LNG接收站：用于接收、储存和输送LNG。\n  LNG加气站：用于为LNG汽车、船舶等运输工具补充燃料。\n  LNG利用设备：如燃气轮机、锅炉等，将LNG转化为热能和电能，供发电、供热等用途。\n  LNG装备行业的发展需要依托于能源产业的政策支持、技术研发和产业链合作。随着全球能源结构向清洁、低碳转型，LNG装备行业将迎来更大的发展机遇。\n先进轨道交通装备 先进轨道交通装备是指采用现代科技手段，具有高性能、智能化、绿色环保等特点的轨道交通车辆和设备。这些装备广泛应用于高速铁路、城际铁路、城市轨道交通等领域，提高了交通运输的效率和安全性，降低了能源消耗和环境污染。以下是一些典型的先进轨道交通装备：\n  高速列车：如复兴号、和谐号等，具有高速、高效、舒适、节能等特点。这些列车广泛应用于中国的高速铁路网，大大提高了长途旅行的舒适度和便捷性。\n  城际动车组：如CRH6系列动车组，专为城际铁路设计，具有速度快、载客量大、起停频繁等特点。城际动车组为城市间的往来提供了快捷、舒适的交通方式。\n  地铁列车：如A型、B型等车型，适用于城市轨道交通系统。地铁列车具有加速快、制动距离短、噪音低等特点，提高了城市公共交通的运载能力和服务水平。\n  轻轨列车：作为一种中低运量、快速便捷的轨道交通方式，轻轨列车通常用于连接城市中心和郊区。轻轨列车节能环保，对城市景观的影响较小。\n  磁悬浮列车：利用磁悬浮技术使列车悬浮在轨道上运行，具有高速、低噪音、低振动等特点。磁悬浮列车可以大幅提高交通运输的速度和舒适性。\n  自动化无人驾驶列车：通过先进的信号和控制技术，实现列车的自动驾驶和智能调度。自动化无人驾驶列车可以提高运营效率，降低人力成本，提高安全性。\n  先进轨道交通装备行业的发展依赖于先进的科技手段和严格的生产工艺，需要国家政策的支持和企业研发投入的不断加大。同时国家的标准体系有待完善。\n绿色、智能是产业转型方向。\n随着传感器网络、工业无线网络、无线射频识别、微电子机械系统等技术的成熟，制造业数字化、网络化、智能化趋势日益明显，推动以信息网络、智能制造、新能源和新材料为代表的新一轮技术在轨道交通装备领域的广泛应用已成为现实，全球领先的轨道交通装备制造企业已开始实施产品数字化设计、智能化制造与信息化服务。\n围绕产业发展实际需求，突破发展包括高强度大尺寸中空铝合金型材、绝缘材料、高性能齿轮渗碳钢，以及高阻尼/高回弹橡胶及热塑性弹性体材料、超耐磨/耐高温摩擦材料、高阻尼隔音材料等专用新型高分子材料在内的关键基础材料，进一步加强车轴/车轮、轴承、列车制动系统、超级电容、功率半导体器件、车钩缓冲装置、空气弹簧等核心基础零部件（元器件）的研发与试验验证，加快突破金属型压力铸造技术、无模化铸造成形技术、双频感应热处理技术等先进制造工艺。\n借助数据系统和云服务等新兴技术，可以进一步优化轨道交通装备的设计研究、生产制造、检测检验、运营管理等各个环节，实现市场信息、资金人才、材料装备等各类生产要素的优化配置，加快推广工业机器人、3D打印、三维布线、三维虚拟装配、焊接仿真机器人、生产制造执行系统（MES）、柔性制造系统等先进制造技术；积极推进生产制造的智能化转型，进而通过优化生产工艺、构建一体化循环经济产业链等方法提高产品的资源利用率，降低污染排放。总之，轨道交通装备产业正在由“高速、重载”技术引领战略向“绿色、智能”技术引领战略转变。\n节能与新能源汽车 节能和新能源汽车是指采用新型动力系统和节能技术，降低能源消耗和污染物排放的汽车。这些汽车包括纯电动汽车、插电式混合动力汽车、燃料电池汽车等。与传统燃油汽车相比，节能和新能源汽车在环保性能、使用成本等方面具有明显优势。以下是一些典型的节能和新能源汽车：\n  纯电动汽车（BEV）：以电池作为唯一动力来源，通过充电来补充电能。纯电动汽车在使用过程中零排放，对环境友好，且运行成本低。\n  插电式混合动力汽车（PHEV）：结合了传统燃油汽车和纯电动汽车的特点，既可以使用燃油驱动，也可以使用电池供电。插电式混合动力汽车在燃油经济性和排放方面具有较好的表现。\n  燃料电池汽车（FCEV）：以氢燃料电池作为动力来源，通过化学反应将氢气和氧气转化为电能。燃料电池汽车具有续航里程长、加氢时间短等特点，是未来新能源汽车的发展方向之一。\n  太阳能汽车：利用太阳能电池将太阳光转化为电能，为汽车提供动力。太阳能汽车是一种可持续发展的绿色交通方式，但受到太阳能转化率和技术成本的限制，目前尚处于研发和应用的初期阶段。\n  空气动力汽车：通过压缩和释放空气产生动力，驱动汽车行驶。空气动力汽车具有零排放、低噪音等优点，但目前尚处于实验和概念阶段。\n  为了促进节能和新能源汽车的发展，各国政府纷纷出台政策扶持，鼓励企业加大研发投入，提高相关技术和产品的竞争力。\n在新技术的发展上偏重的方向是发动机高效率技术，先进变速器技术，低摩擦（低内阻，低风阻，低滚阻）技术，先进电子电器技术。\n电力装备 农业装备 新材料 新材料是指具有优异性能或特殊功能的材料，通过新材料的开发和应用，可以提高产品的性能和功能，降低生产成本，减少环境污染。新材料广泛应用于航空航天、电子信息、生物医药、能源环境等多个领域。以下是一些典型的新材料：\n  石墨烯：一种由碳原子组成的单原子层二维材料，具有高导电性、高导热性、高强度等优异性能。石墨烯在锂电池、太阳能电池、触控屏、传感器等领域具有广泛的应用前景。\n  纳米材料：指尺寸在纳米级别的材料，具有奇特的光学、电学、磁学等性能。纳米材料可应用于催化、传感、生物医学、能源等领域，如纳米颗粒、纳米线、纳米管等。\n  生物降解材料：指在一定条件下能被自然环境分解的材料，如淀粉基塑料、聚乳酸等。生物降解材料可替代传统塑料，降低环境污染，促进可持续发展。\n  气凝胶：一种具有极高孔隙率的轻质材料，具有优异的隔热、隔音、吸附等性能。气凝胶可应用于建筑、交通运输、航天等领域。\n  超导材料：指在一定温度下电阻为零的材料，具有强大的电传输能力。超导材料可应用于磁悬浮列车、医疗和科研等领域，大幅提高能源传输和磁共振成像等设备的性能。\n  智能材料：指具有感知、响应和自适应功能的材料，如形状记忆合金、压电陶瓷、光导纤维等。智能材料可应用于航空航天、机械电子、生物医学等领域，实现材料的智能化和自适应控制。\n  新材料行业的发展需要依托于科研机构的研究突破和企业的产业化应用，通过政策引导和资金支持，推动新材料领域的技术创新和产业发展。\n生物医药及高性能医疗器械 生物医药及高性能医疗器械是指采用现代生物技术、医药技术和工程手段，用于诊断、治疗、预防疾病或改善健康的药品、医疗器械和设备。这些产品具有较高的技术含量和附加值，是推动医疗卫生事业和健康产业发展的重要力量。以下是一些典型的生物医药及高性能医疗器械：\n  基因工程药物：通过基因工程手段制备的药物，如胰岛素、生长激素、干扰素等。这些药物在治疗癌症、遗传病、传染病等方面具有显著疗效。\n  单克隆抗体药物：通过单克隆抗体技术制备的药物，如曲妥珠单抗、利妥昔单抗等。单克隆抗体药物在治疗癌症、自身免疫性疾病等方面具有较高的靶向性和疗效。\n  干细胞治疗：利用干细胞的分化和修复能力，通过干细胞移植等方式治疗疾病，如利用造血干细胞治疗白血病、利用间充质干细胞促进组织修复等。\n  手术机器人：一种通过计算机控制，可实现精密手术操作的医疗器械。手术机器人在微创手术、复杂手术等方面具有更高的手术精度和更少的创伤。\n  人工智能医疗影像诊断系统：利用人工智能技术对医疗影像数据进行分析，实现疾病自动检测和诊断。这种人工智能系统在提高诊断准确率和效率方面具有显著优势。\n  可穿戴医疗设备：如智能手环、血压计、血糖仪等，可实现对人体生理数据的实时监测和远程传输。可穿戴医疗设备在慢性病管理、健康管理等方面具有广泛的应用前景。\n  高性能医疗器械是指采用先进技术和工艺，具有高精度、高灵敏度、高可靠性等特点的医疗器械。这些设备在疾病诊断、治疗、监测等方面具有更高的准确性和效率，提高了医疗质量和水平。以下是一些典型的高性能医疗器械：\n  医学影像设备：如CT扫描仪、MRI扫描仪、超声波仪器等，可实现人体内部结构的高清成像，用于疾病的早期诊断和分期。\n  内窥镜系统：如腹腔镜、胃镜、肠镜等，可通过人体的自然孔道或微小创口进入体内，观察病变组织和实时手术操作。内窥镜系统在微创手术中具有广泛的应用。\n  手术机器人：如达芬奇手术系统，是一种通过计算机控制、可实现精密手术操作的医疗器械。手术机器人在复杂手术、微创手术等方面具有更高的手术精度和更少的创伤。\n  放射治疗设备：如直线加速器、伽马刀等，用于癌症患者的放射治疗。这些设备可以精准控制放射剂量和照射范围，提高治疗效果，减少副作用。\n  心脏起搏器：一种植入式医疗器械，用于帮助心脏恢复正常节律。高性能心脏起搏器具有更长的电池寿命、更小的体积和更高的兼容性，可以提高患者的生活质量。\n  人工器官：如人工心脏、人工肝、人工肾等，可用于治疗终末期器官衰竭患者。高性能人工器官在材料、设计和制造方面具有更高的要求，以实现更好的替代效果和更长的使用寿命。\n  高性能医疗器械行业的发展依赖于多学科交叉合作，包括医学、工程、计算机、材料等领域。政府和企业需要加大研发投入，提高产品质量，推动医疗器械行业的持续创新和升级。\n接下来的话只是我的感觉，这个世界的发展正在变得越来越快，越来越难以预测，世界的奇点越来越密集，2015到2025世界的发展很快，2025到2035会更快，到达2045的时候世界的摸样可能已经不是我们可以想象的了。\n","permalink":"https://tassel234.github.io/posts/note/%E4%B8%AD%E5%9B%BD%E5%88%B6%E9%80%A02025%E5%92%8C%E5%B7%A5%E4%B8%9A4.0/","summary":"更新中 前言 使用资源： 工业4.0(6.1w) 中国制造2025蓝皮书(主要看领域篇) 图解中国制造2025（国家和地区） 百度百科 工业4.0 工业4.0是基于工业发展的不同阶段作出的划分。按照共识，工业1.0是蒸汽机时代，工业2.0是电气化时代，工业3.0是信息化时代，工业4.0则是利用信","title":"中国制造2025和工业4.0"},{"content":"工业大数据建模理论和案例-2 更新中\n前言 使用资源：\n工业大数据分析实例（21w）这本书的内容很全面，广度很大，深度也不小。目前只针对这本书大致了解工业大数据的理论应用。\n智能制造标准案例集(20w)\n工业大数据技术与应用实践（5.5w）\nchatgpt\n平台技术 基本介绍 工业大数据平台的特点由工业大数据的数据负荷特性、分析和应用的特点共同决定。工业大数据平台不能只是一个灵活扩展、成本可控的大数据存储系统，还应是以业务主题为中心的数据服务提供者、支持知识沉淀和快速迭代的分析支撑平台、消除技能壁垒的协同应用平台。\n数据负载特性是指在不同的数据分布和查询条件下，数据库或数据系统的性能表现。不同的数据负载特性可能会导致完全不同的性能表现。因此，在评估一个数据系统的性能时，需要考虑到不同的数据负载特性。以下是一些常见的数据负载特性：\n  数据分布均匀度：数据分布均匀度是指数据在数据库中的分布是否均匀。如果数据分布不均匀，可能导致某些部分的数据访问速度明显慢于其他部分。\n  数据访问频率：数据访问频率是指不同数据项被访问的频率。高频访问的数据项可能需要采用不同的缓存策略来提高性能。\n  数据查询模式：数据查询模式是指常见的数据查询类型，包括点查询、范围查询、聚合查询等。不同的查询模式可能会导致不同的性能问题。\n  数据更新模式：数据更新模式包括插入、更新和删除等操作。不同的更新模式可能会对数据系统的性能产生不同的影响。\n  并发访问：并发访问是指多个用户或进程同时访问数据库。并发访问可能导致锁争用、资源竞争等问题，从而影响性能。\n  数据量：数据量是指数据库存储的数据量。数据量越大，通常意味着检索和更新数据所需的时间越长。\n  在设计和优化数据系统时，需要考虑到这些不同的数据负载特性，以确保数据系统能够在各种场景下提供高性能和稳定性能。\n关系数据需要解决的问题：面向工业大数据分析场景，工业大数据存储组件需要支持关系数据与时序数据、非结构化数据的关联读取和处理。同时工业大数据的存储组件要达到TB单位的内存，支持100个节点以上的分布式管理架构，支持年级别时间的运行。\n模型研发工具 可视化技术：平台在数据准备阶段需要提供可视化算子，帮助数据分析师完成面向业务逻辑的数据准备工作。提供可视化建模和编辑功能，能够屏蔽底层执行引擎内容，加快模型开发。\n平台架构 基本的功能组件包括大数据存储组件、计算引擎组件、可视化建模组件、安全组件和数据可视化组件。\n数据管理的层次感觉是计算机数据库的那些知识。比如TSDB,TSDW,OBJ.\n工业大数据分析案例 实际上《工业大数据分析实例》给出的六个例子都非常好，之后有机会再深究，这里只选取其中三个，而另外三个从《智能制造标准案例集》这本书选择的。\n风电大数据分析 透平设备智能运维 冲压排产优化 “动态性是运筹优化存在的前提，也是挑战。”\n基于工业互联网的新型 生 物 能 源 制取系统 直升机旋翼系统制造智能工厂 数控机床信息安全 ","permalink":"https://tassel234.github.io/posts/note/%E5%B7%A5%E4%B8%9A%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1%E7%90%86%E8%AE%BA%E5%92%8C%E6%A1%88%E4%BE%8B-2/","summary":"工业大数据建模理论和案例-2 更新中 前言 使用资源： 工业大数据分析实例（21w）这本书的内容很全面，广度很大，深度也不小。目前只针对这本书大致了解工业大数据的理论应用。 智能制造标准案例集(20w) 工业大数据技术与应用实践（5.5w） chatgpt 平台技术 基本介绍 工业大数据平台的特点由工业大数据的","title":"工业大数据建模理论和案例-2"},{"content":"《奥本海默》观后感 现代盗火的普罗米修斯，通过毁灭人类的威慑，阻止了可能爆发的超大规模的战争。\n古巴导弹危机，导弹都快在美国头上爆炸了，眼瞅着核战争就要爆发力，不过最后还是谈判解决了。在那个时候美国总统的口号是为了我们下一代的孩子都可以在和平的世界里面生活。我不知道最后苏联为什么会解体，但就结果而言确实极大降低了第三次世界大战的风险，凭借后人不负责任的以教育为意义的从善意和爱的角度出发的，我也比较喜欢给苏联的解体安上一个为了战争的不再发生，人们不再受苦，孩子不再哭泣的名号。所以才让苏联退出了历史舞台。苏联本身的竞争力和早年和晚年的一些暴行污点也是苏联输掉的重要理由。\n代数是演奏的乐曲，关键不在于你是否可以看懂乐谱，而是你是否可以听懂旋律 “愚者才选择光明正大，权力只存在于阴影之中” “他们拍拍你的肩膀，说道一切既往不咎，看似是为了你，其实是为了他们自己” “到底有谁可以说出真相” 主线有两个，一个是奥本海默研究原子弹的过程，一个是官员施特劳斯诬陷奥本海默的故事线。\n电影最后的一幕有些讽刺，爱因斯坦和奥本海默谈论科学和人类存亡的大事，却被某个心胸狭窄的人认为是针对自己政治生涯的密谋。最后否定施特劳斯的有一个美国新秀，精神小伙：肯尼迪。长的帅，笑口常开，脑洞大开，江湖人称美乐宗。\n感觉从科学（原子弹）的角度，整个二战（西部）是犹太人大战德国人（希特勒）的过程。因为科学家感觉很多都是犹太人，也只有德国人那边海森堡他们能压犹太科学家一头。为什么德国没有先研制出原子弹，有一些原因是希特勒不喜欢量子力学，认为这是犹太人的科学，必须加以抵制。这也是科学的威力之一，他强制的让所有人不同信仰的人存在在同一个世界下，从此西方不再活在以太里面，东方也不活在金木水火土里面，从此世界的所以活着的人都生活在原子之间，因为如果不遵守这一点，就赶不上科学技术的发展，无法发展核武器，世界开始存在保真度极高的真理。奥本海默连接了美国所有不同语言，宗教的人，调度所有的力量，承认科学技术，最终赶上了德国制造原子弹的进程。\n我个人还是比较喜欢前两个小时的研究原子弹的拍摄，因为出现了非常多的科学大佬。\n比如费米，波尔，海森堡，泰勒。\n以前听说过爱因斯坦晚年经常和哥德尔一起散步，本来只是听说，没想到电影看到活着的了。哥德尔是逻辑学的宗师级人物，哥德尔不完备定理让人们知道我们对真理的认知有多么匮乏。\n比较遗憾的是我一直留意的费曼并没有详细介绍，没有太多出场镜头，不过一出场就十分搞笑。看原子弹爆炸时费曼露天坐在小椅子上敷防晒霜。一个把物理变成生活的浪子，一个敢于质疑权威，提出路径积分，费曼图的古灵精怪的科学家。不过原子弹爆炸的时候对应 的时间线是费曼的妻子阿琳患肺结核生命所剩无几的时间线，最后原子弹爆炸后费曼是握着妻子的手激动的流泪的，阿琳不久就死了。阿琳离开的后劲来的比较慢，但是后劲比较大，大到我们可以把浪子费曼形容为一个痴情的男人。\n感觉诺兰要么看过刘慈欣的球状闪电，要么刘慈欣看过奥本海默的传记。因为里面对奥本海默在造出原子弹然后抵制的说辞几乎如出一辙，因为科学家就是疯子，虽然现在抵制，但是如果重新来一次，奥本海默还是会去造原子弹。\n一些神秘学的观点。 原子核可能连接着另一个宇宙，ufo经常目击到在核电站附近。宇宙星系的发光交错就像是人类的大脑。\n","permalink":"https://tassel234.github.io/posts/read/%E5%A5%A5%E6%9C%AC%E6%B5%B7%E9%BB%98%E8%A7%82%E5%90%8E%E6%84%9F/","summary":"《奥本海默》观后感 现代盗火的普罗米修斯，通过毁灭人类的威慑，阻止了可能爆发的超大规模的战争。 古巴导弹危机，导弹都快在美国头上爆炸了，眼瞅着核战争就要爆发力，不过最后还是谈判解决了。在那个时候美国总统的口号是为了我们下一代的孩子都可以在和平的世界里面生活。我不知道最后苏联为什么会解","title":"《奥本海默》观后感"},{"content":"工业大数据应用模型 生产安全分析 海因里希法则（Heinrich’s Law）。该法则指出，当一个企业有300个隐患或违章时，非常有可能发生29起轻伤或故障，以及1起重伤、死亡或重大事故。海因里希提出的事故因果连锁论，阐明了发生伤亡事故的各种原因及这些原因与伤亡事故之间的关系。该理论认为，伤亡事故的发生不是孤立事件，尽管可能在某瞬间突然发生，但实际上它是一系列事件相继发生的结果。\n生产安全分析是一种关注生产过程中安全状况的分析方法，旨在识别潜在的安全风险，评估安全水平，并制定相应的预防和控制措施。这种分析方法涉及多个领域，包括安全生产、风险管理、质量控制和工业工程等。通过对生产过程中的人员、设备、物料、环境和管理制度等方面进行全面、深入的分析，可以减少事故发生率，提高生产效率，保障员工的生命财产安全。\n生产安全分析通常包括以下步骤：\n  识别危险源：通过检查生产设备和环境，分析可能出现的安全隐患，例如机械设备的故障、有毒有害物质的泄露等。\n  评估风险程度：根据危险源的性质和可能导致的事故后果，评估风险等级，确定风险优先级。\n  制定预防措施：针对 identified危险源，制定相应的预防和控制措施，包括改进设备、加强人员培训、优化生产流程等。\n  实施安全监控：通过实时监控生产过程中的关键参数和安全指标，确保安全措施的有效实施。\n  持续改进：根据生产安全分析的结果，持续改进生产工艺和设备，提高安全生产水平。\n  在进行生产安全分析时，还可利用一些分析工具和技术，如事故树分析（FTA）、失效模式和效应分析（FMEA）、危险与可操作性分析（HAZOP）等。这些方法可以帮助分析人员更好地识别风险，制定针对性的预防措施，从而达到提高生产安全的目的。\n7.1.1 微观管理 视频分析技术。随着计算处理能力、计算机视觉，传感器和机器人技术的突破，全自动安全程序随之产生。\n音频分析技术。根据设备的声纹信息判断旋转设备的运行工况是否安全，根据次声波分析密闭压力\n特定装备或重点装备的关键参数进行监控和分析。\n7.1.2 宏观管理 基于多维数据， 从 管 理 领 域 需 求 出 发 , 借 助 数 据 分 析 技 术 , 从 管 理 优 化 、 实时 监 管 和 趋 势 预 警 3 个 方 面 进 行 安 监 大 数 据 分 析 应 用 建 设 。 为 保 证 分 析 应 用 可 灵 活。\n在此过程中可以依托物联网，社交媒体数据以及历史管理数据。\n这一方面和数学建模竞赛的习题有很多的相似了。\n营销优化分析 营销优化分析是一种提高营销效果的数据分析方法。这种方法通过深入研究市场数据、客户行为、竞争环境等多方面因素，发现营销活动中存在的问题，并提出优化方案。通过实施营销优化分析，企业能够提高营销效率，降低成本，提高客户满意度和忠诚度，从而实现更好的营销业绩。\n营销优化分析通常包括以下几个步骤：\n  明确目标：首先需要明确营销优化的目标，例如提高销售额、增加潜在客户、提高品牌知名度等。\n  数据收集与整理：收集与营销活动相关的各种数据，包括销售数据、客户行为数据、市场趋势数据等。整理数据，确保数据的准确性和完整性。\n  分析与诊断：对收集到的数据进行详细分析，识别出营销活动中存在的问题和瓶颈。例如，分析客户转化率、活动效果、渠道效率等指标，找出薄弱环节。\n  制定优化方案：根据分析结果，制定针对性的优化方案。这可能包括调整营销策略、修改营销素材、优化渠道组合等。\n  实施优化措施：将优化方案付诸实践，并进行持续跟踪和调整，以确保优化措施的有效性。\n  评估优化效果：经过一定时期的实施后，重新评估营销效果，以检验优化措施的实际效果。根据评估结果，决定是否需要进一步优化。\n  营销优化分析过程中，可以运用多种数据分析方法和工具，如数据挖掘、统计分析、A/B测试等。通过这些方法和工具，可以帮助分析人员更深入地了解市场需求和客户行为，从而做出更明智的营销决策。\n研发数据分析 研发数据分析（R\u0026amp;D Analytics）是一种收集、整理、处理和分析研发数据，以改进产品开发、优化研发流程和降低成本的方法。研发数据分析可以帮助企业更好地了解其研发活动的效率和效果，以便在竞争中保持领先地位。\n研发数据分析的主要步骤包括：\n  数据收集：收集研发过程中的所有相关数据，包括项目计划、需求分析、设计文档、测试结果、缺陷报告、成本数据等。\n  数据整理：对收集到的数据进行整理，包括数据清洗、数据规范化、数据整合等，以确保数据的准确性和一致性。\n  数据分析：运用适当的数据分析方法和技术，对整理后的数据进行深入分析，以挖掘有价值的信息和规律。\n  结果可视化：将分析结果用图表、报告等形式进行可视化，以便进行有效的沟通和决策。\n  研发数据分析的方法和技术包括：\n  描述性统计分析：用于总结研发数据的分布、中心趋势和离散程度，如均值、中位数、标准差、最小值、最大值等。\n  推论统计分析：用于通过样本数据来推断总体特征，如假设检验、T检验、方差分析等。\n  数据挖掘：用于发现数据中的隐藏模式和趋势，如聚类分析、分类分析、关联规则等。\n  可视化分析：用于将数据用图表、图形等形式进行可视化，以便进行有效的沟通和决策，如柱状图、饼图、散点图、箱线图等。\n  研发数据分析可以帮助企业更好地了解研发活动的效率和效果，例如：\n  项目进度分析：通过分析项目进度数据，了解项目是否按计划进行，以便及时采取措施调整进度。\n  成本分析：通过分析项目成本数据，了解项目的成本构成和成本趋势，以便优化成本控制。\n  缺陷分析：通过分析缺陷报告数据，了解缺陷的类型、原因和分布，以便改进产品质量和开发流程。\n  技术趋势分析：通过分析技术文档和数据，了解技术发展趋势和市场需求，以便优化产品规划和研发方向。\n  研发人员效率分析：通过分析研发人员的工作数据，了解研发人员的效率和能力，以便优化研发团队的结构和人力资源配置。\n  研发是一个高度创新的过程，人工智能有时候可以看到我们看不到的东西。比如通过大数据对某些异常情况的分析，我们可以了解那些“意料之外，情理之中”的小发现，不断对工业系统进行改进。\n有限元仿真（Finite Element Simulation，FEM）是一种广泛应用于工程和科学研究的的计算方法，通过将复杂的物理问题分解为较小的、 简单的问题，来近似求解偏微分方程（PDE）。\nFEM将求解域离散化为有限个互不重叠的单元，用简单函数（如线性函数）逼近单元中的解，通过求解单元之间的连接方程（如平衡方程、兼容性方程等），最终获得整个求解域上的数值解。\n有限元仿真在多个领域都有广泛的应用，如：\n 结构分析：评估结构在不同负载和条件下的响应，如应力、应变、位移等。 流体力学：模拟流体流动、热传导和化学反应等问题。 电磁学：分析电磁场和波在复杂结构中的传播和行为。 传热分析：研究热传递现象，如热传导、对流和辐射。  有限元仿真的优势在于可以处理复杂几何形状和载荷条件，考虑材料的非线性行为，并具有较高的计算效率。这使得它们在工程和科学研究中成为了一种不可或缺的工具。\n有限元仿真的时间比较长，而且需要一定的数据支持，基 于 有 限 元 仿 真 结 果 库 , 利 用 统 计 学 习 的 回 归 分 析 算 法 ( 如 神 经 网 络 、 随 机 森 林 等 ) 训 练 得 到 回 归 预 测 模 型。\n在数据上，研发数据分析需要将研发数据（PLM）、管理数据（ERP）、制造数据（MES）、服务数据（MRO）、监测数据（SCADA）等有机融合\n在研发大数据的基础层面，大数据平台应该融合既有的研发数据管理体系，还应该有相对灵活的对象存储模式，以支持数据的不断扩展。\n工业大数据的分析算法 数据和特征决定了机器学习的上限，而模型和算法只是逼近这个上限而已\n时序数据常常呈现自相关（时间维度）、互相关（多个变量间）、多尺度（时间颗粒度）等特性，因而有不少针对这些时序数据特征的领域算法。\n在工业大数据分析实践中，领域理解和特征加工比算法本身更重要，因此，要最大限度地从原始数据中提取特征，以供算法和模型使用。\n8.1 统计分析算法 8.2 机器学习算法 这两个章节的知识和前面博客写过的算法有诸多相似之处，或者应该说这些算法和数学建模竞赛的算法是基本一致的（比如聚类分析，pca,神经网络，决策树，启发算法），因此不再赘述。\n不过这本书介绍的机器学习算法仍然有非常多的可取之处，虽然内容的深度没有拓展多少，但是广度极佳，有大量图表，分类辅助理解，而且还出现了一些我闻所未闻的算法。比专门的建模算法书介绍的都更有条理和全面。\n后续可以针对这两章专门写几篇博客。\n8.3 时序数据挖掘算法 这部分的算法感觉如果应用到23年国赛的C题会比较好，但是当时我们并没有学到时序算法。\n8.3.1 时序分割 不同时间，不同工况之间的数据差异非常大，所以要应用时序分割。而且时序分割也可以达到降维的效果。\n Changepoint（统计量的变化点）  一个最简单的时序分割假设是：时间序列的基础统计量（均值、方差）是分段稳定的。此类算法的重点是寻找统计量的变化点。主要有3种算法：AMOC（At Most One Change）、PELT（Pruned Exact Linear Time）、BinSeg（Binary Segementation）。 AMOC根据均值或方差的变化进行研判，但其最多只能找到1个分割点。AM\nTreeSplit  梯度直方图（Histogram of Oriented Gradients，HOG）是图像识别中流行的特征提取方法，具有旋转不变性、位移不变性等良好性质，形状表达能力非常好\nAutoplait  Autoplait算法使用隐马尔可夫模型（HMM）和最小描述长度准则（MDL）自动决定分割的段数和每段的起始点。\nMDL是基于信息理论的模型选择标准之一，此外值得一提的是，Autoplait算法的鲁棒性不好，容易受到干扰。\n8.3.2 时序分解 时序分解（Temporal decomposition）是一种将复杂问题分解为更小的、可管理的子问题的方法，这些子问题可以在不同的时间点上分别解决，以实现更有效的问题解决。这种方法在人工智能、规划和调度等领域有着广泛的应用。\n时序分解通常包括以下几个步骤：\n  问题识别：确定需要解决的问题，例如任务调度、规划等。\n  子问题生成：将原始问题分解为更小的子问题，这些子问题可以在不同的时间点上解决。\n  子问题求解：对每个子问题进行求解，这可能涉及到使用其他算法或策略。\n  结果合并：将各个子问题的解决方案合并成一个完整的解决方案。\n  评估与优化：评估所得解决方案的质量，并在必要时进行优化。\n  时序分解可以帮助我们更好地理解问题的复杂性，并在解决复杂问题时提供一种系统化的方法。通过将问题分解为更小的子问题，我们可以更容易地找到合适的解决方案，并提高问题的可解性。\n常见的时序分解算法有STL、奇异谱分析（SSA）、经验模态分解（EMD）、小波变换、SuperSmooth、传统线性滤波等。\nSTL的优点是适用于任何周期的数据（X12ARIMA周期只能是季度或月份），且可以控制季节性成分随时间的变化率。stl的鲁棒性很强。\n对经过EMD处理的信号进行希尔伯特变换，就组成了“希尔伯特—黄变换”。EMD是一种信号分解方法，与傅里叶变换、小波变换的核心思想一致，都是将信号分解为相互独立的成分的叠加。\n奇异谱分析是近年来兴起的一种研究非线性时序数据的方法。可以估计混沌系统，比如气候吸引子的维数，这是是SSA在气象学中的最早应用。\n8.3.3 时序再表征 时序再表征（Temporal re-representation）是指在时序数据中，通过一定的方法将原始数据变换为新的表示形式，以便更好地捕获数据中的时间模式、趋势和规律。这种技术在时序预测、金融分析、语音识别等领域有着广泛的应用。\n时序再表征通常包括以下几个步骤：\n  数据预处理：对原始时序数据进行清洗、去噪、填补缺失值等处理，以确保数据质量。\n  特征提取：从原始数据中提取具有预测能力的特征，如时间序列的统计特征、变化率等。\n  特征选择：选择对预测目标最具预测能力的特征，以减少特征向量的维度，提高模型的效率。\n  特征变换：将特征向量从原始空间映射到一个新的空间，以便更好地展现数据中的时间模式。这可能涉及到使用一些非线性映射方法，如傅里叶变换、小波变换、离散余弦变换等。\n  模型构建：根据变换后的特征向量，运用机器学习或深度学习方法建立预测模型。\n  评估与优化：对预测模型的性能进行评估，并在必要时进行优化，以提高预测精度。\n  通过时序再表征，我们可以更好地捕捉时序数据中的时间动态性，从而为预测、分类等任务提供更有效的特征表示。\n8.3.4 序列模式 序列模式（Sequential Pattern）的主要任务是挖掘时间序列中的频繁模式，即时间序列中经常出现的模式。\n8.3.5 异常检测 异常检测有规则驱动、数据驱动两条技术路线。\n8.3.6 时序聚类 时序聚类（Temporal Clustering）是一种将时间序列数据划分为不同簇（或分组）的统计分析技术。这种技术可以帮助我们更好地理解数据，发现潜在的模式和趋势，以及识别异常值。时序聚类有多种方法，以下是一些常见的方法：\n  动态时间折纸（Dynamic Time Warping, DTW）：这是一种常见的时序聚类方法，它通过计算两个时间序列之间的相似度，然后将相似的时间序列聚类在一起。DTW 可以处理时间序列之间的时间不对齐和变形问题。\n  基于距离的聚类方法：如欧式距离、 Pearson 相关系数等，将这些距离或相似性度量作为聚类算法的输入，将相似的时间序列聚在一起。\n  隐马尔可夫模型（Hidden Markov Model, HMM）：HMM 是一种基于概率模型的聚类方法，它假设观测序列是由一个隐藏的马尔可夫链生成的。通过估计模型的参数，可以将相似的时间序列聚类在一起。\n  条件随机场（Conditional Random Fields, CRF）：CRF 是一种基于概率图的聚类方法，它也假设观测序列是由一个隐藏的马尔可夫链生成的。与 HMM 不同，CRF 考虑了观测序列之间复杂的依赖关系。\n  深度学习方法：如循环神经网络（Recurrent Neural Network, RNN）和卷积神经网络（Convolutional Neural Network, CNN），它们可以将时间序列数据作为输入，自动学习输入数据的特征表示，从而实现时间序列的聚类。\n  时序聚类在许多领域都有广泛的应用，如金融（股票市场分析）、物联网（传感器数据聚类）、医疗保健（心电图分析）等。\n8.3.7 时序分类 时序分类常常用于设备异常类型识别、工况状态识别等场景。例如，医学中的心电图类型识别。\n8.3.8 时序预测 处理稳态时间序列的经典方法是采用ARIMA、状态方程（在线Kalman滤波）等。在考虑多种因素的非线性交互作用时，采用ARIMA等解析模型进行处理较为困难。在工程实践中，常利用ARIMA了解变量的时序相关阶数，将其加工为特征变量，再利用通用的回归方法建模。\n8.3.9 可视化 可视化是提高数据可消费性。\n8.3.10 工具与应用 在实际应用中，常常灵活地交叉使用各种时序算法和经典机器学习算法，没有固定模式。例如，对于存在多尺度（Multi-scale）特征量的时序数据，可以用小波变换等方法提前将多尺度分开，在每个尺度上采用机器学习算法，\n8.4 工业知识图谱 在工业生产过程中会积累大量日志文本，如产品手册、维修工单、工艺流程文件、故障记录等，在这些非结构化数据中蕴含着丰富的专家经验，利用文本分析技术能够实现事件实体和类型提取（故障类型抽取）、事件线索抽取（故障现象、征兆、排查路线、结果分析），通过专家知识的沉淀形成专家知识库。这些沉淀的知识可以指导工业企业的产品研发设计、设备运行检修，甚至营销采购等多个方面。\n工业知识图谱是一种重要的知识沉淀工具，它的本质是语义网络，是一种基于图的数据结构，由节点（实体）和边（关系）组成，知识图谱是把所有类型的工业数据连接在一起得到的关系网络，因此具备从“关系”的角度分析问题的能力。\n知识融合：分为数据层知识融合与概念层知识融合。\n把经验和大数据进行融合，或者说把机理和大数据进行融合。\n8.5 其他算法 8.5.1 系统辨识算法 系统辨识算法面向控制和优化系统建模。\n8.5.2 运筹优化算法 运筹学主要研究人类对各种资源的合理使用，在满足外界各类约束的情况下，最大化资源效益，达到总体最优的目标。已经和建模非常相似了\n8.5.3 规则推理算法 Rete算法是规则引擎常用的前向规则快速匹配算法，通过缓存条件结果和触发关系，避免了相同条件的多次计算（即用空间换时间），提高规则引擎的处理效率。\n8.5.4 基于遗传算法的特征提取算法 在数据分析中，特征提取通常花费60%的时间。为了加速这一个过程，可以进行遗传算法和特征提取的结合算法。在遗传算法中，文法树的每条推导路径（即衍生特征变量）对应一个基因。\n","permalink":"https://tassel234.github.io/posts/note/%E5%B7%A5%E4%B8%9A%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1%E7%90%86%E8%AE%BA%E5%92%8C%E6%A1%88%E4%BE%8B-3/","summary":"工业大数据应用模型 生产安全分析 海因里希法则（Heinrich’s Law）。该法则指出，当一个企业有300个隐患或违章时，非常有可能发生29起轻伤或故障，以及1起重伤、死亡或重大事故。海因里希提出的事故因果连锁论，阐明了发生伤亡事故的各种原因及这些原因与伤亡事故之间的关系。该理论认","title":"工业大数据建模理论和案例-3"},{"content":"ps入门 前言 使用资源：\nhttps://www.bilibili.com/video/BV1Q5411P7k4\n简介：\nAdobe Photoshop，简称“PS”，是由Adobe Systems开发和发行的图像处理软件。Photoshop主要处理以像素所构成的数字图像。使用其众多的编修与绘图工具，可以有效地进行图片编辑和创造工作。PS 有很多功能，在图像、图形、文字、视频、出版等各方面都有涉及。可以PS还可以制作表情包，抠图，制造gif。\n我一般绘画采用的是procreate在平板上进行（因为纸质的画笔各种颜色太贵了），ps也可以接入数位板进行绘画，但手眼分离算是比较难受的了。可以使用比较复杂的步骤：通过procreate进行图画的绘制，然后导入到ps进行优化。现在ps完成抠图，procreate进行临摹。\n快捷键 Ps快捷键应用到的常用四个键：Ctrl，Shift，Alt，空格键。\nCtrl键：相当于你命令行，控制的意思。\nShift键：相当于是切换/换挡的意思。按住shift键还可以选择正方形选区，正圆\n选区，或者等比例放大缩小\nAlt”键：“Alter”的缩写，它的中文意思是“更改、改变、修改”\nEsc键：取消操作\nEnter 键：执行操作\n放缩大小：alt+鼠标的轮滑 或者 ctrl+ \u0026ldquo;+或者-\u0026rdquo;\n选择：全部选取 【Ctrl】+【A】、取消选择 【Ctrl】+【D】、重新选择 【Ctrl】+【Shift】+【D】、羽化选择 【Ctrl】+【Alt】+【D】。\n拖动画布: 按住空格，出现抓手即可拖动 撤回: Ctrl+Z 重做: Ctrl+Shift+Z\n界面介绍 左边是最重要的工具，点击工具后上面会出现一些操作属性。\n右边可以方便的修改颜色选取和图层。\n历史记录: 记录PS操作中的每一步，可在其中找到之前的修改操作。\n字符、段落:可以对文字工具进行编辑调整\n颜色、色板、渐变:结合画笔、油漆桶、形状、文字工具使用。图形、字体的色彩调整可以在这几个面板中进行管理。\n属性:针对不同的工具，有不同的内容可以进行调整。\n调整:里面包含多种图片调整工具，例如亮度、色彩平衡、曲线等等。\n图层:显示图层之间的堆叠顺序，以及图层的属性，可以进行的操作有新建图层、删除图层、编组、建立蒙版、混合选项等等。\n通道:根据色彩模式的设置，通道会显示出该色彩模式下的几种颜色通道图层。可建立精确选区、存储选区、载入选区备用\n路径:使用绘图工具创建的任意形状的曲线会显示在路径栏当中，可以创建矢量蒙版、转换为选区、颜色填充、描边。\n图层基本知识 通过对图层的研究可以进行海报 的制作，包括层次感 的显示，大量重复图像的放缩叠加。\n国层混合模式包括下面四种：\n 变暗模式 变亮模式 中性模式 差集模式 颜色模式  ps工具探索 魔棒工具组 -快捷键W\n魔棒工具:选择色彩类似的图像区域\n快速选择工具: 通过查找和追踪图像边缘来创建选区\n裁剪工具组 - 快捷键C\n裁剪工具:裁切或者拓展图像的边缘\n透视裁剪工具:裁剪图像以矫正透视导致的扭曲\n吸管工具 - 快捷键I 吸管工具:从图像中取样颜色\n画笔工具组-快捷键B\n画笔工具:绘制自定义画笔描边\n铅笔工具:绘制硬边缘画笔描边\n颜色替换工具:将选定颜色绘制在现有颜色之上\n混合器画笔工具:模拟真实的绘画技巧，例如混合颜色和变化涂料湿度\n实例1：镂空图像 打开“磨砂纸”素材，使用椭圆工具按住Shf键绘制正圆，并在属性中给圆填充灰色，增加镂空的真实感\n对圆形图层使用图层混合选项，添加内阴影效果\nCtrl+J复制圆形图层，Ctrl+T并按住Alt键以中心为缩放点，缩小圆形\n加入音符素材，调整音符大小与位置，让音符位于圆心\n锁定音符图层不透明像素，用画笔工具为音符涂上灰色\n对音符图层使用图层混合选项，同样添加内阴影效果\n使用椭圆工具绘制正圆，略大于镂空外圆一圈，填充使用预设内的渐变预设进行填充\n丰富画面\n给渐变圆添加图层混合模式，选择叠加模式\n栅格化渐变圆图层，使用滤镜\u0026gt;模糊\u0026gt;高斯模糊，对渐变圆边缘进行过渡，让色彩与背景融合\n在图像正中间下方，使用文字工具输入文字\n实例2：重影海报制作 打开拳击照片，点击照片图层Ctrl+]复制图层\n右键复制的图层对图层使用混合选项，关闭通道R(红色通道)\n轻移关闭通道R的图层，制作出红蓝重影\n使用矩形选框工具，布尔运算选用添加模式，在图片中围绕人物随机框选出一些长条矩形\n点击滤镜\u0026gt;风格化\u0026gt;风，选择大风执行滤镜，效果不明显使用快捷键Alt+Ctrl+F多执行几次滤镜6不要取消选区，点击下方没有关闭通道R的照片图层，同样使用快捷键At+Ctl+F执行几次滤镜，制作故障效果\n使用文字工具输入PUGILIST，在文字面板中更改文字字体大小等\n使用同样的方法，用选框工具结合滤镜给文字制作故障效果\nctrl+J复制文字图层，执行图层混合选项，运用同样的方法制作重影效果\n实例3：灯笼 新建文件，在预设中选择A4尺寸画布建立文件\n拖入纸背景素材并调整图像位置与大小\n拖入灯笼素材，按住Alt键使用移动工具，拖移复制出四个灯笼\nCtrl+T自由变换调整灯笼的大小以及位置，交错摆放在画面上方\n使用文字工具输入Chinese New Year Celebration，并在文字面板对文字进行字体、大小以及间距的更改\n移动文字至画面左下角对文件进行排版\n实例4：抠图和修图 打开熊宝宝素材和草地素材\n在熊宝宝素材中使用快速选择工具或是磁性套索工具对熊宝宝进行抠图\n将扣好的熊宝宝图片复制粘贴到草地素材中\nCtrl+T自由变换调整熊宝宝位置及大小\n使用套索工具绘制熊宝宝在草地上的阴影区域并填充黑色\n使用滤镜\u0026gt;模糊\u0026gt;高斯模糊对绘制的阴影形状进行模糊\n","permalink":"https://tassel234.github.io/posts/note/ps%E5%85%A5%E9%97%A8-1/","summary":"ps入门 前言 使用资源： https://www.bilibili.com/video/BV1Q5411P7k4 简介： Adobe Photoshop，简称“PS”，是由Adobe Systems开发和发行的图像处理软件。Photoshop主要处理以像素所构成的数字图像。使用其众多的编修与绘图工具，可以有效地进行图片编辑和创造工作。PS 有很多功能，在图像、图形、文字、视频、出版等","title":"Ps入门-1"},{"content":"数学建模和算法应用举例-2(智能RGV的动态调度策略) 前言 更新中\n使用资源 2018年高教社杯全国大学生数学建模竞赛题目 B题 智能RGV的动态调度策略\n即其相应的优秀论文：B203,225，334.\nchatgpt\naim 考虑不一样的因素。不同的视角，看到不一样的东西。\n学会建立模型和求解解决实际问题。\n问题重述 问题描述 有一个智能加工系统的示意图，由8台计算机数控机床（Computer Number Controller，CNC）、1辆轨道式自动引导车（Rail Guide Vehicle，RGV）、1条RGV直线轨道、1条上料传送带、1条下料传送带等附属设备组成。RGV是一种无人驾驶、能在固定轨道上自由运行的智能车。它根据指令能自动控制移动方向和距离，并自带一个机械手臂、两只机械手爪和物料清洗槽，能够完成上下料及清洗物料等作业任务。\n针对下面的三种具体情况：\n（1）一道工序的物料加工作业情况，每台CNC安装同样的刀具，物料可以在任一台CNC上加工完成；\n（2）两道工序的物料加工作业情况，每个物料的第一和第二道工序分别由两台不同的CNC依次加工完成；\n（3）CNC在加工过程中可能发生故障（据统计：故障的发生概率约为1%）的情况，每次故障排除（人工处理，未完成的物料报废）时间介于10~20分钟之间，故障排除后即刻加入作业序列。要求分别考虑一道工序和两道工序的物料加工作业情况。\n请你们团队完成下列两项任务：\n任务1：对一般问题进行研究，给出RGV动态调度模型和相应的求解算法；\n任务2：利用表1中系统作业参数的3组数据分别检验模型的实用性和算法的有效性，给出RGV的调度策略和系统的作业效率，并将具体的结果分别填入附件2的EXCEL表中。\n表1：智能加工系统作业参数的3组数据表\n系统的构成及说明 智能加工系统由8台CNC、1台带机械手和清洗槽的RGV、1条RGV直线轨道、1条上料传送带和1条下料传送带等附属设备构成。\n（1）CNC：在上料传送带和下料传送带的两侧各安装4台CNC，等距排列，每台CNC同一时间只能安装1种刀具加工1个物料。 如果物料的加工过程需要两道工序，则需要有不同的CNC安装不同的刀具分别加工完成，在加工过程中不能更换刀具。第一和第二道工序需要在不同的CNC上依次加工完成，完成时间也不同，每台CNC只能完成其中的一道工序。\n（2）RGV：RGV带有智能控制功能，能够接收和发送指令信号。根据指令能在直线轨道上移动和停止等待，可连续移动1个单位（两台相邻CNC间的距离）、2个单位（三台相邻CNC间的距离）和3个单位（四台相邻CNC间的距离）。RGV同一时间只能执行移动、停止等待、上下料和清洗作业中的一项。\n（3）上料传送带：上料传送带由4段组成，在奇数编号CNC1#、3#、5#、7#前各有1段。由系统传感器控制，只能向一个方向传动，既能连动，也能独立运动。\n（4）下料传送带：下料传送带由4段组成，在偶数编号CNC2#、4#、6#、8#前各有1段。由传感器控制，只能向同一个方向传动，既能连动，也能独立运动。\n在附图1中，中间设备是自带清洗槽和机械手的轨道式自动引导车RGV，清洗槽每次只能清洗1个物料，机械手臂前端有2个手爪，通过旋转可以先后各抓取1个物料，完成上下料作业。两边排列的是CNC，每台CNC前方各安装有一段物料传送带。右侧为上料传送带，负责为CNC输送生料（未加工的物料）；左边为下料传送带，负责将成料（加工并清洗完成的物料）送出系统。其他为保证系统正常运行的辅助设备。\n在附图3左图中，机械臂前端上方手爪抓有1个生料A，CNC加工台上有1个熟料B。RGV机械臂移动到CNC加工台上方，机械臂下方空置的手爪准备抓取熟料B，在抓取了熟料B后即完成下料作业。\n在附图3右图中，RGV机械臂下方手爪已抓取了CNC加工台上的熟料B抬高手臂，并旋转手爪，将生料A对准加工位置，安放到CNC加工台上，即完成上料作业。\n系统的作业流程 （1）智能加工系统通电启动后，RGV在CNC1#和CNC2#正中间的初始位置，所有CNC都处于空闲状态。\n（2）在工作正常情况下，如果某CNC处于空闲状态，则向RGV发出上料需求信号；否则，CNC处于加工作业状态，在加工作业完成即刻向RGV发出需求信号。\n（3）RGV在收到某CNC的需求信号后，它会自行确定该CNC的上下料作业次序，并依次按顺序为其上下料作业。根据需求指令，RGV运行至需要作业的某CNC处，同时上料传送带将生料送到该CNC正前方，供RGV上料作业。\nRGV为偶数编号CNC一次上下料所需时间要大于为奇数编号CNC一次上下料所需时间。\n（4）在RGV为某CNC完成一次上下料作业后，就会转动机械臂，将一只机械手上的熟料移动到清洗槽上方，进行清洗作业（只清洗加工完成的熟料）。\n具体过程：首先用另一只机械手抓取出清洗槽中的成料、转动手爪、放入熟料到清洗槽中，然后转动机械臂，将成料放到下料传送带上送出系统。这个作业过程所需要的时间称为RGV清洗作业时间，并且在这个过程中RGV不能移动。\n熟料在清洗槽中的实际清洗时间是很短的，远小于机械手将成料放到下料传送带上的时间。\n（5）RGV在完成一项作业任务后，立即判别执行下一个作业指令。此时，如果没有接到其他的作业指令，则RGV就在原地等待直到下一个作业指令。\n某CNC完成一个物料的加工作业任务后，即刻向RGV发出需求信号。如果RGV没能即刻到达为其上下料，该CNC就会出现等待。\n（6）系统周而复始地重复（3）至（5），直到系统停止作业，RGV回到初始位置。\n初步思路 任务1：对一般问题进行研究，给出RGV动态调度模型和相应的求解算法；\n任务2：利用表1中系统作业参数的3组数据分别检验模型的实用性和算法的有效性，给出RGV的调度策略和系统的作业效率，并将具体的结果分别填入附件2的EXCEL表中。\n立即判别执行下一个作业指令，三种具体情况：单个和两个项目以及故障的情况。\n位置的选择。但是没有给数量啊。要求分别考虑一道工序和两道工序的物料加工作业情况。代表不是混合的情况，刀片一开始就设定好了。最后确定的是4种情况。\n在八个小时的时间里面，考虑故障的情况，获得最大的效率。\nRGV动态调度模型，可能和选择先上料哪一个有关，如何处理重叠的信号。\n似乎可以通过初始化上料时间完成重合度最少的选择。\n似乎不是优化问题，而是对机械过程进行抽象进行描述，对三种情况进行分析。但其实也相当于规划优化的问题了。\n考虑故障的情况：泊松分布。故障时间的假设。故障的台式和发生时间。\nRGV移动1个单位所需时间 RGV移动2个单位所需时间 RGV移动3个单位所需时间 CNC加工完成一个一道工序的物料所需时间 CNC加工完成一个两道工序物料的第一道工序所需时间 CNC加工完成一个两道工序物料的第二道工序所需时间 RGV为CNC1#，3#，5#，7#一次上下料所需时间 RGV为CNC2#，4#，6#，8#一次上下料所需时间 RGV完成一个物料的清洗作业所需时间 启发思路 建模 求解 总结 ","permalink":"https://tassel234.github.io/posts/note/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%92%8C%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B-2%E6%99%BA%E8%83%BDrgv%E7%9A%84%E5%8A%A8%E6%80%81%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/","summary":"数学建模和算法应用举例-2(智能RGV的动态调度策略) 前言 更新中 使用资源 2018年高教社杯全国大学生数学建模竞赛题目 B题 智能RGV的动态调度策略 即其相应的优秀论文：B203,225，334. chatgpt aim 考虑不一样的因素。不同的视角，看到不一样的东西。 学会建立模型和求解解决实际问题。 问题重","title":"数学建模和算法应用举例-2(智能RGV的动态调度策略)"},{"content":"概率论入门-2 前言 使用资源：概率论和数理统计（同济课本）\n后续还会针对学校课程的学习对内容进行补充\n随机事件与概率 第一节 随机事件及其运算 样本空间和分割 第二节 概率的定义及其性质 第三节 等可能概型 第四节 条件概率与事件的相互独立性 第五节 全概率公式与贝叶斯公式\n随机变量及其分布 第一节 随机变量及其分布\n 随机变量的定义 随机变量的分布函数  离散型随机变量的分布律 表格 连续性随机变量及其密度函数  第二节 常用的离散型随机变量 二项分布 n重伯努利实验 泊松分布 (1) 某一时段内某网站的点击量; (2) 早高峰时间段内驶入高架道路的车辆 （3）数一本书上的印刷错误数. 超几何分布 几何分布和负二项分布 第三节 常用的连续型随机变量 均匀分布 U 指数分布 E 正态分布N 第四节 随机变量函数的分布 求和与求积分\n二维随机变量及其分布 第一节 二维随机变量及其联合分布\n样本空间，样本点（单事件），随机变量X，（或叫X（w）），即每一个样本点对于的映射。 也叫二维随机变量。\n(1) O\u0026lt;F (x, y) \u0026lt;1; (2) 当固定y值时，F(x，y) 是变量x的单调非减函数，当固定x值时，F(x，y) 是变量y的单调非减函数; (3) (4) 当固定y值时，F(x，y) 是变量x的右连续函数， 当固定x值时，F(x，y) 是变量y的右连续函数;（5)对任意的X1\u0026lt;x2， Y1\u0026lt;y2有矩形公式 P (x1\u0026lt;X\u0026lt;x2, Y1\u0026lt;Y\u0026lt;Y2) =F (x2， Y2) -F (x1， Y2)- F (X2， Y1) +F (X1， Y1) .\n联合分布函数 联合分布律的图表 联合密度函数 第二节 常用的二维随机变量 二维均匀分布 二维正态分布 第三节 边缘分布 如果已知二维随机变量(x，y) 的联合分布，那么其中一个随机变量的分布肯定能够得到，其分布我们称为边缘分布. 边缘分布律\n边缘密度函数 若已知联合密度函数，边缘密度函数可以直接由定义公式计算得到;若已知联合分布函数，首先计算边缘分布函数，再对边缘分布函数求导得到边缘密度函数，第一种方法更简洁，无论使用哪种方法，首先要确定随机变量的值域，在值域上求出密度函数的表达式，值域之外密度函数都为零.\n随机变量的相互独立性\n第四节 条件分布\n在实际工作中，我们经常考虑这样的问题，当一个随机变量的取值确定时，另外一个随机变量的取值规律如何，比如，新生男婴的身高和体重分别用X与Y表示，已知 (X，Y) 的联合分布，新生男婴平均身高为50cm.讨论当男婴身高为5ocm时，男婴体重的分布规律，这需要引入条件分布才能计算，下面给出二维离散型随机变量及二维连续型随机变量的条件分布函数.\n第五节 二维随机变量函数的分布\n当x,y相互独立 这两个公式称为卷积公式\n当x,y相互独立 最大值和最小值分布\n随机变量的数字特征 数学期望\n第二节 方差和标准差 第三节 协方差和相关系数 协方差表示了随机变量间协调变化的关系 协方差有正有负，正的代表正相关，负的代表负相关，一般来说数值越大代表相关性越强，但不同单位下得到的数值有很大的差异，所以经常先对随机变量标准化， 然后求值。 相关系数为0，代表不相关， 第四节 其他数字特征\nk阶矩 变异系数\n分数和中位数\n","permalink":"https://tassel234.github.io/posts/note/%E6%A6%82%E7%8E%87%E8%AE%BA%E5%85%A5%E9%97%A8-2/","summary":"概率论入门-2 前言 使用资源：概率论和数理统计（同济课本） 后续还会针对学校课程的学习对内容进行补充 随机事件与概率 第一节 随机事件及其运算 样本空间和分割 第二节 概率的定义及其性质 第三节 等可能概型 第四节 条件概率与事件的相互独立性 第五节 全概率公式与贝叶斯公式 随机变量及其分布 第一节 随机变量及其","title":"概率论入门-2"},{"content":"前言 使用资源：概率论和数理统计（同济课本）\n大数定律及中心极限定理 超几何分布的极限是二项分布以及泊松定理，即二项分布的极限是泊松分布。 大数定律 得到频率的极限是概率 依概率收敛，稳定.\n在大量相互独立重复试验中可以用某个事件A发生的频率来近似每次试验中事件A发生的概率，这就是伯努利大数定律的直观意义，当n充分大时，频率与其概率能任意接近的概率趋向于1.因此实际中，只要试验次数足够多，可用频率作为概率的估计。同时伯努利大数定律也解释了概率存在的客观意义，为什么“大数次”重复试验下，事件的概率是存在的，正是因为频率的这种稳定性，我们才意识到概率的存在，才有了概率论这门学科。三个大数定律条件是不同的，切比雪夫大数定律不要求随机变量序列同分布，甚至不要求相互独立，只要两两不相关、方差一致有界即可;辛钦大数定律和伯努利大数定律都要求随机变量序列相互独立且同分布，辛钦大数定律不要求方差存在，仅期望存在即可;伯努利大数定律的共同分布限定为两点分布。三个大数定律的条件关系如图所示。\n切比雪夫大数定律不要求随机变量序列相互独立，因而适用面更广。数学的发展从来都是循序渐进的，正因为有了伯努利大数定律，才会有辛钦大数定律进而才有切比雪夫大数定律，大数定律无论在理论还是在实际应用中，都有举足轻重的作用，对概率论和数理统计的发展有着不可替代的作用，是现代概率论、数理统计学、理论科学和社会科学发展的基石。\n中心极限定理 得到正态分布\n统计量和抽样分布 总体与样本 统计量 样本均值和样本方差三大分布 y2分布、t分布、F分布都是从正态总体中衍生出来的，之前介绍的几种常用的统计量的分布在正态总体假定下都与这三大分布有关，所以它们在正态总体的统计推断中起着重要的作用. 正态总体的抽样分布 参数估计 第一节 点估计 在前一章中，我们已经了解总体这个概念，而总体X的分布永远是未知的，通常根据实际情况假定服从某种类型的分布。例如，假定总体X服从正态分布，那么刻画正态分布的均值u和方差C究竟取什么值呢? 在本章中，我们将讨论参数的他计问题。参数估计的形式有两种: 点估计和区间估计。我们从点估计开始\n第二节 点估计的优良性评判标准 无偏性，相合性\n第三节 区间估计 置信区间\n第四节 单正态总体下未知参数的置信区间 第五节 两个正态总体下未知参数的置信区间 假设检验 检验的基本原理 正态总体参数的假设检验 u检验 拟合优度检验 第七章的参数估计是假定总体的分布类型是已知的，需要通过样本来估计亥画总体分布的一个或若千个参数。但是，在实际问题中，经常不知道总体服从1么分布，这时只能假定其为某种分布，那么就需要根据样本数据来检验假设是否合理，即检验假设的总体分布是否可以被接受，又称为分布的拟合检验，常用的方法有x2拟合优度检验\n","permalink":"https://tassel234.github.io/posts/note/%E6%A6%82%E7%8E%87%E8%AE%BA%E5%85%A5%E9%97%A8-1/","summary":"前言 使用资源：概率论和数理统计（同济课本） 大数定律及中心极限定理 超几何分布的极限是二项分布以及泊松定理，即二项分布的极限是泊松分布。 大数定律 得到频率的极限是概率 依概率收敛，稳定. 在大量相互独立重复试验中可以用某个事件A发生的频率来近似每次试验中事件A发生的概率，这就是伯努利大数定","title":"概率论入门-1"},{"content":"《凛冬之刃》读后感 使用资源 《凛冬之刃》电子书\n国产剧《漫长的季节》，共12集，豆瓣9.4分\n木鱼三个小时的功力\n剪影\n时间线\n内容简介 这本书是电视剧遥远的季节的小说原作，电视剧对小说进行了一些改编，小说也补充了电视剧的一些细节。\n小城桦林，此时，出租司机王响做梦也没想到，他还有机会遇到一个他此生最想遇到，又最怕遇到的人。遇到了，就得有交代，给自己，也给儿子。小城桦林，彼时，火车司机王响意气风发，开得了二十挂的钢铁巨兽却管不好鸡毛蒜皮的三口小家，工厂摇摇欲坠，危机处处紧逼。一包身份未明的碎尸像一块石头砸在桦林的水面上，也砸在王响的头脑里，这片涟漪一荡就是20年，荡到秋叶泛黄，从未停歇。迷失的父亲，死亡的恋人、重逢的老友，因一个未解的谜题被困在三个不同的时代里，只为追寻一个跨越了过去、现在、未来的真相，当谜底揭开时，时空融为一体，在漫长的季节里只剩命运的挽歌。\n感想 书影的描写非常接近接近于那个时代，人物的台词也充满了东北特色的豪放气息，而且最难得的一点是人物的对话有一种没有被“文明用语”污染的美感。\n我知道了那个时代的高级招待所，歌舞厅。\n人物 刚开始我比较讨厌龚彪这个角色，因为这个人像一个混子，满嘴脏话，破皮耍赖，擅自动用妻子为了开店攒的的钱，而且还勾搭别的女人。\n但后来我知道龚彪也算是一个比较聪明的人，虽然泼皮，但是比较有能力，可以摆平事情。年轻的龚彪是一个还算比较正经的，长相帅气的大学生，明明前途光明，却在20年后成了混子。龚彪是大学毕业的高材生，一毕业就分配到桦林钢厂做起了厂办科员。相比于一般的工人，也算是个管理层了。\n为什么呢，因为龚彪这个人敢爱敢恨，对于黄丽茹（后来的媳妇）的追求可以说非常热烈和浪漫。在二人还没有确定关系的时候，黄丽茹怀上了厂长的孩子，而厂长因为自己媳妇在工厂里面闹和自己声誉的原因，选择和黄玉茹划清界限，龚彪知道了这个事情后不管之前厂长对自己的提拔，撸起袖子就要把厂长打一顿，后来被王响拉住了（不过之后王响亲手揍了厂长一顿）。黄玉茹因为意外流产，而今后再也没有怀上孩子的能力，龚彪在医院的病床上告诉她自己仍会照顾她爱她一辈子。结婚，一地鸡毛，因为公然反抗厂长，本来没在下岗名单之列的龚彪也被第一个开除了。而开除之后的龚彪只好开起了出租车，好养活他和黄丽茹，让黄丽茹过上幸福的好日子。\n命运 这本书我刚开始看的时候以为是福尔摩斯，后来以为是钱德勒，最后我才明白这部剧是余华的《活着》。\n1998，王响的儿子为了救沈墨被淹死，老婆受不了自杀了。办案的警察队长马德胜也因为压力中风辞职了，王响和马德胜被困在了那个那个季节。王响在失去配偶和孩子后准备卧轨自杀的时候，遇见了一个弃婴，王响为他起名叫王北，为了抚养他，王响活了下去。多年之后，案子终于查清了，自己的朋友龚彪却因为意外死亡，马德胜也因为脑梗而生活不能自理。\n沈墨是桦林杀人碎尸案最核心的人物，她的身上却背负着那么多悲剧的因和果。父母早亡，沈墨被心理变态的亲戚抚养，在猥亵和折磨中长大，如此的一个女孩似乎一辈子都没有不会获得幸福，这个时候王阳像一束光出现在她的生命中，告诉她不要相信命运，命运是可以改变的，这间接导致了沈墨最后决定举起屠刀去进行反抗，杀害那些欺负自己的人。命运从来不会让沈墨获得幸福。\n时代 杀人当然是不对的，这是社会教化给我们的最重要的规训，但即使如此，童年美满，受过教育的王阳还是陪着沈墨一起，杀人，处理尸体，为了救她牺牲了自己的生命。这个事件客观的拿出来绝对会受到很多的批评，但坏就坏在这件事情是有背景的。有种叫爱或者自私的东西，如果犯下大错的是我们的孩子，父母，非常要好的朋友，非常尊敬的人，会让我们在小范围扭曲自己的公平和正义。沈墨从小被恋童的沈栋梁折磨，考上了别地的医学院终于摆脱了他的约束，然后她遇见了不信命，阳光自信的王阳。在王阳的追求下，二人有了暧昧的关系，但接着情况却急转直下，沈墨被沈栋梁公布的裸照破坏了声誉，被一个有钱的老板侵犯，保护自己的弟弟也被黑社会打的半死。王阳，沈墨，傅卫军（弟弟）被逼迫到拿起了屠刀。\n在那个时代下，只是发生了一个非常小的事件，企业发生整改，一群旧的员工需要被裁员。一个企业的厂长利用自己的权利混的风生水起，一个有钱的商人在娱乐场所花天酒地。但这一切却因为人心的黑暗，引发了一系列的悲剧。\n打个响指吧 他说 我们打个共鸣的响指 遥远的事物将被震碎 面前的人们此时尚不知情 吹个口哨吧 我说 你来吹个斜斜的口哨 像一块铁 然后是一枚针 磁极的弧线拂过绿玻璃 喝一杯水吧，也看一看河 在平静时平静 不平静时 我们就错过了一层台阶 一小颗眼泪 滴在石头上 很长时间也不会干涸 整个季节将它结成了琥珀 块状的流淌 具体的光芒 在它背后是些遥远的事物 ","permalink":"https://tassel234.github.io/posts/read/%E5%87%9B%E5%86%AC%E4%B9%8B%E5%88%83%E8%AF%BB%E5%90%8E%E6%84%9F/","summary":"《凛冬之刃》读后感 使用资源 《凛冬之刃》电子书 国产剧《漫长的季节》，共12集，豆瓣9.4分 木鱼三个小时的功力 剪影 时间线 内容简介 这本书是电视剧遥远的季节的小说原作，电视剧对小说进行了一些改编，小说也补充了电视剧的一些细节。 小城桦林，此时，出租司机王响做梦也没想到，他还有机会遇到一个他","title":"《凛冬之刃》读后感"},{"content":"《深度学习的数学》读书笔记-1 前言 目标：\n  稍微了解神经网络和深度学习的数学基础\n  知道如何简单的实现神经网络和深度学习\n  使用资源:\nchatgtp\n深度学习的数学\n基本概念 https://tassel234.github.io/posts/note/%E7%AE%97%E6%B3%95%E9%A2%84%E8%A7%88%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AF%87-3/\n权重的不同才是实现神经网络的基石，比如在图像识别领域，通过不同的特征值附上不同的权重，在识别01时，有非常显著的像素点差异，凭借此附上不同权值的神经网络就可以完成对01的识别。\n数学基础和应用 矩阵的特征向量和特征值 矩阵的特征向量和特征值是线性代数的重要概念，它们在许多领域都有应用，如机器学习、数据分析、优化等。\n  特征向量（Eigenvector）：特征向量是指满足一定条件的向量。在线性代数中，如果一个向量v是一个方阵A的特征向量，那么对于任何非零向量w，有Av = λw，其中λ是一个非零实数，称为特征值。换句话说，特征向量是将方阵A的行空间投影到某个基向量的方向上的向量。更具体地说，特征向量满足 Ax = λx，其中A是一个方阵，x是一个向量，λ是一个实数。\n  特征值（Eigenvalue）：特征值是方阵A的特征向量对应的非零实数，描述了特征向量的大小。特征值可以是负数、零或者正数。一个方阵A的所有特征值之和称为A的谱半径（Spectral Radius）。\n  特征向量和特征值在许多领域都有应用，如：\n 图像处理：可以用特征向量表示图像中的特征，通过特征向量来提取和识别图像中的信息。 机器学习：在机器学习中，特征向量和特征值是将原始数据转换为可以用于机器学习算法的形式的关键步骤。 数据分析：在数据分析中，特征向量和特征值可以帮助我们找到数据中的关键特征，从而更好地理解和解释数据。  总之，特征向量和特征值是线性代数的重要概念，它们在许多领域都有广泛的应用。理解特征向量和特征值的性质和应用，可以帮助我们更好地理解和分析数据。\n在优化问题中，矩阵的特征向量和特征值对解决特定问题有重要作用。它们在许多不同的领域中都有广泛的应用，如线性规划、图论、计算几何等。以下是一些在优化问题中应用特征向量和特征值的例子：\n  线性规划：线性规划是一种特殊的优化问题，其目标是找到一组线性等式和线性不等式，使得一组变量的取值达到最大或最小。在线性规划中，特征向量和特征值非常关键，因为它们可以用来解决约束优化问题。通过找到一组非零特征向量和对应的特征值，我们可以将线性规划问题转化为一个凸优化问题，从而更容易找到全局最优解。\n  图论和网络优化：在图论和网络优化问题中，特征向量和特征值可以用于描述图的特性。例如，在最小生成树问题中，我们可以找到图中的一组特征向量，使得这些向量的线性组合可以描述出图中的最小生成树。\n  计算几何：在计算几何问题中，特征向量和特征值可以用来描述图形的特性。例如，在凸多边形的判定问题中，我们可以找到多边形的一组特征向量，使得这些向量的线性组合可以描述出凸多边形。\n  机器学习和深度学习：在机器学习和深度学习中，特征向量和特征值也有重要作\n  用。在深度学习中，特征提取是一个重要的步骤，通过将原始数据投影到一组特征向量上，可以提高模型的表示能力和泛化能力。\n总的来说，矩阵的特征向量和特征值在优化问题中具有广泛的应用，可以帮助我们更好地理解和解决各种优化问题。\n在数据分析和优化问题中，矩阵的特征向量和特征值具有重要的应用。以下是一些具体的例子：\n  主成分分析（PCA）：主成分分析是一种常用的降维方法，它通过找到一组新的基向量来表示原始数据。这些基向量是原始数据的线性组合，可以最大化数据的方差。在PCA中，特征向量就是这些新的基向量，而特征值则表示对应特征向量的大小，即这些基向量在原始数据中的重要性。通过选择特征值较大的特征向量，可以将原始数据投影到低维空间，同时保留原始数据的大部分方差。\n  线性最小二乘法：线性最小二乘法是一种优化问题的求解方法，它通过最小化残差平方和来找到数据的最优拟合线。在线性最小二乘法中，特征向量和特征值可以用于求解线性方程组，从而找到最优解。这些特征向量和特征值可以将数据投影到基向量上，从而便于线性最小二乘法的求解。\n  正则化和特征选择：在机器学习和数据挖掘中，正则化和特征选择是优化模型泛化能力的重要方法。通过使用正则化方法（如L1正则化或L2正则化），可以在损失函数中添加与特征值相关的惩罚项，从而选择重要的特征。在特征选择方法中，可以通过计算特征的统计量（如互信息、相关性等）来选择具有较高信息量的特征。特征向量和特征值可以用于计算这些统计量，从而帮助我们选择有用的特征。\n  图像压缩：在图像压缩技术中，特征值和特征向量可以用于提取图像的重要特征。例如，可以使用哈尔小波变换提取图像的低频分量和高频分量，将这些特征表示为特征向量和特征值。这些特征向量和特征值可以用于量化图像数据，从而减小图像的数据量，实现图像压缩。\n  总之，矩阵的特征向量和特征值在数据分析和优化问题中具有广泛的应用。通过使用特征向量和特征值，我们可以找到数据的关键特征，从而提高数据处理和分析的效率。\n概率函数和方差 概率函数（probability function）和方差（variance）是概率论和统计学中的两个重要概念。\n  概率函数（probability function）：概率函数是用于描述随机变量取值概率的函数。在离散情况下，概率函数通常被写作P(X=x)，其中x是随机变量X的取值。在连续情况下，概率函数通常被写作P(|X-X_c| \u0026lt; ε)，其中X_c是随机变量X的取值，ε是一个很小的正实数（或0），表示事件的实际界限。\n  方差（variance）：方差是一种衡量随机变量取值分布离散程度的度量。对于离散随机变量X，其方差定义为E[(X - E)^2]，其中E是随机变量X的数学期望。\n  对于连续随机变量X，其方差定义为Var[X] = E[X^2] - (E[X])^2，其中E[X^2]是随机变量X的平方的数学期望。\n概率函数和方差是随机变量分析和推断的重要工具，例如，它们可以用来确定概率分布，以及进行统计推断（如假设检验）。\n梯度下降法 sigmod函数，在梯度下降法中需要对这个函数求导，而他的求导也有一些规律，f'(x) = f(x) * (1 - f(x))，可以配合链式求导使用。对多元函数链式求导计算权重也可以使用。\n梯度下降函数的基础是使用多变量函数的近似值。多元函数的泰勒展开式，以及使用倒数的近似公式，计算向量的内积。两个向量的方向相反时，内积最小，沿着梯度的相反的方向下降最快，使用哈密顿算子可以使表达更简单，符号是倒三角。\nita可以理解为人爬山时的步长，如果步长过大可能跨过最小值点，步长过小会停留在原地，ita在神经网络中被称为学习率，他的确定方法没有明确的标准，只能通过反复的实验去确认。\n梯度下降法也叫最速下降法，是一种优化算法，用于求解损失函数的最小值。在机器学习和人工智能领域，梯度下降法通常用于训练模型中的参数。\n梯度下降法的基本思想是：给定一个损失函数，初始化一个模型参数向量，通过多次迭代，逐步调整模型参数，使得损失函数值逐渐减小，最终接近（或达到）最小值。在每次迭代过程中，梯度下降法会：\n 计算损失函数关于当前参数向量的梯度。 用梯度值与一个预先设定的学习率相乘，得到参数的更新值。 用更新值替代当前参数向量中的对应元素。  重复进行以上步骤，直到满足特定的终止条件（如损失函数值变化很小或达到预设迭代次数）。\n需要注意的是，梯度下降法并不能保证找到全局最优解，只能保证找到局部最优解。在实际应用中，为了更好地寻找全局最优解，通常会使用梯度下降法的变体，如随机梯度下降法（Stochastic Gradient Descent）和小批量梯度下降法（Mini-batch Gradient Descent）。\n神经网络的最优化 神经网络会自己进行学习，这在数学上的含义是指，对权重和偏置进行最优化，使得输出符合学习数据。而对于最优化而言，求导是不可缺少的一种方法。\n神经网络的计算往往会涉及成千上万个变量，这是因为构成神经网络的神经单元的权重和偏置都被作为变量处理。\n代价函数也可以叫目标函数，损失函数，误差函数。\n数据的规模不能小于参数的个数，否则无法确定模型。\n本书使用平方误差作为实际数据和理论值的误差指标。虽然这个指标容易理解，但由于存在计算收敛时间长的情况，所以也有难点为了克服这个缺陷，人们提出了各种各样的误差指标，其中特别有名的一个指标就是交叉熵。\n利用这个交叉熵和 Sigmoid 函数，可以消除Sigmoid函数的冗长性，提高梯度下降法的计算速度。\n此外，交叉熵来源于信息论中熵的思想。\n虽然神经网络和回归分析确定模型的原理相同，但是它们也存在以下差异。\n相比回归分析中使用的模型的参数，神经网络中使用的参数的数目十分巨大。\n线性回归分析中使用的函数为一次式，而神经网络中使用的函数(激活函数)不是一次式。因此，在神经网络的情况下，代价函数变得很复杂。\n代价函数最小化的过程就是最优化的过程，或者也可以说是神经网络学习的过程。通过这个过程不断优化神经网络的参数（偏置和权重），但因为代价函数过于复杂，需要强大的数学武器才可以支持求解。所以需要梯度下降法，但实际上对某些代价函数的求导有时仍然非常困难，所以人们研究出了误差反向传播法。\n误差反向传播 数列和递推可以用来实现误差反向传播（BP）。\n神经单元误差，delta。\n误差反向传播（Error Backpropagation）是一种用于训练人工神经网络的算法。这种算法通过计算损失函数关于模型参数的梯度，然后将梯度反向传播回网络，以调整模型参数，从而最小化损失函数。以下是关于误差反向传播的简要介绍：\n  正向传播：首先，输入数据进入网络，经过各层神经元的计算，最终得到输出。这一过程被称为正向传播（Forward Propagation）。在正向传播过程中，每一层神经元都会计算损失函数关于当前层权重的偏导数。\n  反向传播：反向传播从输出层开始，根据损失函数关于输出层权重的偏导数，使用链式法则依次计算损失函数关于各层权重的偏导数。最后，将这些偏导数用于更新网络权重。\n  更新参数：在得到损失函数关于各层权重的偏导数后，可以使用梯度下降法、随机梯度下降法等优化算法来更新网络参数。更新参数的过程通常会迭代多次，直到模型收敛或达到预设的迭代次数。\n  误差反向传播算法的优势在于，它可以通过梯度计算 guide 参数的更新方向，从而更高效地训练神经网络。然而，误差反向传播也存在一些局限性，如容易受到梯度消失和梯度爆炸等问题的影响。\n","permalink":"https://tassel234.github.io/posts/note/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%95%B0%E5%AD%A6%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-1/","summary":"《深度学习的数学》读书笔记-1 前言 目标： 稍微了解神经网络和深度学习的数学基础 知道如何简单的实现神经网络和深度学习 使用资源: chatgtp 深度学习的数学 基本概念 https://tassel234.github.io/posts/note/%E7%AE%97%E6%B3%95%E9%A2%84%E8%A7%88%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AF%87-3/ 权重的不同才是实现神经网络的基石，比如在图像识别领域，通过不同的特征值附上不同的权重，在识别01时，有非常显著的像素点差异，凭借此附","title":"《深度学习的数学》读书笔记-1"},{"content":"数学建模和算法应用举例-1 前言 使用资源 2017年高教社杯全国大学生数学建模竞赛题目 B题 “拍照赚钱”的任务定价B248\n上海市数学建模教学视频（过上一段时间就自动失效）\nhttps://blog.csdn.net/qq_63438888/article/details/127413453\nchatgpt\naim 我无意了解算法的每一个实现细节，理论推导，只求可以将现实的东西转化为数学的结构，然后可以使用别人写好的算法解决即可。\n考虑不一样的因素。不同的视角\n聚类分析获得重要的确立影响因子 数据预处理 绘图分析，分析定价和什么因素有关。\n距离的变换，值得考虑的点，因为地球是圆的。还有一个对百分比的变换。\n这篇文章用到了非常多稀奇古怪的库和软件，技术，方法，值得之后进行学习。\n问题一 思路 和供货商评估模型的建立类似，建模的人在选择，发现或者创造那些重要的变量。采用一种网格化的思路。数据分析整理量化，得到任务数量、会员人数、会员平均完成能力、任务与中心点的距离这四个指标，并进行了流程图的绘制。\n一些可见的推测，这是他们经验累计而来，先对数据进行了观察，分析，觉得应该和什么有关，然后才进行描述。对于一些专业的领域，其实可以搜索到相当相近的论文（见下面的本文参考文献），然后学习和研究机理，不过我倒是觉得自己建模更可以锻炼水平。\n[1]杜剑平，韩中庚，“互联网+”时代的出租车资源配置模型[J]，数学建模及其应用，2015,4(04):40-49+85. [2017\n熵权法确定会员完成能力。对于供货商模型的连续度也采用了这种方式。计算各会员的任务完成能力值，使用了两个指标，\n文章也应用了运用灰色关联矩阵定量分析四个影响因子与定价的相关度，分别为0.9710,0.9671,0.9633,0.9390。\n补充知识 灰度和灰度关联矩阵\n在数学建模中，\u0026ldquo;灰度\u0026quot;通常指的是数据的强度或级别。例如，在图像处理领域，一个图像的每个像素都可以被表示为一个灰度值，该值表示像素的亮度或颜色的明暗程度。例如，灰度值0表示最暗的颜色，灰度值255表示最亮的颜色。\n在灰度数据中，通常有一个单一的数字表示一个像素的颜色强度。例如，在8位图像中，灰度值的范围从0到255，每个值代表一种不同的颜色强度。而在16位或32位图像中，每个像素可以有更多的颜色通道，如红、绿、蓝三个通道，每个通道都有自己的灰度值范围。\n在数学建模中，灰度数据的处理和分析是很重要的一部分。例如，可以用灰度直方图来展示数据的分布，或者用灰度阈值分割法来对图像进行分割。在机器学习和人工智能领域，灰度数据的特征提取和模型训练也是常见的任务。\n在数学中，矩阵是一个二维数组，它可以存储数值信息或其他类型的数据（例如文本）。矩阵是线性代数的核心概念，常用于解决线性方程组、图像处理、机器学习等问题。在机器学习和人工智能领域，矩阵运算是一个关键概念。许多现代算法，如梯度下降法、卷积神经网络等，都依赖于矩阵运算来进行数据处理和优化。\n灰度关联矩阵是一个在图像处理、模式识别和机器学习领域中常用的工具。它用于描述不同特征之间的关联性，特别是在处理多特征数据（如图像）时，可以帮助我们了解各个特征之间的依赖关系。\n灰度关联矩阵是一种矩阵，其中行和列分别表示特征向量和特征值。矩阵中的元素表示特征向量在特征值下的权重。通常，我们会选择不同的特征值，以便每个特征在矩阵中占据一定的比例。这可以帮助我们更好地了解哪些特征对于目标变量具有较高的相关性。\n在图像处理领域，灰度关联矩阵可以用来计算图像的各种特征（如灰度级、边缘、纹理等）之间的关联性。通过分析这些关联性，我们可以更好地理解图像的结构，为图像分类、物体识别等任务提供有价值的信息。\n** K-Means 聚类分析的K值选择**\nK-Means 算法的一个关键问题是如何选择 K 值，这将直接影响聚类结果。一种常用的方法是肘部法则（Elbow Method），它通过观察聚类结果随着 K 值变化而产生的变化趋势来选择合适的 K 值。\n然而，肘部法则并非总是有效的，因为它在处理具有不同密度和形状的数据集时可能产生不同的结果。在这种情况下，可以使用其他方法，如轮廓系数（Silhouette Coefficient）或基于相似度的方法（如余弦相似度或 Jaccard 相似度）来选择合适的 K 值。\n问题二 思路 以各个准则为约束条件，建立了多目标优化模型。\n比如建立了吸引度矩阵的建立，阈值确定\n问题三 双层聚类分析，\n问题三的模型建立在问题二的模型之上，仍然考虑对模型中的约束进行一定简化，并做出适当假设，得到全局最优解的近似解作为模型最优解。问题三模型任务安排采用打包分配模式，首先通过聚类把类似的任务聚成一类，从而降低了任务的维度。新的任务数即打包数量影响着任务阈值、吸引度矩阵等变量，通过聚类打包求得新的任务情况，从而套用问题二的算法，对部分变量和维度进行修改，经过遍历得到更优结果。\n问题四 老实说完成度不高，神经网络预测模型只是把机理讲了一下，然后就出来了。\n补充知识 吸引度矩阵\n吸引度矩阵（attractiveness matrix）是一种用于描述和分析网络结构中节点之间相互作用的数学工具。在图论中，吸引度矩阵通常用于表示无向图的节点之间的连通性，以及节点之间的连接强度。通过吸引度矩阵，我们可以了解网络中不同节点之间的连接强度和关系模式。\n吸引度矩阵是一个N×N的矩阵，其中N表示图的节点数。矩阵中的元素表示节点i和节点j之间的连接强度。每个元素的取值范围通常在[-1, 1]或[0, 1]，分别表示节点i和节点j之间存在连接或不存在连接，以及连接强度。较高的元素值表示较强的连接，较低的元素值表示较弱的连接。\n吸引度矩阵可以通过多种方法计算，例如狄利克雷(Dirichlet)分布、威布尔(Weibull)分布等。这些方法可以根据网络的特点和需求进行选择。\n吸引度矩阵在许多领域都有应用，如社交网络分析、生物网络分析、推荐系统等。通过分析吸引度矩阵，我们可以了解网络中不同节点之间的连接模式、强度和影响力，从而为网络优化、社区发现和推荐策略提供理论支持。\n在图论和网络科学中，吸引力阈值（attraction threshold）是一个关键概念，用于描述网络中节点之间的连接强度。吸引力阈值是一种量化指标，用于衡量节点之间的连接强度。当节点之间的连接强度超过一定阈值时，我们认为这些节点之间存在吸引力；否则，它们之间的连接相对较弱。\n吸引力阈值可以根据具体问题和需求进行选择。在实际应用中，吸引力阈值可以根据以下因素进行选择：\n 节点的重要性：对于关键节点，我们可能需要设置较高的吸引力阈值以确保它们之间的连接具有较强的稳定性。 网络的拓扑结构：对于不同类型的网络，吸引力阈值可能需要调整。例如，在社区发现问题中，较小的社区可能需要较低的吸引力阈值来保持紧密联系；而在随机网络中，较低的吸引力阈值可能更加合理。 网络的环境变化：随着网络环境的变化，吸引力阈值可能需要相应地调整。例如，当新节点加入网络时，吸引力阈值可能需要提高以确保新节点与已有节点之间的连接足够强。  吸引力阈值的计算方法可以根据网络的特点和需求进行选择。常见的方法包括节点重要度、社区发现算法、协同过滤等。在社交网络、生物网络和推荐系统等领域，吸引力阈值都有广泛的应用。通过合理设置吸引力阈值，我们可以更好地了解网络中节点之间的连接强度和关系模式，为网络优化和应用提供支持。\n2022年C题 玻璃检验 问题 1 分析文物样品表面有无风化化学成分含量的 统计规律，并根据风化点检测数据，预测其风化前 的化学成分含量。\n问题 2 分析玻璃的分类规律；对于每个类别选择合 适的化学成分对其进行亚类划分。\n问题 3 对表单 3 中未知类别玻璃文物的化学成分进 行分析，鉴别其所属类型，分析敏感性。\n问题 4 针对不同类别的玻璃，分析其化学成分之间 的关联关系，比较差异性。\n22年的C题，区分度最大其实是在数据预处理上。\n比例累加应该到100% 。 本 题 中 将 成 分 比 例 紧 加 和 介 于 85%~105% 之 间 的 数 据 视 为 有 效 数 据 。\n这句话十分重要，不能遗漏。首先一些在范围内的非100%的比例，应该扩展为100%，然后还应该对成分数据（百分百数据）进行对数比变换（找论文），改变分布。\n数据的共线性问题，去除共线性的方法：\n数据变换（Logit变换（21年B题乙醇的提示），对数比变换）或者pca分析。\n一个非常大比例的数据越大，其他比例自然也就越小，这就是相关。\n这里实际上是在提醒相关度的事情。两个变量非常相关，直接使用回归分析可能导致和现实相比非常大的谬误（如经济学问题），pca然后回带可以比较有效的解决这个问题。PCA 的奇怪用法，带入回去，可以使用新的主成分进行线性回归，然后把原成分带入回去，（可以通过系数判断强度）获得比较好的回归方程。\n对玻璃文物表面风化与其类型、纹饰和颜色的关系进行分析二维列联表的独立性检验（卡方检验）。分别进行判别，看相关性如何。\n统计规律：以高钾类、铅钡类两个总体按风化和未风化4个，绘制正态分布图形。\n","permalink":"https://tassel234.github.io/posts/note/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%92%8C%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B-1/","summary":"数学建模和算法应用举例-1 前言 使用资源 2017年高教社杯全国大学生数学建模竞赛题目 B题 “拍照赚钱”的任务定价B248 上海市数学建模教学视频（过上一段时间就自动失效） https://blog.csdn.net/qq_63438888/article/details/127413453 chatgpt aim 我无意了解算法的每一个实现细节，理论推导，只求可以将现实的东西转化为数学的结构，然后可以使用别人写好的算法解决","title":"数学建模和算法应用举例-1"},{"content":"第一章 1.1包饺子模型，一斤面和一斤馅原本可以包100个饺子，但某次馅做多了，而面不变，请问是应该少用面多包几个饺子，还是应该多用面包较少的饺子。\n分析：以我建模还没入门的思维，以日常的经验。实际操作中好像不管比例多少，只要别太离谱，都可以把饺子包完。我一开始是想不到馅就是体积。\n但看到解析时发现为了把模型简化，应该认为厚度不变，这可以直接把一斤面转化为表面积的形式。而由表面积可以转化为体积，求出这两者的关系就可以表示用馅的多少。此外还有一个特征系数K值得注意，还有就是配合特征系数K ，【次方】 数学在物理上的意义和应用。\n1.2 路障设计\n分析：我很缺乏常识,不理解原理，如果没有读题目我会认为减速带的作用是通过改变速度方向而减少速度和动能，但这不能说不对但根本解不了题目，减速带的作用应该是为了让车到减速带前速度接近0，来防颠。\n剩下的求解就比较简单了。\n1.3椅子平放问题\n模型非常巧妙，只用了一个未知数，让我明白了简化和等效的意义。简化就是抛弃凳子的立体形状而抽象为正方形，等效是直接把凳子腿的长方体形状砍了，最开始我还考虑为什么只有旋转没有平移，答案就是等效，你在其他地方和在这个地方是等效的，他是以自身为参考系，在任何地方都一样。\n我更没有想到微积分的介值定理可以这么用。\n数学建模的思考，书上说建模应该使用非常简单的数学工具，让更多人可以使用，而不是成为专家级别的孤芳自赏。老实说，我更倾向于为了模型的精确性，无论使用什么样的数学工具。\n第二章 第二章用到了很多我不知道的物理定律，让我意识到了能力的局限。对流，传导，辐射\n解决方法 就是学习物理，听课，认真学大学物理，学费恩曼物理学讲义。\n冰箱和凉席为什么凉快，隔热。\n对于那些建模中的特殊数学方法的名词，借助ai是一个不错的选择。\n不管对第一个问题有一个启示，就是合情的推理，比如杯子的塑料壁和空气壁都按一毫米，肯定是塑料壁的导热性能高。\n第三四章\n书中把第三四节都归为可以解决优化问题。规划模型和优化肯定有非常大的联系.\n3.1储存模型\n分为可以缺货的存储方法和不允许缺货的存储方法。\n3.2救火模型\n可以运用类比法，结合vt图像，求面积和积分的方法。\n3.3啤酒瓶的中心\n因为形状完全一致，前后的质心也应该是一致的，所以有先下降后上升的趋势。力矩平衡定理感觉就是加权法，然后解方程用软件。待入有一个巧合，但其实也可以分析。\n3.4\n高度为0时，45°最好，加上身高可以变形为角度和身高有关。\n4.1奶制品的生产和销售\n这是数学规划模型的例题一，用我高中数学的回忆可以想到，作图法来 求解最优化，用斜率和截距来看。\n影子价格的求解方法我确实不知道，但我可以了解他有什么用。\n我可以了解某个算法可以达到什么样的目的以及大概的操作方法。\n还要知道怎么过度到算法，明白用什么算法\n4.2 自来水供应和货机装运\n学到了怎么写求和符号的取值范围和右标的取值范围\n专业数学计算软件果然np,只需要专注范围的取值就可以了，python不是我的事了。\n货运的模型假设可以的。\n","permalink":"https://tassel234.github.io/posts/note/%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B.%E5%A7%9C%E5%90%AF%E6%BA%90-1/","summary":"第一章 1.1包饺子模型，一斤面和一斤馅原本可以包100个饺子，但某次馅做多了，而面不变，请问是应该少用面多包几个饺子，还是应该多用面包较少的饺子。 分析：以我建模还没入门的思维，以日常的经验。实际操作中好像不管比例多少，只要别太离谱，都可以把饺子包完。我一开始是想不到馅就是体积。 但","title":"数学模型.姜启源-1"},{"content":"算法预览-3 决策树 步骤 构建决策树主要分为三个步骤：特征选择、决策树生成和决策树剪枝。以下是一个简单的决策树实现过程：\n 特征选择 特征选择是决策树构建的关键步骤，目的是找到最优的特征来进行划分。常用的特征选择方法有信息增益、增益率、基尼指数等。这里以信息增益为例进行说明：  计算每个特征的信息增益，选择信息增益最大的特征作为划分依据。\n信息增益的计算公式为：\n信息增益 = 熵(父节点) - 条件熵(子节点)\n其中，熵表示数据集的纯度，条件熵表示在给定特征取值条件下的数据集纯度。计算过程如下：\n 熵(父节点) = -∑(p(i) * log2(p(i)))，其中 i 是类别标签，p(i) 是类别 i 的概率。 条件熵(子节点) = ∑(p(v) * 熵(子节点))，其中 v 是特征的某个取值，p(v) 是特征取值 v 的概率，熵(子节点) 是在给定特征取值 v 的条件下的数据集纯度。  决策树生成 决策树生成过程是一个递归过程。从根节点开始，根据特征选择结果进行划分。对于每个子节点，重复特征选择和划分过程，直到满足停止条件。停止条件通常包括：   所有数据属于同一类别； 无法再继续划分（所有特征已经用完，或者达到最大深度）； 节点中的数据集纯度达到一定程度（如熵值低于某个阈值）。  决策树剪枝 为了防止过拟合，需要对生成的决策树进行剪枝。常用的剪枝方法有预剪枝和后剪枝。预剪枝是在生成决策树的过程中，对每个节点在划分前先进行估计，如果当前节点的划分不能带来泛化性能的提升，则停止划分。后剪枝是先生成一颗完整的决策树，然后自底向上地对非叶节点进行考察，若将该节点对应的子节点替换为叶节点能带来泛化性能的提升，则将该非叶节点替换为叶节点。  实现决策树时，可以选择现有的机器学习库，如Python的scikit-learn库，或者使用专门的决策树算法库，如C4.5、CART等。这些库已经实现了决策树的构建、剪枝等功能，可以方便地进行调用和操作。\n基本结构有决策节点，实例节点，问题。通过计算最大增益度进行实例节点的选择。\n最后可以使用混淆矩阵进行检验。\n优缺点 决策树（Decision Tree）是一种常用的分类和回归算法。它是一种树形结构，其中每个内部节点表示一个特征（属性），每个分支代表一个特征取值，每个叶节点表示一个分类（分类树）或数值（回归树）。决策树的构建过程是一个递归过程，基本思想是根据特征的某个阈值（或一些阈值组合）将数据集划分为两个子集，然后继续这个过程，直到满足停止条件为止。\n构建决策树时，通常使用贪心算法，每次选择最优的特征进行划分，以尽可能纯化子集。但在实际应用中，这种贪心策略可能导致过拟合问题，因此需要采取一些措施，如剪枝（pruning），来减少模型复杂度，提高泛化能力。\n决策树的优点包括：\n 易于理解和实现； 能够处理多种数据类型； 可以自动发现特征之间的关系； 对噪声数据具有较好的鲁棒性。  决策树的缺点包括：\n 可能会过拟合，导致泛化能力较差； 处理连续特征的能力较差； 对于样本不均衡的数据集，容易出现类别不平衡问题。  决策树的应用场景广泛，包括金融、医疗、市场营销、生物信息学等领域。例如，在信用卡欺诈检测、病人诊断、客户细分等场景中，决策树都能发挥重要作用。\n应用 决策树（Decision Tree）是一种非参数的监督学习方法，它在分类和回归问题中都有广泛的应用。其主要优势在于模型易于理解和解释，同时具有较好的泛化能力。以下是决策树的一些主要用途：\n  数据分析和探索：决策树能够帮助我们对数据进行深入的探索和分析，通过树形结构展示出数据的内在关系和特征重要性。\n  特征选择：决策树能够自动地选择对目标变量有较大影响的特征，有助于我们发现数据中的关键特征。\n  分类预测：在分类问题中，决策树能够根据训练数据生成一棵树形结构，用于对新的数据进行分类预测。这种基于树形结构的分类方法具有较强的解释性，能够提供易于理解的分类规则。\n  回归预测：在回归问题中，决策树可以用于生成一棵回归树，通过树形结构进行数值预测。\n  异常值检测：决策树可以对特征空间的划分进行观察，从而发现哪些数据点可能属于异常值。\n  总之，决策树是一种实用、高效的机器学习方法，适用于许多不同类型的预测和分析任务。在具体应用中，我们可以根据问题的性质和数据特点选择合适的决策树算法（如ID3、C4.5、CART等），以提高模型的预测效果和泛化能力。\n决策树在各种领域和场景中具有广泛的应用，以下是一些典型的应用场景：\n  医学诊断：在医学领域，决策树可以用于辅助医生进行疾病诊断。例如，根据病人的症状、体征、实验室检查等数据，建立决策树模型，帮助医生确定病人的疾病类型和严重程度。\n  金融风控：在金融领域，决策树可以用于信用评分、贷款风险评估等任务。例如，根据客户的基本信息、收入、负债、信用历史等数据，建立决策树模型，预测客户信用风险。\n  市场营销：在市场营销领域，决策树可以用于客户细分、产品推荐等任务。例如，根据客户的年龄、性别、购买历史、浏览行为等数据，建立决策树模型，为客户提供个性化的产品推荐。\n  生物信息学：在生物信息学领域，决策树可以用于基因表达数据分析、蛋白质结构预测等任务。例如，根据基因序列、表达数据等特征，建立决策树模型，预测基因的功能或疾病的发生风险。\n  环境监测：在环境监测领域，决策树可以用于空气质量预测、水质量评价等任务。例如，根据气象数据、污染源数据等特征，建立决策树模型，预测未来一段时间内的空气质量。\n  客户服务：在客户服务领域，决策树可以用于客户问题分类、投诉处理等任务。例如，根据客户的咨询内容、历史记录等数据，建立决策树模型，自动为客户分配合适的客服人员或解决方案。\n  这些仅仅是决策树在各领域应用的一部分示例，实际上，决策树可以广泛应用于各种需要分类或回归预测的问题。\nBP神经网络 BP神经网络（Backpropagation Neural Network）是一种广泛使用的前馈神经网络。它由三个基本组成部分组成：输入层、隐藏层和输出层。输入层接收外部数据，隐藏层进行信息处理，输出层对隐藏层的输出进行处理并输出结果。BP神经网络的关键在于反向传播算法（Backpropagation Algorithm），用于调整神经网络中权重和偏置的值。\n步骤 BP神经网络的训练过程如下：\n  初始化：为神经网络中的权重和偏置分配随机值。\n  前向传播：输入数据从输入层进入，经过隐藏层处理，最后到达输出层。输出层的结果表示为 $Y$。\n  计算损失：使用损失函数（如均方误差、交叉熵损失等）计算实际输出与期望输出之间的差异。\n  反向传播：从输出层开始，沿着网络反向传播损失值。对于每个权重，计算梯度 $\\nabla_{\\theta} L$，其中 $\\theta$ 是权重。\n  更新权重和偏置：根据梯度下降法（如牛顿法、梯度下降法、Adam等）更新权重和偏置的值，使得神经网络的预测性能得到改善。\n  重复2-5步：直到满足设定的停止准则（如训练误差达到预定阈值、达到预定迭代次数等）。\n  权重的选择实际可以和遗传算法等智能算法进行结合。\n感知器组件的简要说明如下:\n输入一一描述输入值。在神经元中，这些值对应着输入信号\n灰重一一描述输入和隐藏节点之间每个连接的权重。权重影响输入的强度，并产生加权后的输入。在神经元中，这些连接就是突触。\n隐藏节点(求和与激活一一对加权之后的输入值进行求和，然后对求和结果应用激活函数。激活函数决定隐藏节点(神经元)的激活(输出)。激活函数可以进行使用sigmoid函数，\n输出一一描述感知器的最终输出。\n优缺点 BP神经网络的优点：\n 适合处理非线性问题：通过调整隐藏层的神经元数量和激活函数，BP神经网络可以实现对非线性问题的建模。 具有学习能力：BP神经网络可以自动调整权重和偏置的值，以最小化损失函数。 可扩展性：BP神经网络可以通过堆叠多个隐藏层实现复杂模型，从而具有很强的表达能力。  BP神经网络的缺点：\n 训练时间长：由于需要不断迭代调整权重和偏置的值，BP神经网络的训练时间可能较长。 容易陷入局部最优解：BP神经网络的训练过程可能会陷入局部最优解，而非全局最优解。 对初始值敏感：神经网络的权重和偏置的初始值对训练结果有很大影响。如果初始值不佳，可能导致训练过程不收敛或者收敛速度慢。  神经网络预测模型 神经网络预测模型是一种复杂的机器学习方法，它基于人脑神经系统的工作方式，并在过去的几十年里取得了显著的成果。在这篇文章中，我们将讨论神经网络预测模型的基本原理，包括它们的发展历程、结构、训练方法以及在实际应用中的优势和挑战。\n 引言  神经网络预测模型起源于20世纪50年代，当时心理学家和神经科学家开始研究人脑的工作原理。随着计算机技术的发展，科学家们试图将这些原理应用于机器学习领域，从而开发出能够模仿人脑工作方式的人工智能模型。\n神经网络的基本结构(解构和架构，理解就可以创造)  神经网络由许多相互连接的神经元（也称为节点或处理单元）组成。每个神经元接收来自其他神经元的输入信号，并根据一组权重和偏置值进行加权求和，然后通过激活函数进行处理。输出信号可以传递给其他神经元，形成一个层次化的网络结构。\n神经网络的发展历程  神经网络预测模型的发展可以分为以下几个阶段：\n3.1 早期发展（20世纪50-70年代）\n在这个阶段，研究者们开始尝试将神经科学的原理应用于机器学习领域。神经元和突触的概念被引入到模型中，并使用感知机（perceptron）作为基本的单元。尽管感知机在某些简单问题上表现良好，但它们无法解决复杂的分类问题。\n3.2 反向传播算法的提出（20世纪80年代）\n反向传播算法（backpropagation）的提出使得神经网络的训练变得更加高效。通过调整神经元之间的连接权值和偏置值，神经网络能够学习从输入到输出的映射关系。这使得神经网络在图像识别、语音识别等领域取得了显著的成果。\n3.3 多层感知机和卷积神经网络（20世纪90年代-21世纪初）\n多层感知机（multilayer perceptron, MLP）是一种具有多个隐藏层的神经网络，可以处理更复杂的特征和数据。卷积神经网络（convolutional neural networks, CNN）是一种专门用于图像识别的神经网络，它通过卷积层和池化层来提取图像中的局部特征。这些方法在图像识别、语音识别和自然语言处理等领域取得了重要成果。\n3.4 深度学习和大数据时代（21世纪初至今）\n随着计算能力的提升和大数据的普及，神经网络的训练变得更加高效。深度学习（deep learning）是一种基于多层神经网络的机器学习方法，它通过堆叠多个神经网络层来学习更复杂的特征表示。卷积神经网络、循环神经网络（recurrent neural networks, RNN）和长短时记忆网络（long short-term memory, LSTM）等架构在语音识别、自然语言处理、图像识别和生成等领域取得了突破性进展。\n神经网络的训练方法  神经网络预测模型的训练通常采用梯度下降法（gradient descent）。在训练过程中，模型通过最小化损失函数来调整神经元之间的连接权值和偏置值。常用的损失函数包括均方误差（mean squared error, MSE）、交叉熵损失（cross-entropy loss）和逻辑回归损失（logistic regression loss）等。\n神经网络预测模型的优势和挑战  神经网络预测模型在许多领域都取得了显著的成果，例如图像识别、自然语言处理、语音识别和生物信息学等。它们的主要优势包括：\n 能够学习复杂的特征表示 具有很强的泛化能力，能够处理未见过的数据 可以通过大量的数据进行训练，从而提高模型的准确性和鲁棒性 //鲁棒性（Robustness）是指一个系统、模型或者算法在面对不确定性、噪声和干扰等因素时，仍能保持其预期的性能、功能和准确性的能力。在计算机科学、控制理论、信号处理等领域，鲁棒性都是一个重要的概念。 一个具有鲁棒性的系统通常具有以下特点：   抗干扰性：在受到噪声、干扰或不确定性因素影响时，系统仍能保持稳定运行，不发生严重错误。 容错性：在系统部分元件或组件出现故障时，系统能够继续正常运行，不受影响。 适应性：系统能够适应外部环境的变化，具有一定的自适应能力。 鲁棒性的稳定性：系统在受到扰动时，能够恢复到其正常状态，而不是在扰动下逐渐失去稳定性。//  然而，神经网络预测模型也面临一些挑战，如计算资源需求高、训练时间长、过度拟合（overfitting）等。为了解决这些问题，研究者们提出了许多改进方法，如增大网络规模、采用批量归一化（batch normalization）和正则化（regularization）技术等。\n总结\n神经网络预测模型已经成为现代机器学习领域的一个重要分支。它们通过模拟人脑的工作方式，能够学习复杂的特征表示和数据之间的关系。随着计算能力的提升和大数据的普及，神经网络预测模型在图像识别、语音识别、自然语言处理等领域取得了突破性进展。然而，神经网络预测模型仍然面临一些挑战，如计算资源需求高、训练时间长和过度拟合等。为了解决这些问题，研究者们需要继续探索新的方法和技术，以充分发挥神经网络预测模型的潜力。\n梯度下降法 梯度下降法（Gradient Descent，GD）是一种用于优化函数的数值方法。它的基本思想是通过迭代更新参数，以使目标函数（优化问题的目标函数）的值逐步降低，从而找到最优解或次优解。梯度下降法是一种线性搜索方法，适用于解决具有梯度信息的优化问题。\n梯度下降法的一般步骤如下：\n  初始化：选择一个初始参数值，例如随机选择一组初始参数。\n  计算梯度：计算目标函数在当前参数值下的梯度。梯度是一个向量，表示目标函数在当前参数值下的斜率。梯度可以通过求导计算得到。\n  更新参数：使用当前参数值和计算得到的梯度作为参数更新公式的参数。更新公式可能是线性的（如步长为1）、平方的（如步长为0.5）或其他形式。\n参数更新公式：\n参数 = 参数 - 学习率 × 梯度\n  检查停止条件：在每次迭代过程中，你需要检查目标函数的值是否有所改善。如果目标函数的值没有改善，你可以停止迭代。常见的停止条件包括设置一个最大迭代次数、判断目标函数的值是否小于某个阈值，或者判断目标函数的值是否在某个范围内等。\n  返回结果：如果目标函数的值在迭代过程中有所改善，你可以继续迭代，直到达到停止条件。最后，你可以将得到的结果作为优化函数的最小值或最大值。\n  梯度下降法在实际应用中广泛用于解决各种优化问题。然而，梯度下降法可能会陷入局部最优解，而不是全局最优解。为了避免这种情况，你可以尝试使用不同的梯度下降法变种，如批量梯度下降法、随机梯度下降法、小批量梯度下降法等。此外，你还可以使用动量、RMSprop等优化策略来加快梯度下降法的收敛速度。\n蒙特卡洛模拟 蒙特卡洛模拟和穷举法耗时耗力，时间复杂度过高\n蒙特卡罗方法（Monte Carlo method），又称随机抽样或统计模拟方法，是一种以概率统计理论为指导的一类非常重要的数值计算方法。此方法使用随机数（或更常见的伪随机数）来解决很多计算问题的方法。 由于传统的经验方法由于不能逼近真实的物理过程，很难得到满意的结果，而蒙特卡罗方法由于能够真实地模拟实际物理过程，故解决问题与实际非常符合，可以得到很圆满的结果。 原理：当所求解问题是某种随机事件出现的概率，或者是某个随机变量的期望值时，通过某种“实验”的方法，以这种事件出现的频率估计这一随机事件的概率，或者得到这个随机变量的某些数字特征，并将其作为问题的解。\n蒙特卡洛模拟（Monte Carlo Simulation）是一种数值计算方法，它通过从一个概率分布中随机抽样来建立数学模型。这种方法广泛应用于经济学、工程学、物理学、计算机科学等领域，用于解决各种复杂的优化问题和不确定性问题。\n蒙特卡洛模拟的基本思想是：当我们需要解决一个实际问题时，可以通过在一个随机抽样过程中统计抽样数据，从而得到问题的统计性质。通过对这些统计性质的研究，我们可以得到关于问题的概率模型，并据此建立数学模型。\n以下是蒙特卡洛模拟的一般步骤：\n  定义问题：首先，你需要清楚地定义你要解决的问题。这可能涉及到找到一个函数的最小值、最大值、区间、统计结果等。\n  选择随机抽样方法：蒙特卡洛模拟通常需要从一个概率分布中进行随机抽样。你需要选择一个适当的抽样方法，如均匀抽样、几何抽样、高斯抽样等。\n  进行随机抽样：在每个抽样步骤中，你需要从抽样分布中随机选择一个样本。这个过程可以通过随机数发生器来实现。\n  处理抽样结果：一旦你得到了一组抽样数据，你需要对这些数据进行统计分析，以获取问题的统计性质。这可能涉及到计算均值、方差、概率密度函数等。\n  建立数学模型：根据问题的统计性质，你可以建立一个数学模型来描述问题。这个模型可能是一个线性方程、一个微分方程、一个概率分布等。\n  求解数学模型：一旦你建立了数学模型，你可以使用数值方法（如牛顿法、梯度下降法等）来求解模型。\n  评估结果：最后，你需要评估你得到的结果。这可能涉及到比较实际结果和预期结果，或者评估解决方案的可靠性和可行性。\n  蒙特卡洛模拟的一个重要优势是，它可以处理具有不确定性和复杂性的问题。通过从一个随机抽样过程中收集数据，蒙特卡洛模拟可以帮助我们更好地理解问题的本质，并找到更有效的解决方案。\n","permalink":"https://tassel234.github.io/posts/note/%E7%AE%97%E6%B3%95%E9%A2%84%E8%A7%88%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AF%87-3/","summary":"算法预览-3 决策树 步骤 构建决策树主要分为三个步骤：特征选择、决策树生成和决策树剪枝。以下是一个简单的决策树实现过程： 特征选择 特征选择是决策树构建的关键步骤，目的是找到最优的特征来进行划分。常用的特征选择方法有信息增益、增益率、基尼指数等。这里以信息增益为例进行说明： 计算每个特征的","title":"算法预览（数学建模篇-3）"},{"content":"前言 使用资源： 人工智能算法图解\nhttps://github.com/rishal-hurbans/Grokking-Artificial-Intelligence-Algorithms\nhttps://www.zhihu.com/people/MicrostrongAI/posts?page=2\nchatgtp\naim  知道算法可以解决什么问题 对一些重要的算法要知道每行代码代表代码，然后可以进行修改  lightgbm LightGBM（Light Gradient Boosting Machine）是一种基于梯度提升框架的高效机器学习算法，由微软亚洲研究院的研究员提出。LightGBM主要针对GBDT（Gradient Boosting Decision Tree）算法进行了优化，以提高训练速度和精度。\nGBDT不仅在工业界应用广泛，通常被用于多分类、点击率预测、搜索排序等任务；在各种数据挖掘竞赛中也非常实用，LightGBM在许多机器学习竞赛中表现出了优秀的性能，如Kaggle竞赛等。\nLightGBM的主要优势如下：\n  更快的训练速度：LightGBM采用了一种基于梯度的单边采样算法，可以减少样本的使用，降低模型训练时间。此外，LightGBM还使用了一种称为“互斥特征捆绑”的技术，可以减少特征的数量，进一步提高训练速度。\n  更高的精度：通过对决策树算法进行优化，LightGBM可以在相对较少的迭代次数内达到较高的精度。此外，LightGBM引入了一种称为“Gradient-based One-Side Sampling”（GOSS）的策略，可以在一定程度上减小过拟合的风险。\n  更好的处理稀疏数据能力：LightGBM针对稀疏数据进行了优化，可以有效处理高维稀疏数据。此外，LightGBM使用了一种基于直方图的决策树算法，可以降低稀疏数据带来的计算开销。\n  并行化和分布式计算：LightGBM支持并行化和分布式计算，可以充分利用计算资源，提高训练速度。\n  鲁棒性强：LightGBM对异常值和噪声数据具有较好的鲁棒性，能够在一定程度上减小这些数据对模型训练的影响。\n  LightGBM主要应用于回归和分类问题，如点击率预测、图像分类、文本分类等。在实际应用中，LightGBM往往可以通过调整参数和特征工程等方法，取得较好的性能。\nLightGBM作为一种高效的机器学习算法，具有广泛的应用。以下是一些常见的应用领域：\n  推荐系统：LightGBM可以用于构建推荐系统，对用户行为、兴趣和历史数据进行建模，从而实现个性化推荐。例如，在用户点击率预测、购买行为预测等场景中，LightGBM可以提供准确的预测结果。\n  金融风控：在金融风控领域，LightGBM可以用于构建信用评分模型，预测客户的信用风险。此外，LightGBM还可以应用于欺诈检测、交易风险评估等场景。\n  医疗健康：在医疗健康领域，LightGBM可以用于疾病预测、患者分群、药物研发等任务。例如，在预测患者疾病风险、分析疾病与基因之间的关系等方面，LightGBM可以发挥重要作用。\n  图像识别与分类：LightGBM可以用于图像识别和分类任务，如物体检测、场景分类等。通过将图像数据转换为特征向量，LightGBM可以构建高效且准确的分类模型。\n  自然语言处理：在自然语言处理领域，LightGBM可以用于文本分类、情感分析、命名实体识别等任务。通过将文本数据转换为特征向量，LightGBM可以为这些任务提供高性能的解决方案。\n  工业制造与物联网：在工业制造与物联网领域，LightGBM可以用于设备故障预测、生产计划优化、产品质量控制等任务。通过分析设备运行数据、生产流程数据等，LightGBM可以为企业提供有价值的决策支持。\n  交通运输与物流：在交通运输与物流领域，LightGBM可以用于路线规划、货运需求预测、库存管理等任务。通过分析历史数据和实时数据，LightGBM可以为企业提供更高效的运营策略。\n  这些应用领域仅是LightGBM的一部分，随着研究的深入和技术的发展，LightGBM将在更多领域发挥重要作用。\n蚁群算法 蚁群算法（Ant Colony Optimization, ACO）是一种基于自然界蚂蚁行为的启发式搜索算法，它模拟蚂蚁在寻找食物过程中如何通过信息素来引导其他蚂蚁找到最短路径。蚁群算法具有分布式计算、全局搜索和自适应性等优点，广泛应用于组合优化、路径规划、调度问题等领域。\n基本步骤 蚁群算法的基本思想是：\n 初始化：为问题定义解空间，并随机为每个解分配一个信息素值。 构建解：蚂蚁在解空间中搜索最优解，搜索过程中根据信息素浓度和启发式信息来选择下一步移动。 信息素更新：蚂蚁在搜索过程中会留下信息素，当其他蚂蚁经过时，会根据当前信息素浓度和启发式信息来选择下一步移动。 停止条件：达到预设最大迭代次数或者找到满足条件的解。  蚁群算法主要包括以下三个要素：\n  信息素（pheromone）：信息素是蚂蚁之间通信的媒介，模拟了蚂蚁在自然界中留下的化学物质痕迹。信息素会随着时间逐渐挥发，可以通过调整挥发系数来控制信息素的持久性。\n  启发式信息（heuristic information）：启发式信息用于指导蚂蚁在解空间中进行搜索。启发式信息可以是解的估值函数，如贪心策略或随机策略等。\n  信息素更新规则：蚁群算法通过信息素更新规则来平衡全局搜索和局部搜索。常用的信息素更新规则有：Ant-Quantity-Based, Ant-Density-Based 和 Max-Min Ant System 等。\n  以寻找游玩游乐场项目的最短路径实例，项目之间构成完全图。距离由距离矩阵编写。\n初始化信息素印迹应该都赋值相同的数字，比如1。\n蚂蚁会移动到不同的游乐项目处，留下信息蚂蚁还会判断接下来要去哪个游乐项目。最后，蚂蚁会知道它们各自的总移动离。下面列出了蚂蚁的基本属性:\n记忆一一在蚁群优化算法中，这代表着已经访问过的游乐项目列表\n最佳适应度一一这是经过所有项目的最短总距离\n行动一选择下一个目的地，并沿途留下信息素\n可以对这些对象进行抽象，封装，面向对象编程。\n建立蚂蚁种群，从随机分配的项目开始，遍历一遍所有的路，然后回到出发点，蚂蚁走过这条路就会让这条路的信息素强度加一。启发式的值代表我们已经知道 的一些信息，有点类似A*算法，在游乐场路径遍历 的例子中启发式的值就是距离，然后可以通过计算选择路径。\n最后算出的结果仍然是进行轮盘法抽取下一个地点。\n更新信息素，即跑完一轮后对信息素进行蒸发，最后信息素强度代表在上一轮过程中有多少乘以蒸发率加上路程之和之和的倒数，第一轮初始为1。\n达到预定的迭代次数时停止。在这一场景中，我们将终止条件设置为算法需要运行的迭代总数。如果把终止条件定义为 100 次选代，则每只蚁需要在算法终止前完成 100 次旅行。\n在最佳解决方案停滞不前时停止。在这种情况下，我们将每次选代后的最佳解与之前的最佳解进行比较。如果在规定的迭代次数后，最佳解决方案没有变化，则算法终止。譬如，若第 20 次选代产生了一个适应度为100 的最佳解，并且直到第 30 次选代，最佳解依然为这个解，则很可能(但不保证)并不存在更好的解。\n代码实现 import csv import random import math # Ant Colony Optimization (ACO) # The Ant Colony Optimization algorithm is inspired by the behavior of ants moving between destinations, dropping # pheromones and acting on pheromones that they come across. The emergent behavior is ants converging to paths of # least resistance. # Set the number of attractions in the data set # Best total distance for 5 attractions: 19 # Best total distance for 48 attractions: 33523 ATTRACTION_COUNT = 48 # Initialize the 2D matrix for storing distances between attractions attraction_distances = [] # Read attraction distance data set store it in matrix with open(\u0026#39;attractions-\u0026#39; + str(ATTRACTION_COUNT) + \u0026#39;.csv\u0026#39;) as file: reader = csv.reader(file, quoting=csv.QUOTE_NONNUMERIC) for row in reader: attraction_distances.append(row) # Set the probability of ants choosing a random attraction to visit (0.0 - 1.0) RANDOM_ATTRACTION_FACTOR = 0.0 # Set the weight for pheromones on path for selection ALPHA = 4 # Set the weight for heuristic of path for selection BETA = 7 # The Ant class encompasses the idea of an ant in the ACO algorithm. # Ants will move to different attractions and leave pheromones behind. Ants will also make a judgement about which # attraction to visit next. And lastly, ants will have knowledge about their respective total distance travelled. # - Memory: In the ACO algorithm, this is the list of attractions already visited. # - Best fitness: The shortest total distance travelled across all attractions. # - Action: Choose the next destination to visit and drop pheromones along the way. class Ant: # The ant is initialized to a random attraction with no previously visited attractions def __init__(self): self.visited_attractions = [] self.visited_attractions.append(random.randint(0, ATTRACTION_COUNT - 1)) # Select an attraction using a random chance or ACO function def visit_attraction(self, pheromone_trails): if random.random() \u0026lt; RANDOM_ATTRACTION_FACTOR: self.visited_attractions.append(self.visit_random_attraction()) else: self.visited_attractions.append( self.roulette_wheel_selection(self.visit_probabilistic_attraction(pheromone_trails))) # Select an attraction using a random chance def visit_random_attraction(self): all_attractions = set(range(0, ATTRACTION_COUNT)) possible_attractions = all_attractions - set(self.visited_attractions) return random.randint(0, len(possible_attractions) - 1) # Calculate probabilities of visiting adjacent unvisited attractions def visit_probabilistic_attraction(self, pheromone_trails): current_attraction = self.visited_attractions[-1] all_attractions = set(range(0, ATTRACTION_COUNT)) possible_attractions = all_attractions - set(self.visited_attractions) possible_indexes = [] possible_probabilities = [] total_probabilities = 0 for attraction in possible_attractions: possible_indexes.append(attraction) pheromones_on_path = math.pow(pheromone_trails[current_attraction][attraction], ALPHA) heuristic_for_path = math.pow(1 / attraction_distances[current_attraction][attraction], BETA) probability = pheromones_on_path * heuristic_for_path possible_probabilities.append(probability) total_probabilities += probability possible_probabilities = [probability / total_probabilities for probability in possible_probabilities] return [possible_indexes, possible_probabilities, len(possible_attractions)] # Select an attraction using the probabilities of visiting adjacent unvisited attractions @staticmethod def roulette_wheel_selection(probabilities): slices = [] total = 0 possible_indexes = probabilities[0] possible_probabilities = probabilities[1] possible_attractions_count = probabilities[2] for i in range(0, possible_attractions_count): slices.append([possible_indexes[i], total, total + possible_probabilities[i]]) total += possible_probabilities[i] spin = random.random() result = [s[0] for s in slices if s[1] \u0026lt; spin \u0026lt;= s[2]] return result[0] # Get the total distance travelled by this ant def get_distance_travelled(self): total_distance = 0 for a in range(1, len(self.visited_attractions)): total_distance += attraction_distances[self.visited_attractions[a]][self.visited_attractions[a-1]] total_distance += attraction_distances[self.visited_attractions[0]][self.visited_attractions[len(self.visited_attractions) - 1]] return total_distance def print_info(self): print(\u0026#39;Ant \u0026#39;, self.__hash__()) print(\u0026#39;Total attractions: \u0026#39;, len(self.visited_attractions)) print(\u0026#39;Total distance: \u0026#39;, self.get_distance_travelled()) # The ACO class encompasses the functions for the ACO algorithm consisting of many ants and attractions to visit # The general lifecycle of an ant colony optimization algorithm is as follows: # - Initialize the pheromone trails: This involves creating the concept of pheromone trails between attractions # and initializing their intensity values. # - Setup the population of ants: This involves creating a population of ants where each ant starts at a different # attraction. # - Choose the next visit for each ant: This involves choosing the next attraction to visit for each ant. This will # happen until each ant has visited all attractions exactly once. # - Update the pheromone trails: This involves updating the intensity of pheromone trails based on the ants’ movements # on them as well as factoring in evaporation of pheromones. # - Update the best solution: This involves updating the best solution given the total distance covered by each ant. # - Determine stopping criteria: The process of ants visiting attractions repeats for a number of iterations. One # iteration is every ant visiting all attractions exactly once. The stopping criteria determines the total number of # iterations to run. More iterations will allow ants to make better decisions based on the pheromone trails. class ACO: def __init__(self, number_of_ants_factor): self.number_of_ants_factor = number_of_ants_factor # Initialize the array for storing ants self.ant_colony = [] # Initialize the 2D matrix for pheromone trails self.pheromone_trails = [] # Initialize the best distance in swarm self.best_distance = math.inf self.best_ant = None # Initialize ants at random starting locations def setup_ants(self, number_of_ants_factor): number_of_ants = round(ATTRACTION_COUNT * number_of_ants_factor) self.ant_colony.clear() for i in range(0, number_of_ants): self.ant_colony.append(Ant()) # Initialize pheromone trails between attractions def setup_pheromones(self): for r in range(0, len(attraction_distances)): pheromone_list = [] for i in range(0, len(attraction_distances)): pheromone_list.append(1) self.pheromone_trails.append(pheromone_list) # Move all ants to a new attraction def move_ants(self, ant_population): for ant in ant_population: ant.visit_attraction(self.pheromone_trails) # Determine the best ant in the colony - after one tour of all attractions def get_best(self, ant_population): for ant in ant_population: distance_travelled = ant.get_distance_travelled() if distance_travelled \u0026lt; self.best_distance: self.best_distance = distance_travelled self.best_ant = ant return self.best_ant # Update pheromone trails based ant movements - after one tour of all attractions def update_pheromones(self, evaporation_rate): for x in range(0, ATTRACTION_COUNT): for y in range(0, ATTRACTION_COUNT): self.pheromone_trails[x][y] = self.pheromone_trails[x][y] * evaporation_rate for ant in self.ant_colony: self.pheromone_trails[x][y] += 1 / ant.get_distance_travelled() # Tie everything together - this is the main loop def solve(self, total_iterations, evaporation_rate): self.setup_pheromones() for i in range(0, TOTAL_ITERATIONS): self.setup_ants(NUMBER_OF_ANTS_FACTOR) for r in range(0, ATTRACTION_COUNT - 1): self.move_ants(self.ant_colony) self.update_pheromones(evaporation_rate) self.best_ant = self.get_best(self.ant_colony) print(i, \u0026#39; Best distance: \u0026#39;, self.best_ant.get_distance_travelled()) # Set the percentage of ants based on the total number of attractions NUMBER_OF_ANTS_FACTOR = 0.5 # Set the number of tours ants must complete TOTAL_ITERATIONS = 10000 # Set the rate of pheromone evaporation (0.0 - 1.0) EVAPORATION_RATE = 0.4 aco = ACO(NUMBER_OF_ANTS_FACTOR) aco.solve(TOTAL_ITERATIONS, EVAPORATION_RATE) 蚁群算法的优点和缺点 蚁群算法具有以下优点：\n  分布式计算：蚁群算法利用多只蚂蚁同时搜索问题空间，这些蚂蚁可以在不同的解空间中进行独立搜索。这种分布式计算方式有助于提高搜索效率，避免过早陷入局部最优解。\n  自适应性：蚁群算法能够根据问题特征和环境变化动态调整搜索策略。例如，信息素挥发和更新规则可以使算法在搜索过程中自动平衡全局探索和局部挖掘。\n  优秀的全局搜索能力：蚁群算法具有较强的全局搜索能力，可以在较大规模的问题空间中找到近似最优解。这是因为蚂蚁在搜索过程中不仅考虑局部信息，还会受到其他蚂蚁留下的信息素的影响，从而在一定程度上避免了局部最优解。\n  适用于离散和连续问题：蚁群算法可以处理离散和连续型问题。对于离散问题，蚂蚁可以在解空间中移动；对于连续问题，可以将问题离散化，或将蚂蚁移动到相邻解空间。\n  鲁棒性强：蚁群算法对问题的初始条件和参数设置具有较好的鲁棒性。即使初始解不理想或参数设置不合理，算法仍然有可能在搜索过程中找到较好的解。\n  易于实现：蚁群算法的实现相对简单，易于理解和实现。此外，由于其分布式计算特性，蚁群算法可以很容易地实现并行化，提高计算效率。\n  尽管蚁群算法具有以上优点，但其收敛速度较慢，容易陷入局部最优解。因此，在具体应用过程中，为了提高搜索效率，研究人员提出了许多改进方法，如：多蚁群系统、精英策略、ACS 算法等。\n蚁群算法的应用 蚁群算法具有广泛的应用，主要包括以下几个方面：\n  组合优化问题：蚁群算法可以有效地解决旅行商问题（TSP）、车辆路径问题（VRP）、背包问题等组合优化问题。通过构建解空间和设计合适的信息素更新规则，蚁群算法可以在这些问题中找到近似最优解。\n  调度与分配问题：蚁群算法可以用于解决作业车间调度问题、生产计划问题、任务分配问题等。这些调度与分配问题通常具有离散、复杂的特点，蚁群算法能够在较大的解空间中找到较优解。\n  图论与网络优化：蚁群算法在图论和网络优化问题中也有广泛应用，如最大割问题、最小生成树问题、最短路径问题等。通过设计合适的启发式信息，蚁群算法可以在这些问题中取得较好的结果。\n  机器学习与人工智能：蚁群算法在人工神经网络、聚类分析、模式识别等领域也有一定应用。通过模拟自然界蚂蚁的协作行为，蚁群算法可以为这些领域提供有效的优化方法。\n  机器人路径规划：蚁群算法可以应用于机器人的路径规划问题，如避障导航、目标搜索等。蚁群算法可以为机器人提供一种高效的搜索策略，使其在复杂环境中找到最优路径。\n  电力系统与能源管理：蚁群算法在电力系统调度、能源管理等领域也有应用，如机组组合问题、电力负荷调度问题等。通过求解这些问题，蚁群算法可以为电力系统提供更好的运行策略和能源管理方案。\n  金融与经济学：蚁群算法还可以应用于金融和经济学领域，如投资组合优化、风险管理、市场预测等。通过模拟自然界的协作行为，蚁群算法可以为这些问题提供有效的优化方法。\n  这些应用领域仅是蚁群算法众多应用之一，随着研究的深入，蚁群算法将继续拓展到更多的领域，为实际问题的求解提供新的思路和方法。\n粒子群算法 粒子群优化（Particle Swarm Optimization, PSO）是一种基于群体智能的全局优化算法，由Kennedy和Eberhart于1995年首次提出。PSO算法模拟了鸟群或者鱼群在寻找食物过程中的行为，通过群体中个体之间的协作来搜索最优解。它具有较强的全局搜索能力，在很多领域，如函数优化、机器学习、神经网络训练等，都得到了广泛应用。\n实现步骤 PSO算法的基本原理可以概括为以下几点：\n  初始化和计算适应度：在问题的搜索空间中，随机生成一群粒子（搜索代理），并为每个粒子随机分配一个初始位置和初始速度。确定当前位置的适应度。\n  速度更新：每个粒子根据自身的速度和历史最优位置（pBest）以及群体历史最优位置（gBest）来更新自己的速度和位置。速度更新的公式如下：\nv_i(t+1) = w * v_i(t) + c1 * r1 * (pBest_i - x_i(t)) + c2 * r2 * (gBest - x_i(t))\n其中，v_i(t)表示粒子i在时刻t的速度，x_i(t)表示粒子i在时刻t的位置，w表示惯性权重，c1和c2是加速因子，r1和r2是随机因子。\n  位置更新：根据更新后的速度，更新每个粒子的位置。位置更新的公式如下：\nx_i(t+1) = x_i(t) + v_i(t+1)\n  终止条件：当达到预定的迭代次数或满足其他终止条件时，算法停止运行。此时，算法输出的最优解即为问题的近似最优解。\n  一种受大雁飞行的启发式算法，\n以下元素构成了粒子的概念:\n位置一粒子在问题空间中的坐标，由所有维度构成的向量来描述\n最佳位置一利用适应度函数所能找到的最佳位置\n速度一粒子运动的当前速度\n初始化粒子群需要考虑的三个重要因素:\n粒子数量一一粒子数量将直接影响计算量。粒子越多，需要的计算量就越大。此外，更多的粒子可能意味着需要更长的时间才能收敛到全局最优解，因为更多的粒子可能被吸引到它们所在位置附近的局部最优解。问题的约束条件也会影响粒子数量的设置。更大的搜索空间可能需要更多的粒子来探索它。粒子数量可能多达 1000 个，也可能少至4个。通常来说，50~100 个粒子就可产生理想的解决方案,同时在计算上不会太耗时。\n每个粒子的起始位置\u0026ndash;每个粒子的起始位置应该是在各个维度上的随机位置。粒子必须在搜索空间中均匀分布。如果大多数粒子都分布在搜索空间的某个特定区域，它们将很难找到该区域之外的解决方案。\n每个粒子的初始速度一粒子的速度被初始化为 0，因为此时粒子尚未受到影响。这就好比鸟类从静止的位置起飞。\n开发人员通常用三个分量来计算每个粒子的新速度:惯性(imertia)、认知(cognitive)和社交(social)。\n惯性一一惯性分量代表特定粒子运动快慢或运动方向要发生变化时受到的阻力，这种阻力会对粒子的速度产生影响。惯性分量由两个值组成:惯性常数和粒子的当前速度。惯性常数是一个介于 0和 1之间的数字。接近0的惯性常数意味着算法更倾向于探索，可能需要更多次的选代。接近 1的惯性常数意味着在更少的迭代中对粒子进行更多的探索。\n惯性代表了原来的速度，惯性分量=惯性常数 *当前速度。\n认知一一认知分量代表特定粒子的自我认知能力。认知能力指的是粒子知道其最佳位置并利用这一位置影响其运动的能力。认知常数是一个大于 0小于 2 的浮点数。认知常数越大，粒子就越倾向于利用自身的信息。\n认知分量也可以计算处理，他代表了个体最佳位置。\n社交一一社交分量代表粒子与群体互动的能力。粒子知道群体的最佳位置，并能使用这一信息来影响其运动。社交加速度由一个常数和一个随机数决定。社交常数在算法的生命周期内保持不变，而随机社交因子会引入有利于社交因素的多样性。社交常数越大，算法就越倾向于探索，因为粒子的速度矢量会更偏向于它的社交分量。社交常数为介于 0和 2之间的某个浮点数。更大的社交常数意味着更多的探索。\n社交分量代表群体最佳位置。\n下面是一种用来理解位置更新的图，实际计算是是对那些分量进行标量相加即可。\n确定终止条件，当最佳解决方案停滞时，可以试着调节速度更新的各个参数\n代码实现 import math import random # The function that is being optimized. Namely the Booth function. # Reference: https://en.wikipedia.org/wiki/Test_functions_for_optimization def calculate_booth(x, y): return math.pow(x + 2 * y - 7, 2) + math.pow(2 * x + y - 5, 2) # Particle Swarm Optimization (PSO) # Representing the concept of a particle: # - Position: The position of the particle in all dimensions. # - Best position: The best position found using the fitness function. # - Velocity: The current velocity of the particle’s movement. class Particle: # Initialize a particle; including its position, inertia, cognitive constant, and social constant def __init__(self, x, y, inertia, cognitive_constant, social_constant): self.x = x self.y = y self.fitness = math.inf self.velocity = 0 self.best_x = x self.best_y = y self.best_fitness = math.inf self.inertia = inertia self.cognitive_constant = cognitive_constant self.social_constant = social_constant self.update_fitness() # Get the fitness of the particle def get_fitness(self): return self.fitness # Update the particle\u0026#39;s fitness based on the function we\u0026#39;re optimizing for def update_fitness(self): self.fitness = calculate_booth(self.x, self.y) if self.fitness \u0026lt; self.best_fitness: self.best_fitness = self.fitness self.best_x = self.x self.best_y = self.y # Calculate the inertia component for the particle # inertia * current velocity @staticmethod def calculate_inertia(inertia, current_velocity): return inertia * current_velocity # Calculate the cognitive component for the particle # cognitive acceleration * (particle best solution - current position) def calculate_cognitive(self, cognitive_constant, cognitive_random, particle_best_position_x, particle_best_position_y, particle_current_position_x, particle_current_position_y): cognitive_acceleration = self.calculate_acceleration(cognitive_constant, cognitive_random) cognitive_distance = math.sqrt(((particle_best_position_x-particle_current_position_x)**2) + ((particle_best_position_y-particle_current_position_y)**2)) return cognitive_acceleration * cognitive_distance # Calculate the social component for the particle # social acceleration * (swarm best position - current position) def calculate_social(self, social_constant, social_random, swarm_best_position_x, swarm_best_position_y, particle_current_position_x, particle_current_position_y): social_acceleration = self.calculate_acceleration(social_constant, social_random) social_distance = math.sqrt(((swarm_best_position_x-particle_current_position_x)**2) + ((swarm_best_position_y-particle_current_position_y)**2)) return social_acceleration * social_distance # Calculate acceleration for the particle @staticmethod def calculate_acceleration(constant, random_factor): return constant * random_factor # Calculate the new velocity for the particle @staticmethod def calculate_updated_velocity(inertia, cognitive, social): return inertia + cognitive + social # Calculate the new position for the particle @staticmethod def calculate_position(current_position_x, current_position_y, updated_velocity): return current_position_x + updated_velocity, current_position_y + updated_velocity # Perform the update on inertia component, cognitive component, social component, velocity, and position def update(self, swarm_best_x, swarm_best_y): i = self.calculate_inertia(self.inertia, self.velocity) print(\u0026#39;Inertia: \u0026#39;, i) c = self.calculate_cognitive(self.cognitive_constant, random.random(), self.x, self.y, self.best_x, self.best_y) print(\u0026#39;Cognitive: \u0026#39;, c) s = self.calculate_social(self.social_constant, random.random(), self.x, self.y, swarm_best_x, swarm_best_y) print(\u0026#39;Social: \u0026#39;, s) v = self.calculate_updated_velocity(i, c, s) self.velocity = v print(\u0026#39;Velocity: \u0026#39;, v) p = self.calculate_position(self.x, self.y, v) self.x = p[0] self.y = p[1] print(\u0026#39;Position: \u0026#39;, p) def to_string(self): print(\u0026#39;Inertia: \u0026#39;, self.inertia) print(\u0026#39;Velocity: \u0026#39;, self.velocity) print(\u0026#39;Position: \u0026#39;, self.x, \u0026#39;,\u0026#39;, self.y) # Ant Colony Optimization (ACO). # The general lifecycle of a particle swarm optimization algorithm is as follows: # - Initialize the population of particles: This involves determining the number of particles to be used and initialize # each particle to a random position in the search space. # - Calculate the fitness of each particle: Given the position of each particle, determine the fitness of that particle # at that position. # - Update the position of each particle: This involves repetitively updating the position of all the particles using # principles of swarm intelligence. Particles will explore then converge to good solutions. # - Determine stopping criteria: This involves determining when the particles stop updating and the algorithm stops. class Swarm: # Initialize a swarm of particles randomly def __init__(self, inertia, cognitive_constant, social_constant, random_swarm, number_of_particles, number_of_iterations): self.inertia = inertia self.cognitive_constant = cognitive_constant self.social_constant = social_constant self.number_of_iterations = number_of_iterations self.swarm = [] if random_swarm: self.swarm = self.get_random_swarm(number_of_particles) else: self.swarm = self.get_sample_swarm() # Return a static swarm of particles @staticmethod def get_sample_swarm(): p1 = Particle(7, 1, INERTIA, COGNITIVE_CONSTANT, SOCIAL_CONSTANT) p2 = Particle(-1, 9, INERTIA, COGNITIVE_CONSTANT, SOCIAL_CONSTANT) p3 = Particle(5, -1, INERTIA, COGNITIVE_CONSTANT, SOCIAL_CONSTANT) p4 = Particle(-2, -5, INERTIA, COGNITIVE_CONSTANT, SOCIAL_CONSTANT) particles = [p1, p2, p3, p4] return particles # Return a randomized swarm of particles @staticmethod def get_random_swarm(number_of_particles): particles = [] for p in range(number_of_particles): particles.append(Particle(random.randint(-10, 10), random.randint(-10, 10), INERTIA, COGNITIVE_CONSTANT, SOCIAL_CONSTANT)) return particles # Get the best particle in the swarm based on its fitness def get_best_in_swarm(self): best = math.inf best_particle = None for p in self.swarm: p.update_fitness() if p.fitness \u0026lt; best: best = p.fitness best_particle = p return best_particle # Run the PSO lifecycle for every particle in the swarm def run_pso(self): for t in range(0, self.number_of_iterations): best_particle = self.get_best_in_swarm() for p in self.swarm: p.update(best_particle.x, best_particle.y) print(\u0026#39;Best particle fitness: \u0026#39;, best_particle.fitness) # Set the hyper parameters for the PSO INERTIA = 0.4 COGNITIVE_CONSTANT = 0.3 SOCIAL_CONSTANT = 0.7 RANDOM_CHANCE = True NUMBER_OF_PARTICLES = 200 NUMBER_OF_ITERATIONS = 500 # Initialize and execute the PSO algorithm swarm = Swarm(INERTIA, COGNITIVE_CONSTANT, SOCIAL_CONSTANT, RANDOM_CHANCE, NUMBER_OF_PARTICLES, NUMBER_OF_ITERATIONS) swarm.run_pso() 应用 PSO算法的优点包括简单、易于实现、收敛速度快、鲁棒性强等。然而，它也存在一些局限性，如容易陷入局部最优解、参数选择对算法性能影响较大等。\n粒子群优化（PSO）算法具有较强的全局搜索能力，被广泛应用于各种领域。以下是一些常见的PSO算法应用：\n  函数优化：PSO算法可以应用于无约束或者约束优化问题，如求解复杂非线性函数的最小值。在这些问题中，PSO算法通常能够找到全局最优解或者近似最优解。\n  机器学习与数据挖掘：PSO算法在机器学习和数据挖掘领域具有广泛的应用，如分类、聚类、特征选择、关联规则挖掘等。在这些任务中，PSO算法通常用于优化模型的参数，以提高模型的性能。\n  神经网络训练：PSO算法可以用于神经网络的训练，包括前向神经网络、递归神经网络、自组织映射等。在这些问题中，PSO算法通常用于调整网络的权重和阈值，以最小化网络的误差。\n  调度与路径规划：PSO算法在调度和路径规划领域有很好的应用，如任务调度、车辆路径规划、TSP问题（旅行商问题）等。在这些问题中，PSO算法通常用于寻找最优的调度策略或路径。\n  控制器设计：PSO算法在控制器设计中也有应用，如PID控制器参数优化、模型预测控制（MPC）等。在这些问题中，PSO算法通常用于优化控制器的参数，以提高控制系统的性能。\n  电力系统优化：PSO算法在电力系统优化领域也有广泛应用，如电力系统调度、无功优化、负荷预测等。在这些问题中，PSO算法通常用于寻找最优的解决方案。\n  机械设计与优化：PSO算法在机械设计与优化领域也有应用，如结构优化、拓扑优化、形状优化等。在这些问题中，PSO算法通常用于优化结构的几何形状或材料分布，以提高结构的性能。\n  粒子群优化算法的一个有趣的应用是深度脑电刺激。这一应用的主要概念涉及一种治疗方式，即在人脑中安装带有电极的探针，刺激大脑以治疗帕金森氏症等疾病。每个探针都包含电极，可配置在不同的方向，以正确地治疗每个患者。明尼苏达大学的研究人员开发了一种粒子群优化算法来优化每个电极的方向，以最大限度地增强对有效区域的刺激，并减弱对回避区域的刺激，同时尽量减少所用的能量。因为粒子能在这一类多维问题空间中进行有效的搜索，所以粒子群优化算法非常适用于解决为探针上的电极寻找最佳配置这一类问题。\n这些只是PSO算法应用的一部分，实际上，PSO算法在许多其他领域也得到了广泛应用。\n优缺点 粒子群优化（PSO）算法是一种基于群体智能的全局优化算法。它具有一些显著的优点，但同时也存在一些局限性。以下是PSO算法的优缺点：\n优点：\n  简单易实现：PSO算法的原理和实现相对简单，易于理解和编程实现。\n  收敛速度快：PSO算法通常能在较少的迭代次数内找到满意的解，具有较快的收敛速度。\n  鲁棒性强：PSO算法对问题的初始解和参数选择具有较好的鲁棒性，能够在多种问题中找到较好的解。\n  全局搜索能力：PSO算法具有较强的全局搜索能力，能够有效地避免陷入局部最优解。\n  并行性：PSO算法天然具有并行性，能够利用多核处理器或分布式计算资源进行加速。\n  局限性：\n  容易陷入局部最优解：虽然PSO算法具有较强的全局搜索能力，但在某些情况下，尤其是在高维问题中，仍然有可能陷入局部最优解。\n  参数敏感：PSO算法的性能受到惯性权重、加速因子和随机因子等参数的影响，参数的选择对算法性能有很大影响。不同的问题可能需要不同的参数设置，这使得PSO算法的参数调整变得较为困难。\n  缺乏理论支持：虽然PSO算法在实践中表现出良好的性能，但其收敛性和最优解性质缺乏严格的理论支持。\n  ","permalink":"https://tassel234.github.io/posts/note/%E7%AE%97%E6%B3%95%E9%A2%84%E8%A7%88%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AF%87-2/","summary":"前言 使用资源： 人工智能算法图解 https://github.com/rishal-hurbans/Grokking-Artificial-Intelligence-Algorithms https://www.zhihu.com/people/MicrostrongAI/posts?page=2 chatgtp aim 知道算法可以解决什么问题 对一些重要的算法要知道每行代码代表代码，然后可以进行修改 lightgbm LightGBM（Light Gradient Boosting Machine）是一种基于梯度提升框架的高效机器学习算法，由微软亚洲研究院的研究员提出。LightGBM主要针对GBDT（Gra","title":"算法预览（数学建模篇-2）"},{"content":"前言 使用资源： 人工智能算法图解\nhttps://github.com/rishal-hurbans/Grokking-Artificial-Intelligence-Algorithms\nhttps://www.zhihu.com/people/MicrostrongAI/posts?page=2\nchatgtp\nhttps://zhuanlan.zhihu.com/p/399770354\nhttps://scikit-opt.github.io/scikit-opt/#/zh/\naim  知道算法可以解决什么问题 对一些重要的算法要知道每行代码代表代码，然后可以进行修改  智能算法预览 遗传算法：优点是能很好的处理约束，能很好的跳出局部最优，最终得到全局最优解，全局搜索能力强；缺点是收敛较慢，局部搜索能力较弱，运行时间长，且容易受参数的影响。\n遗传算法适合求解离散问题，具备数学理论支持，但是存在着汉明悬崖等问题。\n模拟退火：优点是局部搜索能力强，运行时间较短；缺点是全局搜索能力差，容易受参数的影响。\n爬山算法：显然爬山算法较简单，效率高，但是处理多约束大规模问题时力不从心，往往不能得到较好的解。\n粒子群算法适合求解实数问题，算法简单，计算方便，求解速度快，但是存在着陷入局部最优等问题。\n蚁群算法适合在图上搜索路径问题，计算开销会大。\n可以讲什么的某些算法进行混合，针对特定问题，融合其中的优势。比如将遗传算法中的变异算子加入粒子群中就可以形成基于变异的粒子群算法。\n遗传算法 背包问题介绍 背包问题是一类常见的组合优化问题，它在计算机科学、运筹学、经济学和工程学等领域具有广泛的应用。背包问题的主要目标是在给定的限制条件下，从一组可选物品中选择一些物品进行组合，使得总价值最大或总重量最小。这个问题最初是由瑞士数学家丹尼尔·卡内曼（Daniel Kahneman）在1970年代提出的。\n背包问题有多种变体，其中最基本的两种变体是：\n  0/1背包问题：在这个问题中，你有一个背包和一组物品。每个物品有两个属性：体积（w）和价值（v）。你需要在不超过背包总容量的前提下，选择一些物品放入背包，使得放入的物品的总价值最大。\n  完全背包问题：在这个问题中，每个物品都有无限个，且每个物品的价值和体积都是恒定的。你需要在不超过背包总容量的前提下，选择一些物品放入背包，使得放入的物品的总价值最大。\n  此外，还有其他变体，如多重背包问题、分组背包问题和黄金背包问题等。\n解决背包问题的一种常见算法是动态规划。动态规划是一种将复杂问题分解为更小、更简单的子问题的方法，并逐个求解这些子问题，从而得到原问题的解。动态规划可以高效地解决背包问题，并提供一种顺序访问的方式，避免了重复计算。\n可以使用遗传算法解决背包问题。\n基本步骤 遗传算法是一种启发式优化算法，它基于自然选择和遗传机制的概念进行优化搜索。遗传算法的灵感来源于自然界中生物进化的过程，通过模拟这个过程来寻找问题的最优解或近似最优解。遗传算法的基本思想是利用编码、选择、交叉和变异等操作，实现问题空间中的全局搜索。\n以下是遗传算法的基本步骤：\n  编码：首先需要将优化问题的解空间进行编码，通常使用二进制编码（如二进制编码法、遗传算子编码法等）。\n  初始种群：初始化一组解作为遗传算法的初始种群，每个解表示一个个体。\n  适应度函数：定义一个适应度函数，用于衡量个体的优劣。适应度函数通常与目标函数（如最小化问题）相关。\n  选择操作：根据适应度函数，将适应度较高的个体保留在下一代种群中，适应度较低的个体则被淘汰。\n  交叉操作：通过交叉操作，在下一代种群中产生新的个体。交叉操作是遗传算法中的核心操作，通过组合两个个体的部分染色体，生成新的染色体。\n  变异操作：对新产生的染色体进行变异操作，以引入随机性和多样性。变异操作可以改变染色体的某个或多个基因位的值，以增加算法的探索性。\n  迭代操作：重复执行选择、交叉和变异操作，直到满足终止条件。终止条件通常包括迭代次数上限、达到预定的适应度水平或其他优化目标。\n  输出结果：从遗传算法的最终种群中，选择适应度最高的个体作为最优解。\n  以背包问题举例，物品被选上记为一，没有就记为0，使用二进制编码构成染色体。\n根据适应度得分筛选亲本 ，可以使用轮盘法，即将适应度函数计算出来 的数值分配给轮盘 的面积，然后随机抽取亲本，适应度高的亲本 占总群样本中 的比例就大，此外还有几种筛选方法。排序筛选法：均分赛场； 联赛筛选法：分组对抗；精英筛选法：只选最好的。\n交叉操作一般采用均匀交叉，即从每个亲本继承多个部分，变异操作也是利用随机数进行。通过交叉变异构成下一代的总群，然后迭代操作。\n遗传算法的参数配置 在设计遗传算法并配置其参数时，需要作出几个对算法性能产生影响的决性能方面的关注点主要有两个:从精度的角度来看，算法应该致力于寻找当前题的最佳解决方案;从计算效率的角度来看，算法应该能被高效地执行。如果算法的计算成本比其他传统方法(如暴力搜索)更高，那就没必要选用遗传算法来解决当前问题。我们所采用的编码方法、适应度函数以及在算法中设定的其他参数，都会对算法的精度和效率产生影响。为了在寻求良好的解决方案的同时保证计算效率，我们需要考虑下列参数。\n染色体编码方法一一我们需要对染色体编码方法再三斟酌，以确保它适用于当前问题，并确保潜在的解决方案能获取全局最大值。编码方法是遗传算法成功的核心。\n种群规模一一种群规模是可被配置的另一个重要参数。种群规模越大.可选的解决方案就越多样化。然而，种群规模越大，每次迭代的计算量也越大。有时，过大的种群规模抵消了突变的需求，导致开始时种群多样性良好，但随着算法迭代，多样性逐渐消失。一个有效的方法是从某个较小的种群规模开始，并根据每代种群的表现逐步增大种群规模。\n种群初始化一一虽然种群中的个体是随机初始化的，但为了确保解决方案的有效性，也为了优化遗传算法的计算效率，必须在合适的约束条件下对个体进行初始化。\n后代数量一一每一代所需要繁衍的后代数量也是可配置的。在每一次繁殖后，种群中的一部分个体会消亡，以确保种群规模固定不变。更多的后代意味着更高的种群多样性,但是存在一种风险一一为了腾出空间来容纳新的后代，原本种群中好的解决方案可能会被扼杀。如果种群规模被设置为动态的，那么种群中的个体数量可能在每一次繁殖后发生变化，但是这种方法需要更多的参数来控制。\n亲本筛选方法一一用于选择亲本的筛选方法是可配置的。亲本筛选策略的定义必须基于问题的上下文和算法需要平衡的可探索性与可挖掘性。\n交叉方法一一交叉方法与使用的编码方法相关，但通过配置这一参数我们可将算法设计为鼓励或阻止种群多样性。无论如何设计交叉方法我们都需要保证后代个体能产生有效的解。\n突变率一一突变率是另一个可配置的参数，它会导致所繁衍的后代(或者说潜在解决方案)更加多样化。更高的突变率意味着更高的多样性，但是引入过高的多样性可能会使表现良好的个体恶化。突变率可随着时间的推移而变化，我们可使算法在早期引入更高的多样性，并在晚期逐渐减少多样性。这种设计也可描述为在开始时偏重于探索，在后期偏重于挖掘。\n突交方法一一突变方法类似于交叉方法，因为它也取决于所使用的编码方法。突变方法需要具备一个重要的属性一一突变后产生的新解决方案仍然是有效的;否则，我们需要为该个体分配一个极低的适应度分数\n世代筛选方法一一与亲本筛选方法非常相似，世代筛选方法需要选出能幸存到下一代的个体。如果选用了不合适的筛选方法，算法可能发生收敛过快、陷入停滞或过度探索等不利状况。\n停止条件一一算法的停止条件必须基于问题的上下文设计，并能保证所获取的结果有意义。计算复杂度和时间是停止条件的主要考虑因素。\n此外还有实值编码，用来处理有多个相同的物品，编码的数字代表个数。\n顺序编码用来处理序列 。\n树编码用来处理层次结构 。\n算法实现 import random # The indexes for data array # 0 = name, 1 = weight, 2 = value, 3 = fitness KNAPSACK_ITEM_NAME_INDEX = 0 KNAPSACK_ITEM_WEIGHT_INDEX = 1 KNAPSACK_ITEM_VALUE_INDEX = 2 # Small knapsack dataset # knapsack_items = [ # [\u0026#39;Pearls\u0026#39;, 3, 4], # [\u0026#39;Gold\u0026#39;, 7, 7], # [\u0026#39;Crown\u0026#39;, 4, 5], # [\u0026#39;Coin\u0026#39;, 1, 1], # [\u0026#39;Axe\u0026#39;, 5, 4], # [\u0026#39;Sword\u0026#39;, 4, 3], # [\u0026#39;Ring\u0026#39;, 2, 5], # [\u0026#39;Cup\u0026#39;, 3, 1], # ] # Large knapsack dataset knapsack_items = [ [\u0026#39;Axe\u0026#39;, 32252, 68674], [\u0026#39;Bronze coin\u0026#39;, 225790, 471010], [\u0026#39;Crown\u0026#39;, 468164, 944620], [\u0026#39;Diamond statue\u0026#39;, 489494, 962094], [\u0026#39;Emerald belt\u0026#39;, 35384, 78344], [\u0026#39;Fossil\u0026#39;, 265590, 579152], [\u0026#39;Gold coin\u0026#39;, 497911, 902698], [\u0026#39;Helmet\u0026#39;, 800493, 1686515], [\u0026#39;Ink\u0026#39;, 823576, 1688691], [\u0026#39;Jewel box\u0026#39;, 552202, 1056157], [\u0026#39;Knife\u0026#39;, 323618, 677562], [\u0026#39;Long sword\u0026#39;, 382846, 833132], [\u0026#39;Mask\u0026#39;, 44676, 99192], [\u0026#39;Necklace\u0026#39;, 169738, 376418], [\u0026#39;Opal badge\u0026#39;, 610876, 1253986], [\u0026#39;Pearls\u0026#39;, 854190, 1853562], [\u0026#39;Quiver\u0026#39;, 671123, 1320297], [\u0026#39;Ruby ring\u0026#39;, 698180, 1301637], [\u0026#39;Silver bracelet\u0026#39;, 446517, 859835], [\u0026#39;Timepiece\u0026#39;, 909620, 1677534], [\u0026#39;Uniform\u0026#39;, 904818, 1910501], [\u0026#39;Venom potion\u0026#39;, 730061, 1528646], [\u0026#39;Wool scarf\u0026#39;, 931932, 1827477], [\u0026#39;Cross bow\u0026#39;, 952360, 2068204], [\u0026#39;Yesteryear book\u0026#39;, 926023, 1746556], [\u0026#39;Zinc cup\u0026#39;, 978724, 2100851, 0] ] # The best knapsack score from the brute force approach BEST_LARGE_KNAPSACK_SCORE = 13692887 # Genetic algorithms are used to evaluate large search spaces for a good solution. It is important to note that a # genetic algorithm is not guaranteed to find the absolute best solution. It attempts to find the global best whilst # avoiding local best solutions. The general lifecycle of a genetic algorithm is as follows: # - Creation of a population: This involves creating a random population of potential solutions. # - Measuring fitness of individuals in the population: This involves determining how good a specific solution is. # This is accomplished by using a fitness function which scores solutions to determine how good they are. # - Selecting parents based on their fitness: This involves selecting a number of pairs of parents that will reproduce # offspring. # - Reproducing individuals from parents: This involves creating offspring from their respective parents by mixing # genetic information and applying slight mutations to the offspring. # - Populating the next generation: This involves selecting individuals and offspring from the population that will # survive to the next generation. # The indexes for an individual\u0026#39;s properties INDIVIDUAL_CHROMOSOME_INDEX = 0 INDIVIDUAL_FITNESS_INDEX = 1 INDIVIDUAL_PROBABILITY_INDEX = 2 # Generate an initial population of random individuals def generate_initial_population(population_size): population = [] for individual in range(0, population_size): individual = \u0026#39;\u0026#39;.join([random.choice(\u0026#39;01\u0026#39;) for n in range(26)]) population.append([individual, 0, 0]) return population # Calculate the fitness for each individual in the population given the maximum weight def calculate_population_fitness(population, maximum_weight): best_fitness = 0 for individual in population: individual_fitness = calculate_individual_fitness(individual[INDIVIDUAL_CHROMOSOME_INDEX], maximum_weight) individual[INDIVIDUAL_FITNESS_INDEX] = individual_fitness if individual_fitness \u0026gt; best_fitness: best_fitness = individual_fitness if individual_fitness == -1: population.remove(individual) return best_fitness # Calculate the fitness for an individual def calculate_individual_fitness(individual, maximum_weight): total_individual_weight = 0 total_individual_value = 0 for gene_index in range(len(individual)): gene_switch = individual[gene_index] if gene_switch == \u0026#39;1\u0026#39;: total_individual_weight += knapsack_items[gene_index][KNAPSACK_ITEM_WEIGHT_INDEX] total_individual_value += knapsack_items[gene_index][KNAPSACK_ITEM_VALUE_INDEX] if total_individual_weight \u0026gt; maximum_weight: return -1 return total_individual_value # Set the probabilities for selection for each individual in the population def set_probabilities(population): population_sum = sum(individual[INDIVIDUAL_FITNESS_INDEX] for individual in population) for individual in population: individual[INDIVIDUAL_PROBABILITY_INDEX] = individual[INDIVIDUAL_FITNESS_INDEX] / population_sum # Roulette wheel selection to select individuals in a population def roulette_wheel_selection(population, number_of_selections): set_probabilities(population) slices = [] total = 0 for r in range(0, len(population)): individual = population[r] slices.append([r, total, total + individual[INDIVIDUAL_PROBABILITY_INDEX]]) total += individual[INDIVIDUAL_PROBABILITY_INDEX] chosen_ones = [] for r in range(number_of_selections): spin = random.random() result = [s[0] for s in slices if s[1] \u0026lt; spin \u0026lt;= s[2]] chosen_ones.append(population[result[0]]) return chosen_ones # Reproduce children given two individuals using one point crossover def one_point_crossover(parent_a, parent_b, xover_point): children = [parent_a[:xover_point] + parent_b[xover_point:], parent_b[:xover_point] + parent_a[xover_point:]] return children # Reproduce children given two individuals using two point crossover def two_point_crossover(parent_a, parent_b, xover_point_1, xover_point_2): children = [parent_a[:xover_point_1] + parent_b[xover_point_1:xover_point_2] + parent_a[xover_point_2:], parent_b[:xover_point_1] + parent_a[xover_point_1:xover_point_2] + parent_b[xover_point_2:]] return children # Randomly mutate children def mutate_children(children, mutation_rate): for child in children: random_index = random.randint(0, mutation_rate) if child[INDIVIDUAL_CHROMOSOME_INDEX][random_index] == \u0026#39;1\u0026#39;: mutated_child = list(child[INDIVIDUAL_CHROMOSOME_INDEX]) mutated_child[random_index] = \u0026#39;0\u0026#39; child[INDIVIDUAL_CHROMOSOME_INDEX] = mutated_child else: mutated_child = list(child[INDIVIDUAL_CHROMOSOME_INDEX]) mutated_child[random_index] = \u0026#39;1\u0026#39; child[INDIVIDUAL_CHROMOSOME_INDEX] = mutated_child return children # Reproduce children given selected individuals def reproduce_children(chosen_selections): children = [] for parent_index in range(len(chosen_selections)//2 - 1): children = one_point_crossover(chosen_selections[parent_index], chosen_selections[parent_index + 1], CROSSOVER_POSITION_1) return children # Combine the existing population and newly reproduced children def merge_population_and_children(population, children): return population + children # Set the hyper parameters for the genetic algorithm NUMBER_OF_GENERATIONS = 1000 INITIAL_POPULATION_SIZE = 1000 KNAPSACK_WEIGHT_CAPACITY = 6404180 CROSSOVER_POSITION_1 = 13 CROSSOVER_POSITION_2 = 22 MUTATION_RATE = 10 NUMBER_OF_ITERATIONS = 5 # Run the genetic algorithm def run_ga(): best_global_fitness = 0 global_population = generate_initial_population(INITIAL_POPULATION_SIZE) for generation in range(NUMBER_OF_GENERATIONS): current_best_fitness = calculate_population_fitness(global_population, KNAPSACK_WEIGHT_CAPACITY) if current_best_fitness \u0026gt; best_global_fitness: best_global_fitness = current_best_fitness the_chosen = roulette_wheel_selection(global_population, 100) the_children = reproduce_children(the_chosen) the_children = mutate_children(the_children, MUTATION_RATE) global_population = merge_population_and_children(global_population, the_children) # print(global_population) print(\u0026#39;Best fitness: \u0026#39;, best_global_fitness) print(\u0026#39;Actual best: \u0026#39;, BEST_LARGE_KNAPSACK_SCORE) print(\u0026#39;Accuracy: \u0026#39;, best_global_fitness / BEST_LARGE_KNAPSACK_SCORE * 100) print(\u0026#39;Final population size: \u0026#39;, len(global_population)) # calculate_population_fitness(global_population, KNAPSACK_WEIGHT_CAPACITY) # the_chosen = roulette_wheel_selection(global_population, 100) # the_children = reproduce_children(the_chosen) # the_children = mutate_children(the_children) # global_population = merge_population_and_children(global_population, the_children) # global_population = roulette_wheel_selection(global_population, 100) # Run the genetic algorithm for a number of iterations for i in range(0, NUMBER_OF_ITERATIONS): run_ga() # print(calculate_individual_fitness(\u0026#39;01100100010110001110001001\u0026#39;, 6404180)) # print(calculate_individual_fitness(\u0026#39;00110101000100011010001000\u0026#39;, 6404180)) # print(calculate_individual_fitness(\u0026#39;11100100110110000100101101\u0026#39;, 6404180)) # print(calculate_individual_fitness(\u0026#39;00001000010010101101001001\u0026#39;, 6404180)) 也可以选择使用scikit-opt进行调用，可以自己写算子，也可以调用提供的算子。\nimport numpy as np from sko.GA import GA, GA_TSP demo_func = lambda x: x[0] ** 2 + (x[1] - 0.05) ** 2 + (x[2] - 0.5) ** 2 ga = GA(func=demo_func, n_dim=3, size_pop=100, max_iter=500, prob_mut=0.001, lb=[-1, -10, -5], ub=[2, 10, 2], precision=[1e-7, 1e-7, 1]) 算法的运行速度比较慢，大概几分钟才解完。\n优点和缺点 遗传算法具有以下优点：\n 能够处理连续和离散问题。 全局搜索能力强。 具有一定的自适应性。 具有较强的并行性和鲁棒性。  遗传算法的缺点： 尽管遗传算法具有很强的全局搜索能力和一定的自适应性，但在实际应用中，它也存在一些缺点和挑战：\n  初始种群的选择：遗传算法的性能在很大程度上取决于初始种群的质量。如果初始种群选择不当，可能导致算法陷入局部最优解，甚至无法收敛。为了解决这个问题，研究者们提出了多种方法，如自适应进化策略、启发式搜索等。\n  收敛速度：遗传算法的收敛速度可能较慢，尤其是在处理复杂问题时。为了加速收敛，可以采用其他优化方法（如梯度下降法、共轭梯度法等）作为辅助，或通过调整遗传算法的参数来提高收敛速度。\n  计算复杂性：遗传算法的计算复杂性随问题规模的增加而增加。在处理大规模问题时，遗传算法可能会面临较高的计算成本和较低的效率。\n  局部搜索能力：遗传算法在局部搜索方面的性能相对较弱，容易陷入局部最优解。为了提高局部搜索能力，可以使用遗传算子（如变异算子）或局部搜索策略。\n  噪声敏感性：遗传算法对初始种群的噪声敏感。在高噪声的初始种群中，算法容易陷入局部最优解，甚至无法收敛。为了减小噪声对算法性能的影响，可以尝试使用合适的初始种群策略、自适应遗传算子等方法。\n  参数调整：遗传算法的性能在很大程度上取决于参数的选择。为了获得最佳性能，需要对参数进行精细调整。然而，参数调整的难度较大，可能需要多次试验才能获得合适的参数设置。\n  应用领域限制：遗传算法的应用领域相对有限，主要适用于求解那些具有一定全局搜索能力和自适应性的问题。对于那些需要精确求解或具有很强局部搜索能力的问题，遗传算法可能不是最佳选择。\n  实际应用 在实际应用中，可以根据问题特点和计算资源选择适当的优化方法。遗传算法和其他优化方法的结合可以互补各自的优缺点，提高问题求解的效果。 遗传算法作为一种全局优化方法，已经成功地应用于许多领域的问题求解。以下是遗传算法的一些主要应用：\n  函数优化：遗传算法被广泛应用于求解函数的最小值或最大值问题，如函数f(x) = x^3 + 2x^2 + 3x - 5在区间[-2, 2]上的最小值。\n  组合优化问题：遗传算法在求解组合优化问题方面具有很好的性能，如旅行商问题（TSP）、背包问题、装箱问题等。\n  机器学习和数据挖掘：遗传算法在机器学习和数据挖掘中的特征选择、降维、模型选择等方面也有广泛应用。\n  化学和材料科学：遗传算法在化学反应优化、材料结构优化，分子结构仿真和设计等方面发挥重要作用。\n  控制系统：遗传算法被用于求解复杂的控制系统，如PID控制器参数优化、非线性控制系统设计等。\n  经济学：遗传算法在经济领域的供应链优化、成本最小化、投资组合选择等问题中发挥作用。\n  机器人学：遗传算法在机器人学中的路径规划、运动规划、操作臂控制等方面具有应用价值。\n  神经科学：遗传算法被用于研究神经网络的优化问题，以寻找最佳的突触权重和连接方式。\n  分布式计算和并行计算：遗传算法具有较好的并行性，可以与其他优化算法结合，实现分布式计算和并行优化。\n  密码破解\n  电路设计与优化是电气工程、电子工程、计算机科学等领域中的重要问题，如逻辑门电路、存储器、微处理器等。遗传算法在电路设计与优化方面的应用主要涉及以下方面：\n  电路综合：电路综合是将多个门电路、触发器和其他电子元件组合在一起，形成一个具有所需功能的电路。遗传算法可以帮助设计者找到具有最佳性能和面积（或功耗）的电路结构。\n  网络分析：网络分析是一种分析电子系统中信号传输特性的技术。遗传算法可以用于分析不同网络拓扑结构的性能，以找到最佳的网络拓扑。\n  逻辑优化：逻辑优化是通过调整门电路、触发器和其他逻辑元件的连接方式，以提高电路的性能。遗传算法可以用于自动寻找最优的逻辑优化方案。\n  多目标优化：电路设计与优化通常涉及到多个性能指标，如功耗、面积、速度等。遗传算法可以同时考虑这些指标，实现多目标优化。\n  遗传算法在电路设计与优化中的应用需要解决一些挑战，如有限的计算资源、设计空间的复杂性以及收敛速度等问题。因此，在实际应用中，通常需要与其他优化方法（如模拟退火、蚁群算法、粒子群优化等）结合使用，以提高求解性能。 需要注意的是，遗传算法在实际应用中需要根据具体问题进行参数调整和优化，以获得最优解。同时，为了处理大规模问题，常常需要使用并行计算或分布式计算技术。\n全局最优解和局部最优解 全局最优解和局部最优解是优化问题中的两个重要概念。\n  全局最优解（Global Optimality）：如果一个优化问题的解是全局最优的，那么它在所有可能的局部最优解中是最优的。也就是说，如果改变一个解的微小部分（例如，移动一个变量的小量），新的解仍然是最优的，并且在所有可能的移动中仍然是最优的。全局最优解通常是最优化问题的目标，因为它们保证找到了问题的最优解。\n  局部最优解（Local Optimality）：如果一个优化问题的解是局部最优的，那么它在当前的搜索空间内是最优的。也就是说，如果改变一个解的微小部分，新的解不一定仍然是最优的，而且在所有可能的移动中不一定仍然是最优的。局部最优解是优化问题中的一种常见解。\n  优化问题通常是寻找全局最优解，但实际上，局部最优解经常是首选。原因是：\n 计算复杂性：全局最优解可能需要在非常大的搜索空间中进行搜索，这在实际问题中可能是不可行的。相反，局部最优解通常更容易搜索，因为它们只需要在一个小的搜索区域中进行搜索。 实际影响：局部最优解可能对实际应用产生较大影响，而全局最优解的影响可能相对较小。  有许多算法，如梯度下降法、牛顿法、拟牛顿法等，都旨在找到优化问题的全局最优解。然而，实际上，这些算法往往在搜索的早期阶段就达到了一个局部最优解，而不是全局最优解。这就是所谓的\u0026quot;局部最优陷阱\u0026quot;问题。为了解决这个问题，有些算法，如模拟退火、遗传算法等，试图在搜索过程中跳出局部最优解，以寻找全局最优解。\n","permalink":"https://tassel234.github.io/posts/note/%E7%AE%97%E6%B3%95%E9%A2%84%E8%A7%88%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AF%87-1/","summary":"前言 使用资源： 人工智能算法图解 https://github.com/rishal-hurbans/Grokking-Artificial-Intelligence-Algorithms https://www.zhihu.com/people/MicrostrongAI/posts?page=2 chatgtp https://zhuanlan.zhihu.com/p/399770354 https://scikit-opt.github.io/scikit-opt/#/zh/ aim 知道算法可以解决什么问题 对一些重要的算法要知道每行代码代表代码，然后可以进行修改 智能算法预览 遗传算法：优点是能很好的处理约束，能很好的跳出局部最优，最终得到全局最优解，全局搜索能力强；缺点是收敛较慢，局部搜索能力较弱，运行时间长，且容易受","title":"算法预览（数学建模篇-1）"},{"content":"Python数学建模算法-6（评价和预测） 14.1 综合评价指标体系 综合评价（Comprehensive Evaluation，CE），也叫综合评价方法或多指标综合评价方法，是指使用比较系统的、规范的方法对于多个指标、多个单位同时进行评价的方法。它不只是一种方法，而是一个方法系统，是指对多指标进行综合的一系列有效方法的总称。综合评价方法在现实中应用范围很广。综合评价是针对研究的对象，建立一个进行测评的指标体系，利用一定的方法或模型，对搜集的资料进行分析，对被评价的事物作出定量化的总体判断。\n14.2 综合评价数据处理 首先应该进行数据的预处理，包括一致化处理（把极小型转化为极大型），无量纲化处理（向量归一化等方法），定性指标的定量化（把高，很高的描述转化为数字）。\nimport numpy as np import pandas as pd a = np.loadtxt(\u0026#39;data14_1_1.txt\u0026#39;) b = np.linalg.norm(a,axis=0) #逐列求2范数 m1 = a.max(axis=0) #逐列求最大值 m2 = a.min(axis=0) #逐列求最小值 R1 = a / b #全部列向量归一化处理 R2 = a / m1 #全部列向量比例变换 R3 = (a-m2) / (m1-m2) #全部列向量极差变换 R1[:,3] = 1 - a[:,3] / b[3] #第4列特殊处理 R2[:,3] = m2[3] / a[:,3] #第4列特殊处理 R3[:,3] = (m1[3]-a[:,3]) / (m1[3]-m2[3]) np.savetxt(\u0026#39;data14_1_2.txt\u0026#39;, R1, fmt=\u0026#39;%.4f\u0026#39;) f = pd.ExcelWriter(\u0026#39;data14_1_3.xlsx\u0026#39;) pd.DataFrame(R1).to_excel(f, index=None) #写入Excel文件方便做表 pd.DataFrame(R2).to_excel(f, \u0026#39;Sheet2\u0026#39;, index=None) pd.DataFrame(R3).to_excel(f, \u0026#39;Sheet3\u0026#39;, index=None); f.save() 14. 3 常用的综合评价数学模型 线型加权评价法，TOPSIS评价法，熵值法，秩和比法。层次分析、模糊评价、数据包络分析、灰色综合评价、多维标度法 。\n14.3.6 综合评价示例 import numpy as np from scipy.stats import rankdata a = np.loadtxt(\u0026#39;data14_1_2.txt\u0026#39;) bp = a.max(axis=0) #求正理想解 bm = a.min(axis=0) #求负理想解 d1 = np.linalg.norm(a-bp,axis=1) #求到正理想解的距离 d2 = np.linalg.norm(a-bm,axis=1) #求到负理想解的距离 f1 = d2 / (d1+d2); print(\u0026#39;TOPSIS评价值：\u0026#39;, f1) c = bp - a #计算参考序列与每个序列的差 m1 = c.max(); m2 = c.min() #计算最大差和最小差 r = 0.5 #分辨系数 xs = (m2+r*m1)/(c+r*m1) #计算灰色关联系数 f2 = xs.mean(axis=1) #求灰色关联度 print(\u0026#39;灰色关联度：\u0026#39;, np.round(f2,4)) n = a.shape[0]; s = a.sum(axis=0) #逐列求得 P = a / s #求特征比重矩阵 e = -(P*np.log(P)).sum(axis=0)/np.log(n) #计算熵值 g = 1- e; w = g / sum(g) #计算差异系数和权重系数 f3 = P @ w #计算各对象的评价值 print(\u0026#39;评价值：\u0026#39;, np.round(f3,4)) R = rankdata(a, axis=0) #逐列编秩 RSR = R.mean(axis=1) / n #计算秩和比 print(\u0026#39;秩和比：\u0026#39;, np.round(RSR,4)) 14.4 模糊数学方法 隶属函数（模糊分布），模糊贴合度。\nimport numpy as np a = np.loadtxt(\u0026#39;data14_4.txt\u0026#39;) f1 = lambda x: x/8800 f2 = lambda x: 1-x/8000 f3 = lambda x: (x\u0026lt;=5.5)+(8-x)/(8-5.5)*((x\u0026gt;5.5) \u0026amp; (x\u0026lt;8)) f4 = lambda x: 1-x/200 f5 = lambda x: (x-50)/(1500-50) R = [] for i in range(len(a)): s = \u0026#39;f\u0026#39;+str(i+1)+\u0026#39;(a[\u0026#39;+str(i)+\u0026#39;])\u0026#39;; R.append(eval(s)) R = np.array(R) w = np.array([0.25, 0.2, 0.2, 0.1, 0.25]) B = w @ R #计算综合评价值 print(\u0026#39;评价值：\u0026#39;, np.round(B,4)) 14.5 数据包络分析 适用于多输入多输出的复杂系统，应用数学规划模型计算比较决策单元之间的相对效率。计算投入产出比最大。\nimport numpy as np import cvxpy as cp d = np.loadtxt(\u0026#39;data14_5.txt\u0026#39;) a = d[:,:3]; b = d[:,3:] u = cp.Variable(3, pos=True); v = cp.Variable(2, pos=True) for j in range(10): con = [ a @ u \u0026gt;= b @ v, a[j] @ u ==1] obj = cp.Maximize(b[j]@v) prob = cp.Problem(obj, con) prob.solve() print(\u0026#39;第\u0026#39;,str(j+1),\u0026#39;个对象最优值：\u0026#39;,round(prob.value,4)) print(\u0026#39;最优解：\\n\u0026#39;, np.round(u.value,4),\u0026#39;\\n\u0026#39;, np.round(v.value,4)) 15.1 灰色预测模型 灰色预测模型是通过少量的、不完全的信息，建立数学模型做出预测的一种预测方法。是基于客观事物的过去和现在的发展规律，借助于科学的方法对未来的发展趋势和状况进行描述和分析，并形成科学的假设和判断。\n灰色预测是一种对含有不确定因素的系统进行预测的方法。灰色预测通过鉴别系统因素之间发展趋势的相异程度，即进行关联分析，并对原始数据进行生成处理来寻找系统变动的规律，生成有较强规律性的数据序列，然后建立相应的微分方程模型，从而预测事物未来发展趋势的状况。其用等时距观测到的反映预测对象特征的一系列数量值构造灰色预测模型，预测未来某一时刻的特征量，或达到某一特征量的时间。\n15.1.1 GM(1,1)预测模型 一阶微分方程和只含有一个变量的灰色模型。\n有两个检验方法，分别是相对误差检验和级比偏差值检验。\nimport numpy as np import sympy as sp x0 = np.array([71.1, 72.4, 72.4, 72.1, 71.4, 72.0, 71.6]) n = len(x0); lamda = x0[:-1]/x0[1:] #计算级比 b1 = [min(lamda), max(lamda)] #计算级比取值范围 b2 = [np.exp(-2/(n+1)), np.exp(2/(n+1))] #计算级比容许范围 x1 = np.cumsum(x0) #求累加序列 z = (x1[:-1]+x1[1:]) / 2 #求均值生成序列 B = np.vstack([-z, np.ones(n-1)]).T u = np.linalg.pinv(B) @ x0[1:] #最小二乘法拟合参数 sp.var(\u0026#39;t\u0026#39;); sp.var(\u0026#39;x\u0026#39;, cls=sp.Function) #定义符号变量和函数 eq = x(t).diff(t)+u[0]*x(t)-u[1] #定义符号微分方程 xt0 = sp.dsolve(eq, ics={x(0):x0[0]}) #求解符号微分方程 xt0 = xt0.args[1] #提取方程中的符号解 xt = sp.lambdify(t, xt0, \u0026#39;numpy\u0026#39;) #转换为匿名函数 t = np.arange(n+1); xh = xt(t) #求预测值 x0h = np.hstack([x0[0], np.diff(xh)]) #还原数据 x1993 = x0h[-1] #提取1993年的预测值 cha = x0 - x0h[:-1]; delta = abs(cha/x0) * 100 #计算相对误差 rho = abs(1 - (1-0.5*u[0])/(1+0.5*u[0])*lamda) print(cha) print(\u0026#39;1993年预测值：\u0026#39;, round(x1993,4)) [ 0. -0.00574144 0.16376344 0.0328715 -0.49841633 0.26990088 0.03782405] 1993年预测值： 71.3946\n上述的代码也代表了模型的建立过程：\n 级比检验 数据累加，构建数据矩阵好数据向量，计算求解 建立微分方程模型，求解预测值和模糊还原值 求相对误差检验  15.1.2 GM(2,1)、DGM和Verhulst模型 GM(2,1)和DGM 二阶微分方程，只含有一个变量的灰色模型。DGM和GM(2,1)的区别在于DGM没有自变量0阶微分的项。\nVerhulst 模 型 的 提 出 : 将 离 散 的 随 机 数 列 进 行 一 次 累 加 , 生 成 新 序 列 , 再 对 其 进 行 建 模 计 算 , 得 到 预 测 值 。 该 模 型 主 要 用 来饱和状态的过程, 即 S 型 过 程 , 常 用 于 人 口 预 测 , 生 物 生 长 , 繁 殖 预 测 及 产 品 经 济 寿 命 预 测 等 。\nimport numpy as np x0 = np.array([4.93, 2.33, 3.87, 4.35, 6.63, 7.15, 5.37, 6.39, 7.81, 8.35]) n = len(x0); x1 = np.cumsum(x0) #求累加序列 z = (x1[1:]+x1[:-1]) / 2 #求均值生成序列 B = np.vstack([-z, z**2]).T u = np.linalg.pinv(B) @ x0[1:] #最小二乘法拟合参数 print(\u0026#39;参数u：\u0026#39;, np.round(u,4)) #下面直接利用解的表达式写出对应的匿名函数 x = lambda t: u[0]*x0[0]/(u[1]*x0[0]+(u[0]-u[1]*x0[0])*np.exp(u[0]*t)) xh1 = x(np.arange(n)) #求预测值 xh0 = np.hstack([x0[0], np.diff(xh1)]) #还原数据 ea = x0 - xh0 #计算预测的残差 er = abs(ea)/x0*100 #计算相对误差 15.2 马尔科夫预测 系统未来下一刻的状态只和现在有关，而与过去无关。类似于编程的迭代递归。\n步骤是先写出第一次的概率分布，然后写出状态转移矩阵，然后求解。\nimport numpy as np P1 = np.mat([0.2, 0.4, 0.4]) P = np.mat([[0.8, 0.1, 0.1],[0.5, 0.1, 0.4],[0.5, 0.3, 0.2]]) P4 = P1 @ P ** 3 print(\u0026#39;P4:\u0026#39;, P4) 若转移矩阵是正则的，概率转移进行了比较大的次数，概率值会稳定下来。\n可以使用线性方程去解，也可以用特征值向量去解题。\nimport numpy as np import sympy as sp p = np.array([[0.8, 0.1, 0.1],[0.5, 0.1, 0.4],[0.5, 0.3, 0.2]]) a = np.vstack([p.T-np.eye(3), np.ones(3)]) #构造方程组系数矩阵 b = np.hstack([np.zeros(3),1]) #构造方程组常数项列 x = np.linalg.pinv(a) @ b #求线性方程组的数值解 print(\u0026#39;解为：\u0026#39;, np.round(x,4)) 15. 3 神经元网络 感知器 感知器是由 Rosenblatt于 1957年提出的它是最早的人工神经网络。单层感知器是一个具有一层神经元、采用闽值激活函数的前向网络,通过对网络权值的训练,可以使感知器对一组输入向量的响应达到0或1的目标输出,从而实现对输入向量的分类。学习方法是梯度下降法。\nfrom sklearn.linear_model import Perceptron import numpy as np x0=np.array([[-0.5,-0.5,0.3,0.0],[-0.5,0.5,-0.5,1.0]]).T y0=np.array([1,1,0,0]) md = Perceptron().fit(x0,y0) #构造并拟合模型 print(\u0026#39;模型系数和常数项分别为：\u0026#39;, md.coef_,\u0026#39;,\u0026#39;,md.intercept_) print(\u0026#39;模型精度：\u0026#39;,md.score(x0,y0)) #模型检验 print(\u0026#39;预测值为：\u0026#39;,md.predict([[-0.5,0.2]])) BP神经网络 P神经网络是一种按误差反向传播(简称误差反传)训练的多层前馈网络，其算法称为BP算法，它的基本思想是梯度下降法，利用梯度搜索技术，以期使网络的实际输出值和期望输出值的误差均方差为最小。\nBP网络是在输入层与输出层之间增加若干层(一层或多层)神经元，这些神经元称为隐单元，它们与外界没有直接的联系，但其状态的改变，则能影响输入与输出之间的关系，每一层可以有若干个节点。\n有下面几个缺点:\n①学习速度慢，即使是一个简单的问题，一般也需要几百次甚至上千次的学习才能收敛。\n②容易陷入局部极小值。\n③网络层数、神经元个数的选择没有相应的理论指导。\nfrom sklearn.neural_network import MLPRegressor import numpy as np import pylab as plt a = np.loadtxt(\u0026#39;data15_12.txt\u0026#39;) x0 = a[:,:3]; y0 = a[:,3] #提出训练样本数据 m1 = x0.max(axis=0); m2 = x0.min(axis=0) #计算逐列最大值和最小值 bx0 = 2*(x0-m2)/(m1-m2)-1 #数据标准化 #构造并拟合模型 md = MLPRegressor(solver=\u0026#39;lbfgs\u0026#39;,activation=\u0026#39;identity\u0026#39;, hidden_layer_sizes=10).fit(bx0, y0) x = np.array([[73.39,75.55],[3.9635,4.0975],[0.9880,1.0268]]).T bx = 2*(x-m2) / (m1-m2)-1 #数据标准化 yh = md.predict(bx); print(\u0026#39;预测值为：,\u0026#39;,np.round(yh,4)) yh0 = md.predict(bx0); delta = abs(yh0-y0)/y0*100 print(\u0026#39;已知数据预测的相对误差：\u0026#39;, np.round(delta,4)) t = np.arange(1990, 2010) plt.rc(\u0026#39;font\u0026#39;, size=15); plt.rc(\u0026#39;font\u0026#39;, family=\u0026#39;SimHei\u0026#39;) plt.plot(t, y0, \u0026#39;--o\u0026#39;, label=\u0026#39;原始数据\u0026#39;) plt.plot(t, yh0, \u0026#39;-*\u0026#39;, label=\u0026#39;预测数据\u0026#39;) plt.xticks(t, rotation=55); plt.legend(); plt.show() 每一次的运行结果都有所不同，比如接下的数据：\n预测值为： [54449.6151 56573.6823]\n","permalink":"https://tassel234.github.io/posts/note/python%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AE%97%E6%B3%95-6%E8%AF%84%E4%BB%B7%E5%92%8C%E9%A2%84%E6%B5%8B/","summary":"Python数学建模算法-6（评价和预测） 14.1 综合评价指标体系 综合评价（Comprehensive Evaluation，CE），也叫综合评价方法或多指标综合评价方法，是指使用比较系统的、规范的方法对于多个指标、多个单位同时进行评价的方法。它不只是一种方法，而是一个方法系统，是指对多","title":"Python数学建模算法-6（评价和预测）"},{"content":"6.1 图与网络的基础理论 图是描述于一组对象的结构，其中某些对象对在某种意义上是“相关的”。这些对象对应于称为顶点的数学抽象（也称为节点或点），并且每个相关的顶点对都称为边（也称为链接或线）。图论的主要表示方式是邻接矩阵或者邻接表。\n6.2 NetworkX简介 是Python的一个库，用来创建和辅助plot绘画一个图.\n而且可以将图以邻接矩阵或者邻接表的方式进行导出，并且可以方便的调用各种遍历算法。\nimport networkx as nx import pylab as plt G=nx.DiGraph() List=[(1,2),(1,3),(2,3),(3,2),(3,5),(4,2),(4,6), (5,2),(5,4),(6,5)] G.add_nodes_from(range(1,7)) #必须显式地对顶点赋值 G.add_edges_from(List) plt.rc(\u0026#39;font\u0026#39;,size=16) pos=nx.shell_layout(G) nx.draw(G,pos,with_labels=True, font_weight=\u0026#39;bold\u0026#39;, node_color=\u0026#39;y\u0026#39;) W = nx.to_numpy_array(G) #从图G导出邻接矩阵 print(W);plt.show() 6. 3 最短路算法 6.3.1 固定起点的最短路 一般使用迪杰斯特拉算法算法，示例如下：\nimport networkx as nx G = nx.DiGraph() List = [(1,2,6), (1,3,3), (1,4,1), (2,5,1), (3,2,2), (3,4,2), (4,6,10), (5,4,6), (5,6,4), (5,7,3), (5,8,6), (6,5,10), (6,7,2), (7,8,4), (9,5,2), (9,8,3)] G.add_nodes_from(range(1,10)) G.add_weighted_edges_from(List) path = nx.dijkstra_path(G, 1, 8, weight=\u0026#39;weight\u0026#39;) #求最短路径 d = nx.dijkstra_path_length(G, 1, 8, weight=\u0026#39;weight\u0026#39;) print(\u0026#39;最短路径为：\u0026#39;, path) print(\u0026#39;最小费用为：\u0026#39;, d) 输出结果：\n最短路径为： [1, 3, 2, 5, 8]\n最小费用为： 12\n6.3.2 所有点对之间最短路的Floyd算法 可以知道所有点的最小的距离，可以有效简化复杂的，多节点的问题。\nimport networkx as nx import numpy as np G = nx.Graph() List = [(1, 3, 10), (1, 4, 60), (2, 3, 5), (2, 4, 20), (3, 4, 1)] G.add_nodes_from(range(1,5)) G.add_weighted_edges_from(List) d = nx.floyd_warshall_numpy(G) print(\u0026#39;最短距离矩阵为：\\n\u0026#39;, d) path = nx.shortest_path(G, weight=\u0026#39;weight\u0026#39;, method=\u0026#39;bellman-ford\u0026#39;) for i in range(1,len(d)): for j in range(i+1, len(d)+1): print(\u0026#39;顶点{}到顶点{}的最短路径为：\u0026#39;.format(i,j), path[i][j]) 最短距离矩阵为：\n[[ 0. 15. 10. 11.]\n[15. 0. 5. 6.]\n[10. 5. 0. 1.]\n[11. 6. 1. 0.]]\n顶点1到顶点2的最短路径为： [1, 3, 2]\n顶点1到顶点3的最短路径为： [1, 3]\n顶点1到顶点4的最短路径为： [1, 3, 4]\n顶点2到顶点3的最短路径为： [2, 3]\n顶点2到顶点4的最短路径为： [2, 3, 4]\n顶点3到顶点4的最短路径为： [3, 4]\n对于最短路问题的，也可以采用0-1整数规划模型进行解决，但最短路径已经有了较为高效的算法，因此不做赘述。\n6.4 最小生成树 6.4.1 基本概念和算法 在图（包括赋权图）中，可以找到的路径长度之和最小的树。\n只要达到每一个地点就行，形成连通图。可以解决电缆安装问题等。普里姆算法，克鲁斯卡尔算法 都是较为高效的算法。\nT=nx.minimum_spanning_tree(G)\n可以直接采用这条语句进行求解。\nimport numpy as np import networkx as nx import pylab as plt L=[(0,1,2),(0,2,1),(0,3,3),(0,4,4),(0,5,4),(0,6,2),(0,7,5),(0,8,4), (1,2,4),(1,8,1),(2,3,1),(3,4,1),(4,5,5),(5,6,2),(6,7,3),(7,8,5)] G=nx.Graph() G.add_weighted_edges_from(L) T=nx.minimum_spanning_tree(G) #返回可迭代对象 c=nx.to_numpy_array(T) #返回最小生成树的邻接矩阵 print(\u0026#34;邻接矩阵c=\\n\u0026#34;,c) w=c.sum()/2 #求最小生成树的权重 print(\u0026#34;最小生成树的权重W=\u0026#34;,w) pos=nx.circular_layout(G) plt.subplot(121) #下面画连通图 nx.draw(G,pos,with_labels=True, font_size=13) w1=nx.get_edge_attributes(G, \u0026#39;weight\u0026#39;) nx.draw_networkx_edge_labels(G, pos, edge_labels=w1) plt.subplot(122) #下面画最小生成树 nx.draw(T, pos, with_labels=True, font_weight=\u0026#39;bold\u0026#39;) w2=nx.get_edge_attributes(T, \u0026#39;weight\u0026#39;) nx.draw_networkx_edge_labels(T, pos, edge_labels=w2) plt.show() 最小生成树的权重W= 13.0\n6.4.2 最小生成树的数学规划模型 为了防止形成子圈有第三四条限制。\nimport cvxpy as cp import numpy as np L=[(0,1,2),(0,2,1),(0,3,3),(0,4,4),(0,5,4),(0,6,2),(0,7,5),(0,8,4), (1,2,4),(1,8,1),(2,3,1),(3,4,1),(4,5,5),(5,6,2),(6,7,3),(7,8,5)] a=np.ones((9,9))*10000 for i in range(len(L)): a[L[i][0], L[i][1]]=L[i][2] a[L[i][1], L[i][0]]=L[i][2] x=cp.Variable((9,9), integer=True) u=cp.Variable(9, pos=True) obj=cp.Minimize(cp.sum(cp.multiply(a,x))) con=[cp.sum(x[0,:])\u0026gt;=1, u[0]==0, u[1:]\u0026gt;=1, u[1:]\u0026lt;=8, x\u0026gt;=0, x\u0026lt;=1] for i in range(1,9): con.append(sum(x[:,i])==1) for i in range(9): for j in range(1,9): con.append(u[i]-u[j]+9*x[i,j]\u0026lt;=8) prob = cp.Problem(obj, con) prob.solve() i, j = np.nonzero(x.value) print(\u0026#34;最优值为:\u0026#34;,prob.value) print(\u0026#34;最优解为：\\n\u0026#34;,x.value) print(\u0026#39;i=\u0026#39;, i); print(\u0026#39;j=\u0026#39;, j) 最优值为: 13.0\n6.5 着色问题 用来处理某些事物不能共存在一起的问题。和安排会议时间的问题。\n比如下面的例子中，有6个部门的会议，有一些相同的人参加，安排不同的最少的时间段，就是着色问题。\n三个要素分别是点，线，和需要最小的涂色。连上的线代表如果安排在同一时间，就会因为有相同的人而导致会议有人缺席。\nimport cvxpy as cp import networkx as nx import numpy as np L = [{\u0026#39;张\u0026#39;,\u0026#39;李\u0026#39;,\u0026#39;王\u0026#39;},{\u0026#39;李\u0026#39;,\u0026#39;赵\u0026#39;,\u0026#39;刘\u0026#39;},{\u0026#39;张\u0026#39;,\u0026#39;刘\u0026#39;,\u0026#39;王\u0026#39;}, {\u0026#39;赵\u0026#39;,\u0026#39;刘\u0026#39;,\u0026#39;孙\u0026#39;},{\u0026#39;张\u0026#39;,\u0026#39;王\u0026#39;,\u0026#39;孙\u0026#39;},{\u0026#39;李\u0026#39;,\u0026#39;刘\u0026#39;,\u0026#39;王\u0026#39;}] w = np.zeros((6,6)) for i in range(5): for j in range(i+1,6): if len(L[i] \u0026amp; L[j])\u0026gt;=1: w[i,j] = 1 #构造邻接矩阵的上三角元素 ni, nj = np.nonzero(w) #边的端点编号 w = w + w.T #构造完整的邻接矩阵 deg = w.sum(axis=1) #求各个顶点的度 K = int(max(deg)) #顶点的最大度 n = len(w) #顶点的个数 x = cp.Variable((n, K+1), integer=True) y = cp.Variable() #定义一个变量 obj = cp.Minimize(y) con = [cp.sum(x, axis=1)==1, x\u0026gt;=0, x\u0026lt;=1] for i in range(n): con.append(y\u0026gt;=range(1,K+2)@x[i,:]) for k in range(K+1): for i in range(len(ni)): con.append(x[ni[i],k]+x[nj[i],k]\u0026lt;=1) prob = cp.Problem(obj, con) prob.solve() i, k = np.nonzero(x.value) print(\u0026#34;最优值为:\u0026#34;,prob.value) print(\u0026#34;最优解为：\\n\u0026#34;,x.value) print(\u0026#39;顶点和颜色的对应关系如下：\u0026#39;) print(\u0026#39;i=\u0026#39;, i+1); print(\u0026#39;k=\u0026#39;, k+1) 最优值为: 4.0\n6.6 最大流与最小费用流问题 6.6.1 最大流问题 最大流问题是一种组合优化问题，讨论如何充分利用装置的能力，使得运输的流量最大以取得最好的效果的问题。有容量限制原则和流量守恒原则。\n#程序文件ex6_17.py import numpy as np import networkx as nx import pylab as plt L=[(1,2,6),(1,3,4),(1,4,5),(2,3,3),(2,5,9),(2,6,9), (3,4,5),(3,5,6),(3,6,7),(3,7,3),(4,3,2),(4,7,5), (5,8,12),(6,5,8),(6,8,10),(7,6,4),(7,8,15)] G=nx.DiGraph() G.add_nodes_from(range(1,9)) G.add_weighted_edges_from(L,weight=\u0026#39;capacity\u0026#39;) value, flow_dict= nx.maximum_flow(G, 1, 8) print(\u0026#34;最大流的流量为：\u0026#34;,value) print(\u0026#34;最大流为：\u0026#34;, flow_dict) n = len(flow_dict) adj_mat = np.zeros((n, n), dtype=int) for i, adj in flow_dict.items(): for j, weight in adj.items(): adj_mat[i-1,j-1] = weight print(\u0026#34;最大流的邻接矩阵为：\\n\u0026#34;,adj_mat) ni,nj=np.nonzero(adj_mat) #非零弧的两端点编号 plt.rc(\u0026#39;font\u0026#39;,size=16) pos=nx.shell_layout(G) #设置布局 w=nx.get_edge_attributes(G,\u0026#39;capacity\u0026#39;) nx.draw(G,pos,font_weight=\u0026#39;bold\u0026#39;,with_labels=True,node_color=\u0026#39;y\u0026#39;) nx.draw_networkx_edge_labels(G,pos,edge_labels=w) path_edges=list(zip(ni+1,nj+1)) nx.draw_networkx_edges(G,pos,edgelist=path_edges,edge_color=\u0026#39;r\u0026#39;,width=3) plt.show() 6.6.2 最小费用流问题 求解总运费最小的方案。流量等于最大流就是最小费用最大流问题。\n第一个赋权的数字是流量，第二个是单位运费。\nnx.max_flow_min_cost(G,\u0026lsquo;vs\u0026rsquo;,\u0026lsquo;vt\u0026rsquo;)\nnx.max_flow_min_cost(G,\u0026lsquo;vs\u0026rsquo;,\u0026lsquo;vt\u0026rsquo;)\n求解语句分别是上面的两个。\nimport numpy as np import networkx as nx L=[(\u0026#39;vs\u0026#39;,\u0026#39;v2\u0026#39;,5,3),(\u0026#39;vs\u0026#39;,\u0026#39;v3\u0026#39;,3,6),(\u0026#39;v2\u0026#39;,\u0026#39;v4\u0026#39;,2,8),(\u0026#39;v3\u0026#39;,\u0026#39;v2\u0026#39;,1,2),(\u0026#39;v3\u0026#39;,\u0026#39;v5\u0026#39;,4,2), (\u0026#39;v4\u0026#39;,\u0026#39;v3\u0026#39;,1,1),(\u0026#39;v4\u0026#39;,\u0026#39;v5\u0026#39;,3,4),(\u0026#39;v4\u0026#39;,\u0026#39;vt\u0026#39;,2,10),(\u0026#39;v5\u0026#39;,\u0026#39;vt\u0026#39;,5,2)] G=nx.DiGraph() for k in range(len(L)): G.add_edge(L[k][0], L[k][1], capacity=L[k][2], weight=L[k][3]) maxFlow=nx.max_flow_min_cost(G,\u0026#39;vs\u0026#39;,\u0026#39;vt\u0026#39;) print(\u0026#34;所求最大流为：\u0026#34;,maxFlow) mincost=nx.cost_of_flow(G, maxFlow) print(\u0026#34;最小费用为：\u0026#34;, mincost) node = list(G.nodes()) #导出顶点列表 n=len(node); flow_mat=np.zeros((n,n)) for i,adj in maxFlow.items(): for j,f in adj.items(): flow_mat[node.index(i),node.index(j)]=f print(\u0026#34;最大流的流量为：\u0026#34;, sum(flow_mat[:,-1])) print(\u0026#34;最小费用最大流的邻接矩阵为：\\n\u0026#34;,flow_mat) 6.7 关键路径 在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系。这样的有向图为顶点表示活动的网，我们称为AOV网（Activity On Vertex Network）。先做某些工作才可以做接下来的工作。\n一个AOV网应该是一个有向无环图，即不应该带有回路，因为若带有回路，则回路上的所有活动都无法进行。\nimport numpy as np import cvxpy as cp x = cp.Variable(8, pos=True) L = [(1,2,5), (1,3,10), (1,4,11), (2,5,4), (3,4,4), (3,5,0), (4,6,15), (5,6,21), (5,7,25), (5,8,35), (6,7,0), (6,8,20), (7,8,15)] obj = cp.Minimize(sum(x)); con = [] for k in range(len(L)): con.append(x[L[k][1]-1] \u0026gt;= x[L[k][0]-1] + L[k][2]) prob = cp.Problem(obj, con); prob.solve(solver = \u0026#39;SCIPY\u0026#39;) print(\u0026#39;最优值为\u0026#39;, prob.value); print(\u0026#39;最优解为：\u0026#39;, x.value) 最优值为 156.0\n最优解为： [ 0. 5. 10. 14. 10. 31. 35. 51.]\n最优解代表各个任务开始在第几天，最后一个数据就是最短工期。\n可以通过一些方法进行开工时间范围的求解。\n后记 W = nx.to_numpy_matrix(G) 报错\n应该修改为：\nW = nx.to_numpy_array(G) #从图G导出邻接矩阵\n推测为版本过低，导致的错误。\n安装cvx conda install cvxopt的安装速度即使使用conda也慢的让人发指。\nsolver=\u0026lsquo;GLPK_MI\u0026rsquo;没有，显示报错，可以去掉，或者改为solver=\u0026lsquo;SCIPY\u0026rsquo;\n报错的一些策略\n是可以求得解的，最终的目标结果相差不大，但组成目标结果的各个参数的值都有所不同。\nconda config \u0026ndash;add channels \u0026ldquo;http://conda.anaconda.org/gurobi\u0026quot;\n在添加默认安装渠道。\nconda info -e\n","permalink":"https://tassel234.github.io/posts/note/python%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AE%97%E6%B3%95-5%E5%9B%BE%E8%AE%BA/","summary":"6.1 图与网络的基础理论 图是描述于一组对象的结构，其中某些对象对在某种意义上是“相关的”。这些对象对应于称为顶点的数学抽象（也称为节点或点），并且每个相关的顶点对都称为边（也称为链接或线）。图论的主要表示方式是邻接矩阵或者邻接表。 6.2 NetworkX简介 是Python的一个库，用来创建","title":"Python数学建模算法-5（图论）"},{"content":"py数模（pca，聚类和判别） 前言 使用资源： https://blog.csdn.net/weixin_43584807/article/details/105539675\nhttps://blog.csdn.net/qq_46092061/article/details/119045393\nhttps://zhuanlan.zhihu.com/p/37777074\npython数学建模算法与应用（司守奎）\naim  知道编程可以做到什么 会看每一行代码在表达什么意思 知道生成数据或者表格的意义 提高建模水平，对各种应用问题进行归纳总结  聚类分析与判别分析 聚类分析 聚类分析的目标就是在相似的基础上收集数据来分类。聚类源于很多领域，包括数学，计算机科学，统计学，生物学和经济学。在不同的应用领域，很多聚类技术都得到了发展，这些技术方法被用作描述数据，衡量不同数据源间的相似性，以及把数据源分类到不同的簇中。\n聚类是将数据分类到不同的类或者簇这样的一个过程，所以同一个簇中的对象有很大的相似性，而不同簇间的对象有很大的相异性。\n从机器学习的角度讲，聚类是搜索簇的无监督学习过程。与分类不同，无监督学习不依赖预先定义的类或带类标记的训练实例，需要由聚类学习算法自动确定标记，而分类学习的实例或数据对象有类别标记。聚类是观察式学习，而不是示例式的学习。\n聚类分析是一种探索性的分析，在分类的过程中，人们不必事先给出一个分类的标准，聚类分析能够从样本数据出发，自动进行分类。聚类分析所使用方法的不同，常常会得到不同的结论。不同研究者对于同一组数据进行聚类分析，所得到的聚类数未必一致。\n从实际应用的角度看，聚类分析是数据挖掘的主要任务之一。而且聚类能够作为一个独立的工具获得数据的分布状况，观察每一簇数据的特征，集中对特定的聚簇集合作进一步地分析。聚类分析还可以作为其他算法（如分类和定性归纳算法）的预处理步骤。\n数据变换 拿到数据首先要消除量纲的影响，常用的处理方法为：\n 中心化处理（坐标轴平移） 规格化处理（最大值减去最小值做分母） 标准化处理（使用标准差）  样本（或指标）间亲疏程度的测度计算 在聚类分析中， 对于两个m维样本常用的距离度量有欧式距离、曼哈顿距离、切比雪夫距离和明可夫斯基距离等。\n欧式距离（Euclidean Distance）是计算欧式空间中两点之间的距离，是最容易理解的距离计算方法。\n曼哈顿距离（Manhattan Distance）也称城市街区距离，欧式距离表明了空间中两点间的直线距离，但是在城市中，两个地点之间的实际距离是要沿着道路行驶的距离，而不能计算直接穿过大楼的直线距离，曼哈顿距离就用于度量这样的实际行驶距离。\n切比雪夫距离（Chebyshev Distance）是向量空间中的一种度量，将空间坐标中两个点的距离定义为其各坐标数值差绝对值的最大值。切比雪夫距离在国际象棋棋盘中，表示国王从一个格子移动到此外一个格子所走的步数。\n明可夫斯基距离（Minkowski Distance）是欧式空间的一种测度，是一组距离的定义，被看作是欧式距离和曼哈顿距离的一种推广。\n基于类间距离的系统聚类 使用linkage,默认是使用最短距离的方法，使用欧几里得距离进行计算。\nimport numpy as np import scipy.cluster.hierarchy as sch import pylab as plt plt.rc(\u0026#39;text\u0026#39;, usetex=True); plt.rc(\u0026#39;font\u0026#39;, size=16) a=np.loadtxt(\u0026#39;data11_2.txt\u0026#39;); n=a.shape[0] b=(a-a.min(axis=0))/(a.max(axis=0)-a.min(axis=0)) z=sch.linkage(b) s=[\u0026#39;$\\\\omega_\u0026#39;+str(i+1)+\u0026#39;$\u0026#39; for i in range(n)] sch.dendrogram(z, labels=s); plt.show() 最长距离的方法和最短距离的步骤基本相似，但距离的定义不同以及计算新类与类的方法不同。 下面的例子是使用马氏距离进行计算的。\nimport numpy as np import scipy.cluster.hierarchy as sch import pylab as plt plt.rc(\u0026#39;text\u0026#39;,usetex=True) a=np.array([[2, 3, 3.5, 7, 9]]).T; n=len(a) c=sch.linkage(a, \u0026#39;complete\u0026#39;, \u0026#39;mahalanobis\u0026#39;) s=[\u0026#39;$\\\\omega_\u0026#39;+str(i+1)+\u0026#39;$\u0026#39; for i in range(n)] sch.dendrogram(c, labels=s); plt.show() n0=eval(input(\u0026#39;请输入聚类的类数n0:\\n\u0026#39;)) cluster= sch.fcluster(c, t=n0, criterion=\u0026#39;maxclust\u0026#39;) print(\u0026#39;聚类的结果为：\u0026#39;,cluster) 可以从图像看出是通过高度进行划分的。\n动态聚类法 k‐均值聚类是基于划分的聚类算法，计算样本点与类簇质心的距离，与类簇质心相近的样本点划分为同一类簇。k‐均值通过样本间的距离来衡量它们之间的相似度，两个样本距离越远，则相似度越低，否则相似度越高。属于一种动态聚类，可以降低内存占用以及运行时间。适用于大量的数据，可以用来简化数据处理的作用。\n#程序文件ex11_5.py import numpy as np from sklearn.cluster import KMeans a = np.array([[2,3,3.5,7,9]]).T md = KMeans(2).fit(a) #构造并求解模型 labels = md.labels_ #提取聚类标签 centers = md.cluster_centers_ #每一行是一个聚类中心 print(labels,\u0026#39;\\n-----------\\n\u0026#39;,centers) 最佳的簇数可以使用探索法，多改几次参数运行代码，然后人工选择。\n还可以采用程序编写的轮廓系数法或者拐点法。\nR型聚类法 研究变量之间的相似程度，按变量的相似程度聚合成多个类。\nimport pandas as pd import scipy.cluster.hierarchy as sch import pylab as plt import numpy as np a = pd.read_excel(\u0026#39;data11_8.xlsx\u0026#39;, header=None) b = a.values.T; b = np.triu(b, k=1) #取对角线上方元素 r = b[np.nonzero(b)]; d = 1 - abs(r) z = sch.linkage(d,\u0026#39;complete\u0026#39;) sch.dendrogram(z,labels=range(1,15)); plt.show() 判别分析 已经确定了分类的结果（比如病人和正常人），对这些分类的大量数据进行判别分析，然后对未知样本进行所属类别的判定。\n距离判别法 通过计算样本均值和协方差来获得马氏距离和判别函数，然后进行判别。inv\nimport numpy as np import sympy as sp from numpy.linalg import inv f = open(\u0026#39;data11_9.txt\u0026#39;); d = f.readlines() a = []; b = [] for i in range(2): a.extend(d[i].split()) a = np.array([eval(e) for e in a]).reshape(2,-1) mu1 = a.mean(axis=1, keepdims=True); s1 = np.cov(a, ddof=1) for i in range(2,4): b.extend(d[i].split()) b = np.array([eval(e) for e in b]).reshape(2,-1) mu2 = b.mean(axis=1, keepdims=True); s2 = np.cov(b, ddof=1) sp.var(\u0026#39;x1,x2\u0026#39;); X = sp.Matrix([x1, x2]) #X为列向量 d1 = (X-mu1).T@inv(s1)@(X-mu1) d1 = sp.expand(d1) d2 = (X-mu2).T@inv(s2)@(X-mu2) d2 = sp.expand(d2) W = sp.lambdify(\u0026#39;x1,x2\u0026#39;, d1-d2, \u0026#39;numpy\u0026#39;) sol = W(np.array([1.24,1.28,1.40]), np.array([1.80,1.84,2.04])) check1 = W(a[0], a[1]); check2 = W (b[0], b[1]) print(np.round(sol,4)) #输出3个判别函数值 Fisher判别 基本思想是投影。LDA\nimport numpy as np from numpy.linalg import inv from sklearn.discriminant_analysis import LinearDiscriminantAnalysis as LDA a = np.loadtxt(\u0026#39;data11_11.txt\u0026#39;) a1 = a[:5, :]; a2 = a[5:10, :]; x = a[10:, :] V = np.cov(a[:10, :].T, ddof=1) #计算协方差阵 VI = inv(V) #计算协方差阵的逆阵 mu1 = a1.mean(axis=0); mu2 = a2.mean(axis=0) k = VI @ (mu1-mu2) #判别函数系数向量 b = -(mu1+mu2) @ VI @ (mu1-mu2)/2 #判别函数常数项 val = x @ k + b #计算判别函数的值 print(\u0026#39;判别函数的值：\u0026#39;, val) d = {0:\u0026#39;B\u0026#39;, 1:\u0026#39;A\u0026#39;} print(\u0026#39;直接计算结果：\u0026#39;,[d[e\u0026gt;0] for e in val]) #输出判别结果 y0 = np.hstack([np.ones(5), np.zeros(5)]) md = LDA().fit(a[:10, :], y0) #直接使用库函数 k2 = md.coef_; b2 = md.intercept_ c = b2/b; check = k * c #验证直接计算和库函数调用等价 val2 = md.predict(x) print(\u0026#39;库函数结果： \u0026#39;,[d[e] for e in val2]) print(\u0026#39;k=\u0026#39;,k, \u0026#39;,b=\u0026#39;,b); print(\u0026#39;k2=\u0026#39;,k2, \u0026#39;,b2=\u0026#39;,b2); print(\u0026#39;比例c=\u0026#39;, c) print(\u0026#39;已知样本误判率为：\u0026#39;, 1-md.score(a[:10, :], y0)) 判别准则的评价 一种评价的估计方法是回代法，估计是有一些偏小的，便于计算。\n还有一种评价的方法是交叉法，较为真实。\n#程序文件ex11_12.py import pandas as pd from sklearn.discriminant_analysis import LinearDiscriminantAnalysis as LDA from sklearn.model_selection import cross_val_score a=pd.read_excel(\u0026#34;data11_10.xlsx\u0026#34;,header=None) b=a.values; x0=b[:-2,:-1].astype(float) y0=b[:-2,-1].astype(float) md = LDA(); print(cross_val_score(md, x0, y0,cv=2)) 主成分分析与因子分析 降维到底是什么，原来的变量和生成的是一样的吗。答案是否定的，他只是多个变量间系数不同的多种组合方式。\n提取成分和降维的区别。 降维和特征提取是机器学习和数据分析中常用的技术，它们之间有一定的区别，但也有很多相似之处。\n  目标： 降维的目标是将高维数据转化为低维数据，同时尽量保留原始数据的重要信息和结构。降维技术通常应用于可视化、压缩和加速计算等领域。 特征提取的目标是从原始数据中提取有意义的特征，以便更好地描述数据。特征提取技术通常应用于分类、回归和聚类等机器学习任务。\n  概念： 降维是一种数据预处理方法，旨在减少数据的复杂性，同时保留数据中的重要信息。降维技术主要包括线性降维（如主成分分析（PCA））和非线性降维（如局部线性嵌入（LLE）和t-分布邻域嵌入算法（t-SNE））。 特征提取是数据预处理的一种形式，旨在从原始数据中提取相关信息，以便更好地用于机器学习算法。特征提取方法包括从原始数据中提取特征，例如图像处理中的边缘检测、形状检测等。\n  数据类型： 降维通常应用于数值型数据，如多维数组和矩阵。降维技术可以将高维数据转换为低维数据，同时保留数据的重要信息。 特征提取通常应用于非数值型数据，如图像、文本和音频数据。特征提取技术可以从原始数据中提取有意义的特征，以便更好地描述数据。\n  总之，降维和特征提取都是数据预处理的重要方法。降维主要关注将高维数据转化为低维数据，以便更好地进行可视化、压缩和加速计算等操作。而特征提取关注从原始数据中提取有意义的特征，以便更好地应用于分类、回归和聚类等机器学习任务。\n降维的两种方式：\n特征选择 主成分分析（可以理解一种特征提取的方式）  主成分分析 主成分分析的基本原理和步骤 数学建模中的降维是指将高维数据转化为低维数据的过程。在这个过程中，数据从高维空间映射到低维空间，同时保留数据的重要信息。降维技术在数学建模中具有很多应用，包括数据可视化、特征选择、模型解释和数据压缩等。降维的主要目的是减少数据中的冗余信息，降低计算复杂度，提高模型的效率和准确性。同时，降维有助于我们更好地理解数据的结构和内在规律。\n在减少需要分析的指标同时，尽量减少原指标包含信息的损失，以达到对所收集数据进行全面分析的目的。由于各变量之间存在一定的相关关系，因此可以考虑将关系紧密的变量变成尽可能少的新变量，使这些新变量是两两不相关的，那么就可以用较少的综合指标分别代表存在于各个变量中的各类信息。主成分分析与因子分析就属于这类降维算法。\n在实际应用中，选择哪种降维方法取决于数据本身的特性、任务需求和模型性能。通过对数据进行有效的降维处理，可以提高模型的解释性、预测准确性和计算效率。\n主成分分析的应用 pca函数的系数分析 （1）在第一主成分的表达式中,可以看出第一、二四五六七项的系数比较大,这6项指标对城镇居民消费水平的影响较大,其中食品消费和医疗保健消费系数比另外几项都大,说明居民现在很注重吃和健康两方面。\n(2)在第二主成分的表达式中 只有第八项的系数比较大,远远超过其他指标的系数,因此可以单独看作是杂项商品与服务的影响,说明杂项商品与服务在消费水平中也据了很大的比例。\n主成分回归分析\n为了减少最小二乘法估计在数据矩阵存在多重共线性而出现的不稳定性提出来的。\n就是把回归的变量改为主成分。\nimport numpy as np from sklearn.decomposition import PCA import statsmodels.api as sm a=np.loadtxt(\u0026#39;data12_2.txt\u0026#39;) mu=a.mean(axis=0) #逐列求均值 s=a.std(axis=0,ddof=1) #逐列求标准差 b=(a-mu)/s #数据标准化 r=np.corrcoef(b[:,:-1].T) #计算相关系数矩阵 md1=PCA().fit(b[:,:-1]) #构造并拟合模型 print(\u0026#39;特征值为：\u0026#39;, md1.explained_variance_) print(\u0026#39;各主成分贡献率：\u0026#39;, md1.explained_variance_ratio_) xs=md1.components_ #提出各主成分系数，每行是一个主成分 print(\u0026#39;主成分系数：\\n\u0026#39;, np.round(xs,4)) print(\u0026#39;累积贡献率：\u0026#39;, np.cumsum(md1.explained_variance_ratio_)) n=3 #选定主成分的个数 f=b[:,:-1]@(xs[:n,:].T) #主成分的得分 d2={\u0026#39;y\u0026#39;:a[:,-1],\u0026#39;x\u0026#39;: a[:,:-1]} md2=sm.formula.ols(\u0026#39;y~x\u0026#39;,d2).fit() #原始数据线性回归 d3={\u0026#39;y\u0026#39;:a[:,-1], \u0026#39;z\u0026#39;:f} md3=sm.formula.ols(\u0026#39;y~z\u0026#39;,d3).fit() #对主成分的回归方程 xs3=md3.params #提取主成分回归方程的系数 xs40=xs3[0]-sum(xs3[1:]@xs[:n,:]*mu[:-1]/s[:-1]) #常数项 xs4=xs3[1:]@xs[:n,:]/s[:-1] #原始变量回归方程的其他系数 print(\u0026#39;回归方程的常数项：\u0026#39;,round(xs40,4)) print(\u0026#39;回归方程的其他系数：\u0026#39;,np.round(xs4,4)) print(\u0026#39;直接回归的残差方差：\u0026#39;,md2.mse_resid) print(\u0026#39;主成分回归的残差方差：\u0026#39;,md3.mse_resid) 核主成分分析\n即KPCA。PCA可以出来线型相关的问题，但没有考虑那些非线性相关的关系，KPCA就是用来解决这个问题的，还可以提供更多的特征信息。\n因子分析 因子分析的数学理论 因子分析是把原始变量分解为若干个因子的线型组合。\n 因子分析模型 因子旋转 因子得分  import numpy as np r=np.array([[1, 1/5, -1/5],[1/5, 1, -2/5],[-1/5, -2/5, 1]]) val,vec=np.linalg.eig(r) #求相关系数阵的特征值和特征向量 A0=vec*np.sqrt(val) #利用广播运算求载荷矩阵 print(\u0026#39;特征值:\u0026#39;,val,\u0026#39;\\n载荷矩阵：\\n\u0026#39;,A0,\u0026#39;\\n----------\u0026#39;) num=int(input(\u0026#34;请输入选择公共因子的个数：\u0026#34;)) A=A0[:,:num] #提出num个因子的载荷矩阵 Ac=np.sum(A**2, axis=0) #逐列元素求和，求信息贡献 Ar=np.sum(A**2, axis=1) #逐行元素求和，求共同度 print(\u0026#34;对x的贡献为：\u0026#34;,Ac) print(\u0026#34;共同度为：\u0026#34;,Ar) u是期望向量，A因子载荷矩阵，艾布西隆是特殊因子向量。\n公共因子的贡献率不同，可以提取较强的公共因子，其他都归为特殊因子艾布西隆。\n不同变量之间有较强的相关性，这些也有一个或者多个公共因子在驱动。\n","permalink":"https://tassel234.github.io/posts/note/python%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AE%97%E6%B3%95-4pca%E5%92%8C%E8%81%9A%E7%B1%BB%E4%B8%8E%E5%88%A4%E5%88%AB/","summary":"py数模（pca，聚类和判别） 前言 使用资源： https://blog.csdn.net/weixin_43584807/article/details/105539675 https://blog.csdn.net/qq_46092061/article/details/119045393 https://zhuanlan.zhihu.com/p/37777074 python数学建模算法与应用（司守奎） aim 知道编程可以做到什么 会看每一行代码在表达什么意思 知道生成数据或者表格的意义 提高建模水平，对各种应用问题进行归纳总结 聚类分析与判别分析 聚类分析 聚类分析的目标就是在相似的基础上收集数据来分类。","title":"Python数学建模算法-4（pca和聚类与判别）"},{"content":"使用资源 （主）目前爬虫真正的应用\n（主）爬虫实例视频\n基础知识 爬虫大概可以分为网页爬虫（也就是搜索引擎）和精确爬虫（爬取单个页面的数据，比如建模使用的机场数据）。\nRobots协议 (也称为爬虫协议、机器人协议等) 的全称是\u0026quot;网络爬虫排除标准”，robots.txt是报索引警访问网站时第一个查看的文件，当我们网站有部分内容希望收提索警抓取时，就可以通过Robots协议来告诉提索察哪些页面是不能抓取的，大多用来保护网站的隐私，以及一些死链、重复页面等等。是君子协议，遵守与否全看你的品行和判刑。\nhttps://www.zhihu.com\nhttps://www.zhihu.com/robots.txt\n为了不进橘子要注意的：不要侵犯个人信息，不要恶意破坏计算机系统，政府网站尽量爬的慢一点。\n爬虫的本质所见即所得，如果你没有b站vip就爬爬不了vip视频，如果真的想爬就学习渗透，不过更容易进橘子。\n如何使用爬虫 第一步:请求信息 网页的一些快捷键：F6选择网页地址。F11当前页面全屏。F12检查（爬虫用的多，还可以鼠标右键进行选择）。control+u显示源代码。control+f可以进行查找。\nget请求直接传过去网址，但有的网站只提供了一个框架，点击内容网站并不跳转，这个时候需要抓包。这种情况一般使用post，有一些情况要自己去查看。\n请求头header，也作为输入的参数之一。还有一些网站的请求头被加密了，如果要使用还要破解，不过这种情况一般比较少。\nparams字典可以让网址的书写更加优雅。\n第二步:提取数据 .json。json的一个字典，提取数据，可以进行遍历。\n.content。保存一些视频图片的二进制等。\n第三步:保存数据 导入csv库，进行csv保存，一般通过记事本看，excel也可以打开。\n注意utf-8,gbk等编码格式。\nopen的Python语法打开和书写文件。\nwith open可以自动关掉。\n反爬之一: 需要登录 .session\n复制加密的cookie\n手搓一个爬虫 tqdm是引入进度条的一个库。 headers的内容直接在检查，网络里面找，搜索pek找到。虽然账号和密码加密了，但是可以直接复制然后使用。\n数据在json库中。\nimport csv from concurrent import futures import requests import pandas as pd import time import tqdm import random def get_data(start_time, end_time, air=\u0026#34;CTU\u0026#34;): url_get_data = \u0026#34;https://data-api.133.cn/api/v1/airport/statistics\u0026#34; params = { \u0026#34;airport\u0026#34;: air, \u0026#34;route_type\u0026#34;: \u0026#34;all\u0026#34;, \u0026#34;start_time\u0026#34;: start_time, \u0026#34;end_time\u0026#34;: end_time } headers = { \u0026#34;Authorization\u0026#34;: \u0026#34;复制自己的\u0026#34;, \u0026#34;Origin\u0026#34;: \u0026#34;https://dast.133.cn\u0026#34;, \u0026#34;Referer\u0026#34;: \u0026#34;https://dast.133.cn/\u0026#34;, \u0026#34;user-agent\u0026#34;: \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36\u0026#34;, \u0026#34;client-id\u0026#34;: \u0026#34;复制自己的\u0026#34;,# 后面要有逗号 \u0026#34;Content-Type\u0026#34;: \u0026#34;application/x-www-form-urlencoded\u0026#34;, \u0026#34;sec-ch-ua-mobile\u0026#34;: \u0026#34;?0\u0026#34;, \u0026#34;sec-ch-ua-platform\u0026#34;: \u0026#34;Windows\u0026#34;, \u0026#34;Sec-Fetch-Dest\u0026#34;: \u0026#34;empty\u0026#34;, \u0026#34;Sec-Fetch-Mode\u0026#34;: \u0026#34;cors\u0026#34;, \u0026#34;Sec-Fetch-Site\u0026#34;: \u0026#34;same-site\u0026#34; } resp = requests.get(url=url_get_data, params=params, headers=headers) resp_json = resp.json() print(resp_json ) arr_plan = resp_json[\u0026#34;data\u0026#34;][\u0026#34;fluctuation\u0026#34;][\u0026#34;arr_plan\u0026#34;] # 计划进港 arr_real = resp_json[\u0026#34;data\u0026#34;][\u0026#34;fluctuation\u0026#34;][\u0026#34;arr_real\u0026#34;] # 实际进港 dep_plan = resp_json[\u0026#34;data\u0026#34;][\u0026#34;fluctuation\u0026#34;][\u0026#34;dep_plan\u0026#34;] # 计划出港 dep_real = resp_json[\u0026#34;data\u0026#34;][\u0026#34;fluctuation\u0026#34;][\u0026#34;dep_real\u0026#34;] # 实际出港 data_list = arr_plan + arr_real + dep_plan + dep_real return data_list def main(da): data = get_data(start_time=da, end_time=da) dataWriter.writerow([da] + data) if __name__ == \u0026#39;__main__\u0026#39;: with open(\u0026#34;CTU_data_twoYears.csv\u0026#34;, mode=\u0026#34;a\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;, newline=\u0026#34;\u0026#34;) as f: dataWriter = csv.writer(f) for date in tqdm.tqdm(pd.date_range(\u0026#34;2020-06-25\u0026#34;, \u0026#34;2022-07-27\u0026#34;)): date_str = str(date.date()) main(date_str) time.sleep(random.random() + 2) # 一定要 2 秒以上，不然大概率封号一阵子 最后爬取到的数据：\n2020-07-16,21,21,19,17,1,1,0,0,0,2,1,1,0,0,1,1,0,6,2,10,14,20,13,11,13,18,19,14,13,15,14,15,15,10,19,12,13,16,13,15,18,17,20,11,22,15,21,24,15,18,13,11,3,0,0,1,2,0,0,0,0,0,1,0,2,6,6,8,11,13,11,12,10,16,16,12,12,14,13,12,12,13,10,12,15,13,13,12,13,14,13,17,15,13,14,12,0,0,0,1,1,0,1,0,0,0,0,5,18,27,23,23,25,20,20,14,14,11,18,18,15,10,14,14,17,15,14,16,14,14,15,13,19,15,17,10,17,10,12,10,7,9,3,3,2,1,1,0,0,1,0,0,0,0,0,1,11,23,22,18,18,17,15,8,10,15,15,15,13,6,11,15,16,11,13,13,14,15,12,15,12,13,17,14,14,10,9,10,8,6,9,1\n2020-07-17,18,18,19,18,1,1,0,0,0,1,1,1,1,0,1,2,1,6,2,10,18,14,15,10,13,19,18,18,15,16,14,17,14,18,15,14,15,15,14,17,20,14,18,11,23,15,25,24,14,14,14,13,7,9,8,0,2,1,0,0,0,0,1,0,1,6,9,11,14,12,12,7,10,16,14,13,13,12,12,12,14,11,11,16,13,11,8,14,16,13,13,16,19,16,17,16,0,0,2,2,2,0,1,0,0,0,0,4,18,23,24,24,29,20,26,18,13,13,19,18,15,9,14,17,15,16,16,12,18,15,15,11,15,17,18,12,14,16,12,11,9,7,3,2,1,2,1,0,1,0,0,1,0,0,0,0,11,16,21,13,19,19,17,14,12,16,13,10,10,13,10,8,14,14,14,15,15,15,15,12,12,14,15,10,12,11,12,8,6,7,7,5\n2020-07-18,23,21,17,19,0,1,0,0,1,0,2,0,1,0,1,2,0,6,2,11,15,18,14,12,13,18,20,16,12,12,17,15,17,15,17,10,14,15,15,15,19,18,17,11,21,15,19,22,13,16,19,8,2,2,3,0,1,0,0,0,0,0,1,1,4,3,7,9,13,8,11,8,11,15,14,11,13,11,12,12,12,10,8,7,13,11,13,15,15,15,15,17,19,17,13,12,0,0,2,4,0,0,1,0,0,0,1,3,19,28,22,25,22,22,24,16,13,12,16,19,15,10,14,15,17,18,15,17,13,13,16,14,18,16,17,11,15,11,12,9,7,9,3,2,0,2,1,1,0,0,0,0,0,0,0,1,11,19,15,13,17,20,18,15,14,15,16,14,15,13,10,9,3,11,14,12,11,5,15,15,15,14,15,14,7,12,9,11,7,5,5,6\n2020-07-19,21,18,20,19,0,1,0,0,1,0,1,0,2,0,1,3,0,7,2,12,17,17,12,12,14,17,19,15,16,13,16,13,14,16,17,12,15,14,13,18,22,12,17,9,26,14,24,24,15,15,10,13,10,9,2,2,0,0,1,1,0,0,2,1,3,4,10,10,15,12,11,10,9,11,15,16,12,14,12,12,13,9,9,6,14,14,16,16,15,9,15,15,17,12,14,17,0,0,0,2,1,0,1,0,0,0,0,3,17,24,24,24,27,19,24,16,15,13,17,20,15,10,14,18,14,14,16,12,16,17,15,11,16,19,15,12,14,15,13,11,8,7,6,2,2,4,1,2,2,2,1,1,0,0,0,1,11,21,18,16,19,18,18,17,14,12,11,10,12,14,12,13,11,10,16,15,14,13,14,13,9,15,13,8,12,11,13,14,5,11,6,3\n上面是爬下来的一些数据，像这样的还有700多行，保存的是csv文件，使用逗号分隔，通过空白页面寻找逗号的个数，可以知道数字的数量。\n191个逗号，192=48*4个数据。\n# tasks = [] # with futures.ThreadPoolExecutor(20) as t: # for date in pd.date_range(\u0026#34;2020-01-01\u0026#34;, \u0026#34;2022-07-27\u0026#34;): # tasks.append(t.submit(main, date)) # print(\u0026#34;爬\u0026#34;) # for task in tqdm.tqdm(futures.as_completed(tasks), total=len(tasks)): # task.result() 这一位是多线程爬虫，是20个爬虫一起爬的存在，很容易封号，因为这二十个爬虫都是使用同一个账号，\n可以买账号，但还是有可能被封，因为20个爬虫公用一个ip地址了，这个时候应该买代理（IP地址）。\n后续学习可以参考的资源 爬虫实例视频\ngithub上的教学，比较全面learn_python3_spider\n爬虫视频2\n各种软件应用的爬虫\n书籍：爬虫实战案例 python让工作自动化 不能使用书籍的代码爬虫写博客，直接使用github的代码。\n在应用更多造好的爬虫之前应该首先学会伪装技术，\n目前阶段只爬取一些人畜无害的东西，学会基础的数据抓取和导入excel表格，比如机场数据。\nsulenium 模拟人工。\nuu模拟器，安卓6，爬取头条等。\n正则表达式，较为万能。\n","permalink":"https://tassel234.github.io/posts/note/%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8-1/","summary":"使用资源 （主）目前爬虫真正的应用 （主）爬虫实例视频 基础知识 爬虫大概可以分为网页爬虫（也就是搜索引擎）和精确爬虫（爬取单个页面的数据，比如建模使用的机场数据）。 Robots协议 (也称为爬虫协议、机器人协议等) 的全称是\u0026quot;网络爬虫排除标准”，robots.txt是报索引警访问","title":"爬虫入门-1"},{"content":"本书是社会派推理小说，主要探讨了死刑制度和普通刑法附带的社会惩罚，以及人性善恶。\n作者高野和明，也是人类灭绝这本书的作者。\n杀人的动机，为了正当防卫而杀人，以及罪犯的改过自新可能性都是这本书的讨论范围。\n一对老夫妇惨遭杀害。一切证据都指向树原亮，他却因车祸，恰好丧失了案发前后数小时的记忆。于是死刑执行官南乡携手刚假释出狱的纯一调查，希望替这位丧失记忆的死刑犯洗清冤屈。但他们查到的线索，只有树原亮记得自己曾“走在台阶上”。距离树原亮被执行死刑的时间所剩无几，但这起案件始终疑云重重，仅有的线索“台阶”仿佛也凭空消失了。\n通过读这本书我知道了日本的死刑制度怎么执行的。十三级台阶是什么。以及执行死刑的人似乎也会被罪恶感所折磨。这是让我想起来之前的一个小故事。在二战时，美国士兵开枪常常因为对方是人而无法瞄准，导致美国士兵被日本士兵反杀。而日本士兵却不会有这种情况，他们下手开枪就要干净利落很多。但这倒不是论证了日本人是天生的恶魔，因为在之后美国的军官发明出了让美国士兵果断开枪的方法，即通过把标靶改为人形，然后训练美国士兵条件反射的开枪，这样就避免了上述的情况。日本士兵的情况我不太了解，不过大概率与他们对天皇近乎病态的信仰有关，然后他们就成为了杀人机器。然后在和平年代的日本，竟然会有执行死刑的人似乎也会被罪恶感所折磨的情况。这只是是说明人类是可以通过一些社会的教化来达到克服本能的效果。不过还有一个反例是天生的杀人魔的情况，只能感叹基因 的神奇了，杀人偿命的观念对杀人魔的基因付出了很多年的清洗，所以到底是为什么呢。是因为时间还不够吗。\n还有一个是关于死刑制度的废除的观点。基于被害人父亲的角度，面对法律的不能偿命的判决，只能收下巨额的抚恤金，然后自己策划对“过失杀人”的主角的复仇。从朴素的复仇观念来考虑，夺走了自己最亲近的人，自己想报仇也无可厚非。实际上这也是大多数国人的观点，至少是我在b站弹屏看到的观点。关于废除死刑的观点下面几个视频有一些表述。不过B站到底还是一个更属于非常年轻的人的一个平台，低龄化严重，似乎不具有代表性（但毕竟他们会成为我们的未来）。还有一个我比较在意的就是网文情节，以前看过一个外国人说的如何辨别中国网文的方法，那就是是否快意恩仇，灭族之类的行为（基督山伯爵也有类似的复仇情节，不过做的就没有中国网文那么果敢了）。关于复仇的情节应该说似乎是一种非常好的爽点。我个人认为这似乎和我们从小接受的历史有关，1840年开始，中国就开始在山河破碎，多国胁迫下度日，屈辱不断，民生凋零。到了二战，日本人又对中国人进行了惨无人道的屠杀，我在历史课本中看到时往往是悲愤的情感，我们把自己带入了前几代人的角色，感受到了自己是受害者，有非常充足的理由去找那些伤害我们的人去复仇。\nhttps://www.bilibili.com/video/BV1Ep4y1J7mk\nhttps://www.bilibili.com/video/BV1Ep4y1J7mk\nhttps://www.bilibili.com/video/BV1Ch411B7FY\n","permalink":"https://tassel234.github.io/posts/read/%E6%B6%88%E5%A4%B1%E7%9A%84%E5%8D%81%E4%B8%89%E7%BA%A7%E5%8F%B0%E9%98%B6%E8%AF%BB%E5%90%8E%E6%84%9F/","summary":"本书是社会派推理小说，主要探讨了死刑制度和普通刑法附带的社会惩罚，以及人性善恶。 作者高野和明，也是人类灭绝这本书的作者。 杀人的动机，为了正当防卫而杀人，以及罪犯的改过自新可能性都是这本书的讨论范围。 一对老夫妇惨遭杀害。一切证据都指向树原亮，他却因车祸，恰好丧失了案发前后数小时的记","title":"《消失的十三级台阶》读后感"},{"content":"线性规划和整数规划模型 4.1 线性规划模型 分为目标方程，也是需要最优化的对象。以及s.t.（即约束条件）\n对于数学规划模型一定要进行灵敏度分析。\nimport cvxpy as cp from numpy import array c = array([70, 50, 60]) #定义目标向量 a = array([[2, 4, 3], [3, 1, 5], [7, 3, 5]]) #定义约束矩阵 b = array([150, 160, 200]) #定义约束条件的右边向量 x = cp.Variable(3, pos=True) #定义3个决策变量 obj = cp.Maximize(c@x) #构造目标函数 cons = [a@x \u0026lt;=b] #构造约束条件 prob = cp.Problem(obj, cons) prob.solve(solver=\u0026#39;SCIPY\u0026#39;) #求解问题 print(\u0026#39;最优解为：\u0026#39;, x.value) print(\u0026#39;最优值为：\u0026#39;, prob.value) Variable还 可以生成未知变量矩阵。\n最后默认求解器和SCIPY以及无法使用的glpk都给出了不一样的结果，但最优解都是相似的。\n4.2 整数规划 0-1规划，决策变量只能取0或者1的整数规划。\n可以用来求解背包问题 背包问题比较简单。\n指派问题 有点类似于穷举的方法。\n旅行商问题\n第三四个条件几乎是绑定的，用来约束不含子回路 的条件。\n前两个条件分别代表每个城市只允许进入和出去一次。\n非标准指派问题举例\n个数约束条件由等于1改为\u0026lt;=2.\nimport cvxpy as cp import numpy as np c = np.loadtxt(\u0026#39;data4_10.txt\u0026#39;) x = cp.Variable((4,5), integer=True) #定义3个决策变量 obj = cp.Minimize(cp.sum(cp.multiply(c,x))) #构造目标函数 cons = [0\u0026lt;=x, x\u0026lt;=1, cp.sum(x, axis=0)==1, cp.sum(x, axis=1)\u0026lt;=2] #构造约束条件 prob = cp.Problem(obj, cons) prob.solve() #求解问题 print(\u0026#39;最优解为：\\n\u0026#39;, x.value) print(\u0026#39;最优值为：\u0026#39;, prob.value) 4. 3 投资的收益与风险 分为三种模型\n1.固定风险，优化收益\n2.固定收益，极小化风险\n3.加权\n#模型一的实现代码 import cvxpy as cp import pylab as plt b = plt.array([0.025, 0.015, 0.055, 0.026]) c = plt.array([0.05, 0.27, 0.19, 0.185, 0.185]) x = cp.Variable(5, pos=True) aeq = plt.array([1, 1.01, 1.02, 1.045, 1.065]) obj = cp.Maximize( c @ x) a = 0; aa = []; Q = []; X = []; M = 10000; while a \u0026lt; 0.05: con = [aeq @ x == M, cp.multiply(b,x[1:])\u0026lt;=a*M] prob = cp.Problem(obj, con) prob.solve(solver=\u0026#39;SCIPY\u0026#39;) aa.append(a); Q.append(prob.value) X.append(x.value) a = a + 0.001 plt.rc(\u0026#39;text\u0026#39;, usetex=True); plt.rc(\u0026#39;font\u0026#39;, size=15) plt.plot(aa, Q, \u0026#39;r*\u0026#39;); plt.xlabel(\u0026#39;$a$\u0026#39;) plt.ylabel(\u0026#39;$Q$\u0026#39;, rotation=0); plt.show() 4. 4 比赛项目排序问题 05年电工杯B题\n先使用0 1对必须同时参加两个项目的人数进行数学描述，赋值为0或者1.\n然后可以可以划分为旅行商问题，安排比赛的行程，然后使同时参加两个项目的人数最小。\nD5章 非线性规划和多目标规划模型 5.1 非线性规划概念和理论 可以使用拉格朗日乘数法或者罚函数法。\n其实对应python编写程序的复杂度来说并没有什么大的不同。\n5.2 一个简单非线性规划模型 彩电例子，有两种彩电，他们每售出一台，会让自己和对方的价格都有所下降。\n#程序文件ex5_2.py import sympy as sp import pylab as plt plt.rc(\u0026#39;text\u0026#39;, usetex=True) #使用LaTeX字体 plt.rc(\u0026#39;font\u0026#39;,size=14) sp.var(\u0026#39;x1, x2\u0026#39;) #定义符号变量 y = (339-0.01*x1-0.003*x2)*x1+(399-0.004*x1-0.01*x2)*x2-(400000+195*x1+225*x2) y = sp.simplify(y) #化简 dy1 = y.diff(x1) #求关于x1的偏导 dy2 = y.diff(x2) #求关于x2的偏导 s = sp.solve([dy1, dy2], [x1, x2]) x10 = round(float(s[x1])) #取整 x20 = round(float(s[x2])) y0 = y.subs({x1: x10, x2: x20}) #符号函数代入数值 f = sp.lambdify(\u0026#39;x1, x2\u0026#39;, y, \u0026#39;numpy\u0026#39;) #符号函数转换为匿名函数 x = plt.linspace(0, 10000, 100) X, Y = plt.meshgrid(x, x) #转换为网格数据 Z = f(X, Y) ax=plt.subplot(121, projection=\u0026#39;3d\u0026#39;) #第一个子窗口三维画图 ax.plot_surface(X, Y, Z,cmap=\u0026#39;viridis\u0026#39;) ax.set_xlabel(\u0026#39;$x_1$\u0026#39;); ax.set_ylabel(\u0026#39;$x_2$\u0026#39;) plt.subplot(122) #激活第二个子窗口 contr=plt.contour(X,Y,Z,10) #10条等高线 plt.clabel(contr) #等高线标注 plt.ylabel(\u0026#39;$x_2$\u0026#39;,rotation=0) plt.xlabel(\u0026#39;$x_1$\u0026#39;) sp.var(\u0026#39;a\u0026#39;, pos=True) #定义灵敏度分析的符号参数 y = (339-a*x1-0.003*x2)*x1+(399-0.004*x1-0.01*x2)*x2-(400000+195*x1+225*x2) y = sp.simplify(y) #化简 dy1 = y.diff(x1) #求关于x1的偏导 dy2 = y.diff(x2) #求关于x2的偏导 s = sp.solve([dy1, dy2], [x1, x2]) sx1 = s[x1]; sx2 = s[x2] #提取解分量 s1 = sp.lambdify(\u0026#39;a\u0026#39;, sx1, \u0026#39;numpy\u0026#39;) #符号函数转换为匿名函数 s2 = sp.lambdify(\u0026#39;a\u0026#39;, sx2, \u0026#39;numpy\u0026#39;) a0 = plt.linspace(0.002, 0.02, 50) plt.figure() plt.subplots_adjust(wspace = 0.65) plt.subplot(121); plt.plot(a0, s1(a0)) plt.xlabel(\u0026#39;$a$\u0026#39;); plt.ylabel(\u0026#39;$x_1$\u0026#39;) plt.subplot(122); plt.plot(a0, s2(a0)) plt.xlabel(\u0026#39;$a$\u0026#39;); plt.ylabel(\u0026#39;$x_2$\u0026#39;) dx1 = sx1.diff(a); dx10 = dx1.subs(a, 0.01) sx1a = dx10 * 0.01 / 4735 dx2 = sx2.diff(a); dx20 = dx2.subs(a, 0.01) sx2a = dx20 * 0.01 / 7043 Y = y.subs({x1: s[x1], x2: s[x2]}) #求关于a的目标函数 Y = sp.factor(Y); Y = sp.simplify(Y) Ya = sp.lambdify(\u0026#39;a\u0026#39;, Y, \u0026#39;numpy\u0026#39;) #转换为匿名函数 a0 = plt.linspace(0.002, 0.02, 1000) plt.figure(); plt.plot(a0, Ya(a0)) plt.xlabel(\u0026#39;$a$\u0026#39;); plt.ylabel(\u0026#39;$y$\u0026#39;, rotation=0) Sya = - 4735 ** 2 * 0.01 / 553641.025 y2 = y.subs({x1: 4735, x2: 7043, a: 0.011}) #计算近似最优利润 y3 = Y.subs(a, 0.011) #计算最优利润 delta = (y3 - y2) / y2 #计算利润的相对误差 plt.show() 使用到了sympy进行公式推导。\n5. 3 二次规划模型 这个点要注意双变量组合的方程，普通的方差加上协方差。\n5.4 非线性规划的求解及应用 直接使用scipy库里面 的minimize函数可以进行求解。\n不过程序编写的属性发生了一点改变，不需要写没有大于等于或者小于等于的符号了，需要人工转换为\u0026gt;=的表示方法。\n#程序文件ex5_6.py import numpy as np from scipy.optimize import minimize obj=lambda x: sum(x**2)+8 def constr1(x): x1, x2, x3 = x return [x1**2-x2+x3**2, 20-x1-x2**2-x3**2] def constr2(x): x1, x2, x3 = x return [-x1-x2**2+2, x2+2*x3**2-3] con1={\u0026#39;type\u0026#39;: \u0026#39;ineq\u0026#39;, \u0026#39;fun\u0026#39;: constr1} con2={\u0026#39;type\u0026#39;: \u0026#39;eq\u0026#39;, \u0026#39;fun\u0026#39;: constr2} con=[con1, con2] #构造全部约束条件 bd = [(0, np.inf) for i in range(3)] res = minimize(obj, np.random.randn(3), constraints=con, bounds=bd) print(res) #输出解的信息 5.5 多目标规划 分为4种对多目标的处理方法。\n 线型加权法 约束法 理想点法 优先级法  理想点法是通过分别求各个目标的最优解，然后做目标函数和最优解的差的平方之和，合并为同一个目标函数。\n优先级法是先确保某一个目标有最优解，然后才保证其他目标的最优解。\n#程序文件ex5_9.py import numpy as np import cvxpy as cp c1 = np.array([-2, -3]) c2 = np.array([1, 2]) a = np.array([[0.5, 0.25], [0.2, 0.2], [1, 5], [-1, -1]]) b = np.array([8, 4, 72, -10]) x = cp.Variable(2, pos=True) obj = cp.Minimize(0.5 * (c1 + c2) @ x) con = [a @ x \u0026lt;= b] prob = cp.Problem(obj, con) prob.solve(solver=\u0026#39;SCIPY\u0026#39;) print(\u0026#39;最优解为：\u0026#39;, x.value) print(\u0026#39;最优值为：\u0026#39;, prob.value) obj1 = cp.Minimize(c1 @ x) prob1 = cp.Problem(obj1, con) prob1.solve(solver=\u0026#39;SCIPY\u0026#39;) v1 = prob1.value #线型加权目标函数的最优值 obj2 = cp.Minimize(c2 @ x) prob2 = cp.Problem(obj2, con) prob2.solve(solver=\u0026#39;SCIPY\u0026#39;) v2 = prob2.value #理想点法的目标函数的最优值 print(\u0026#39;两个目标函数的最优值分别为：\u0026#39;, v1, v2) obj3 = cp.Minimize((c1@x-v1)**2+(c2@x-v2)**2) prob3 = cp.Problem(obj3, con) prob3.solve() print(\u0026#39;解法二的最优解：\u0026#39;, x.value) con.append( c1 @ x == v1) prob4 = cp.Problem(obj2, con) prob4.solve(solver=\u0026#39;SCIPY\u0026#39;) x3 = x.value #优先级法求最优解的值 print(\u0026#39;解法三的最优解：\u0026#39;, x3) print(\u0026#39;利润：\u0026#39;, -c1@x3); print(\u0026#39;排放污染物：\u0026#39;, c2@x3) ","permalink":"https://tassel234.github.io/posts/note/python%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AE%97%E6%B3%95-3%E8%A7%84%E5%88%92/","summary":"线性规划和整数规划模型 4.1 线性规划模型 分为目标方程，也是需要最优化的对象。以及s.t.（即约束条件） 对于数学规划模型一定要进行灵敏度分析。 import cvxpy as cp from numpy import array c = array([70, 50, 60]) #定义目标向量 a = array([[2, 4, 3], [3, 1, 5], [7, 3, 5]]) #定义约束矩阵 b = array([150, 160, 200]) #定义约束条件的右边向量 x = cp.Variable(3, pos=True) #定义3个决策变量 obj = cp.Maximize(c@x) #","title":"Python数学建模算法-3（规划）"},{"content":"树结构 树的基本概念 树广泛应用于计算机的操作系统，数据库管理系统。\n树可以形成森林。\n二叉树 二叉树的定义 二叉树的链接浪费率最低，约为1/2。\n树根是上面的那个节点，最下面的是树叶。\n二叉树的左子数存放比较小的数字，右边存放比较大的数字。\n空集合可以是二叉树，但不能是树，很奇怪，但是就是这样规定的。\n两个定理： 高度为k的满二叉树的节点为2的K次方-1。 度数为2的节点数是树叶节点的个数减一。  特殊二叉树 满二叉树，完全二叉树，斜二叉树，严格二叉树。 从上到下，从左到右，编号一一对应。\n二叉树的存储方式 用一维数组来实现二叉树 从上到下，从左到右，编号一一对应。空的地方填0.\n用链表来实现二叉树 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; #define ArraySize 10 using namespace std; class Node //二叉树的节点声明 { public: int value; //节点数据 struct Node *left_Node; //指向左子树的指针 struct Node *right_Node; //指向右子树的指针 }; typedef class Node TreeNode; //定义新的二叉树节点数据类型 typedef TreeNode *BinaryTree; //定义新的二叉树指针数据类型 BinaryTree rootNode; //二叉树的根节点的指针 //将指定的值加入到二叉树中适当的节点 void Add_Node_To_Tree(int value) { BinaryTree currentNode; BinaryTree newnode; int flag=0; //用来记录是否插入了新的节点 newnode=(BinaryTree) new TreeNode; //建立节点内容 newnode-\u0026gt;value=value; newnode-\u0026gt;left_Node=NULL; newnode-\u0026gt;right_Node=NULL; //如果为空的二叉树，则将新的节点设置为根节点 if(rootNode==NULL) rootNode=newnode; else { currentNode=rootNode; //设置一个指针指向根节点 while(!flag) if (value\u0026lt;currentNode-\u0026gt;value) { //在左子树 if(currentNode-\u0026gt;left_Node==NULL) { currentNode-\u0026gt;left_Node=newnode; flag=1; } else currentNode=currentNode-\u0026gt;left_Node; } else { //在右子树 if(currentNode-\u0026gt;right_Node==NULL) { currentNode-\u0026gt;right_Node=newnode; flag=1; } else currentNode=currentNode-\u0026gt;right_Node; } } } int main(void) { int tempdata; int content[ArraySize]; int i=0; rootNode=(BinaryTree) new TreeNode; rootNode=NULL; cout\u0026lt;\u0026lt;\u0026#34;请连续输入10个数据：\u0026#34;\u0026lt;\u0026lt;endl; for(i=0;i\u0026lt;ArraySize;i++) { cout\u0026lt;\u0026lt;\u0026#34;请输入第\u0026#34;\u0026lt;\u0026lt;setw(1)\u0026lt;\u0026lt;(i+1)\u0026lt;\u0026lt;\u0026#34;个数据：\u0026#34;; cin\u0026gt;\u0026gt;tempdata; content[i]=tempdata; } for(i=0;i\u0026lt;ArraySize;i++) Add_Node_To_Tree(content[i]); cout\u0026lt;\u0026lt;\u0026#34;完成了用链表建立二叉树！\u0026#34;; cout\u0026lt;\u0026lt;endl; return 0; } 二叉树的遍历 中序遍历, 后序遍历 ,前序遍历 中序遍历, 后序遍历 ,前序遍历 指的顺序都是树根什么时候被查。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; class tree //节点链表结构声明 { public : int data; //节点数据 class tree *left,*right; //节点左指针和右指针 }; typedef class tree node; typedef node *btree; btree creat_tree(btree,int); void pre(btree); void in(btree); void post(btree); int main(void) { int arr[]={7,4,1,5,16,8,11,12,15,9,2}; //原始数组内容 btree ptr=NULL; //声明树根 cout\u0026lt;\u0026lt;\u0026#34;[原始数组内容]\u0026#34;\u0026lt;\u0026lt;endl; for (int i=0;i\u0026lt;11;i++) //建立二叉树，并将二叉树的内容打印出来 { ptr=creat_tree(ptr,arr[i]); cout\u0026lt;\u0026lt;\u0026#34;[\u0026#34;\u0026lt;\u0026lt;setw(2)\u0026lt;\u0026lt;arr[i]\u0026lt;\u0026lt;\u0026#34;] \u0026#34;; } cout\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;[二叉树的内容]\u0026#34;\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;前序遍历的结果：\u0026#34;\u0026lt;\u0026lt;endl; //打印前、中、后序遍历的结果 pre(ptr); cout\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;中序遍历的结果：\u0026#34;\u0026lt;\u0026lt;endl; in(ptr); cout\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;后序遍历的结果：\u0026#34;\u0026lt;\u0026lt;endl; post(ptr); cout\u0026lt;\u0026lt;endl; return 0; } btree creat_tree(btree root,int val) //建立二叉树的子程序 { btree newnode,current,backup; //声明一个新节点newnode来存放数组中的数据 newnode = new node; //其中current和backup用于暂存指针 newnode-\u0026gt;data=val; //设置新节点的数据及左右指针 newnode-\u0026gt;left=NULL; newnode-\u0026gt;right=NULL; if (root==NULL) //如果root为空值，则把新节点返回当作树根 { root=newnode; return root; } else //若root不是树根，则建立二叉树 { for(current=root;current!=NULL;) //current复制root以保留当前的树根值 { backup=current; //暂存父节点 if(current-\u0026gt;data \u0026gt; val) //比较树根节点和新节点的数据 current=current-\u0026gt;left; else current=current-\u0026gt;right; } if(backup-\u0026gt;data \u0026gt; val) //把新节点和树根链接起来 backup-\u0026gt;left=newnode; else backup-\u0026gt;right=newnode; } return root; //返回指向树的指针，即指向树根的指针 } void pre(btree ptr) //前序遍历 { if (ptr != NULL) { cout\u0026lt;\u0026lt;\u0026#34;[\u0026#34;\u0026lt;\u0026lt;setw(2)\u0026lt;\u0026lt;ptr-\u0026gt;data\u0026lt;\u0026lt;\u0026#34;] \u0026#34;; pre(ptr-\u0026gt;left); pre(ptr-\u0026gt;right); } } void in(btree ptr) //中序遍历 { if (ptr != NULL) { in(ptr-\u0026gt;left); cout\u0026lt;\u0026lt;\u0026#34;[\u0026#34;\u0026lt;\u0026lt;setw(2)\u0026lt;\u0026lt;ptr-\u0026gt;data\u0026lt;\u0026lt;\u0026#34;] \u0026#34;; in(ptr-\u0026gt;right); } } void post(btree ptr) //后序遍历 { if (ptr != NULL) { post(ptr-\u0026gt;left); post(ptr-\u0026gt;right); cout\u0026lt;\u0026lt;\u0026#34;[\u0026#34;\u0026lt;\u0026lt;setw(2)\u0026lt;\u0026lt;ptr-\u0026gt;data\u0026lt;\u0026lt;\u0026#34;] \u0026#34;; } } 二叉树节点的插入与删除 #include \u0026lt;iostream\u0026gt; using namespace std; struct tree { int data; struct tree *left,*right; }; typedef struct tree node; typedef node *btree; btree creat_tree(btree root,int val) { btree newnode,current,backup; newnode=(btree)new node; newnode-\u0026gt;data=val; newnode-\u0026gt;left=NULL; newnode-\u0026gt;right=NULL; if(root==NULL) { root=newnode; return root; } else { for(current=root;current!=NULL;) { backup=current; if(current-\u0026gt;data \u0026gt; val) current=current-\u0026gt;left; else current=current-\u0026gt;right; } if(backup-\u0026gt;data \u0026gt; val) backup-\u0026gt;left=newnode; else backup-\u0026gt;right=newnode; } return root; } btree search(btree ptr,int val) //查找二叉树的子程序 { while(1) { if(ptr==NULL) //没找到就返回NULL return NULL; if(ptr-\u0026gt;data==val) //节点值等于查找值 return ptr; else if(ptr-\u0026gt;data \u0026gt; val) //节点值大于查找值 ptr=ptr-\u0026gt;left; else ptr=ptr-\u0026gt;right; } } void inorder(btree ptr) //中序遍历的子程序 { if(ptr!=NULL) { inorder(ptr-\u0026gt;left); cout\u0026lt;\u0026lt;\u0026#34;[\u0026#34;\u0026lt;\u0026lt;ptr-\u0026gt;data\u0026lt;\u0026lt;\u0026#34;]\u0026#34;; inorder(ptr-\u0026gt;right); } } int main() { int i,data,arr[]={7, 1, 4, 2, 8, 13, 12, 11, 15, 9, 5}; btree ptr=NULL; cout\u0026lt;\u0026lt;\u0026#34;[原始数组内容]\u0026#34;\u0026lt;\u0026lt;endl; for (i=0;i\u0026lt;11;i++) { ptr=creat_tree(ptr,arr[i]); //建立二叉树 cout\u0026lt;\u0026lt;\u0026#34;[\u0026#34;\u0026lt;\u0026lt;arr[i]\u0026lt;\u0026lt;\u0026#34;] \u0026#34;; } cout\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;请输入要查找的值：\u0026#34;; cin\u0026gt;\u0026gt;data; if((search(ptr,data))!=NULL) //查找二叉树 cout\u0026lt;\u0026lt;\u0026#34;二叉树中有此节点了!\u0026#34;\u0026lt;\u0026lt;data\u0026lt;\u0026lt;endl; else { ptr=creat_tree(ptr,data); inorder(ptr); } return 0; } 二叉运算树 线索二叉树 可以提高节点的利用率，中序遍历时不需要使用栈堆与递归。但运行速度较慢。\n按中序遍历顺序，空连接指针如果是该节点的左指针，指向中序遍历顺序下的前一个节点；空连接指针如果是该节点的右指针，指向中序遍历顺序下的后一个节点。没有前后的就空着。 树的二叉树表示法 （左儿子，右兄弟） 树转化为二叉树 二叉树转化为树 实际上是上述过程的逆运算，先把右子树旋转45度，然后删除兄弟连接，改为父子。\n森林转化为二叉树 方法基本一样，把根节点当兄弟节点连接到一起。\n二叉树转化为森林 逆运算。\n树与森林的遍历 中序遍历, 后序遍历 ,前序遍历 指的顺序都是树根什么时候被查。 方向是从左到右。\n确定唯一二叉树 知道中序遍历, 后序遍历或知道中序遍历, 前序遍历都可以确定唯一的树，但知道后序遍历 ,前序遍历 不能确定唯一的树。\n优化二叉查找树 扩充二叉树 对空链接加上外节点，其他的节点都是内节点。\n内径长是所有内节点的到根节点的距离。外径长也顾名思义。\n可对外径长进行加权处理。\n哈夫曼树 平衡树 （AVL树） 所有内部节点的左右子树的高度大概平衡，左右子树的节点相差小于或等于1.\n高级树结构的研究 博弈树 博弈树(game tree)是一种特殊的根树,它是人工智能领域一个重要的研究课题。博弈树就是符合博弈规则的决策树。\n博弈决策形成人工智能的方式是查找，在所有情况下找出获胜的情况。\nB树 平衡树概念的延申。 一棵m阶B树(balanced tree of order m)是一棵平衡的m路搜索树。它或者是空树，或者是满足下列性质的树： 1、根结点至少有两个子女； 2、每个非根节点所包含的关键字个数 j 满足：┌m/2┐ - 1 \u0026lt;= j \u0026lt;= m - 1； 3、除根结点以外的所有结点（不包括叶子结点）的度数正好是关键字总数加1，故内部子树个数 k 满足：┌m/2┐ \u0026lt;= k \u0026lt;= m ； 4、所有的叶子结点都位于同一层。\n二叉空间分割树 属于二叉树，特点是每一个节点都有两个子节点。这是游戏空间常用的一种分割方法，通常应用于平面绘图软件。\n二叉树节点内的数据结构以平面方式分割场景。\n四叉树与八叉树 提供更好的分类能力。\n堆 树的形状取决于数据的个数。结点的排列顺序为从上到下，同一行里则为从左到右。\n在堆中存储数据时必须遵守这样一条规则:子结点必定大于父结点。因此最小值被存储在顶端的根结点中。往堆中添加数据时，为了遵守这条规则，一般会把新数据放在最下面一行靠左的位置。当最下面一行里没有多余空间时，就再往下另起一行，把数据加在这一行的最左端。\n按顺序加入 在堆中取出数字，取得是上面最小的数据。 然后把最后的数据移到上面，和下面的节点按照规则比较并移动。最终的结果如下。\n图的数据表示法 邻接矩阵法 无向图的邻接矩阵是对称的，因为连接是双向的，而有向图不是。\n声明的元素个数是6x6个，而点只有5个 ,声明7个可以，方便填入。\n#include \u0026lt;iostream\u0026gt; using namespace std; int main(void) { int arr[6][6];\t//声明矩阵arr， int data[14][2]={{1,2},{2,1},{1,5},{5,1}, //无向图各边的起点值和终点值 {2,3},{3,2},{2,4},{4,2}, {3,4},{4,3},{3,5},{5,3}, {4,5},{5,4}}; for (int i=0;i\u0026lt;6;i++)\t//把矩阵清为0 for (int j=0;j\u0026lt;6;j++) arr[i][j]=0; for (int i=0;i\u0026lt;14;i++)\t//读取图的数据 //for (int j=0;j\u0026lt;6;j++)\t//填入arr矩阵,源代码加上了这一行和下面一行， //for (int k=0;k\u0026lt;6;k++)//但貌似没什么用，可以直接去掉 { int tmpi, tmpj; tmpi=data[i][0];\t//tmpi为起始顶点 tmpj=data[i][1];\t//tmpj为终止顶点 arr[tmpi][tmpj]=1;\t//有边的点填入1 } cout\u0026lt;\u0026lt;\u0026#34;无向图矩阵：\u0026#34;\u0026lt;\u0026lt;endl; for (int i=1;i\u0026lt;6;i++) { for (int j=1;j\u0026lt;6;j++) cout\u0026lt;\u0026lt;\u0026#34;[\u0026#34;\u0026lt;\u0026lt;arr[i][j]\u0026lt;\u0026lt;\u0026#34;] \u0026#34;; //打印矩阵内容 cout\u0026lt;\u0026lt;endl; } } 有向图的表示方法类似。 只是修改了一点。\nint data[5][2]={{1,2},{2,1},{2,3},{2,4},{4,3}} 邻接链表法 空间利用率高。\n/* [示范]:使用邻接表来表示图(a)和(b) */ #include \u0026lt;iostream\u0026gt; using namespace std; class list { public: int val; class list *next; }; class list head[6];//声明一个节点类型的数组 int main(void) { list *ptr,*newnode; int data[14][2]={{1,2},{2,1},{1,5},{5,1},//声明存储图的数组 {2,3},{3,2},{2,4},{4,2}, {3,4},{4,3},{3,5},{5,3}, {4,5},{5,4}}; cout\u0026lt;\u0026lt;\u0026#34;图(a)的邻接表内容：\u0026#34;\u0026lt;\u0026lt;endl; for (int i=1;i\u0026lt;6;i++) { head[i].val=i; //链表头head head[i].next=NULL; cout\u0026lt;\u0026lt;\u0026#34;顶点 \u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; =\u0026gt;\u0026#34;;\t//把顶点值打印出来 ptr=\u0026amp;(head[i]); //暂存节点ptr for (int j=0;j\u0026lt;14;j++) //遍历图数组 { if (data[j][0]==i) //如果节点值=i，加入节点到链表头 { newnode = new list; newnode-\u0026gt;val=data[j][1];//声明新节点，值为终点值 newnode-\u0026gt;next=NULL; while(ptr!=NULL) //判断是否为链表的末尾 ptr=ptr-\u0026gt;next; ptr=newnode; //加入新节点 cout\u0026lt;\u0026lt;\u0026#34;[\u0026#34;\u0026lt;\u0026lt;newnode-\u0026gt;val\u0026lt;\u0026lt;\u0026#34;] \u0026#34;;//打印相邻顶点 } } cout\u0026lt;\u0026lt;endl; } } 其他方法 邻接复合链表法 索引表格法\n图的遍历 深度优先遍历 首先需要生成邻接链表，方便之后遍历。\n然后使用递归和堆栈的知识去进行广度优先搜索。压入一个点相邻的所有顶点，然后用堆栈去取出一个点，压入这个点相邻的所有顶点，递归调用，循环往复。\n/* [示范]:深度优先遍历法(BFS) */ #include \u0026lt;iostream\u0026gt; using namespace std; class list { public: int val; class list *next; }; typedef class list node; typedef node *link; class list* head[9]; void dfs(int); int run[9]; int main(void) { link ptr,newnode; int data[20][2]={{1,2},{2,1},{1,3},{3,1},//声明存放图的边的数组 {2,4},{4,2},{2,5},{5,2}, {3,6},{6,3},{3,7},{7,3}, {4,5},{5,4},{6,7},{7,6}, {5,8},{8,5},{6,8},{8,6}}; for (int i=1;i\u0026lt;=8;i++)//共有八个顶点 { run[i]=0; //把所有顶点设置为尚未遍历过 head[i]= new node; head[i]-\u0026gt;val=i; //设置各个链表头的初值 head[i]-\u0026gt;next=NULL; ptr=head[i]; //设置指针为链表头 for(int j=0;j\u0026lt;20;j++) //二十条边 { if(data[j][0]==i) //如果起点和链表头相等，则把顶点加入链表 { newnode =new node; newnode-\u0026gt;val=data[j][1]; newnode-\u0026gt;next=NULL; do { ptr-\u0026gt;next=newnode;//加入新节点 ptr=ptr-\u0026gt;next; }while(ptr-\u0026gt;next!=NULL); } } } cout\u0026lt;\u0026lt;\u0026#34;图的邻接表内容：\u0026#34;\u0026lt;\u0026lt;endl;//打印图的邻接表内容 for(int i=1;i\u0026lt;=8;i++) { ptr=head[i]; cout\u0026lt;\u0026lt;\u0026#34;顶点 \u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34;=\u0026gt; \u0026#34;; ptr = ptr-\u0026gt;next; while(ptr!=NULL) { cout\u0026lt;\u0026lt;\u0026#34;[\u0026#34;\u0026lt;\u0026lt;ptr-\u0026gt;val\u0026lt;\u0026lt;\u0026#34;] \u0026#34;; ptr=ptr-\u0026gt;next; } cout\u0026lt;\u0026lt;endl; } cout\u0026lt;\u0026lt;\u0026#34;深度优先遍历顶点：\u0026#34;\u0026lt;\u0026lt;endl;//打印深度优先遍历的顶点 dfs(1); cout\u0026lt;\u0026lt;endl; } void dfs(int current) //深度优先遍历子程序 { link ptr; run[current]=1; cout\u0026lt;\u0026lt;\u0026#34;[\u0026#34;\u0026lt;\u0026lt;current\u0026lt;\u0026lt;\u0026#34;] \u0026#34;; ptr=head[current]-\u0026gt;next; while(ptr!=NULL) {\tif (run[ptr-\u0026gt;val]==0) //如果顶点尚未遍历， dfs(ptr-\u0026gt;val); //就进行dfs的递归调用 ptr=ptr-\u0026gt;next; } } 广度优先遍历 仍然先 生成邻接链表，然后使用队列进行广度优先搜索。\n部分实现如下。\n/* [示范]:广度优先遍历法(BFS) */ void bfs(int current) { link tempnode;\t//临时的节点指针 enqueue(current);\t//将第一个顶点加入队列 run[current]=1;\t//将遍历过的顶点设置为1 cout\u0026lt;\u0026lt;\u0026#34;[\u0026#34;\u0026lt;\u0026lt;current\u0026lt;\u0026lt;\u0026#34;]\u0026#34;;\t//打印出该遍历过的顶点 while(front!=rear) {\t//判断当前是否为空队列 current=dequeue();\t//将顶点从队列中取出 tempnode=Head[current].first; //先记录当前顶点的位置 while(tempnode!=NULL) { if(run[tempnode-\u0026gt;x]==0) { enqueue(tempnode-\u0026gt;x); run[tempnode-\u0026gt;x]=1; //记录已遍历过 cout\u0026lt;\u0026lt;\u0026#34;[\u0026#34;\u0026lt;\u0026lt;tempnode-\u0026gt;x\u0026lt;\u0026lt;\u0026#34;]\u0026#34;; } tempnode=tempnode-\u0026gt;next; } } } 生成树 深度优先生成树和广度优先生成树 又叫花费树，成本树。联通所有的顶点。可以利用bfs或者dfs来生成。\n最小生成树 又叫最小花费树，最小成本树。如果路径上有权重，就使用最小权重和的生成树。\nKruskal算法 先把权值从小到大排列，从最小的边开始，建立最小生成树，如果形成圈就舍弃不用，直到加入n-1条边。\n/* [示范]:最小成本生成树 */ #include \u0026lt;iostream\u0026gt; #define VERTS 6 //图的顶点数 using namespace std; void mintree(mst head) //最小成本生成树子程序 { mst ptr,mceptr; int result=0; ptr=head; for(int i=0;i\u0026lt;=VERTS;i++) v[i]=0; while(ptr!=NULL) { mceptr=findmincost(head); v[mceptr-\u0026gt;from]++; v[mceptr-\u0026gt;to]++; if(v[mceptr-\u0026gt;from]\u0026gt;1 \u0026amp;\u0026amp; v[mceptr-\u0026gt;to]\u0026gt;1) { v[mceptr-\u0026gt;from]--; v[mceptr-\u0026gt;to]--; result=1; } else result=0; if(result==0) cout\u0026lt;\u0026lt;\u0026#34;起始顶点 [\u0026#34;\u0026lt;\u0026lt;mceptr-\u0026gt;from \u0026lt;\u0026lt;\u0026#34;]\\t终止顶点 [\u0026#34;\u0026lt;\u0026lt;mceptr-\u0026gt;to\u0026lt;\u0026lt;\u0026#34;]\\t路径长度 [\u0026#34; \u0026lt;\u0026lt;mceptr-\u0026gt;val\u0026lt;\u0026lt;\u0026#34;]\u0026#34;\u0026lt;\u0026lt;endl; ptr=ptr-\u0026gt;next; } } Prim算法 图的最短路径 单点对全部顶点——Dijkstra算法 果然福特算法过于费时间，所以这本书没有提及。可以看看其他的图论笔记。\n/* [示范]:Dijkstra算法(单点对全部顶点的最短路径) */ #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;iomanip\u0026gt; #define SIZE 7 #define NUMBER 6 #define INFINITE 99999\t//无穷大 using namespace std; int Graph_Matrix[SIZE][SIZE];\t//存放图的数组 int distance[SIZE];\t//路径的长度 //建立图 void BuildGraph_Matrix(int *Path_Cost) { int Start_Point;\t//边的起点 int End_Point;\t//边的终点 int i, j; for ( i = 1; i \u0026lt; SIZE; i++ ) for ( j = 1; j \u0026lt; SIZE; j++ ) if ( i == j ) Graph_Matrix[i][j] = 0;\t//对角线设为0 else Graph_Matrix[i][j] = INFINITE; //存入图的边 i=0; while(i\u0026lt;SIZE) { Start_Point = Path_Cost[i*3]; End_Point = Path_Cost[i*3+1]; Graph_Matrix[Start_Point][End_Point]=Path_Cost[i*3+2]; i++; } } //打印出图 void printGraph_Matrix() { int i, j; for ( i = 1; i \u0026lt; SIZE; i++ ) { cout\u0026lt;\u0026lt;\u0026#34;vex\u0026#34;\u0026lt;\u0026lt;i; for ( j = 1; j \u0026lt; SIZE; j++ ) if ( Graph_Matrix[i][j] == INFINITE ) cout\u0026lt;\u0026lt;setw(5)\u0026lt;\u0026lt;\u0026#39;x\u0026#39;; else cout\u0026lt;\u0026lt;setw(5)\u0026lt;\u0026lt;Graph_Matrix[i][j]; cout\u0026lt;\u0026lt;endl; } } //单点对全部顶点的最短距离 void shortestPath(int vertex1, int vertex_total) { extern int distance[SIZE];\t//声明为外部变量 int shortest_vertex = 1; //记录最短距离的顶点 int shortest_distance; //记录最短距离 int goal[SIZE]; //用来记录该顶点是否被选取 int i,j; for ( i = 1; i \u0026lt;= vertex_total; i++ ) { goal[i] = 0; distance[i] = Graph_Matrix[vertex1][i]; } goal[vertex1] = 1; distance[vertex1] = 0; cout\u0026lt;\u0026lt;endl; for (i=1; i\u0026lt;=vertex_total-1; i++ ) { shortest_distance = INFINITE; //找出最短距离的顶点 for (j=1;j\u0026lt;=vertex_total;j++ ) if (goal[j]==0\u0026amp;\u0026amp;shortest_distance\u0026gt;distance[j]) { shortest_distance=distance[j]; shortest_vertex=j; } goal[shortest_vertex] = 1; //计算开始顶点到各顶点的最短距离 for (j=1;j\u0026lt;=vertex_total;j++ ) { if ( goal[j] == 0 \u0026amp;\u0026amp; distance[shortest_vertex] +Graph_Matrix[shortest_vertex][j]\u0026lt;distance[j]) { distance[j]=distance[shortest_vertex] +Graph_Matrix[shortest_vertex][j]; } } } } //主程序 int main(void) { extern int distance[SIZE];\t//声明为外部变量 int Path_Cost[7][3] = { {1, 2, 10}, {2, 3, 20}, {2, 4, 25}, {3, 5, 18}, {4, 5, 22}, {4, 6, 95}, {5, 6, 77} }; int j; BuildGraph_Matrix(\u0026amp;Path_Cost[0][0]); cout\u0026lt;\u0026lt;\u0026#34;==================================\u0026#34;\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;此范例图的邻接矩阵如下: \u0026#34;\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;==================================\u0026#34;\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;顶点 vex1 vex2 vex3 vex4 vex5 vex6\u0026#34;\u0026lt;\u0026lt;endl; printGraph_Matrix(); //显示图 shortestPath(1,NUMBER); //查找最短路径 cout\u0026lt;\u0026lt;\u0026#34;==================================\u0026#34;\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;顶点1到各顶点最短距离的最终结果\u0026#34;\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;==================================\u0026#34;\u0026lt;\u0026lt;endl; for (j=1;j\u0026lt;SIZE;j++) cout\u0026lt;\u0026lt;\u0026#34;顶点 1到顶点\u0026#34;\u0026lt;\u0026lt;setw(2)\u0026lt;\u0026lt;j\u0026lt;\u0026lt;\u0026#34;的最短距离=\u0026#34; \u0026lt;\u0026lt;setw(3)\u0026lt;\u0026lt;distance[j]\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;endl; return 0; } A*算法 引用推测权重，使用距离预估函数，但有一定可能会出错而造成找不到最短路径。\n两两顶点间的最短路径——Floyd算法 弗洛伊德算法，可以找到任意两点之间的最小路径。\nAOV网络与拓扑排序 也叫顶点活动网络，在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系。这样的有向图为顶点表示活动的网，我们称为AOV网（Activity On Vertex Network）。先做某些工作才可以做接下来的工作。\n一个AOV网应该是一个有向无环图，即不应该带有回路，因为若带有回路，则回路上的所有活动都无法进行。\n在AOV网中，若不存在回路，则所有活动可排列成一个线性序列，使得每个活动的所有前驱活动都排在该活动的前面，我们把此序列叫做拓扑序列(Topological order)，由AOV网构造拓扑序列的过程叫做拓扑排序(Topological sort)。AOV网的拓扑序列不是唯一的，满足上述定义的任一线性序列都称作它的拓扑序列。\nAOE网络 在带权有向图中若以顶点表示事件，有向边表示活动，边上的权值表示该活动持续的时间，这样的图简称为AOE网。\n完成工程的最短时间：从工程开始点（源点）到完成点（汇点）的最短路径称为完成工程的最短时间。\n关键路径：路径长度最长的路径称为关键路径。\n","permalink":"https://tassel234.github.io/posts/note/%E4%BD%BF%E7%94%A8cpp%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-3%E6%A0%91%E5%92%8C%E5%9B%BE%E8%AE%BA/","summary":"树结构 树的基本概念 树广泛应用于计算机的操作系统，数据库管理系统。 树可以形成森林。 二叉树 二叉树的定义 二叉树的链接浪费率最低，约为1/2。 树根是上面的那个节点，最下面的是树叶。 二叉树的左子数存放比较小的数字，右边存放比较大的数字。 空集合可以是二叉树，但不能是树，很奇怪，但是就是这样规","title":"使用Cpp实现数据结构-3（树和图论）"},{"content":"数组的定义和使用 （1）一维数组的定义、初始化、引用 使用数组，可以方便地定义一个名字（数组名）来表示大批量数据，并能够通过循环批处理大量数据。\n一维数组是由元素类型、数组名和长度组成的构造类型。例如：\nint A[10], B[20]; // 元素是整型 常量表达式表示数组中元素的个数，称为数组长度。常量表达式的值必须为正整数且大于等于1。数组一经定义，数组长度就始终不变。定义中数组的值不能是变量。\n初值列表提供的元素个数不能超过数组长度，但可以小于数组长度。如果初值个数小于数组长度，则只初始化前面的数组元素，剩余元素初始化为0。\n可以用下面的表达式计算出数组A的长度：\nint A[]={1,8,9}; sizeof(A) / sizeof(int) 下标表达式可以是常量、变量、表达式，但必须是正整数，不允许为负。下标由0开始。整个数组不允许进行赋值运算、算术运算等操作，只有元素才可以。\n（2）二维数组的定义、初始化、引用 本质上，C++的多维数组都是一维数组。\nint A[2][3]={ {1,2,3},{4,5,6}};//初值按二维形式 int A[2][3]={ 1,2,3,4,5,6 };//初值按一维形式 初值列表提供的元素个数不能超过数组长度，但可以小于数组长度。如果初值个数小于数组长度，则只初始化前面的数组元素；剩余元素初始化为0。这个规则两种初始化形式都适用。\nint A[3][4]={{1},{1,2},{1,2,3}}; int A[3][4]={1,2,3,4,5}; 多维数组定义时可以不用指定第1维的数组长度，但其余维的长度必须指定，编译器会根据列出的元素个数自动确定第1维的长度。\nint A[][2][3]={1,2,3,4,5,6,7,8,9,10,11,12};//正确 int B[2][][3]={1,2,3,4,5,6,7,8,9,10,11,12};//错误，只能省略第1维 数组与函数 （1）数组作为函数的参数 x=max(c,-10); //使用变量或常数作为函数实参 x=max(A[2],-10); //使用数组元素作为函数实参 a[5]的a就是数组的首地址，可以作为参数传递到数组。如果实参使用数组名调用，本质上是将这个数组的首地址传递到形参中。这就造成了数组即使形式参数又是实际参数，（内存中 两个对象所处位置相同，则它们实为同一个对象）不像变量是生成副本，无法在函数体内修改它的值。\nvoid fun(int A[5],int n) { A[1]=100; //A[1]实质就是实参a[1] n=10; //赋值给形参n，不影响实参x } void caller() { int a[5]={1,2,3,4,5},x=5; fun(a,x); cout\u0026lt;\u0026lt;a[1]\u0026lt;\u0026lt;“,“\u0026lt;\u0026lt;x\u0026lt;\u0026lt;endl; //a[1]=100,x=5 } 数组的定义中可以不写长度，写长或者写短都可以。而且名字可以不同，只有是数组就可以。（对一维数组而言）\n（2）数组参数的传递机制 既然形参数组就是实参数组，所以函数调用时不会为形参数组分配存储空间。\n多维数组作为函数的参数，形参数组第1维可以与实参相同，也可以不相同；可以是任意长度，也可以不写长度；但其他维的长度需要相同。\nvoid f(int A[5][10]); //正确 void f(int A[2][10]); //正确 void f(int A[][10]); //正确 void f(int A[][]); //错误，第2维长度必须给出 void f(int A[5][5]); //错误，第2维长度必须相同 void f(int A[50]); //错误，必须是二维数组 字符串的处理 （1）字符数组 char s[20]; //定义字符数组 char s[4]={\u0026#39;J\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;v\u0026#39;,\u0026#39;a\u0026#39;}; //字符数组初始化 C++语言规定字符串是以'\\0'（ASCII值为0）字符作为结束符的字符数组。C++总是在编译时为字符串常量自动在其后增加一个空字符。以定义字符数组时数组的长度至少为字符串长度加1（空字符也要占位）。\nchar c; char s[10]=“hello.”; c=‘a’; //正确 c=“a”; //错误 //因为使用\u0026#34;\u0026#34;会造成自动带一个空字符，数组的长度至少为2 （1）使用标准输入输出流，将整个字符串一次输入或输出\nchar str[80];//数组应该比较大 cin \u0026gt;\u0026gt; str; //输入字符串 cout \u0026lt;\u0026lt; str; //输出字符串 （2）使用字符串输入输出函数\nchar str[80]; gets(str); //输入字符串 char str[80]=\u0026#34;Programming\u0026#34;; puts(str); //输出字符串 （2）字符串处理函数 C++标准库提供了兼容C语言的字符串处理函数，其头文件为string.h。\n►（1）字符串复制函数strcpy char str1[10],str2[]=\u0026#34;Computer\u0026#34;; strcpy(str1,str2); //复制str2到str1 ►（2）字符串复制函数strncpy char str1[10], str2[]=\u0026#34;Computer\u0026#34;; strncpy(str1,str2,4);//复制str2的前4个字符到str1 ►（3）字符串连接函数strcat char str1[10]=\u0026#34;ABC\u0026#34;, str2[]=\u0026#34;123\u0026#34;; strcat(str1,str2);//在str1后面连接str2,str2未变化 ►（4）字符串连接函数strncat char str1[10]=\u0026#34;ABC\u0026#34;,str2[]=\u0026#34;123456\u0026#34;; strncat(str1,str2,4);//将str2前4个字符连接到str1后面 ►（5）字符串比较函数strcmp if (strcmp(str1,str2)==0)...... //比较字符串相等 if (strcmp(str1,str2)\u0026gt;0)......//比较str1大于str2 ►（6）计算字符串长度函数 n=strlen(\u0026#34;Language\u0026#34;); //n=8 char str[20]=\u0026#34;Visual Basic\u0026#34;; n=strlen(str); //n=12 ►（7）字符串转换成数值函数 f=atof(\u0026#34;123.456\u0026#34;); //f=123.456 i=atoi(\u0026#34;-456\u0026#34;); //i=-456 （3）字符串对象 C++特有，使用string类型，比使用C风格字符串更方便、更安全。这样和python非常类似了。\n#include \u0026lt;string\u0026gt; //不能写为string.h char S2[20]=\u0026#34;Java\u0026#34;; //C风格字符串初始化 string str2=\u0026#34;Java\u0026#34;; //string对象复制初始化 string str3(\u0026#34;C++\u0026#34;); //string对象直接初始化 输入输出和上个章节类似。\nstr1=\u0026#34;Java\u0026#34;; //C风格字符串可以直接赋给string str1.c_str(); //string转换为C风格字符串，返回char指针 str1.copy(S1,n,pos); //把str1中从pos开始的n个字符复制到S1字符数组 （4）字符串对象的操作 string对象允许使用运算符进行操作，实现类似C风格字符串的处理。如复制（strcpy）、连接（strcat）、比较（strcmp）等。下面的这些运算和python非常类似了。\n字符串连接运算\nstr1=\u0026#34;12\u0026#34; , str2=\u0026#34;AB\u0026#34; , str3=\u0026#34;CD\u0026#34;; str1 = str2 + str3; //str1结果为ABCD str1 = str1 + \u0026#34;PHP\u0026#34;; //str1结果为12PHP str1 += str3; //str1结果为12CD 字符串关系运算\nstr1=\u0026#34;ABC\u0026#34; , str1=\u0026#34;XYZ\u0026#34;; str1 \u0026gt; str2; //结果为假 str1 == str2; //结果为假 str1 == \u0026#34;ABC\u0026#34;; //结果为真 其他\nstr1=\u0026#34;ABCDEFGHIJK\u0026#34;; //获取字符串的长度 n = str1.size(); //n为11 n = str1.length(); //n为11 //检查字符串是否为空字符串 b = str1.empty(); //b为假 //得到子字符串 str2 = str1.substr(2,4); //从下标2开始的4个字符，str2为CDEF //查找子字符串 n = str1.find(\u0026#34;DEF\u0026#34;,pos); //从pos开始查找字符串\u0026#34;DEF\u0026#34;在str1中的位置，n为3 //删除字符 str1.erase(3,5); //从下标3开始往后删5个字符，str1变为ABCIJK //增加字符 str1.append(\u0026#34;12345\u0026#34;,1,3); //在str1末尾增加\u0026#34;12345\u0026#34;下标从1开始的3个字符，即\u0026#34;234\u0026#34; //字符串替换和插入操作 str1.replace(p0,n0,S1,n); //删除从p0开始的n0个字符，然后在p0处插入字符串S1前n个字符 str1.replace(p0,n0,str2,pos,n); //删除从p0开始的n0个字符，然后在p0处插入字符串str2中pos开始的前n个字符 str1.insert(p0,S1,n); //在p0位置插入字符串S1前n个字符 str1.insert(p0,str2,pos,n); //在p0位置插入字符串str2中pos开始的前n个字符 字符串对象数组\nstring SY[5]={\u0026#34;123\u0026#34;,\u0026#34;12\u0026#34;,\u0026#34;1234\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;12345\u0026#34;}; //长度 3,2,4,1,5 数组的应用 （1）用数组解决排序问题 冒泡排序 冒泡排序法（bubble sort）的基本思想是通过相邻两个记录之间的比较和交换，使关键码较小的记录逐渐从底部移向顶部。\n#include \u0026lt;iostream\u0026gt; using namespace std; #define N 10 //数组元素个数 int main() { int A[N], i, j, t; //注意数组下标从0开始 for (i=0; i\u0026lt;N; i++) cin\u0026gt;\u0026gt;A[i]; //输入N个数 for(j=0 ; j\u0026lt;N-1 ; j++) //冒泡排序法 for(i=0 ; i\u0026lt;N-1-j; i++) //一趟冒泡排序 if(A[i] \u0026gt; A[i+1]) //A[i]与A[i+1]比较 \u0026lt;升序 \u0026gt;降序 t=A[i], A[i]=A[i+1], A[i+1]=t; //交换 for (i=0; i\u0026lt;N; i++) cout\u0026lt;\u0026lt;A[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; //输出排序结果 return 0; } 选择排序法 选择排序法（selection sort）的基本思想是第i趟选择排序通过n-i次关键码的比较，从n-i+1个记录中选出关键码最小的记录，并和第i个记录进行交换。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;ctime\u0026gt; using namespace std; void SelectionSort(int A[],int n) //选择排序 n为数组元素个数 { int i,j,k,t; for(i=0; i\u0026lt;n-1; i++) { //选择排序法 k=i; for(j=i+1; j\u0026lt;n; j++) //一趟选择排序 if (A[j] \u0026lt; A[k]) k=j; //\u0026lt;升序 \u0026gt;降序 if(i!=k) t=A[i], A[i]=A[k], A[k]=t; } } #define N 10 int main() { int A[N],i; srand((unsigned int)time(0)); //设置随机数种子 for(i=0; i\u0026lt;N; i++) { //随机产生N个数 A[i] = rand()%100; cout\u0026lt;\u0026lt;A[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; SelectionSort(A,N); for(i=0; i\u0026lt;N; i++) cout\u0026lt;\u0026lt;A[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; //输出排序结果 return 0; （2）用数组解决查找问题 顺序查找法 就是这个比较，返回数组下标。\n#include \u0026lt;iostream\u0026gt; using namespace std; int Search(int A[],int n,int find) { //顺序查找 n=序列元素个数 find=欲查找数据 int i; for (i=0; i\u0026lt;n ; i++) if (A[i]==find) return i; return -1; //未找到 } #define N 10 int main() { int A[N]={18,-3,-12,34,101,211,12,90,77,45}, i,find; cin\u0026gt;\u0026gt;find; i=Search(A,N,find); if(i\u0026gt;=0) cout\u0026lt;\u0026lt;\u0026#34;A[\u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34;]=\u0026#34;\u0026lt;\u0026lt;find\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;\u0026#34;not found\u0026#34;\u0026lt;\u0026lt;endl; return 0; } 二分查找法 先排序，后查找\n#include \u0026lt;iostream\u0026gt; using namespace std; int BinarySearch(int A[],int n,int find) { //二分查找 n=序列元素个数 find=欲查找数据 int low,upper,mid; low=0 , upper=n-1; //左右两部分 while(low\u0026lt;=upper) { mid = low + (upper-low)/2; //不用(upper+low)/2，避免upper+low溢出 if( A[mid] \u0026lt; find) low = mid+1; //右半部分 else if (A[mid] \u0026gt; find) upper = mid - 1; //左半部分 else return mid; //找到 } return -1; //未找到 } #define N 10 int main() { int A[N]={8,24,30,47,62,68,83,90,92,95},i,find; cin\u0026gt;\u0026gt;find; i=BinarySearch(A,N,find); if(i \u0026gt;= 0) cout\u0026lt;\u0026lt;\u0026#34;A[\u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34;]=\u0026#34;\u0026lt;\u0026lt;find\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;\u0026#34;not found\u0026#34;\u0026lt;\u0026lt;endl; return 0; } 指针的定义与使用 （1）指针的定义 return语句只能返回一个值，即使有多个return也只还回第一个。加上数组也是只针对多个相同类型的数据，如果使用指针就可以想返回多少就返回多少。指针是两个函数进行数据交换必不可少的工具。\n 指针记录某一变量的地址，指针本身也有地址，存于特定的区域 int *pa=pb的写法正确，* 是间接寻址符或者叫取值符,可以理解为从pa指针取出的值是整形。但如果在声明中赋值也是可以的，因为pa在声明中也确实是指针，可以理解为把 *分配给了int，可以理解定义了一个指向int的指针，所以应该使用地址赋值，而不是数值赋值。 *pa单独出现代表了从pa指向的地址中取出来的值，前面要是加上int,char等声明，* pa就只是代表pa指针了。 int *pa;pa=\u0026amp;a这样声明也可以 \u0026amp; 是取地址运算符  由于指针数据的特殊性，其初始化和赋值运算是有约束条件的，只能使用以下四种值： （1）0值常量表达式\np1=null; //正确，指针允许0值常量表达式 p1=0; //正确，指针允许0值常量表达式 （2）相同指向类型的对象的地址。 （3）相同指向类型的另一个有效指针。例如：\nint x, *px=\u0026amp;x; //正确 int *py=px; //正确，相同指向类型的另一个指针 （4）对象存储空间后面下一个有效地址，如数组下一个元素的地址。\nint a[10], *px=\u0026amp;a[2]; //正确 int *py=\u0026amp;a[++i]; //正确，相同指向类型的另一个指针 （2）指针的有效性和运算 无效的情况 如果指针的值为0，称为0值指针，又称空指针（null pointer），空指针是无效的。\n如果指针未经初始化，或者没有赋值，或者指针运算后指向未知对象，那么该指针是无效的。\n一个指针曾经指向一个已知对象，在对象的内存空间释放后，虽然该指针仍是原来的内存地址，但指针所指已是未知对象，称为“迷途指针”\n如果指针的位置停留在未知的位置，那么修改指针的值有可能造成重要的数据被修改。\n指针的运算 （1）指针加减整数运算\nint x[10], n=3 , *p=\u0026amp;x[5]; p+1 //指向存储空间中x[5]后面的第1个int型存储单元 p+n //指向存储空间中x[5]后面的第n(3)个int型存储单元 p-1 //指向存储空间中x[5]前面的第1个int型存储单元 p-n //指向存储空间中x[5]前面的第n(3)个int型存储单元 （2）指针变量自增自减运算\nint x[10], *p=\u0026amp;x[5]; p++ //p指向x[5]后面的第1个int型内存单元 ++p //p指向x[5]后面的第1个int型内存单元 p-- //p指向x[5]前面的第1个int型内存单元 --p //p指向x[5]前面的第1个int型内存单元 （3）两个指针相减运算\nint x[5], *p1=\u0026amp;x[0], *p2=\u0026amp;x[4]; int n; n=p2-p1;//n的值为4 （4）指针的关系运算 即比较地址数据的大小，位置的前后。\nconst的三种 主要应用领域是让实参于函数中不可修改 单const\nconst int *p//代表不可以改变变量的值，但是可以改变指针指向， //实际编程中，指向const的指针常用作函数的形参，以此确保传递给函数的实参对象在函数中不被修改。 int *const pc=\u0026amp;a//代表地址不可以改了，但数值可以改 双const\nconst int *const cpc=\u0026amp;b\n指针与数组 一维数组与指针 数组名既代表数组本身，又代表整个数组的地址，还是是数组首元素的地址值.\nint a[10], b[10], c[10]; a=b; //错误，a是常量不能出现在左值的位置 c=a+b; //错误，a、b是地址值，不允许加法运算 a++; //错误，a是常量不能使用++运算 int a[]; int *p p=a//数组的名称就代表了地址 pb=\u0026amp;a[0]//a[0]就是变量了，要用取地址运算符 *(a+i) *(p+i) 上述代码都是成立的\n区别  指针并不能被赋予常量的值int *p,p=2//是错的 指针所存储的是变量的地址值，指针可以进行数加减，自增，自减；相减时值得注意，间隔几个元素取决他的类型。也可以进行关系运算 数组的数组名不可以进行这些操作  （1）使用下标法访问数组元素，程序写法比较直观，能直接知道访问的是第几个元素。\n（2）而使用指针引用法，指针变量直接指向元素，不必每次都重新计算地址，能提高运行效率。\n（3）将自增和自减运算用于指针变量十分有效，可以使指针变量自动向前或向后指向数组的下一个或前一个元素。\n指针写起来更简捷一些\n（2）指针与字符串 char *p=\u0026#34;C Language\u0026#34;; //或者 char *p; p=\u0026#34;C Language\u0026#34;; 访问\nchar str[]=\u0026#34;C Language\u0026#34;, *p=str; //p指向字符串的指针 cout\u0026lt;\u0026lt;p\u0026lt;\u0026lt;endl; //输出：C Language cout\u0026lt;\u0026lt;p+2\u0026lt;\u0026lt;endl; //输出：Language cout\u0026lt;\u0026lt;\u0026amp;str[7]\u0026lt;\u0026lt;endl; //输出：age 遍历\nchar str[]=\u0026#34;C Language\u0026#34; , *p=str; //p指向字符串的指针 while (*p!=\u0026#39;\\0\u0026#39;) cout\u0026lt;\u0026lt;*p++; 指针与函数 （1）指针作为函数的参数 指针是函数参数传递的重要工具。比如swap交换函数要使用指针，直接使用变量会生成副本。通过将指针作为函数参数的方法，既可以返回多个运算结果，又避免了使用全局变量。\n（2）数组作为函数的参数 数组同样是直接使用地址，不使用副本，直接修改原数组数据。将一个字符串传递到函数中，传递的是地址，则函数形参既可以用字符数组，又可以用指针变量，两种形式完全等价。在子函数中可以修改字符串的内容，主调函数得到的是变化后的字符串。\n（3）引用 引用类型是结合了数组和指针的优点，不在C语言中，而属于C++的一个特性。\n 引用类型自带const限定，引用一旦被初始化，就不能改变引用关系，不能再作为其他对象的引用。 初始化是必定要绑定赋值，不能为空 写法是int x;\u0026amp;r=x  int x, \u0026amp;r=x; //定义整型变量x,y int *p1=\u0026amp;x; //p1指向x int *p2=\u0026amp;r; //p2指向r，本质上指向x //程序① 传递对象本身 #include \u0026lt;iostream\u0026gt; using namespace std; //对象作为函数形参 void swap(int a,int b) { int t; t=a, a=b, b=t; } int main() { int x=10, y=20; swap(x,y); 12 cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34;,\u0026#34;\u0026lt;\u0026lt;y; 13 return 0; 14 } //程序② 传递对象的指针 #include \u0026lt;iostream\u0026gt; using namespace std; //指针作为函数形参 void swap(int *a,int *b) { int t; t=*a, *a=*b, *b=t; } int main() { int x=10, y=20; swap(\u0026amp;x,\u0026amp;y); cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34;,\u0026#34;\u0026lt;\u0026lt;y; return 0; } //程序③ 传递对象的引用 #include \u0026lt;iostream\u0026gt; using namespace std; //引用作为函数形参 void swap(int \u0026amp;a,int \u0026amp;b) { int t; t=a, a=b, b=t; } int main() { int x=10, y=20; swap(x,y); cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34;,\u0026#34;\u0026lt;\u0026lt;y; return 0; （4）指向函数的指针 函数代码在内存中也要占据一段存储空间（代码区内），这段存储空间的起始地址称为函数入口地址。C++规定函数入口地址为函数的指针，即函数名既代表函数，又是函数的指针（或地址）。\nC++允许定义指向函数的指针变量，定义形式为：\nint (*p)(int a, int b); //定义函数指针变量 int max(int a, int b); //max函数原型 int min(int a, int b); //min函数原型 int (*p)(int a, int b); //定义函数指针变量 p=max; c=p(a,b); //等价于c=max(a,b); 变为动态方式调用。熟练掌握函数指针的应用，有利于程序的模块化设计，提高程序的可扩展性。\n动态分配内存 （1）new与delete运算符 数据类型* 指针名称 = new 数据类型 int* p = new int delete p; 可以拓展到结构体或类\n动态分配是根据程序的需要适时分配，且分配的大小就是程序要求的大小。分配的空间可以根据程序的需要扩大或缩小；\nnew 动态分配\nnew [] 动态分配数组\ndelete 释放空间\ndelete [] 释放数组空间\n（2）动态内存的应用 ►（1）静态内存管理由编译器进行，而动态内存管理按程序员人为的指令进行。\n►（2）动态内存分配和释放必须对应，即有分配就必须有释放，后果是随着程序运行多次，可以使用的内存空间越来越少.\n► （3）动态分配内存的生命期由程序员决定，即从分配时开始，至释放时结束。特别地，动态分配内存的生命期允许跨多个函数。\n►（4）避免释放内存后出现“迷途指针”，应及时设置为空指针。\n#include \u0026lt;iostream\u0026gt; using namespace std; int *f1(int n) //分配n个整型内存，返回首地址 { int *p, i; p = new int[n]; //分配 for (i=0; i\u0026lt;n; i++) p[i]=i; //赋初始值 return p; //动态分配的指针返回是有意义的 } void f2(int *p,int n) //输出动态内存中的n个数据 { while (n--\u0026gt;0) cout\u0026lt;\u0026lt;*p++\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } void f3(int *p) { delete [] p; } //释放内存 int main() { int *pi; pi=f1(5); //分配 f2(pi,5); //输出 f3(pi); //释放 return 0; } int *f1(int n)返回指针的函数\n（3）动态分配数组 #include \u0026lt;iostream\u0026gt; using namespace std; double AVE(double *A,int N) //计算N*N二维数组元素的平均值 { int i,j,sum=0; for(i=0;i\u0026lt;N;i++) for(j=0;j\u0026lt;N;j++) sum=sum+*(A+i*N+j); return sum/(N*N); } int main() { int i,j,n=4; cin\u0026gt;\u0026gt;n; double *A=new double[n*n]; //分配“数组”A[n][n] for (i=0;i\u0026lt;n;i++) for (j=0;j\u0026lt;n;j++) cin\u0026gt;\u0026gt;*(A+i*n+j); //输入数据到A[i][j] cout\u0026lt;\u0026lt;\u0026#34;detA=\u0026#34;\u0026lt;\u0026lt;AVE(A,n)\u0026lt;\u0026lt;endl; delete [] A; //释放“数组” return 0; } （4）动态分配字符串 char *p=new char[1000]; //分配字符串空间 cin\u0026gt;\u0026gt;p; //输入字符串 cout\u0026lt;\u0026lt;p; //输出字符串 delete [] p; //释放字符串空间 结构体 基本知识 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { cout\u0026lt;\u0026lt;\u0026#34;hello\\n\u0026#34;; struct DATA{ int year; int mouth; int day; }; struct staff{ int no; char name[21]; char sex; DATA birthday; double salary; }; staff s1={1001,\u0026#34;archer\u0026#34;,\u0026#39;m\u0026#39;,{1980,1,1},2900.0};//s1是一个结构体对象， cout\u0026lt;\u0026lt;s1.birthday.year;//成员引用使用. //成员只可以逐个输入和输出 }  结构体声明一般放在开头，也可以放在main的外面。大概等价于数据类型的定义和声明，也不会在声明中分配存储空间，实例化才会分配存储空间，空间是连续按顺序的。 可以放在函数内部，但此时这个声明是局部的，而不是全局的。 结构体对象可以赋值，但不可以算数和比较运算。  结构体和指针的关系 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { cout\u0026lt;\u0026lt;\u0026#34;hello\\n\u0026#34;; struct DATA{ int year; int mouth; int day; }; DATA d={1980,1,1};//一个奇怪的devc++规则，即用即声明，但反正也不麻烦 //更新，可以在结构体后声明成员，但前提是要把结构体的创建写到main函数外部 struct staff{ int no; char name[21]; char sex; DATA *pbirthday; double salary; }; staff *p;//指针可以提前声明然后赋值，这里声明s1会报错 staff s1={1001,\u0026#34;archer\u0026#34;,\u0026#39;m\u0026#39;,\u0026amp;d,2900.0}; p=\u0026amp;s1;//赋地址值，没有*，下方编译成功 cout\u0026lt;\u0026lt;p-\u0026gt;sex\u0026lt;\u0026lt;endl;//这是字母l不是一数字1，/用于除法和注释 p-\u0026gt;pbirthday-\u0026gt;year=2008; p-\u0026gt;sex=\u0026#39;w\u0026#39;; cout\u0026lt;\u0026lt;s1.sex\u0026lt;\u0026lt;endl; } 结构体和数组的关系 如同声明int,char数组，可以用结构体进行声明。用这个方法可以表示几何的点。\n#include\u0026lt;iostream\u0026gt; using namespace std; struct staff{ int no; char name[21]; double salary; }a[3],t; int main() { cout\u0026lt;\u0026lt;\u0026#34;hello\\n\u0026#34;; int i,j; for (i=0;i\u0026lt;3;i++) cin\u0026gt;\u0026gt;a[i].name \u0026gt;\u0026gt;a[i].no \u0026gt;\u0026gt;a[i].salary; for (i=0;i\u0026lt;3;i++) cout\u0026lt;\u0026lt;a[i].name \u0026lt;\u0026lt;a[i].no \u0026lt;\u0026lt;a[i].salary\u0026lt;\u0026lt;endl; }; 结构体和函数的关系 就像传int类型等，直接传递进去，在函数内部进行各种操作。 对结构体数组进行传递，是对首地址进行传入。\n共用体  对于实体对象，分配的存储空间是成员内存的最大值。 定义和结构体的定义和引用相似。使用union定义，   修改一个成员的值会让其他值都改变 成员的首地址相同，所有成员的值相同，不同成员所用到的内存长度有差异  枚举类型(enum)  定义都是相似的 必须是指定值 枚举常量是右值不是左值  没有给定值时从0往后排\nenum COLORS {RED=10,GREEN=8,BLUE,BLACK,WHITE}; //RED为10、GREEN为8、BLUE为9、BLACK为10、WHITE为11。 RED=10; //错误，RED不是左值，不能被赋值 GREEN++; //错误，GREEN不是左值，不能自增自减 enum DIRECTION {LEFT,UP,RIGHT,DOWN,BEFORE,BACK} dir=LEFT; typedef 就是把一个结构的名字进行更改\n自定义数据类型的应用——链表 基础知识 链表主要用于两个目的：一是建立不定长度的数组。二是链表可以 在不重新安排整个存储结构的情况下，方便且迅速地插入和删除数 据元素。\nstruct NODE { //结点数据类型 ElemType data; //数据域 NODE *link; //指针域 }; 首先设计一种称为结点（node）的数据类型： 这个结构体类型中，data成员表示数据域，代表结点的数据信息。\nElemType可以是简单的内置数据类型，也可以是复杂的数据类型， 如\ntypedef struct tagElemType { //复杂的数据元素类型 ...... //任意数目、任意组合、任意类型的数据成员 } ElemType; 数据域是链表中的信息对象（元素），实际应用中结合具体要求设 计其数据类型。为方便介绍，将ElemType简单设定为int型，即\ntypedef int ElemType; //简单的数据元素类型 link成员表示指针域，存放另一个结点的地址，是链表中的组织者。 假定有一个NODE类型的对象指针L，将一个新结点的地址赋给L的 link成员，则L可以通过它的link成员“链接”到新结点上，重复这 个过程可以得到链表结构。\n链表的类型 struct LNode { //单链表结点类型 ElemType data; //数据域\nLNode *next; //指针域：指向直接后继结点 }; typedef LNode* LinkList; //LNode为单链表结构体类型， LinkList为单链表指针类型\n此外还有双链表和循环链表\n创建单链表 创建链表常用两种方法：头插法和尾插法。\n头插法 #include \u0026lt;iostream\u0026gt; using namespace std; typedef int ElemType; //简单的数据元素类型 struct LNode { //单链表结点类型 ElemType data; //数据域 LNode *next; //指针域：指向直接后继结点 }; typedef LNode* LinkList; //LNode为单链表结构体类型，LinkList为单链表指针类型 void input(ElemType *ep) //实现数据域元素输入的定制函数 { //在函数中可以写更加复杂、任意形式、任意数目的输入 cin\u0026gt;\u0026gt;*ep; } void CreateLinkF(LinkList *L,int n,void(*input)(ElemType*)) { //头插法创建单链表，调用input输入函数输入数据 LinkList s; *L=new LNode;//创建头结点 (*L)-\u0026gt;next=NULL; //初始时为空表 for (; n\u0026gt;0; n--) { //创建n个结点链表 s=new LNode; //创建新结点 input(\u0026amp;s-\u0026gt;data); //调用input输入数据域 s-\u0026gt;next=(*L)-\u0026gt;next; //将s增加到开始结点之前 (*L)-\u0026gt;next=s; //头结点之后 } } int main() { LinkList L; int n; cin\u0026gt;\u0026gt;n; CreateLinkF(\u0026amp;L,n,input); } 尾插法 #include \u0026lt;iostream\u0026gt; using namespace std; typedef int ElemType; //简单的数据元素类型 struct LNode { //单链表结点类型 ElemType data; //数据域 LNode *next; //指针域：指向直接后继结点 }; typedef LNode* LinkList; //LNode为单链表结构体类型，LinkList为单链表指针类型 void input(ElemType *ep) //实现数据域元素输入的定制函数 { //在函数中可以写更加复杂、任意形式、任意数目的输入 cin\u0026gt;\u0026gt;*ep; } void CreateLinkR(LinkList *L,int n,void(*input)(ElemType*)) { //尾插法创建单链表，调用input输入函数输入数据 LinkList p,s; p=*L=new LNode; //创建头结点 for (; n\u0026gt;0; n--) { //创建n个结点链表 s=new LNode; //创建新结点 input(\u0026amp;s-\u0026gt;data); //调用input输入数据域 p-\u0026gt;next=s, p=s; //将s插入到当前链表末尾 } p-\u0026gt;next=NULL; //尾结点 } int main() { LinkList L; int n; cin\u0026gt;\u0026gt;n; CreateLinkR(\u0026amp;L,n,input); } 链表的撤销 void DestroyList(LinkList *L) //销毁单链表L { LinkList q,p=*L; //p指向头结点 while(p!=NULL) { //若不是链尾继续 q=p-\u0026gt;next; //指向直接后继结点 delete p; //释放结点存储空间 p=q; //直接后继结点 } *L=NULL; //置为空表 链表的运算 链表的遍历 即p=p-\u0026gt;next\n查找节点 int compare(ElemType *ep1,ElemType *ep2) //实现两个数据元素关系比较的定制函数 {//在函数中对数据元素进行定制的关系比较，如相等，大于或小于 if (*ep1==*ep2) return 1; //满足相等关系返回真（1） return 0; //不满足关系返回假（0） int LocateElem(LinkList L,ElemType e, int(*compare)(ElemType*,ElemType*)) {//返回L中第1个与e满足关系compare()的元素的位序 int i=0; LinkList p=L-\u0026gt;next; //p指向开始结点 while(p!=NULL) { //若不是链尾继续 i++; //记录结点的位序 if(compare(\u0026amp;(p-\u0026gt;data),\u0026amp;e)) return i; p=p-\u0026gt;next; //指向直接后继结点 } return 0; //关系不存在返回0 插入节点 int ListInsert(LinkList *L,int i,ElemType e) { //在第i个位置之前插入元素e LinkList s,p=*L; //p指向头结点 while(p!=NULL \u0026amp;\u0026amp; i\u0026gt;1) { //寻找第i-1个结点 p=p-\u0026gt;next; //p指向直接后继结点 i--; } if(p==NULL||i\u0026lt;1) return 0; //i值不合法返回假（0） s=new LNode; //创建新结点 s-\u0026gt;data=e; //插入L中 s-\u0026gt;next=p-\u0026gt;next, p-\u0026gt;next=s; //结点插入算法 return 1; //操作成功返回真（1） 删除节点 int ListDelete(LinkList *L,int i,ElemType *ep) { //删除第i个结点,并由*ep返回其值 LinkList p=NULL,q=*L; //q指向头结点 while(q!=NULL \u0026amp;\u0026amp; i\u0026gt;=1) { //直到第i个结点 p=q; //p是q的前驱 q=q-\u0026gt;next; //q指向直接后继结点 i--; } if(p==NULL||q==NULL) return 0;//i值不合法返回假（0） p-\u0026gt;next=q-\u0026gt;next; //结点删除算法 if(ep!=NULL) *ep=q-\u0026gt;data; //删除结点由*ep返回其值 delete q; //释放结点 return 1; //操作成功返回真（1） ","permalink":"https://tassel234.github.io/posts/note/c++%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/","summary":"数组的定义和使用 （1）一维数组的定义、初始化、引用 使用数组，可以方便地定义一个名字（数组名）来表示大批量数据，并能够通过循环批处理大量数据。 一维数组是由元素类型、数组名和长度组成的构造类型。例如： int A[10], B[20]; // 元素是整型 常量表达式表示数组中元素的个数，称为数组长度。常量表达式的值必须为","title":"C++入门学习笔记-3(数组，指针，结构体)"},{"content":"图论入门_2 图着色 图着色可以应用于调度问题，平面图的点着色也和著名的四色问题也有很深的联系。\n点着色 即一条边上两点的颜色均不相同。顶点着色可以应用于调度问题，即日程安排或工作安排问题。对不同的人执行两种或以上的操作构成图，对着色相同的各个事件，在同一段时间平行的去做，节约时间成本。\n任意图都是最大度加一可顶点着色的。\n布鲁克斯定理 对于连通图G，如果G不是完全图，又不是奇数长的圈，则G是可顶点着色的  可以知道，除了上述给出的两种情况，其他图都是可以（最大度加一）减 可着色的。\n非正则的连通图都是最大度-可以顶点着色的。 G是2-可顶点着色，G是二部图，G中不含奇数长的圈这三个命题等价。  3-顶点可着色问题是np完全问题。\n4-顶点也是np完全问题，等价于四色问题。\n任意平面图都存在度不超过5的顶点。 五色定理：任意平面图都是5-可着色的。  边着色 如果图中用5中颜色进行了边着色，因为任意平面图都存在度不超过5的顶点，所以不能使用颜色更少的方案。\n维京定理：任意图可边着色数都小于或等于最大度加一。  而由定义可知，图可边着色数要大于等于最大度数。\n克里希定理：对任意二部图，边着色就是最大度数。  最大流问题 什么是最大流问题 最大流问题是一种组合优化问题，讨论如何充分利用装置的能力，使得运输的流量最大以取得最好的效果的问题。有容量限制原则和流量守恒原则。\ns表示网络的源点. t表示网络的汇点.\n福特- 富尔克森算法 残留网络，给出某路径和流量后反向生成新的路径和对应的流量，生成的路径可以视为新的路（增广路），增广路相当于可以把流量流回去，然后进行查找，重复几次，同向的流可以合并，没有流量的路可以擦掉。当找不到通往终点的路径了，就可以认为程序完成了。\n最大流最小割定理 穿过某些路径进行分割，一个部分含s,一个部分含t,将节点分为两个部分称为割。\n割选中的路径流量累计，也称作容量（特别注意，流量的计算是针对对含起点的部分指向外部的割边，反向的路不计算）最小的割叫做图的最小割。\n最小割定理：最大流等于最小割的容量。\n匹配问题 什么是匹配 就是把点和点通过线做一一对应，一个点只能被一个点匹配和一个点只能匹配一个点。 主要应用于二部图，在二部图里像一一映射。\n二向图中的匹配 极大匹配的定义是不能再添加其他边了。\n最大匹配的就是指边数最多的情况。\n最大匹配一定是极大匹配，但极大匹配不一定是最大匹配。\n如四点三段直线图。\n霍尔定理刻画了二部图完美匹配的存在性。\n匈牙利算法 和福特- 富尔克森算法很类似\n先随意确定几个路径，然后利用增广路进行反悔，如搜索5a1d这条路，然后修改。\n用求解最大流问题的算法求解匹配问题 甚至可以直接转化为最大流问题，使用对应的算法求解。\n","permalink":"https://tassel234.github.io/posts/note/%E5%9B%BE%E8%AE%BA%E5%85%A5%E9%97%A8_2/","summary":"图论入门_2 图着色 图着色可以应用于调度问题，平面图的点着色也和著名的四色问题也有很深的联系。 点着色 即一条边上两点的颜色均不相同。顶点着色可以应用于调度问题，即日程安排或工作安排问题。对不同的人执行两种或以上的操作构成图，对着色相同的各个事件，在同一段时间平行的去做，节约时间成本。","title":"图论入门_2"},{"content":"资源 (主)算法图解动画软件\n我的第一本算法书\n图解算法使用c++\n传输数据的四个问题及其解决方法 B从A那里收到了消息,但作为消息发送者的A可能对卫抱有恶意,并在事后声称“这不是我发送的消息“。这种情况会导致互联网上的商业交易或合同签罪无法成立。这种行为便是事后否认。\n哈希函数 哈希值简介和特征 哈 希 函 数 可 以 把 给 定 的 数 据 转 换 成 固 定 长 度 的 无 规 律 数 值 。 转 换 后 的 无 规 律 数 值 可 以 作 为 数 据 摘 要 应 用 于 各 种 各 样 的 场 景 。哈希值多用16进制表示。\n 第 一 个 特 征 是 输 出 的 哈 希值 数 据 长 度 不 变 。 如果输入的数据相同，那么输出的哈希值也必然相同。 输入的数据相似，哪怕只有一比特的差别，也会导致输出的哈希值大不相同。 如果两个数据完全不同，输出的哈希值也可能是相同的，叫做哈希冲突。 不可能从哈希值反向推出原本的数据。 求哈希值的计算相对容易  哈 希 函 数 的 算 法 中 具 有 代 表 性 的 是 MD5、SHA-1 和 SHA-2 等 。 其 中 SHA-2是 现 在 应 用 较 为 广 泛 的 一 个 , 而 MD5 和 SHA-1 存 在 安 全 隐 患 , 不 推 荐 使 用 。\n哈希算法 哈希算法是使用哈希函数计算出一个键值对应的地址，然后建立哈希表。查找的速度和数据大小无关，在没有碰撞好溢出的情况下，一次即可查找成功。\n除留余数法 h（key）= key mod B //B最好选一个质数。 算出来的数当索引，索引对应地址。\n平方取中法 把数组平方后区中间的两个数字，也要分配100个地址。\n折叠法 把数据拆成几个部分，然后相加，即得到索引值。\n不过哈希值的设计原则之一是减小碰撞的产生（虽然前面几个例子碰的可厉害了），可以对拆分后的数据进行奇数或者偶数的反转，改进后的做法称为边界折叠法。\n数字分析法 适用于数据不会更改，且为数字类型的静态表。\n然后观察分析，排除重复率高的存在。\n碰撞和溢出处理 线型探测法 如果发生了碰撞，就以线型的方式往后查找空的位置。\n线性探测法通常视为环状结构，当后面满了，数据也可以加在前面。\n平方探测法 相当类似的键值聚集在一起后，线性探测法就不太适用了。\n可以使用平方探测法，把数先平方，然后加或者减某数字i，然后用质数b取模。\nb必须是4j+3的质数，i大于等于1，小于等于(b-1)/2\n再哈希法 第一种哈希函数溢出，就用第二种，再溢出，就是第三种，第四种等。\n链表法 让哈希表所在空间建立对应数目的链表，如果溢出直接加到后面。\n应 用 示 例 哈希函数也常用于数据的压缩。\n将 用 户 输 入 的 密 码 保 存 到 服 务 器 时 也 需 要 用 到 哈 希 函 数 。\n如 果 把 密 码 直 接 保 存 到 服 务 器 , 可 能 会 被 第 三 者 窃 听 , 因 此 需 要 算 出 密 码 的哈 希 值 , 并 只 存 储 哈 希 值 。 当 用 户 输 入 密 码 时 , 先 算 出 该 输 入 密 码 的 哈 希 值 , 再把 它 和 服 务 器 中 的 哈 希 值 进 行 比 对 。 这 样 一 来 , 就 算 保 存 的 晗 希 值 暴 露 了 , 鉴 于上 文 中 提 到 的 哈 希 函 数 的 第 五 个 特 征 ( 输 入 输 出 不 可 逆 ) , 第 三 者 也 无 法 得 知 原本 的 密 码 。\n共享密钥加密 就是加密方式和解密方式两者都知道，可以理解为实际上给的是一把钥匙和完全一样的副本，传输的是加密的数据，就不怕被窃听了。\n实 现 共 享 密 钥 加 密 的 算 法 有 凯 撤 密 码 、AES、DES、 动 态 口 令 等 , 其中 AES 的 应 用 最 为 广 泛 。\n但是因为加密的密钥也应该会通过互联网发送，密匙也有可能被窃听者盗取，于是信息又不安全了。\n既 然 密 钥 有 被 第 三 者 窃 听 的 风 险 , 那 也 可 以 先 加 密 密 钢 再 发 送 。用 这 种 方 式 , 又 会 产 生 如 何 把 加 密 密 钥 的 密 钢 发 送 给 对 方 的 问 题 , 还 是 回 到 了 一开 始 的 问 题 。因 此 需 要 找 到 可 以 把 密 钢 安 全 送 出 的 方 法 , 这 就 是 “ 密 钥 分 配 问 题 “。\n要 想 解 决 这 个 问 题 , 可 以 使 用 “ 宿 钥 交 换 协 议 “ 和 “ 公 开 密 钢 加 密 “ 两 种 方 法 。\n公开密匙加密 首先先由B生成共开密匙和私有密匙（开锁和上锁的钥匙不同），然后公开密匙发给A，或者发给很多人，或者直接公布在互联网，其他人用公开密匙进行加密，然后发给B，只有B可以用私有密匙对数据进行解密。\n提 示 实 现 公 开 密 钥 加 密 的 算 法 有 RAS 算 法 、 椭 圆 曲 线 加 密 算 法 等 , 其 中 使用 最 为 广 泛 的 是 RSA 算 法 。RSA 算 法 由 其 开 发 者 Rivest、Shamir、Adleman 的首 字 母 命 名 而 来 , 三 人 在 2002 年 获 得 了 图灵 奖 。\n这样做的安全性很高，因为只有B知道怎么解密。而且可以让其他很多人都可以发送数据给B，而不用一一传递密匙。 缺点是一般这种加密算法的实现速度很慢，比共享密钥法慢的多。 但即使这样监听者用一些方法也可以盗取，比如上图。因为公开密匙并不会显示是谁创建的，窃听者把 密 文 发 送 给 B, 这 个 密 文 由 B 发 出 的 公 开 密 钢 B 来 解 密 。 从 收 到 密文 到 解 密 密 文 都 没 发 生 任 何 问 题 , 因 此 B 也 意 识 不 到 数 据 己 经 被 穸 听 。 这 种通 过 中 途 替 换 公 开 密匙来 窃 听 数 据 的 攻 击 方 法 叫 作 \u0026quot; 中 间 人 攻 击 \u0026ldquo;。\n公 开 密 钥 的 可 靠 性 会 出 现 问 题 , 就 是 因 为 A 无 法 判 断 收 到 的 公 开 密 钢 是 否 来自 B。 要 想 解 决 这 个 问 题 , 就 要 用 到 之 后 会 讲 到 的 “ 数 字 证 书 “。\n公 开 密 钥 加 密 还 有 一 个 问 题 , 那 就 是 加 密 和 解 密 都 比 较 耗 时 , 所 以 这 种 方 法不 适 用 于 持 续 发 送 零 碎 数 据 的 情 况 。 要 想 解 决 这 个 问 题 , 就 要 用 到 “ 混 合 加 密 “。\n混合加密 对数据量较小的共享密匙进行公开加密，保证安全性。\n用加密和解密速度快的共享密匙进行主要数据的加密，保证速度。\n迪菲-赫尔曼密钥交换 这 种 合 成 方 法 有 三 个 特 征 。\n第 一 ,即使 持 有 P 和 合 成 的 密 钥 P-S, 也 无 法 把 密 钥 S 单 独 取 出 来 。\n第 二 , 不 管 是 怎 样 合 成 而 来 的 密匙 , 都 可 以 把 它 作 为 新 的 元 素 , 继 续 与别 的 密 钥 进 行 合 成 。 使 用 密 钥 卫 和 密 锏 P-S, 还 能合 成 出 新 的 密 钥 P-P-S。\n第三：合成的结果和顺序无关。\n双方分别创建自己的私有密匙并且妥善保管，然后使用一个公开密匙，反复加密。 得到相同的加密方式，相同的密匙。\n具体实现可以使用非常大的素数。\n消息认证码 我是真的感觉下面这三个兄弟，是真的兵来将挡水来土掩，反复套娃。\n首先是消息认证码，为了解决密文被篡改的情况。 必要条件是制作一个用于消息认证码的密钥，然后用安全的方法发送为B。消息认证码简称mac, 但还是有缺陷。 加密和解密是双向的，消息的来源A可能是恶意的，A可能在发送信息后矢口否认。\n数字签名 数字加密使用的公开密匙，但和一般的公开密匙不同，私有的是用来加密的，共有的是用来解密的，这在加密通信层面毫无意义，但却可以肯定是A发送的。\n补 充 说 明\n公 开 密 钥 加 密 的 加 密 和 解 密 都 比 较 耗 时 。 为 了 节 约 运 算 时 间 , 实 际 上 不 会 对消 息 直 接 进 行 加 密 , 而 是 先 求 得 消 息 的 哈 希 值 , 再 对 哈 希 值 进 行 加 密 , 然 后 将 其作 为 签 名 来 使 用 ( 请 参 考 下 图 ）\n但这样就完美了吗，不，还没有。\n因为公开密匙加密好数字签名 无法保证是信息的发送者。公开密匙可能会被第三方恶意替换，中转破译发送，接受者甚至无法注意到。\n数字证书 A应该向一个非常权威的认证中心去申请认证证书。\n将 公 开 密 钥 A 和 包 含 邮 箱 信 息 的 个 人 资 料 发 送 给 认 证 中 心 。\n认 证 中 心 对 收 到 的 资 料 进 行 确 认 , 判 断 其 是 否 为 A 本 人 的 资 料 。 确 认 完毕 后 , 认 证 中 心 使 用 自 己 的 私 有 密匙， 根 据 A 的 资 料 生 成 数 字 签 名 。\n认 证 中 心 将 生 成 的 数 字 签 名 和 资 料 放 进 同 一 个 文 件 中 。然后交给A，B确认邮箱地址，使用认证中心的密匙确认是否为认证中心给出的数字签名。\n但这是完美的了吗，其实还没有，因为窃听者也可以假冒认证公司发布证书。\n认 证 中 心 是 管 理 数 字 证 书 的 组 织 机 构 。 原 则 上 谁 都 可 以 成 为 认 证 中 心 ,所 以 认 证 中 心 的 数 量 也 比 较 多 , 但 建 议 在 经 过 政 府 审 查 的 大 型 企 业 机 构 进 行 申请 , 这 些 机 构 更 令 人 放 心 。\n所以套娃到最后信任的是权威。\n拓展资源 图解密码技术\n信息安全数学基础网课\n应用密码学 协议、算法与C源程序_protocols, algorithms, and source code in C\n密码学C_C++语言实现 原书第2版\n信息论、编码与密码学\n","permalink":"https://tassel234.github.io/posts/note/%E7%AE%97%E6%B3%95%E9%A2%84%E8%A7%88%E5%AE%89%E5%85%A8%E7%AF%87/","summary":"资源 (主)算法图解动画软件 我的第一本算法书 图解算法使用c++ 传输数据的四个问题及其解决方法 B从A那里收到了消息,但作为消息发送者的A可能对卫抱有恶意,并在事后声称“这不是我发送的消息“。这种情况会导致互联网上的商业交易或合同签罪无法成立。这种行为便是事后否认。 哈希函数 哈希值简介和","title":"算法预览（安全篇）"},{"content":"使用资源 图解数据结构，使用C++ 吴灿明 （源代码来自这里）\n递归法详解 斐波那契数列 /* [示范]：斐波那契数列的递归程序 */ #include\u0026lt;iostream\u0026gt; using namespace std; int fib(int);\t//fib()函数的原型声明 int main() { int i,n; cout\u0026lt;\u0026lt;\u0026#34;请输入要计算到第几项斐波那契数列：\u0026#34;;//如果输入的数字太大会导致算到负数 ，后面会越来越慢 cin\u0026gt;\u0026gt;n; for(i=0;i\u0026lt;=n;i++) //计算前n项斐波那契数列 cout\u0026lt;\u0026lt;\u0026#34;fib(\u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34;)=\u0026#34;\u0026lt;\u0026lt;fib(i)\u0026lt;\u0026lt;endl; return 0; } int fib(int n) // 定义函数fib() { if (n==0) return 0; // 如果n=0，则返回0 else if(n==1 || n==2)\t//如果n=1或n=2，则返回1 return 1; else\t// 否则返回 fib(n-1)+fib(n-2) return (fib(n-1)+fib(n-2)); } 汉诺塔问题 /* [示范]:利用汉诺塔函数求出不同圆盘数时圆盘的移动步骤 */ #include \u0026lt;iostream\u0026gt; using namespace std; void hanoi(int, int, int, int); // 函数原型 int main(void) { int j; cout\u0026lt;\u0026lt;\u0026#34;请输入圆盘数量：\u0026#34;; cin\u0026gt;\u0026gt;j; hanoi(j,1, 2, 3); return 0; } void hanoi(int n, int p1, int p2, int p3) { if (n==1) cout\u0026lt;\u0026lt;\u0026#34;圆盘从 \u0026#34;\u0026lt;\u0026lt;p1\u0026lt;\u0026lt;\u0026#34; 号木桩移到 \u0026#34;\u0026lt;\u0026lt;p3\u0026lt;\u0026lt;\u0026#34; 号木桩\u0026#34;\u0026lt;\u0026lt;endl; else { hanoi(n-1, p1, p3, p2); cout\u0026lt;\u0026lt;\u0026#34;圆盘从 \u0026#34;\u0026lt;\u0026lt;p1\u0026lt;\u0026lt;\u0026#34; 号木桩移到 \u0026#34;\u0026lt;\u0026lt;p3\u0026lt;\u0026lt;\u0026#34; 号木桩\u0026#34;\u0026lt;\u0026lt;endl; hanoi(n-1, p2, p1, p3); } } 由一些数学公式可得汉诺塔的执行步骤最小为$2^{n} -1$,n代表圆盘的个数\n动态规划法（DPA） 动态规划法（Dynamic Programming Aigorithm）是一种优化算法策略，主要应用于求解具有重叠子问题和最优子结构性质的问题。动态规划法的核心思想是将问题分解为更小的子问题(和分治法类似)，并将子问题的解存储在一个表中（分治法没有的），从而避免了对相同子问题的重复计算。\n动态规划法的基本步骤如下：\n 定义子问题：将原问题分解为若干个子问题。 定义状态：用数学表示子问题的解。 定义状态转移方程：描述子问题之间的关系，如何通过子问题的解计算原问题的解。 初始化边界条件：确定状态转移方程的初始值。 自底向上或自顶向下计算：根据状态转移方程逐步计算子问题的解，最终得到原问题的解。  动态规划法可以应用于各种问题，如最短路径问题、背包问题、字符串匹配问题等。动态规划法的一个重要应用场景是求解最优化问题，例如最大（最小）问题。通过动态规划，可以在多项式时间内求解这些问题，而其他方法（如穷举法）可能需要指数级时间。\n例如使用递归法进行斐波那契数列的Fib(9)计算时，需要反复计算Fib(4),Fib(5)等值，浪费了时间，使用动态规划算法将计算过的结果储存起来，在后续的计算中只需要判断数值的存在与否，若存在就直接调用。\nDijkstra 算法 Dijkstra算法,中文名音译作迪杰斯特拉算法或戴克斯特拉算法。\n回溯法—老鼠走迷宫 回溯法（Backtracking）是一种用于搜索解空间的算法，通常在组合问题、优化问题和约束满足问题等领域中使用。回溯法通过对解空间的节点进行深度优先搜索，尝试找到问题的解。当搜索到某个节点时，如果该节点不能继续搜索下去，就回溯到该节点的父节点并尝试其他分支。回溯法的基本思想是：先广搜索，后深入搜索。\n以下是回溯法的一般步骤：\n 定义问题的解空间：首先需要明确问题的解空间，即所有可能的解的集合。 确定解空间的组织结构：将解空间组织成树形结构，每个节点表示一个部分解。 设计回溯算法的递归函数：递归函数需要完成以下功能： a. 判断当前节点是否包含问题的解，如果是，则保存解并返回。 b. 如果当前节点不能包含问题的解，则回溯到父节点并尝试其他分支。  回溯法是枚举法的一种。\n老鼠走迷宫就是一种回溯法的应用。老鼠走迷宫问题的描述是:假设把一只老鼠放在一个没有盖子的大迷宫盒的入口处，盒中有许多墙，使得大部分路径都被挡住而无法前进。老鼠可以采用尝试错误的方法找到出口。不过，这只老鼠必须在走错路时就退回来并把走过的路记下来，避免下次走重复的路，就这样直到找到出口为止。简单来说，老鼠行进时必须遵守以下3 个原则:\n(1)一次只能走一格。\n(2) 遇到墙无法往前走时，则退回一步找找看是否有其他的路可以走。\n(3)走过的路不会再走第二次。\n人们对这个问题感兴趣的原因是它可以提供一种典型堆栈应用的思考方法。\n/*题目：设计一个 C++程序，使用链表堆栈来找出老鼠走迷宫的路线，1 表示该处有墙无法通过， 0表示[i][i]处无墙可通行，并且将走过的位置对应的数组元素内容标记为 2。*/ #include \u0026lt;iostream\u0026gt; #define EAST MAZE[x][y+1] //定义东方的相对位置 #define WEST MAZE[x][y-1] //定义西方的相对位置 #define SOUTH MAZE[x+1][y]\t//定义南方的相对位置 #define NORTH MAZE[x-1][y]\t//定义北方的相对位置 using namespace std; const int ExitX = 8; //定义出口的X坐标在第8列 const int ExitY = 10; //定义出口的Y坐标在第10行 struct list { int x,y; struct list* next; }; typedef struct list node; typedef node* link; int MAZE[10][12] = {1,1,1,1,1,1,1,1,1,1,1,1, //声明迷宫数组 1,0,0,0,1,1,1,1,1,1,1,1, 1,1,1,0,1,1,0,0,0,0,1,1, 1,1,1,0,1,1,0,1,1,0,1,1, 1,1,1,0,0,0,0,1,1,0,1,1,//1是墙，0是可走的路 1,1,1,0,1,1,0,1,1,0,1,1, 1,1,1,0,1,1,0,1,1,0,1,1, 1,1,1,1,1,1,0,1,1,0,1,1, 1,1,0,0,0,0,0,0,1,0,0,1,//最右下角的0代表出口 1,1,1,1,1,1,1,1,1,1,1,1}; link push(link stack,int x,int y); link pop(link stack,int* x,int* y); int chkExit(int ,int ,int,int); int main(void) { int i,j; link path = NULL; int x=1;\t//入口的X坐标 int y=1; //入口的Y坐标 cout\u0026lt;\u0026lt;\u0026#34;[迷宫的路径(0的部分)]\\n\u0026#34;\u0026lt;\u0026lt;endl; //打印出迷宫的路径图 for(i=0;i\u0026lt;10;i++) { for(j=0;j\u0026lt;12;j++) cout\u0026lt;\u0026lt;MAZE[i][j]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;endl; } while(x\u0026lt;=ExitX\u0026amp;\u0026amp;y\u0026lt;=ExitY) { MAZE[x][y]=2; if(NORTH==0) { x -= 1; path=push(path,x,y); } else if(SOUTH==0) { x+=1; path=push(path,x,y); } else if(WEST==0) { y-=1; path=push(path,x,y); } else if(EAST==0) { y+=1; path=push(path,x,y); } else if(chkExit(x,y,ExitX,ExitY)==1) // 检查是否走到出口了 break; else { MAZE[x][y]=2; path=pop(path,\u0026amp;x,\u0026amp;y); } } cout\u0026lt;\u0026lt;\u0026#34;[老鼠走过的路径(2的部分)]\u0026#34;\u0026lt;\u0026lt;endl; // 打印出老鼠走完迷宫后的路径图 for(i=0;i\u0026lt;10;i++) { for(j=0;j\u0026lt;12;j++) cout\u0026lt;\u0026lt;MAZE[i][j]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;endl; } return 0; } link push(link stack,int x,int y) { link newnode; newnode = new node; if(!newnode) { cout\u0026lt;\u0026lt;\u0026#34;Error！内存分配失败！\u0026#34;\u0026lt;\u0026lt;endl; return NULL; } newnode-\u0026gt;x=x; newnode-\u0026gt;y=y; newnode-\u0026gt;next=stack; stack=newnode; return stack; } link pop(link stack,int* x,int* y) { link top; if(stack!=NULL) { top=stack; stack=stack-\u0026gt;next; *x=top-\u0026gt;x; *y=top-\u0026gt;y; delete top; return stack; } else *x=-1; return stack; } int chkExit(int x,int y,int ex,int ey) { if(x==ex\u0026amp;\u0026amp;y==ey) { if(NORTH==1||SOUTH==1||WEST==1||EAST==2) return 1; if(NORTH==1||SOUTH==1||WEST==2||EAST==1) return 1; if(NORTH==1||SOUTH==2||WEST==1||EAST==1) return 1; if(NORTH==2||SOUTH==1||WEST==1||EAST==1) return 1; } return 0; } 八皇后问题 八皇后问题也是一种常见的堆栈应用实例。在国际象棋中的皇后可以对棋盘中的其他棋子直吃、横吃和对角斜吃(左斜吃或右斜吃都可)。现在要放入多个皇后到棋盘上，后放入的新皇后，放入前必须考虑所放位置的直线方向、横线方向或对角线方向是否已被放置了旧皇后，否则就会被先放入的旧皇后吃掉。这个问题难倒了高斯，但如果使用计算机思维和计算机的算力可以比较轻松的求得结果。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;cmath\u0026gt; #define EIGHT 8 //定义堆栈的最大容量 #define TRUE 1 #define FALSE 0 using namespace std; int queen[EIGHT]; //存放8个皇后的行位置 int number=0; //计算总共有几组解 //决定皇后存放的位置 //输出所需要的结果 int attack(int ,int); void print_table() { int x=0,y=0; number+=1; cout\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;八皇后问题的第\u0026#34;\u0026lt;\u0026lt;setw(2)\u0026lt;\u0026lt;number\u0026lt;\u0026lt;\u0026#34;组解\u0026#34;\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;\u0026#34;\\t\u0026#34;; for(x=0;x\u0026lt;EIGHT;x++) { for(y=0;y\u0026lt;EIGHT;y++) if(x==queen[y]) cout\u0026lt;\u0026lt;\u0026#34;\u0026lt;q\u0026gt;\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;\u0026lt;-\u0026gt;\u0026#34;; cout\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;\u0026#34;\\t\u0026#34;; } system(\u0026#34;pause\u0026#34;); } void decide_position(int value) { int i=0; while(i\u0026lt;EIGHT) { //是否受到攻击的判断式 if(attack(i,value)!=1) { queen[value]=i; if(value==7) print_table(); else decide_position(value+1); } i++; } } //测试在(row,col)上的皇后是否遭受攻击 //若遭受攻击则返回值为1,否则返回0 int attack(int row,int col) { int i=0,atk=FALSE; int offset_row=0,offset_col=0; while((atk!=1)\u0026amp;\u0026amp;i\u0026lt;col) { offset_col=abs(i-col); offset_row=abs(queen[i]-row); //判断两皇后是否在同一行或同一对角线上 if((queen[i]==row)||(offset_row==offset_col)) atk=TRUE; i++; } return atk; } //主程序 int main(void) { decide_position(0); return 0; } 算术表达式的表示法 我们正常的算数公式书写是中序法，而对于计算机来说处理较为复杂，解决方法就是使用前序法与后序法（后序法只使用一个堆栈缓冲区，前序法两个）。\n中序法转为前序法与后序法 可以使用括号法，值得注意的是每两个数进行一次运算就要一次括号。\n也可以使用堆栈法。\n(1)从右到左读进中序法表达式的每个字符\n(2)如果读进的字符为操作数，则直接输出到前序法表达式中。\n(3) 如果遇到“(”，则弹出堆内的运算符，直到弹出到一个“)”，两者互相抵消。\n(4)“)”的优先级在堆内比任何运算符都小，任何运算符的优先级都高过它，不过在堆栈外却是优先级最高者。\n(5)当运算符准备进入堆栈内时，必须和堆顶端的运算符比较，如果外面的运算符优先级高于或等于堆栈顶端的运算符则压入堆栈，如果优先级低于堆栈顶端的运算符就把堆栈顶端的运算符弹出直到堆栈顶端的运算符优先级低于外面的运算符或堆栈为空时，就再把外面这个运算符压入堆栈\n(6) 中序法表达式读完后，如果运算符堆栈不是空的，则将其内的运算符逐一弹出，输出到前序法表达式中即可。 前序法与后序法表达式转为中序法表达式 也可以使用括号法或堆栈法。\n 括号法的乘法除法运算符在前序法向后括一个，加减法括两个。符号向右取代 括号法的乘法除法运算符在后序法向前括一个，加减法括两个。符号向左取代  中序法求值 需要两个堆栈，一个用于存储运算符，一个存放操作数。 但计算方法和人算大同小异。\n前序法求值 需要两个堆栈，一个用于存储表达式，一个存放操作数。不需要比较操作符的优先级。\n后序法求值 只需要一个堆栈。不需要比较操作符的优先级，计算非常直观简单\n","permalink":"https://tassel234.github.io/posts/note/%E7%AE%97%E6%B3%95%E9%A2%84%E8%A7%88%E9%80%92%E5%BD%92%E6%B3%95%E5%92%8C%E7%AE%97%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/","summary":"使用资源 图解数据结构，使用C++ 吴灿明 （源代码来自这里） 递归法详解 斐波那契数列 /* [示范]：斐波那契数列的递归程序 */ #include\u0026lt;iostream\u0026gt; using namespace std; int fib(int); //fib()函数的原型声明 int main() { int i,n; cout\u0026lt;\u0026lt;\u0026#34;请输入要计算到第几项斐波那契数列：\u0026#34;;//如果输入的数字太大会导致算到负数","title":"算法预览（递归法和算数表达式）"},{"content":"堆栈简介 基本知识 也可以简写为栈，具有后进先出的特性（LIFO）\n与链表和数组一样，栈的数据也是线性排列，但在栈中，添加和删除数据的操作只能在一端进行，访问数据也只能访问到顶端的数据。想要访问中间的数据时，就必须通过出栈操作将目标数据移到栈顶才行。\n放入栈的顶端，称为压入PUSH,从顶端取出，称为弹出pop\n栈只能在一端操作，这一点看起来似乎十分不便，但在只需要访问最新数据时，使用它就比较方便了。另外，我们将要在接下来学习深度优先搜索算法，通常会选择最新的数据作为候补顶点。在候补顶点的管理上就可以使用栈。\n代码实现 使用数组实现堆栈 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; #define MAXSTACK 100\t//定义堆栈的最大容量 using namespace std; int stack[MAXSTACK];\t//声明用于堆栈操作的数组 int top=-1;\t//堆栈的顶端 //判断是否为空堆栈 int isEmpty() { if(top==-1) return 1; else return 0; } //将指定的数据压入堆栈 int push(int data) { if(top\u0026gt;=MAXSTACK) { cout\u0026lt;\u0026lt;\u0026#34;堆栈已满,无法再压入\u0026#34;\u0026lt;\u0026lt;endl; return 0; } else { stack[++top]=data;\t//top的值一直在变化，将数据压入堆栈 return 1; } } //从堆栈弹出数据 int pop() { if(isEmpty())\t//判断堆栈是否为空,如果是则返回-1 return -1; else return stack[top--];\t//将数据弹出后,再将堆栈指针往下移 //先输出，再自减 } //主程序 int main(void) { int value; int i; cout\u0026lt;\u0026lt;\u0026#34;请按序输入10个数据:\u0026#34;\u0026lt;\u0026lt;endl; for(i=0;i\u0026lt;10;i++) { cin\u0026gt;\u0026gt;value; push(value); } cout\u0026lt;\u0026lt;\u0026#34;====================\u0026#34;\u0026lt;\u0026lt;endl; while(!isEmpty())\t//将数据陆续从顶端弹出 cout\u0026lt;\u0026lt;\u0026#34;堆栈弹出的顺序为:\u0026#34;\u0026lt;\u0026lt;setw(4)\u0026lt;\u0026lt;pop()\u0026lt;\u0026lt;endl; //C++ setw() 函数用于设置字段的宽度, //语法格式如下setw(n)n 表示宽度,用数字表示。setw() 函数只对紧接着的输出产生作用。 //当后面紧跟着的输出字段长度小于 n 的时候，在该字段前面用空格补齐，当输出字段长度大于 n 时，全部整体输出。 cout\u0026lt;\u0026lt;\u0026#34;====================\u0026#34;\u0026lt;\u0026lt;endl; return 0; } //发牌程序 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;ctime\u0026gt; #include \u0026lt;cstdlib\u0026gt; using namespace std; void Swap(int*,int*); void push(int statck[],int MAX,int val); int pop(int stack[]); int top=-1; int main(void) { int card[52],stack[52]={0}; int i,j,k=0, ascVal; char suit[4][10]={\u0026#34;草花\u0026#34;,\u0026#34;方块\u0026#34;,\u0026#34;红桃\u0026#34;,\u0026#34;黑桃\u0026#34;}; int style; srand((unsigned)time(NULL));//srand函数是C语言中的种子函数,它的功能是生成一个随机数。 //srand(1); 直接使用1来初始化种子。不过为了防止随机数每次重复，常常使用系统时间来初始化， //即使用 time函数来获得系统时间，它的返回值为从 00:00:00 GMT, January 1, 1970 到现在所持续的秒数， //然后将time_t型数据转化为(unsigned)型再传给srand函数，即: srand((unsigned) time(\u0026amp;t)); //还有一个经常用法，不需要定义time_t型t变量,即: srand((unsigned) time(NULL)); //直接传入一个空指针，因为你的程序中往往并不需要经过参数获得的数据。 //若去掉这段语句，会造成接下来的数据一直保持在同一个值 for (i=0;i\u0026lt;52;i++) card[i]=i+1; cout\u0026lt;\u0026lt;\u0026#34;[洗牌中...请稍后!]\u0026#34;\u0026lt;\u0026lt;endl; while(k\u0026lt;30) { for(i=0;i\u0026lt;51;i++) for(j=i+1;j\u0026lt;52;j++) if(rand()%52==2)//不是52也可以，为什么是52呢 Swap(\u0026amp;card[i],\u0026amp;card[j]);//洗牌 k++; } i=0; while(i!=52) { push(stack,52,card[i]);//将52张牌压入堆栈 i++; } cout\u0026lt;\u0026lt;\u0026#34;[逆时针发牌]\u0026#34;\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;[显示各家拿到的牌]\u0026#34;\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34; 东家\\t\\t 北家\\t\\t 西家\\t\\t 南家\u0026#34;\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;=========================================================\u0026#34;\u0026lt;\u0026lt;endl; while (top \u0026gt;=0) { style = stack[top]/13;\t//计算扑克牌的花色 switch(style)\t//扑克牌花色对应的图标 { case 0:\t//梅花 ascVal=0; break; case 1:\t//方块 ascVal=1; break; case 2:\t//红心 ascVal=2; break; case 3:\t//黑桃 ascVal=3; break; } cout\u0026lt;\u0026lt;\u0026#34;[\u0026#34;\u0026lt;\u0026lt;suit[ascVal]\u0026lt;\u0026lt;setw(3)\u0026lt;\u0026lt;stack[top]%13+1\u0026lt;\u0026lt;\u0026#34;]\\t\u0026#34;; if(top%4==0) cout\u0026lt;\u0026lt;endl; top--; } return 0; } void push(int stack[],int MAX,int val) { if(top\u0026gt;=MAX-1) cout\u0026lt;\u0026lt;\u0026#34;[堆栈已经满了]\u0026#34;\u0026lt;\u0026lt;endl; else { top++; stack[top]=val; } } int pop(int stack[]) { if(top\u0026lt;0) cout\u0026lt;\u0026lt;\u0026#34;[堆栈已经空了]\u0026#34;\u0026lt;\u0026lt;endl; else top--; return stack[top]; } void Swap(int* a,int* b) { int temp; temp=*a; *a=*b; *b=temp; } 使用链表实现堆栈 使用链表设计堆栈的好处是链表的大小是可以变动的，不会造成内存空间的浪费 缺点是设计复杂\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; class Node\t//声明堆栈链表节点 { public: int data;\t//声明存放堆栈数据的变量 class Node *next;\t//堆栈中用来指向下一个节点的指针 }; typedef class Node Stack_Node;\t//定义堆栈中节点的新类型 typedef Stack_Node *Linked_Stack;\t//定义链表堆栈的新类型 Linked_Stack top=NULL;\t//指向堆栈顶端的指针 //判断是否为空堆栈 int isEmpty() { if(top==NULL) return 1; else return 0; } //将指定的数据压入堆栈 void push(int data) { Linked_Stack new_add_node;\t//新加入节点的指针 new_add_node=new Stack_Node;//分配内存给新节点 new_add_node-\u0026gt;data=data;\t//将传入的值赋值给节点的数据变量 new_add_node-\u0026gt;next=top;\t//将新节点指向堆栈的顶端 top=new_add_node;\t//新节点成为堆栈的顶端 } //从堆栈弹出数据 int pop() { Linked_Stack ptr;\t//指向堆栈顶端的指针 int temp; if(isEmpty())\t//判断堆栈是否为空,如果是则返回-1 { cout\u0026lt;\u0026lt;\u0026#34;===目前为空堆栈===\u0026#34;\u0026lt;\u0026lt;endl; return -1; } else { ptr=top;\t//指向堆栈的顶端 top=top-\u0026gt;next;\t//将堆栈顶端的指针指向下一个节点 temp=ptr-\u0026gt;data;\t//取出堆栈的数据 free(ptr);\t//将节点占用的内存释放 return temp;\t//将从堆栈取出的数据返回给主程序 } } //主程序 int main(void) { int value; int i; cout\u0026lt;\u0026lt;\u0026#34;请按序输入10个数据:\u0026#34;\u0026lt;\u0026lt;endl; for(i=0;i\u0026lt;10;i++) { cin\u0026gt;\u0026gt;value; push(value); } cout\u0026lt;\u0026lt;\u0026#34;====================\u0026#34;\u0026lt;\u0026lt;endl; while(!isEmpty()) //将数据陆续从顶端弹出 cout\u0026lt;\u0026lt;\u0026#34;堆栈弹出的顺序为:\u0026#34;\u0026lt;\u0026lt;setw(2)\u0026lt;\u0026lt;pop()\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;====================\u0026#34;\u0026lt;\u0026lt;endl; return 0; } 堆栈类模板的实现 样板的设计概念也被称为泛型编程，通过对模板输入特定的数据类型可以形成对应的函数或类。 C++有stl模板库，但本书并没有使用。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; using namespace std; template \u0026lt;class Type\u0026gt;\t// 定义链表中的节点 struct Node { Type data;\t// 记录数据 Node* next;\t// 记录下一笔节点的地址 }; template \u0026lt;class Type\u0026gt; class LinkedList\t// 链表类型 { private: Node\u0026lt;Type\u0026gt;* first;\t// 指到第一个节点的指针 public: LinkedList()\t// 构造函数 { first = NULL; } void addNode(Type data);\t// 加入节点 void display();\t// 显示所有的节点 }; template\u0026lt;class Type\u0026gt; void LinkedList\u0026lt;Type\u0026gt;::addNode(Type data) { Node\u0026lt;Type\u0026gt;* newNode = new Node\u0026lt;Type\u0026gt;;\t// 新增一个节点 newNode-\u0026gt;data = data;\t// 记录数据 newNode-\u0026gt;next = first;\t// 指向前一个节点 first = newNode;\t// 指向新的节点 } template\u0026lt;class Type\u0026gt; void LinkedList\u0026lt;Type\u0026gt;::display() { Node\u0026lt;Type\u0026gt;* currentNode = first; // 从第一个节点开始显示 while( currentNode != NULL ) { cout \u0026lt;\u0026lt; currentNode-\u0026gt;data \u0026lt;\u0026lt; \u0026#34; -\u0026gt; \u0026#34;; currentNode = currentNode-\u0026gt;next; } } int main() { LinkedList\u0026lt;double\u0026gt; dblList;\t// 建立一个存储double类型数据的链表 double num;\t// 记录输入的数据 char ch;\t// 记录用户的选择 do{ cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt;\u0026#34;请输入一个数字 : \u0026#34;; cin \u0026gt;\u0026gt; num; dblList.addNode( num ); cout \u0026lt;\u0026lt; \u0026#34;继续输入(y / n)?\u0026#34;; cin \u0026gt;\u0026gt; ch; }while( ch != \u0026#39;n\u0026#39; ); cout \u0026lt;\u0026lt; endl; dblList.display();\t// 显示所有的数据 cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; return 0; } #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; using namespace std; // 设置类样版的类型参数Type的默认值为整数int,非类型参数的类型为整数int,默认值为5 template \u0026lt;class Type = int, int size = 5\u0026gt;\t// 声明类样板 class Stack { private: Type st[size];\t// 声明一数组作为堆栈的存储空间 int top;\t// 堆栈数据顶端的索引 public: Stack() { top = -1; } void push(Type data);\t// 将数据压入堆栈 Type pop();\t// 将数据从堆栈中弹出 }; template \u0026lt; class Type, int size \u0026gt; void Stack\u0026lt; Type, size \u0026gt; :: push ( Type data ) { st[ ++top ] = data; } template \u0026lt; class Type, int size \u0026gt; Type Stack\u0026lt;Type, size\u0026gt; :: pop() { return st[ top-- ]; } int main() { Stack\u0026lt;\u0026gt; stk_1;\t// 声明一个堆栈对象, 并使用其默认值 Stack\u0026lt;char*, 4\u0026gt; stk_2;\t// 声明堆栈对象, 其类型为字符串, 大小为4 stk_1.push( 11 ); stk_1.push( 22 ); stk_1.push( 33 ); cout \u0026lt;\u0026lt; \u0026#34;stack_1 [1] = \u0026#34; \u0026lt;\u0026lt; stk_1.pop() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;stack_1 [2] = \u0026#34; \u0026lt;\u0026lt; stk_1.pop() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;stack_1 [3] = \u0026#34; \u0026lt;\u0026lt; stk_1.pop() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; endl; stk_2.push( \u0026#34;第一名\u0026#34; ); stk_2.push( \u0026#34;第二名\u0026#34; ); stk_2.push( \u0026#34;第三名\u0026#34; ); cout \u0026lt;\u0026lt; \u0026#34;stack_2 [1] = \u0026#34; \u0026lt;\u0026lt; stk_2.pop() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;stack_2 [2] = \u0026#34; \u0026lt;\u0026lt; stk_2.pop() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;stack_2 [3] = \u0026#34; \u0026lt;\u0026lt; stk_2.pop() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; endl; return 0; } 队列 (1)图遍历的广度优先搜索法 (BFS) 就是使用队列。 (2)可用于计算机的模拟，在模拟过程中，由于各种事件 的输入时间不一定，可以使用队列来反映真实的情况。 (3)可用于 CPU 的作业调度 ，利用队列来处理，可实现作业先到先执行的要求。 (4)外围设备联机并发处理系统的应用，也就是让输入/输出的数据先在高速磁驱动器中完成，把磁盘当成一个大型的工作缓冲区，如此可让输入/输出操作快速完成，因而缩短了系统响应的时间，接下来由系统软件负责将磁盘数据输出到打印机，其中就应用了队列的工作原理。\n认识队列 队列的基本操作 create,add,delete,front,empty\n用数组来实现队列 好处是算法简单，只需要front和rear来指队首和队尾，初始值都赋上-1，add,delete时对数据增加。 rear指向最后的元素，front指向最前面的元素的前一个位置，刚开始就是-1。 坏处是只能声明固定长度。\n/* [示范]：实现往队列中加入数据和从队列中取出数据 */ #include \u0026lt;iostream\u0026gt; using namespace std; const int MAX=20; //定义队列的大小 int main(void) { int front,rear,val,queue[MAX]={0}; char ch; front=rear=-1; while(rear\u0026lt;MAX-1\u0026amp;\u0026amp;ch!=\u0026#39;E\u0026#39;) { cout\u0026lt;\u0026lt;\u0026#34;输入I：往队列加入一个数据 输入G：从队列中取出一个数据\\n输入E：结束程序\\n请输入：\u0026#34;; cin\u0026gt;\u0026gt;ch; switch(ch) { case \u0026#39;I\u0026#39;: cout\u0026lt;\u0026lt;\u0026#34;[请输入数据]：\u0026#34;; cin\u0026gt;\u0026gt;val; rear++; queue[rear]=val; break; case \u0026#39;G\u0026#39;: if(rear\u0026gt;front) { front++; cout\u0026lt;\u0026lt;\u0026#34;[从队列中取出的数据为]: [\u0026#34;\u0026lt;\u0026lt;queue[front]\u0026lt;\u0026lt;\u0026#34;]\u0026#34;; cout\u0026lt;\u0026lt;endl; queue[front]=0; } else { cout\u0026lt;\u0026lt;\u0026#34;[队列已经空了]\u0026#34;\u0026lt;\u0026lt;endl; exit(0); } break; default: cout\u0026lt;\u0026lt;endl; break; } } if(rear==MAX-1) cout\u0026lt;\u0026lt;\u0026#34;[队列已经满了]\u0026#34;\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;[目前队列中的数据]:\u0026#34;; if (front\u0026gt;=rear) { cout\u0026lt;\u0026lt;\u0026#34;没有\u0026#34;\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;[队列已经空了]\u0026#34;\u0026lt;\u0026lt;endl; } else { while (rear\u0026gt;front) { front++; cout\u0026lt;\u0026lt;\u0026#34;[\u0026#34;\u0026lt;\u0026lt;queue[front]\u0026lt;\u0026lt;\u0026#34;]\\t\u0026#34;; } cout\u0026lt;\u0026lt;endl; } return 0; } 用链表实现队列 /* [示范]：以链表来实现队列 */ #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; class Node { public: int data; class Node *next; }; typedef class Node QueueNode; typedef QueueNode *QueueByLinkedList; QueueByLinkedList front=NULL; QueueByLinkedList rear=NULL; //方法enqueue：把数据加入队列 void enqueue(int value) { QueueByLinkedList node; //建立节点 node=new QueueNode; node-\u0026gt;data=value; node-\u0026gt;next=NULL; //检查是否为空队列 if (rear==NULL) front=node; //如果rear为NULL，表示这是队列的第一个元素（节点） else rear-\u0026gt;next=node; //将新元素（新节点）连接至队列末尾 rear=node; //将队列的末尾指针指向新加入的节点 } //方法dequeue：从队列中取出数据 int dequeue() { int value; //检查队列是否为空队列 if (!(front==NULL)) { if(front==rear) rear=NULL; value=front-\u0026gt;data; //从队列中取出数据 front=front-\u0026gt;next; //将队列的前端指针指向下一个 return value; } else return -1; } int main(void) { int temp; cout\u0026lt;\u0026lt;\u0026#34;用链表来实现队列\u0026#34;\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;====================================\u0026#34;\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;在队列前端加入第1个数据，此数据为1\u0026#34;\u0026lt;\u0026lt;endl; enqueue(1); cout\u0026lt;\u0026lt;\u0026#34;在队列前端加入第2个数据，此数据为3\u0026#34;\u0026lt;\u0026lt;endl; enqueue(3); cout\u0026lt;\u0026lt;\u0026#34;在队列前端加入第3个数据，此数据为5\u0026#34;\u0026lt;\u0026lt;endl; enqueue(5); cout\u0026lt;\u0026lt;\u0026#34;在队列前端加入第4个数据，此数据为7\u0026#34;\u0026lt;\u0026lt;endl; enqueue(7); cout\u0026lt;\u0026lt;\u0026#34;在队列前端加入第5个数据，此数据为9\u0026#34;\u0026lt;\u0026lt;endl; enqueue(9); cout\u0026lt;\u0026lt;\u0026#34;====================================\u0026#34;\u0026lt;\u0026lt;endl; while (1) { if (!(front==NULL)) { temp=dequeue(); cout\u0026lt;\u0026lt;\u0026#34;从队列前端按序取出的数据为：\u0026#34;\u0026lt;\u0026lt;setw(1)\u0026lt;\u0026lt;temp\u0026lt;\u0026lt;endl; } else break; } cout\u0026lt;\u0026lt;endl; return 0; } 环形队列 上述的数组程序可以实现先进先出的排队策略，但没有办法模拟排队的人走了接下来几位向前走的情形，没法加入其他数据。可以利用环形队列解决这个问题。\n当数据满了，把rear的值重写为0. (rear+1)mod n\nfront指向最前面的元素的前一个位置。\nrear指向的下一个是front时判断队列已经满了，队列只可以存放n-1个数据。\n/* [示范]：实现环状队列数据的进队和出队 */ #include \u0026lt;iostream\u0026gt; using namespace std; int main(void) { int front,rear,val=0,queue[5]={0}; front=rear=-1; while(rear\u0026lt;5\u0026amp;\u0026amp;val!=-1) { cout\u0026lt;\u0026lt;\u0026#34;请输入一个值以存入队列，欲取出值请输入-2。(结束输入-1)：\u0026#34;; cin\u0026gt;\u0026gt;val; if(val==-2) { if(front==rear) { cout\u0026lt;\u0026lt;\u0026#34;[队列已经空了]\u0026#34;\u0026lt;\u0026lt;endl; break; } front++; if (front==5) front=0; cout\u0026lt;\u0026lt;\u0026#34;取出队列值 [\u0026#34;\u0026lt;\u0026lt;queue[front]\u0026lt;\u0026lt;\u0026#34;]\u0026#34;\u0026lt;\u0026lt;endl; queue[front]=0; } else if(val!=-1 \u0026amp;\u0026amp; rear\u0026lt;5) { if(rear+1==front || rear==4 \u0026amp;\u0026amp; front\u0026lt;=0) { cout\u0026lt;\u0026lt;\u0026#34;[队列已经满了]\u0026#34;\u0026lt;\u0026lt;endl; break; } rear++; if(rear==5) rear=0; queue[rear]=val; } } cout\u0026lt;\u0026lt;\u0026#34;\\n队列剩余数据：\u0026#34;\u0026lt;\u0026lt;endl; if (front==rear) cout\u0026lt;\u0026lt;\u0026#34;队列已空!!\u0026#34;\u0026lt;\u0026lt;endl; else { while(front!=rear) { front++; if (front==5) front=0; cout\u0026lt;\u0026lt;\u0026#34;[\u0026#34;\u0026lt;\u0026lt;queue[front]\u0026lt;\u0026lt;\u0026#34;]\u0026#34;; queue[front]=0; } } cout\u0026lt;\u0026lt;endl; return 0; } 双向队列 一般双向队列的应用可以分为2种，一种是两端都可以加入数据但只有一段可以取出数据，另一种是两端都可以取出数据但只有一段可以加入数据。\n优先队列 每一个元素都赋给了一个优先级，加入任意，但取出时优先级高的先出，不是FIFO了。\n后记 我是使用devc++打开源代码的，其中可能会用目录寻找错误而导致打不开文件，这是因为编码方式不一样，容易出现汉字乱码，可以试试把文件打开路径的中文改成英文或拼音。\n","permalink":"https://tassel234.github.io/posts/note/%E4%BD%BF%E7%94%A8cpp%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/","summary":"堆栈简介 基本知识 也可以简写为栈，具有后进先出的特性（LIFO） 与链表和数组一样，栈的数据也是线性排列，但在栈中，添加和删除数据的操作只能在一端进行，访问数据也只能访问到顶端的数据。想要访问中间的数据时，就必须通过出栈操作将目标数据移到栈顶才行。 放入栈的顶端，称为压入PUSH,从顶","title":"使用Cpp实现数据结构-2（栈和队列）"},{"content":"资源 （主）图解数据结构，使用C++ 吴灿明 （源代码来自这里）\n使用软件\u0026quot;算法动画图解\u0026quot;\n我的第一本算法书（书中彩色配图来自上面那个软件）\n算法简单介绍 算法加数据结构构成可执行程序。\n算法的五个条件，输入，输出，有效，明确，有穷\n链表 链表主要用于两个目的：一是建立不定长度的数组。二是链表可以 在不重新安排整个存储结构的情况下，方便且迅速地插入和删除数 据元素。\n动态分配内存 3.1.1 C++的动态分配变量\n数据类型* 指针名称 = new 数据类型 int* p = new int delete p; 可以拓展到结构体或类\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; using namespace std; int main() { int *intptr = new int(50); //声明一指向整数的指针,在该内存中存入整数值50 float *floatptr = new float; //声明一指向浮点数的指针,但未指定内存中存储的数据值 cout \u0026lt;\u0026lt; \u0026#34;intptr 指向的数据值：\u0026#34; \u0026lt;\u0026lt; *intptr \u0026lt;\u0026lt; \u0026#34;\\n\\n\u0026#34;; *floatptr = 0.5; cout \u0026lt;\u0026lt; \u0026#34;floatptr 指向的数据值：\u0026#34; \u0026lt;\u0026lt; *floatptr \u0026lt;\u0026lt; \u0026#34;\\n\\n\u0026#34;; delete intptr; delete floatptr; return 0; } 3.1.2 动态分配数组\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; using namespace std; int main(){ int no,count=0, Total=0; // 定义整数变量 count 与 Total cout\u0026lt;\u0026lt;\u0026#34;要输入计算的个数为:\u0026#34;; cin\u0026gt;\u0026gt;no; int *ptr=new int[no]; // 动态分配数组为n个元素 cout\u0026lt;\u0026lt;endl;\tfor (count=0; count \u0026lt; no; count++)\t{\tcout \u0026lt;\u0026lt; \u0026#34;输入ptr[\u0026#34; \u0026lt;\u0026lt; count \u0026lt;\u0026lt; \u0026#34;]:\u0026#34;; cin \u0026gt;\u0026gt; ptr[count]; // 采用数组下标来输入数组元素 } for (count=0; count \u0026lt; no; count++) Total+=*(ptr+count); // 采用指针变量运算来存取数组的元素值 cout\u0026lt;\u0026lt;\u0026#34;---------------------------------------\u0026#34;\u0026lt;\u0026lt;endl; cout \u0026lt;\u0026lt; no\u0026lt;\u0026lt;\u0026#34;个数的总和=\u0026#34; \u0026lt;\u0026lt; Total; // 显示结果 cout \u0026lt;\u0026lt; endl; delete [] ptr; // 释放分配给 ptr 的内存空间 ptr=NULL;\treturn 0; } 单向链表 在C++网课学习期间已经对该部分内容有部分了解，和网课不同的是本书的程序不是由结构体，而是由类写的。\n接下来的笔记主要以程序为主，笔记以标注//形式写出。\n3.2.1 单向链表的创建与遍历\n#include \u0026lt;iostream\u0026gt; using namespace std; class list { public: int num,score; char name[10]; class list *next; }; typedef class list node;//删除class也可以，有class是偏c语言的写法 typedef node *link; int main() { link newnode,ptr,delptr; //声明三个链表结构的指针 cout\u0026lt;\u0026lt;\u0026#34;请输入 5 位学生的数据：\u0026#34;\u0026lt;\u0026lt;endl; delptr=new node; //delptr暂当链表头指针 if (!delptr) { cout\u0026lt;\u0026lt;\u0026#34;[Error!!内存分配失败!]\u0026#34;\u0026lt;\u0026lt;endl; exit(1); } cout\u0026lt;\u0026lt;\u0026#34;请输入学号：\u0026#34;; cin\u0026gt;\u0026gt;delptr-\u0026gt;num; cout\u0026lt;\u0026lt;\u0026#34;请输入姓名：\u0026#34;; cin\u0026gt;\u0026gt;delptr-\u0026gt;name; cout\u0026lt;\u0026lt;\u0026#34;请输入成绩：\u0026#34;; cin\u0026gt;\u0026gt;delptr-\u0026gt;score; ptr=delptr; //保留链表头指针，以ptr为指向当前节点的指针 for (int i=1;i\u0026lt;5;i++) { newnode=new node; //创建新节点 if(!newnode) { cout\u0026lt;\u0026lt;\u0026#34;[Error!!内存分配失败!\u0026#34;\u0026lt;\u0026lt;endl; exit(1); } cout\u0026lt;\u0026lt;\u0026#34;请输入学号：\u0026#34;; cin\u0026gt;\u0026gt;newnode-\u0026gt;num; cout\u0026lt;\u0026lt;\u0026#34;请输入姓名：\u0026#34;; cin\u0026gt;\u0026gt;newnode-\u0026gt;name; cout\u0026lt;\u0026lt;\u0026#34;请输入成绩：\u0026#34;; cin\u0026gt;\u0026gt;newnode-\u0026gt;score; newnode-\u0026gt;next=NULL; ptr-\u0026gt;next=newnode; //把新节点加在链表后面 ptr=ptr-\u0026gt;next; //让ptr保持在链表的最后面 } cout\u0026lt;\u0026lt;\u0026#34;\\n 学 生 成 绩\u0026#34;\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34; 学号\\t姓名\\t成绩\\n=====================\u0026#34;\u0026lt;\u0026lt;endl; ptr=delptr; //让ptr回到链表头 while(ptr!=NULL) { cout\u0026lt;\u0026lt;ptr-\u0026gt;num\u0026lt;\u0026lt;\u0026#34;\\t\u0026#34;\u0026lt;\u0026lt;ptr-\u0026gt;name\u0026lt;\u0026lt;\u0026#34;\\t\u0026#34;\u0026lt;\u0026lt;ptr-\u0026gt;score\u0026lt;\u0026lt;endl; delptr=ptr; ptr=ptr-\u0026gt;next; //ptr按序往后遍历整个链表 delete delptr; //释放内存空间 } } 3.2.2 单向链表中新节点的插入\n方法同网课\n3.2.3 单向链表中节点的删除\ny=ptr-\u0026gt;next; ptr-\u0026gt;next=y-\u0026gt;next; delete y; 也可以采用网课讲的方法。\n3.2.4 单向链表的反转 （指全部数据）\n/* [示范]:将学生成绩按学号反转打印出来 */ #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;ctime\u0026gt; #include \u0026lt;cstdlib\u0026gt; using namespace std; class list { public: int num,score; char name[10]; class list *next; }; typedef class list node; typedef node *link; int main() { link ptr,last,before; int i,j,findword=0,data[12][2]; char namedata[12][10]={{\u0026#34;Allen\u0026#34;},{\u0026#34;Mako\u0026#34;},{\u0026#34;Lean\u0026#34;}, {\u0026#34;Melissa\u0026#34;},{\u0026#34;Angel\u0026#34;},{\u0026#34;Sabrina\u0026#34;},{\u0026#34;Joyce\u0026#34;}, {\u0026#34;Jasica\u0026#34;},{\u0026#34;Hanson\u0026#34;},{\u0026#34;Amy\u0026#34;},{\u0026#34;Bob\u0026#34;},{\u0026#34;Jack\u0026#34;}}; srand((unsigned)time(NULL)); for (i=0;i\u0026lt;12;i++) { data[i][0]=i+1; data[i][1]=rand()%50+51;//随机给成绩 } link head=new node;\t//建立链表头指针 if(!head) { cout\u0026lt;\u0026lt;\u0026#34;Error!! 内存分配失败!!\u0026#34;\u0026lt;\u0026lt;endl; exit(1); } head-\u0026gt;num=data[0][0]; for (j=0;j\u0026lt;10;j++) head-\u0026gt;name[j]=namedata[0][j]; head-\u0026gt;score=data[0][1]; head-\u0026gt;next=NULL; ptr=head; for(i=1;i\u0026lt;12;i++) //建立链表 { link newnode=new node; newnode-\u0026gt;num=data[i][0]; for (j=0;j\u0026lt;10;j++) newnode-\u0026gt;name[j]=namedata[i][j]; newnode-\u0026gt;score=data[i][1]; newnode-\u0026gt;next=NULL; ptr-\u0026gt;next=newnode; ptr=ptr-\u0026gt;next; } ptr=head; i=0; cout\u0026lt;\u0026lt;\u0026#34;原始链表数据：\u0026#34;\u0026lt;\u0026lt;endl; while (ptr!=NULL) { //打印链表数据 cout\u0026lt;\u0026lt;\u0026#34;[\u0026#34;\u0026lt;\u0026lt;setw(2)\u0026lt;\u0026lt;ptr-\u0026gt;num\u0026lt;\u0026lt;setw(8) \u0026lt;\u0026lt;ptr-\u0026gt;name\u0026lt;\u0026lt;setw(3)\u0026lt;\u0026lt;ptr-\u0026gt;score\u0026lt;\u0026lt;\u0026#34;] -\u0026gt; \u0026#34;; i++; if(i\u0026gt;=3) //三个元素为一行 { cout\u0026lt;\u0026lt;endl; i=0; } ptr=ptr-\u0026gt;next; } ptr=head; before=NULL; cout\u0026lt;\u0026lt;\u0026#34;\\n反转后链表数据：\u0026#34;\u0026lt;\u0026lt;endl; while(ptr!=NULL) //链表反转 { last=before; before=ptr; ptr=ptr-\u0026gt;next; before-\u0026gt;next=last; } ptr=before; while(ptr!=NULL) { cout\u0026lt;\u0026lt;\u0026#34;[\u0026#34;\u0026lt;\u0026lt;setw(2)\u0026lt;\u0026lt;ptr-\u0026gt;num\u0026lt;\u0026lt;setw(8) \u0026lt;\u0026lt;ptr-\u0026gt;name\u0026lt;\u0026lt;setw(3)\u0026lt;\u0026lt;ptr-\u0026gt;score\u0026lt;\u0026lt;\u0026#34;] -\u0026gt; \u0026#34;; i++; if(i\u0026gt;=3) { cout\u0026lt;\u0026lt;endl; i=0; } ptr=ptr-\u0026gt;next; } } 3.2.5 多项式链表表示法\n/* [示范]:多项式相加 */ #include \u0026lt;iostream\u0026gt; using namespace std; class list //声明链表结构 { public : int coef,exp; class list *next; }; typedef class list node; typedef node *link; link creat_link(int data[4]); void print_link(link head);//函数定义 link sum_link(link a,link b); int main() { link a,b,c; int data1[4]={3,0,4,2}; //多项式A的系数 int data2[4]={6,8,6,9}; //多项式B的系数 cout\u0026lt;\u0026lt;\u0026#34;原始多项式：\u0026#34;\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;\u0026#34;A=\u0026#34;; a=creat_link(data1); //建立多项式A b=creat_link(data2); //建立多项式B print_link(a); //打印多项式A cout\u0026lt;\u0026lt;\u0026#34;B=\u0026#34;; print_link(b); //打印多项式B cout\u0026lt;\u0026lt;\u0026#34;多项式相加的结果：\\nC=\u0026#34;; c=sum_link(a,b); //C为A、B多项式相加的结果 print_link(c); //打印多项式C } link creat_link(int data[4])//建立多项式子程序 { link head,newnode,ptr; for(int i=0;i\u0026lt;4;i++) { newnode = new node; if(!newnode) { cout\u0026lt;\u0026lt;\u0026#34;Error!! 内存分配失败!!\u0026#34;\u0026lt;\u0026lt;endl; exit(1); } if(i==0) { newnode-\u0026gt;coef=data[i]; newnode-\u0026gt;exp=3-i; newnode-\u0026gt;next=NULL; head=newnode; ptr=head; } else if(data[i]!=0) { newnode-\u0026gt;coef=data[i]; newnode-\u0026gt;exp=3-i; newnode-\u0026gt;next=NULL; ptr-\u0026gt;next=newnode; ptr=newnode; } } return head; } void print_link(link head) //打印多项式子程序 { while(head!=NULL) { if(head-\u0026gt;exp==1 \u0026amp;\u0026amp; head-\u0026gt;coef!=0)\t//X^1时不显示指数 cout\u0026lt;\u0026lt;head-\u0026gt;coef\u0026lt;\u0026lt;\u0026#34;X + \u0026#34;; else if(head-\u0026gt;exp!=0 \u0026amp;\u0026amp; head-\u0026gt;coef!=0) cout\u0026lt;\u0026lt;head-\u0026gt;coef\u0026lt;\u0026lt;\u0026#34;X^\u0026#34;\u0026lt;\u0026lt;head-\u0026gt;exp\u0026lt;\u0026lt;\u0026#34; + \u0026#34;; else if(head-\u0026gt;coef!=0) //X^0时不显示变量 cout\u0026lt;\u0026lt;head-\u0026gt;coef; head=head-\u0026gt;next; } cout\u0026lt;\u0026lt;endl; } link sum_link(link a,link b) //多项式相加子程序 { int sum[4],i=0; link ptr; ptr=b; while(a!=NULL) //判断多项式1 { b=ptr; //重复比较A和B的指数 while(b!=NULL) { if(a-\u0026gt;exp==b-\u0026gt;exp)\t//指数相等，系数相加 { sum[i]=a-\u0026gt;coef+b-\u0026gt;coef; a=a-\u0026gt;next; b=b-\u0026gt;next; i++; } else if(b-\u0026gt;exp \u0026gt; a-\u0026gt;exp)\t//B指数较大，指定系数给C { sum[i]=b-\u0026gt;coef; b=b-\u0026gt;next; i++; } else if(a-\u0026gt;exp \u0026gt; b-\u0026gt;exp)\t//A指数较大，指定系数给C { sum[i]=a-\u0026gt;coef; a=a-\u0026gt;next; i++; } } } return creat_link(sum);\t//建立相加结果的链表C } 环形链表 单链表如果头指针丢失，整个链表就会丢失。\n对单向链表进行了改进，把尾节点本该空着的指针改为指向头节点。这样每一个节点都可以作为头指针。\n环形链表通常应用于内存工作区和IO缓冲区。\n双向链表 把指针增加为2个，一个指向前方，一个指向后方，增加链表的结实长度，让链表不会因为某指针，链接的断裂而失去数据。同时也可以反方向遍历。\n","permalink":"https://tassel234.github.io/posts/note/%E4%BD%BF%E7%94%A8cpp%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1%E9%93%BE%E8%A1%A8/","summary":"资源 （主）图解数据结构，使用C++ 吴灿明 （源代码来自这里） 使用软件\u0026quot;算法动画图解\u0026quot; 我的第一本算法书（书中彩色配图来自上面那个软件） 算法简单介绍 算法加数据结构构成可执行程序。 算法的五个条件，输入，输出，有效，明确，有穷 链表 链表主要用于两个目的：一是建立不定长度的","title":"使用Cpp实现数据结构-1（链表）"},{"content":"类的定义 （1）定义类 面向程序设计更偏向于把每一个细节都做好，从每一个零件开始是制造汽车。面向对象编程偏向于把很多细小的零件已经主装好了，保留集成了很多接口，只需要把部件进行拼接就可以得到产品。\n面向对象编程的意义在于自然界都是由实体组成，面向对象也是软件开发的主流方式。\n面对对象的三大特征，分别是抽象，封装，继承。抽象指的是将成员和成员的行为分别表示为数据成员和成员函数。封装就是把抽象来的对象代码写到类里面，并设计一些接口。继承和派生，指的是可以对一些类进行修改，得到子类，比如把本科学生信息管理系统稍作修改就可以变成研究生学生信息管理系统。\n类的定义和结构体相似，但比结构体多了对共有，私有成员的声明，还有就是类里面可以由函数。公有成员就是所有类的用户都可以使用，私有成员是只有类的成员可以用，被保护的成员基本和私有成员相同，但派生继承的类的成员也可以访问\n函数可以定义先声明在类的里面，然后定义在类外。使用：：符号\nclass Data { //Data类定义 void set(int d); //成员函数原型声明，与 void set(int); 等价 int get() { //成员函数类内部定义 return data; } //get函数定义结束 int data; //数据成员 }; //Data类定义结束 void Data::set(int d) //成员函数类外部定义 { data=d; //访问类的数据成员 } 类定义一般放在程序文件开头，或者放到头文件中被程序文件包含， 此时这个定义是全局的。在全局作用域内，该定义处处可见，因此 同作用域内的所有函数都可以使用它。\n类定义向编译器声明了一种新的数据类型，该数据类型有不同类型 的数据成员和成员函数。因此尽管数据成员类似变量的定义，但类 型声明时并不会产生该成员的实体，即为它分配存储空间。\n（2）成员的访问控制 类的每个成员都有访问控制属性，由以下三种访问标号说明：public（公有的）、private（私有的）和protected（保护的）。\npublic实现了类的外部接口。私有成员用private标号声明，只有类成员可以访问私有成员，类用户的访问是不允许的。显然，private实现了私有成员的隐蔽。保护成员用protected标号声明，在不考虑继承的情况下，protected的性质和private的性质一致，但保护成员可以被派生类的类成员访问。\n实际编程中，为了使程序清晰，每一种成员访问限定符在类体中只出现一次\n（3）类的数据成员 类的数据成员可以是基本类型、数组、指针、引用、共用体、枚举 类型、void指针、const限定等数据类型。\n但不可以是自身，后面会提到构造函数，可以构造同名的函数体。\n（4）类的成员函数 在成员函数中可以访问这个类的任何成员，无论它是公有的 或是私有的，是类内部声明的还是类外部定义的。\n（::）是作用域限定符（field qualifed）。如果在作用域限定符的前面没有类名，或者函数前面既无类名又无作用域限定符，例 如：::set(10) 或 set(10）则表示set函数不属于任何类，这个函数不是成员函数，而是全局的普通函数。此时的（::）不是类作用域限定符的含义，而是命名空间域限定符的含义。\n类的成员函数可以指定为inline，即内联函数。声明在类外或者类内都可以。\n可以对成员函数重载或使用默认参数。需要注意，声明成员函数的多个重载版本或指定成员函数的默认参 数，只能在类内部中进行。\n用类实例化一个对象时，系统会为每一个对象分配存储空问。如果 一个类包括了数据成员和成员函数，则要分别为数据和函数的代码 分配存储空间。 （5）类的声明 类不能具有自身类型的数据成员。然而，只要类名一经出现就可以 认为该类己声明。因此，类的数据成员可以是指向自身类型的指针 或引用。\nclass Point; //Point类声明，非Point类定义，因为没有类体 class Line { Point a; //错误，不能使用仅有类声明而没有类定义的类定义数 据对象 Point *pp, \u0026amp;rp; //正确，只有类声明，即可用它定义该类的指 针或引用 Line b; //错误，类不能具有自身类型的数据成员 Line *pl, \u0026amp;rl; //正确，类可以有指向自身类型的指针或引用 的数据成员 }; 对象的定义和使用 （1）对象的的定义 从现在起，“对象”一词专门表示类的实体。\nPoint a,b; //C++特色定义对象 class Point x,y; //兼容C语言特色定义对象 具体定义方式和结构体类似\n（2）对象的动态建立和释放 利用new运算符可以动态地分配对象空间，delete运算符释放对象空间。 用new运算动态分配得到的对象是无名的，它返回一个指向新对象的指针的值，即分配得到是对象的内存单元的起始地址。程序通过这个地址可以间接访问这个对象，因此需要定义一个指向类的对象的指针变量来存放该地址。显然，用new建立的动态对象是通过指针来引用的。\n在执行new运算时，如果内存不足，无法开辟所需的内存空间，C++编译器会返回一个0值指针。\n#include\u0026lt;iostream\u0026gt; using namespace std; class Box { public: int width, length, height; }; int main() { Box * p=new Box; p-\u0026gt;width=10; p-\u0026gt;length=20; p-\u0026gt;height=30; 1 cout\u0026lt;\u0026lt;p-\u0026gt;width\u0026lt;\u0026lt;\u0026#34;\\t\u0026#34;\u0026lt;\u0026lt;p-\u0026gt;length\u0026lt;\u0026lt;\u0026#34;\\t\u0026#34;\u0026lt;\u0026lt;p-\u0026gt;height\u0026lt;\u0026lt;endl; delete p; return 0; （3）对象成员的引用 访问对象中的成员可以有3种方法：\n①通过对象名和对象成员引用运算符（.）访问对象中的成员；\n②通过指向对象的指针和指针成员引用运算符（-\u0026gt;）访问对象中的成员；\n③通过对象的引用变量和对象成员引用运算符（.）访问对象中的成员；\n需要注意，从类外部只能访问类公有的成员\nvoid caller1() { Data A, *p, *p1; //定义对象指针变量 p1=\u0026amp;A; //p1指向对象A p1-\u0026gt;data=100; //正确，类外部可以访问类的public数据成员 p1-\u0026gt;fun(1,2,3); //正确，类外部可以访问类的public成员函数 p = new Data; //动态分配Data对象 p-\u0026gt;data=100; //正确，类外部可以访问类的public数据成员 p-\u0026gt;fun(1,2,3); //正确，类外部可以访问类的public成员函数 delete p; //撤销p所指向的Data对象 } void caller1() { Data A, \u0026amp;r=A; //定义对象引用变量 r.data=100; //正确，类外部可以访问类的public数据成员 r.fun(1,2,3); //正确，类外部可以访问类的public成员函数 } （4）对象的赋值 如果一个类定义了两个或多个对象，则这些同类的对象之间可以互相赋值。这里所指的对象的“值”是指对象中所有数据成员的值。\n（5）对象、对象指针或对象引用作为函数的参数和返回值 当形参是对象时，实参要求是相同类的对象名，C++不能对类对象进行任何隐式类型转换。此时形参是实参对象的副本。实际编程中，传递对象时需要考虑类的规模带来的调用开销，如果开销很大时建议不用对象作为函数参数。\n当形参是对象指针时，实参要求是同类对象的指针，C++不能对对象指针进行任何隐式类型转换。采用地址传递方式，在函数中若按间接引用方式修改了形参对象本质上就是修改实参对象。因此，使用对象指针作为函数参数可以向主调函数传回变化后的对象。\n当形参是对象引用时，实参要求是同类的对象，其功能与对象指针相似。\n#include \u0026lt;iostream\u0026gt; using namespace std; void func1(Data a,Data *p,Data \u0026amp;r) { a.data=100; p-\u0026gt;data=200; r.data=300; } int main() { Data A, B, C; A.fun(1,2,3); B.fun(4,5,6); C.fun(7,8,9); func1(A,\u0026amp;B,C);//将对象A、B的地址、对象C的引用传递到函数func1 return 0; 如果不希望在函数中修改实参对象的值，函数形参可以作const限定\nvoid func2(Data a,const Data *p,const Data \u0026amp;r) { a.data=100; p-\u0026gt;data=200; //错误，左值是const对象 r.data=300; //错误，左值是const对象 } 函数返回值可以是对象、对象指针或对象引用。函数返回对象指针或引用，本质上返回的是对象的地址而不是它的存储内容，因此不要返回局部对象的指针或引用，因为它在函数返回后是无效的。\nData* func() { Data a; Data *p=\u0026amp;a; return p; //返回局部对象a的指针p } void caller() { Data *p1; p1=func(); p1-\u0026gt;data=100; //a已不存在，引用错误 } 构造函数 （1）什么是构造函数 在类的对象创建之处就会被执行，用来对数据成员（公有还是私有都可以）进行赋值，函数的名字要和类的名字相同。 类的数据成员是不能在类定义时初始化的，因为本身不分配存储空间如果一个类中所有的数据成员是公有的，则可以在定义对象时对数据成员进行初始化，如果类中的数据成员是私有的，如private的或protected的，就不能用这种方法初始化，因为外部不能直接访问私有的数据成员。构造函数不需要人为调用，而是在建立对象时自动被执行。\n（2）构造函数的定义 与其他任何函数一样，构造函数可以声明为内联的。\n#include \u0026lt;iostream\u0026gt; using namespace std; class Cuboid { //Cuboid类表示长方体 public: Cuboid(int l,int h, int d); //构造函数 int volumn() { return length*height*depth; } //计算体积 private: int length,height,depth; //长、高、深 }; Cuboid::Cuboid(int l,int h,int d) //外部定义的构造函数 { length=l, height=h, depth=d; //初始化数据成员 cout\u0026lt;\u0026lt;\u0026#34;Cuboid: \u0026#34;\u0026lt;\u0026lt;\u0026#34;L=\u0026#34;\u0026lt;\u0026lt;l\u0026lt;\u0026lt;\u0026#34; ,H=\u0026#34;\u0026lt;\u0026lt;h\u0026lt;\u0026lt;\u0026#34; ,D=\u0026#34;\u0026lt;\u0026lt;d\u0026lt;\u0026lt;endl; } int main() { Cuboid a(1,2,3); //定义长方体对象a，调用构造函数初始化 cout\u0026lt;\u0026lt;\u0026#34;volumn=\u0026#34;\u0026lt;\u0026lt;a.volumn()\u0026lt;\u0026lt;endl; //输出体积 Cuboid b(10,20,30); //定义长方体对象b，调用构造函数初始化 cout\u0026lt;\u0026lt;\u0026#34;volumn=\u0026#34;\u0026lt;\u0026lt;b.volumn()\u0026lt;\u0026lt;endl; //输出体积 return 0; 构造函数一般声明为公有的（public），因为创建对象通常是在类的外部进行的。如果构造函数声明为保护的（protected）或私有的（protected），那就意味着在类外部创建对象（并调用构造函数）是错误的。\n每个构造函数应该为每个数据成员提供初始化。否则将使那些数据成员处于未定义的状态。而使用一个未定义的成员是错误的。\n构造函数初始化列表 与普通函数一样，构造函数具有函数名、形参列表和函数体。与其他函数不同的是，构造函数可以包含一个构造函数初始化列表。与其他的成员函数一样，构造函数可以定义在类的内部或外部，但构造函数初始化列表只在构造函数的定义中而不是函数原型声明中指定。\n#include \u0026lt;iostream\u0026gt; using namespace std; class Cuboid { //Cuboid类表示长方体 public: Cuboid(int l,int h, int d); //构造函数 int volumn() { return length*height*depth; }; //计算体积 private: int length,height,depth; //长、高、深 }; Cuboid::Cuboid(int l,int h,int d) :length(l),heght(h),depth(d) //带构造函数初始化列表的构造函数 { cout\u0026lt;\u0026lt;\u0026#34;Cuboid: \u0026#34;\u0026lt;\u0026lt;\u0026#34;L=\u0026#34;\u0026lt;\u0026lt;l\u0026lt;\u0026lt;\u0026#34; ,H=\u0026#34;\u0026lt;\u0026lt;h\u0026lt;\u0026lt;\u0026#34; ,D=\u0026#34;\u0026lt;\u0026lt;d\u0026lt;\u0026lt;endl; } 如果没有为类类型的数据成员提供初始化列表，编译器会隐式地使用该成员的默认构造函数。如果那个类没有默认构造函数，则编译器会报告错误。在这种情况下，为了初始化类类型的数据成员，必须提供初始化列表。\n一般地，没有默认构造函数的成员，以及const或引用类型的成员，都必须在构造函数初始化列表中进行初始化。\n（3）构造函数的重载 在一个类中可以定义多个构造函数版本，即构造函数允许被重载，只要每个构造函数的形参列表是唯一的\n尽管在一个类中可以包含多个构造函数，但是对于每一个对象来说，建立对象时只执行其中一个，并非每个构造函数都被执行。\n（4）带默认参数的构造函数 构造函数的参数允许使用默认值。对类的设计者来说，使用默认参数可以减少代码重复；对类的使用者者来说，使用默认参数可以方便地用适当的参数进行初始化。\n必须在类的内部指定构造函数的默认参数，不能在类外部指定默认参数。\n如果构造函数的全部参数都指定了默认值，则在定义对象时可以给一个或几个实参，也可以不给出实参。这时，就与无参数的构造函数有歧义了。\nclass Point { public: Point(){x=y=0;} Point(int a=1,int b=1):x(a),y(b) { }; void display() { cout\u0026lt;\u0026lt;\u0026#34;x=\u0026#34;\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34; ,y=\u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl; } private: int x,y; //坐标值 }; int main() { Point k; //出现歧义，既可以x=0，y=0；也可以x=1，y=1 return 0; } 一般地，不应同时使用构造函数的重载和带默认参数的构造函数。\n默认构造函数和复制构造函数 （1）定义默认构造函数 默认构造函数就是在没有显式提供初始化式时调用的构造函数，它 是一个不带参数的构造函数。如果定义某个类的对象时没有提供初 始化式就会使用默认构造函数。\n它由不带参数的构造函数，或者所有形参均是默认参数的构造函数 定义。\n任何一个类有且只有一个默认构造函数。如果定义的类中没有显式 定义任何构造函数，编译器会自动为该类生成默认构造函数，称为 合成默认构造函数.一个类哪怕只定义了一个构造函数，编译器也不会再生成默认构造 函数。一般地，任何一个类都应定义一个默认构造函数。\n（2）隐式类类型转换 #include \u0026lt;iostream\u0026gt; using namespace std; class Data { //Data类定义 public: Data(const string\u0026amp; str=\u0026#34;\u0026#34;) : s1(str) { } //const限定 引用字符串类型 为str变量设置默认初值 提供初始化列表 void SetString(const Data\u0026amp; r) //期待的是Data类型的对象 { s1=r.s1; } void print() { cout\u0026lt;\u0026lt;s1\u0026lt;\u0026lt;endl; } private: string s1; } int main() { Data a,b,c(\u0026#34;world\u0026#34;); string i=\u0026#34;string\u0026#34;; a.SetString(c); b.SetString(string(\u0026#34;world\u0026#34;)); //隐式转换 a.print(); b.print(); Data d=Data(i); //隐式转换 d.print(); return 0; 类名(const 指定数据类型\u0026amp; obj)\nC++关键字explicit用来修饰类的构造函数，指明该构造函数是显式 的。explicit关键字只能用于类内部的构造函数声明上，在类定义外 部不能重复它。\n可以禁止由构造函数定义的隐式转换，方法是通过将构造函数声明 为explicit，来防止在需要隐式转换的上下文中使用构造函数。\n（3）复制构造函数与合成复制构造函数 ►复制构造函数又称为拷贝构造函数，它是一种特殊的构造函数。它 的作用就是用一个已经生成的对象来初始化另一个同类的对象。\nPoint pt1(10,20); Point pt2=pt1 复制构造函数定义的一般形式为：\n类名(const 类名\u0026amp; obj) { 函数体 } class Point { //Point类 public: Point() : x(0), y(0) { } //默认构造函数 Point(const Point\u0026amp; r) : x(r.x), y(r.y) { } //复制构造函 数 Point(int a,int b) : x(a), y(b) { } //带参数构造函数 private: int x,y; }; ►复制构造函数有且只有一个本类类型对象的引用形参，通常使用const限定。\n每个类必须有一个复制构造函数。如果类没有定义复制构造函数， 编译器就会自动合成一个，称为合成复制构造函数 与合成默认构造函数不同，即使定义了其他构造函数，编译器也会合成复制构造函数。\n►以下3种情况会使用复制构造函数。\n►（1）用一个对象显式或隐式初始化另一个对象。\n►C++支持两种初始化形式：复制初始化和直接初始化。复制初始化 使用等号（=），而直接初始化将初始化式放在圆括号中。\n►复制初始化和直接初始化是有区别的：直接初始化会调用与实参匹 配的构造函数；而复制初始化总是调用复制构造函数。\nPoint pt1(10,20); Point pt2=pt1; //复制初始化 Point pt3(pt1); //直接初始化 （2）函数参数按值传递对象时或函数返回对象时 当函数形参为对象类型，而非指针和引用类型时，函数调用按值传 递对象，即编译器调用复制构造函数产生一个实参对象副本传递到 函数中。\n类似地，以对象类型作为返回值时，编译器调用复制构造函数产生 一个return语句中的值的副本返回到调用函数。\n（3）根据元素初始化式列表初始化数组元素时。\n总的来说，正是有了复制构造函数，函数才可以传递对象和返回对 象，对象数组才能用初值列表的形式初始化。\n（4）深复制与浅复制 是合成复制构造函数和复制构造函数的区别。 若复制对象但未复制资源内容称为浅复制， 如果一个拥有资源（如用new得到的动态内存）的类对象发生复制 的时候，若对象数据与资源内容一起复制，称为深复制。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string.h\u0026gt; using namespace std; class CA { public: CA(int b,char *cstr) //构造函数 { a=b; str=new char[b]; strcpy(str,cstr); } CA(const CA \u0026amp;C) //复制构造函数 { a=C.a; str=new char[a]; //深复制，浅复制则写成str=C.str; if(str!=0) strcpy(str,C.str); } void show() { cout\u0026lt;\u0026lt;str\u0026lt;\u0026lt;endl; } ~CA() //析构函数 { delete str; } private: int a; char *str; }; int main() { CA a(10,\u0026#34;hello\u0026#34;); CA b=a; b.show(); return 0; } 析构函数 （1）析构函数的定义 析构函数：当对象脱离其作用域时（例如对象所在的函数已调用完 毕），系统会自动执行析构函数。析构函数往往用来做“清理善后” 的工作（例如在建立对象时用new开辟了一段内存空间，则在该对 象消亡前应在析构函数中用delete释放这段存储空间）。\n一个类可以有多个构造函数，但是只能有一个析构函数。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string.h\u0026gt; using namespace std; class Point { public: Point(int a,int b):x(a),y(b){} //带参数的构造函数 ~Point() //析构函数 { cout\u0026lt;\u0026lt;\u0026#34;析构函数被调用。\u0026#34;\u0026lt;\u0026lt;endl; } void show() { cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34;,\u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl; } private: int x,y; }; int main() { Point pt1(10,20); pt1.show(); return 0; （2）合成析构函数 与复制构造函数不同，编译器总是会为类生成一个析构函数，称为合成析构函数 需要注意，合成析构函数并不删除指针成员所指向的对象，它需要 程序员显式编写析构函数去处理。\n（3）何时需要编写析构函数 需要注意，合成析构函数并不删除指针成员所指向的对象，它需要 程序员显式编写析构函数去处理。\n如果类需要析构函数，则该类几乎必然需要定义自己的复制构造函 数和赋值运算符重载，这个规则称为析构函数三法则(三个同时出现)\n#include \u0026lt;iostream\u0026gt; using namespace std; class CString { //CString类 public: CString(const char *str); //单个参数构造函数 ~CString(); //析构函数 void show() { cout\u0026lt;\u0026lt;p\u0026lt;\u0026lt;endl; } //显示字符串 private: char *p; //存储字符串动态内存区 CString::CString(const char *str) { p=new char[strlen(str)+1]; //为存储str动态分配内存 strcpy(p,str); //复制str到p cout\u0026lt;\u0026lt;\u0026#34;构造：\u0026#34;\u0026lt;\u0026lt;str\u0026lt;\u0026lt;endl; } CString::~CString() { cout\u0026lt;\u0026lt;\u0026#34;析构：\u0026#34;\u0026lt;\u0026lt;p\u0026lt;\u0026lt;endl; delete [] p; //析构函数必须是否p占用的内存 } int main() { CString s1(\u0026#34;C++\u0026#34;), s2=\u0026#34;JavaScript\u0026#34;; //定义对象 s1.show(); s2.show(); return 0; } （4）构造函数和析构函数的调用次序 构造函数和析构函数的调用很像一个栈的先进后出，调用析构函数 的次序正好与调用构造函数的次序相反。最先被调用的构造函数， 其对应的（同一对象中的）析构函数最后被调用，而最后被调用的 构造函数，其对应的析构函数最先被调用。\n","permalink":"https://tassel234.github.io/posts/note/c++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1-1/","summary":"类的定义 （1）定义类 面向程序设计更偏向于把每一个细节都做好，从每一个零件开始是制造汽车。面向对象编程偏向于把很多细小的零件已经主装好了，保留集成了很多接口，只需要把部件进行拼接就可以得到产品。 面向对象编程的意义在于自然界都是由实体组成，面向对象也是软件开发的主流方式。 面对对象的三","title":"C++学习笔记-1（类和对象-1）"},{"content":"注释语句 /* ......块注释内容 */ //......行注释内容 输入和输出 标准输入输出流库的头文件\ncin输入时，为了分隔多项数据，默认要求在键盘输入数据之间使用空格、Tab键、回车作为分隔符。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; int main() { bool v; int a,m,n; double x,y,z,p,f; float f1;//除了已经定义的变量，下面出现的oct,setw都是关键字 cin\u0026gt;\u0026gt;boolalpha\u0026gt;\u0026gt;v; //输入：true cin\u0026gt;\u0026gt;oct\u0026gt;\u0026gt;a\u0026gt;\u0026gt;hex\u0026gt;\u0026gt;m\u0026gt;\u0026gt;dec\u0026gt;\u0026gt;n;//输入：144 46 -77 cin\u0026gt;\u0026gt;p\u0026gt;\u0026gt;f\u0026gt;\u0026gt;f1\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;z;//输入：3.14 3.14 3.14 3.14159 0.1 0.1e1 cout\u0026lt;\u0026lt;v\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;boolalpha\u0026lt;\u0026lt;v\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;noboolalpha\u0026lt;\u0026lt;v\u0026lt;\u0026lt;endl;//输出：1 true 1 cout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;p\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;a*p\u0026lt;\u0026lt;endl;//输出：100 3.14 314 cout\u0026lt;\u0026lt;hex\u0026lt;\u0026lt;m\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;oct\u0026lt;\u0026lt;m\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;dec\u0026lt;\u0026lt;m\u0026lt;\u0026lt;endl;//输出：46 106 70，分别是16，8，10进制 cout\u0026lt;\u0026lt;showbase\u0026lt;\u0026lt;hex\u0026lt;\u0026lt;m\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;oct\u0026lt;\u0026lt;m\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;dec\u0026lt;\u0026lt;m\u0026lt;\u0026lt;endl; //输出：0x46 0106 70 cout.precision(5); cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;z\u0026lt;\u0026lt;endl;//输出：3.1416 0.1 1 cout\u0026lt;\u0026lt;fixed\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;z\u0026lt;\u0026lt;endl;//输出：3.14159 0.10000 1.00000 cout\u0026lt;\u0026lt;scientific\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;z\u0026lt;\u0026lt;endl; //输出：3.14159e+000 1.00000e-001 1.00000e+000 cout\u0026lt;\u0026lt;left\u0026lt;\u0026lt;setw(6)\u0026lt;\u0026lt;n\u0026lt;\u0026lt;endl; //输出：-77 cout.width(6); cout\u0026lt;\u0026lt;right\u0026lt;\u0026lt;n\u0026lt;\u0026lt;endl; //输出：_ _ _-77 cout\u0026lt;\u0026lt;setw(10)\u0026lt;\u0026lt;77\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;setfill(\u0026#39;0\u0026#39;)\u0026lt;\u0026lt;setw(10)\u0026lt;\u0026lt;77\u0026lt;\u0026lt;endl; //输出：_ _ _ _ _ _ _77 0000000077 cout\u0026lt;\u0026lt;fixed\u0026lt;\u0026lt;setprecision(5)\u0026lt;\u0026lt;f\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;setprecision(9)\u0026lt;\u0026lt;f\u0026lt;\u0026lt;endl; //输出：3.14000 3.140000000 cout\u0026lt;\u0026lt;showpos\u0026lt;\u0026lt;1\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;0\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;endl; //输出：+1 +0 -1 cout\u0026lt;\u0026lt;noshowpos\u0026lt;\u0026lt; 1\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;0\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;-1\u0026lt;\u0026lt;endl; //输出：1 0 -1 return 0; } 顺序结构 所谓顺序结构是指：语句以其出现的顺序执行。\n分支 if语句 if (a\u0026gt;b) { x=a+b; y=a-b; } else { x=a-b; y=a+b; } a=5,b=2; if ( a ) x=a*10; //等价于a!=0 switch语句 switch ( 表达式 ) { case 常量表达式1 : … 语句序列1 case 常量表达式2 : … 语句序列2 ┇ case 常量表达式n : … 语句序列n default : … 默认语句序列//其他值都在这，无论表达式的值是什么（特指case没有的值），写在最后的该语句都会被执行 } switch语句中case分支的语句序列可以是一个语句，也可以是任意多的语句序列，也可以没有语句；\nswitch语法中各个case分支和default分支的出现次序在语法上没有规定，但次序的不同安排会影响执行结果。\nswitch (n) { default: cout\u0026lt;\u0026lt;\u0026#34;0\u0026#34;;//输入1或2不执行此语句 case 1 : cout\u0026lt;\u0026lt;\u0026#34;1\u0026#34;; case 2 : cout\u0026lt;\u0026lt;\u0026#34;2\u0026#34;; } switch语法中default分支是可选的，若没有default分支且没有任何case标号的值相等时，switch语句将什么也不做，直接执行后续语句。\nswitch语句的分支表达式可以是C++语言的任意表达式，但其值必须是整数（含字符类型）、枚举类型。\n更常见的switch结构应该如下，它提供了程序多分支选择执行流程。\nswitch ( 表达式 ) { case 常量表达式1: … 语句序列1; break; case 常量表达式2: … 语句序列2; break; ┇ case 常量表达式n: … 语句序列n; break; default : … 默认语句序列 } //成绩分层程序 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; int main() { int g; cin\u0026gt;\u0026gt;g; //输入成绩等级 switch(g) { case \u0026#39;A\u0026#39;:cout\u0026lt;\u0026lt;\u0026#34;85～100\\n\u0026#34;; break; case \u0026#39;B\u0026#39;:cout\u0026lt;\u0026lt;\u0026#34;70～84\\n\u0026#34;; break; case \u0026#39;C\u0026#39;:cout\u0026lt;\u0026lt;\u0026#34;60～69\\n\u0026#34;; break; case \u0026#39;D\u0026#39;:cout\u0026lt;\u0026lt;\u0026#34;\u0026lt;60\\n\u0026#34;; break; default: cout\u0026lt;\u0026lt;\u0026#34;error\\n\u0026#34;; } return 0; } 选择语句的嵌套 if第一种方式\nif ( 表达式1 ) 语句1 else if ( 表达式2 ) 语句2 else if ( 表达式3 ) 语句3 ...... else if ( 表达式n ) 语句n else 语句m if第二种方式\nif ( 表达式1 ) if ( 表达式2 ) 语句1 else 语句2 else if ( 表达式3 ) 语句3 else 语句4 switch的嵌套\n#include \u0026lt;iostream\u0026gt; using namespace std; int main() { int y,m,d,Days; cin\u0026gt;\u0026gt;y\u0026gt;\u0026gt;m\u0026gt;\u0026gt;d; //输入日期 switch(m) { //计算每月的天数 case 2 : Days=28; if((y%4==0\u0026amp;\u0026amp;y%100!=0)|| (y%400==0)) Days++; //闰年天数加1 break; case 4 : case 6 : case 9 : case 11 : Days=30;break; default: Days=31; //其余月份为31天 } d++; if (d\u0026gt;Days) d=1,m++; //判断月末 if (m\u0026gt;12) m=1,y++; //判断年末 cout\u0026lt;\u0026lt;y\u0026lt;\u0026lt;“-”\u0026lt;\u0026lt;m\u0026lt;\u0026lt;“-”\u0026lt;\u0026lt;d\u0026lt;\u0026lt;endl; //输出第二天的日期 return 0; } 循环 基本语法 循环语句大致可以分为下面三种\n1、while语句\n2、do while语句（几乎和while等价，可以相互转化，区别在于do while多少要执行一次）\n3、for语句\nfor语句的说明。\n►（1）整个循环过程中表达式1只求解一次；作用是给循环控制变量赋初值。\n►（2）表达式2相当于是for的循环条件。\n►（3）表达式3是重复执行的内容；通常是改变循环控制变量值的语句。\n//判断质数 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int i,m; cin\u0026gt;\u0026gt;m;//从2到m-1之间逐一检查是否被m整除 for (i=2 ; i\u0026lt;=m-1 ; i++) if (m % i==0) break; //如果整除则结束检查 if (i==m) cout\u0026lt;\u0026lt;\u0026#34;Yes\u0026#34;\u0026lt;\u0026lt;endl; //根据循环结束位置判断是否素数 else cout\u0026lt;\u0026lt;\u0026#34;No\u0026#34;\u0026lt;\u0026lt;endl; return 0;\t} ►break语句的作用是结束switch语句和循环语句的运行，转到后续语句，语法形式为：break；\n►break语句只能用在switch语句和循环语句（while、do、for）中，不得单独使用。\n►continue语句的作用是在循环体中结束本次循环，直接进入下一次循环，语句形式为：continue；（可以用来求解奇书偶数的和） ► continue语句只能用在循环语句（while、do、for）中，不能单独使用。\n循环语句的选用 ►计数型循环常使用for语句\n►计数型循环用于处理已知循环次数的循环过程。\n►控制变量在每次循环时都要发生规律性变化（递增或递减），当控制变量达到预定的循环次数时，循环就结束。\n►条件型循环常使用while语句和do while语句。可以写较为抽象的条件。\n►条件型循环用于处理循环次数未知的循环过程，称为“不定次数循环”。\n►在条件型循环中，由于事先不能准确知道循环的次数，因此循环控制是由条件来判定的。在每次循环时检测这个条件，当条件一旦满足，循环就结束。\n//求π的近似值 π/4≈1-1/3+1/5-1/7+1/9-…，直到最后一项的绝对值小于10-7为止。 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; int main() { double s=1,pi=0,n=1,t=1; while (fabs(t)\u0026gt;1e-7) pi=pi+t, n=n+2, s=-s, t=s/n; cout\u0026lt;\u0026lt;pi*4\u0026lt;\u0026lt;endl; return 0; } 循环语句应用举例 百元买鸡问题\n百钱买百鸡问题：有人有一百块钱，打算买一百只鸡。公鸡一只5元，母鸡一只3元，小鸡3只1元，求应各买多少？\n//百元买鸡问题 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int x,y,z; for (x=0; x\u0026lt;=20; x++) //枚举公鸡的可能数量，最多为20 for (y=0; y\u0026lt;=33; y++) //枚举母鸡的可能数量，最多为33 for (z=0; z\u0026lt;=100; z++)//枚举小鸡的可能数量，最多为100 if(z%3==0\u0026amp;\u0026amp;x+y+z==100\u0026amp;\u0026amp;5*x+3*y+z/3==100)//约束条件 cout\u0026lt;\u0026lt;\u0026#34;公鸡=\u0026#34;\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34;,母鸡=\u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;\u0026#34;,小鸡=\u0026#34;\u0026lt;\u0026lt;z\u0026lt;\u0026lt;endl; return 0; } //百元买鸡问题（二重循环优化） #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int x,y,z; for (x=0; x\u0026lt;=20; x++) //枚举公鸡的可能数量，最多为20 for (y=0; y\u0026lt;=33; y++) { //枚举母鸡的可能数量，最多为33 z=100-x-y; //小鸡的数量根据约束条件求得 if (z%3==0 \u0026amp;\u0026amp; 5*x+3*y+z/3==100) //约束条件 cout\u0026lt;\u0026lt;\u0026#34;公鸡=\u0026#34;\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34;,母鸡=\u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;\u0026#34;,小鸡=\u0026#34;\u0026lt;\u0026lt;z\u0026lt;\u0026lt;endl;} return 0; } //百元买鸡问题（一重循环） #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { int rooster, hen, chick; int count; count = 0; //设公鸡r只,母鸡h只,雏鸡c只 //由计算可得,r = (4 * c - 300) / 3 //但是必须使等式有意义,即r\u0026gt;=0,即可求解出r的范围:c\u0026gt;=75 //此外,因为1钱可买3雏鸡,雏鸡的数量c必须是3的整数倍* //经检验,75是\u0026gt;=75且能被三整除的最小整数 //由*可知,雏鸡增加的数量也必须为3的整数倍,所以变量c每次加3 for(chick = 75; chick \u0026lt;= 300; chick = chick + 3) //这条语句限定了chick的范围 75~300 { count++; if ((4 * chick - 300) % 3 == 0)//rooster表达式递增且大于0,但要保证为整数 { rooster = (4 * chick - 300) / 3; hen = (600 - 7 * chick) / 3;//这里无需检验hen是否为整数,因为hen=100-r-c,且前面保证了r,c为整数 if (hen \u0026gt;= 0)//因为hen的表达式递减,这条语句限定了hen的范围\u0026gt;0 printf(\u0026#34;Rooster: %d, Hen: %d, Chick: %d\\n\u0026#34;, rooster, hen, chick); else break; } } printf(\u0026#34;Total count: %d\u0026#34;, count); return 0; } 函数 函数的定义和使用 （1）函数的定义和函数的参数\n返回类型可以是C++除数组之外的内置数据类型或自定义类型。 函数可以不返回数据，此时返回类型应写成void，表示没有返回值。\n#include \u0026lt;iostream\u0026gt; using namespace std; int IsPrime(int m) //求素数函数 { //枚举法求m是否素数 int i; for (i=2 ; i\u0026lt;=m-1 ; i++) if (m % i==0) return 0; //不是素数返回0 return 1; //是素数返回1 } int main() { int m; cin\u0026gt;\u0026gt;m; if (IsPrime(m)) cout\u0026lt;\u0026lt;\u0026#34;Yes\u0026#34;\u0026lt;\u0026lt;endl; //是素数输出Yes else cout\u0026lt;\u0026lt;\u0026#34;No\u0026#34;\u0026lt;\u0026lt;endl; //不是素数输出No return 0; } 1）函数定义时指定的形参，在未进行函数调用前，并不实际占用 内存中的存储单元。\n2）只有在发生函数调用时，形参才分配实际的内存单元，接受从 主调函数传来的数据。\n3）当函数调用结束后，形参占用的内存单元被自动释放。\n值传递（pass-by-value）过程中，形参作为被调函数的内部变量来处理，即开辟内存空间以存放由主调函数复制过来的实参的值，从而成为实参的一个副本。实参数据传递给形参是单向传递，即只能由实参传递给形参，而不能由形参传回给实参。\n函数调用时提供给被调函数的参数称为实际参数（arguments）， 简称实参。\n实参必须有确定的值，因为调用函数会将它们传递给形参。实参可 以是常量、变量或表达式，还可以是函数的返回值。例如：\nx = max(a,b); //max函数调用，实参为a,b y = max(a+3,128); //max函数调用，实参为a+3,128 z = max(max(a,b),c); //max函数调用，实参为max(a,b),c （2）函数的声明与内联函数\n声明时使用函数原型（function prototype）。其作用是提供函数调用所必须的接口信息，函数原型可以没有形式参数的名字，到后面函数定义可以再写。但为了调用函数原型必须放在调用之前，而函数定义可以放在函数调用之后。\nint gcd(int m, int n) //求最大公约数，gcd函数实现在后 { int r; while (n!=0) { //欧几里德算法，举例是：m=9, n=6 ① r=3, m=6, n=3 ② r=0, m=3, n=0 r = m % n ; //r为m/n的余数 m = n ; //则gcd(m,n)=gcd(n,r)=... n = r ; //r=0时n即是gcd } return m; } C++提供一种提高函数效率的方法，即在编译时将被调函数的代码 直接嵌入到主调函数中，取消调用这个环节。这种嵌入到主调函数 中的函数称为内联函数（inline function）。\ninline 返回类型 函数名(形式参数列表) { 函数体 } 但因为过于复杂的函数内联会导致错误，内联函数中不允许用循环语句和switch语句。\n函数的设计 默认参数\nint add(int x=5,int y=6) 可以这样调用。 add(10,20); //10+20 add(10); //10+6 add(); //5+6\n可以设置多个默认参数，设置的顺序为自右向左，换言之，要为某个参数设置默认值，则它右边的所有参数必须都是默认参数。\n默认值可以是常量、全局变量，甚至是一个函数调用，但不可以是局部变量。 函数重载 就是可以取同名的函数。\n函数重载的使用说明：\n（1）重载函数的形参必须不同（个数不同或类型不同）。\n（2）编译程序将根据实参和形参的类型及个数的最佳匹配来选择调用哪一个函数。\n（3）不要将不同功能的函数声明为重载函数，以免出现调用结果的误解、混淆。\n函数模板与库函数的调用\n函数模板（function template）是一个独立于类型的函数，可作为一种模式，产生函数的特定类型版本。\ntemplate\u0026lt;typename T\u0026gt; T abs(T x) { return x\u0026lt;0?-x:x; } 标准库函数的连接在开发环境中是默认的，一般可以不用特别设置，只需要在文件开头输入#include 声明一下就行。包括stl,c语言库等。\n对于一些特殊的由其他人编写的库，一般提前下载，然后再按配置说明进行安装就行。\n函数的调用 （1）函数的嵌套调用\n在调用一个函数的过程中，又调用另一个函数，称为函数的嵌套调 用，C++允许函数多层嵌套调用，只要在函数调用前有函数声明即 可。\n（2）函数的递归调用\n可以使用递归解决阶乘，汉诺塔问题的求解。\n作用域、生命期和程序的组织结构 （1）作用域和生命期\n局部变量只能在定义它的区域及其子区域中使用。\n在不同区域中允许定义相同名字的变量，但本质上它们是不同的变量\n如果一个变量所处区域的子区域中有同名的变量，则该变量在子区域无效，有效的是子区域的变量，称为定义屏蔽。\n#include \u0026lt;iostream\u0026gt; using namespace std; void swap(int x,int y) { int t; t=x; x=y; y=t; } int main( ) { int a,b; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; swap(a,b); cout\u0026lt;\u0026lt;\u0026#34;a=\u0026#34;\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026#34;,b=\u0026#34;\u0026lt;\u0026lt;b\u0026lt;\u0026lt;endl; return 0;//最后不交换次序 } #include \u0026lt;iostream\u0026gt; using namespace std; int x,y; void swap() { int t; t=x; x=y; y=t; } int main( ) { int a,b; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; swap(a,b); cout\u0026lt;\u0026lt;\u0026#34;a=\u0026#34;\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026#34;,b=\u0026#34;\u0026lt;\u0026lt;b\u0026lt;\u0026lt;endl; return 0;//会交换次序 作用域是程序中的一段区域。在同一个作用域上，C++程序中每个名字都与唯一的实体对应；如果在不同的作用域上，程序中可以多次使用同一个名字，对应不同作用域中的不同实体。\n实体在包含它的作用域内，从定义或声明的位置开始，按文件行的顺序往后（往下）直到该作用域结束均是可见的，包含作用域内的所有子区域及其嵌套。但是往前就看不到了。\n可以使用extern声明将变量或函数实体的可见区域往前延伸，称为前置声明。\n在全局作用域中，变量或函数实体若使用static修饰，则该实体对于其他源文件是屏蔽的，称为私有的（private）。\n动态存储在分配和释放的形式有两种，一种是由函数调用来自动完 成的，称为自动存储（automatic storage）如默认参数，结构体和类的实例化，一种是由程序员通过 指令的方式来人工完成的，称为自由存储（free storage）\n现代程序设计的观点是，除非有必要尽量少地使用静态存储\nC++语言允许用CPU的寄存器来存放局部变量，称为寄存器变量。 在局部变量前加上register存储类别修饰来定义的，其形式为：\nregister 类型 变量名[=初值] 在局部对象的前面加上static存储类别修饰用来指明对象是静态局 部对象（static local ）\n#include \u0026lt;iostream\u0026gt; using namespace std; int fun() { static int cnt=0; //静态局部变量会保持其值 ，可以做计数器 cnt++; return cnt; } int main() { int i,c; for (i=1;i\u0026lt;=10;i++) c=fun(); cout\u0026lt;\u0026lt;c\u0026lt;\u0026lt;endl; return 0; } （2）程序的组织结构\n函数本质上是全局的，在多文件的程序中，在连接时会检查函数在 全局作用域内是否名字唯一，如果不是则出现连接错误。\n在函数定义前加上static修饰，则函数称为内部函数。内部函数仅在包含它的文件中有效。\n在函数定义前加上extern声明，则函数称为外部函数。C++中所有的函数本质上都是外部函数。因此，上面的extern都可以省略。\n头文件与工程文件\n如果是多文件结构程序，欲在文件中调用别的文件中的函数，需要有函数的声明，而且每个文件均是如此。如果是函数声明比较多的情况下，在每个文件中都写上函数声明不是好办法，很难管理。如果某个函数定义有变动，那么所有含有这个函数声明的调用文件都需要找出来，逐一修改。使用头文件可以解决这个问题，其工作原理是通过将每个源文件中外部函数的函数声明等信息集中写到一个文件中，称为头文件（有别于源文件），而别的源文件只需用文件包含命令将这个头文件包含，则编译时编译器自然就有了函数声明。\n多文件结构程序在编译时需要工程文件来管理，不同的编译器有不 同的工程文件格式。\n多文件编译\n头文件a.h和cpp文件a.cpp\n#include \u0026#34;a.h\u0026#34;//\u0026#34;\u0026#34;表示在工程文件夹寻找，\u0026lt;\u0026gt;是只在系统文件夹找 //直接引用.h头文件 ","permalink":"https://tassel234.github.io/posts/note/c++%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%87%BD%E6%95%B0/","summary":"注释语句 /* ......块注释内容 */ //......行注释内容 输入和输出 标准输入输出流库的头文件 cin输入时，为了分隔多项数据，默认要求在键盘输入数据之间使用空格、Tab键、回车作为分隔符。 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; int main() { bool v; int a,m,n; double x,y,z,p,f; float f1;//除了已经定义的变量，下面出现的oct,setw都","title":"C++入门学习笔记-2(语句和函数)"},{"content":"前言 使用资源 （主）程序员的数学4：图论 算法图解动画软件演示 b站视频图解\n目标指向 了解图的基本知识，可以对图论模型进行数学建模和程序求解。\n图的基础知识 什么是图 在数学中，图是描述于一组对象的结构，其中某些对象对在某种意义上是“相关的”。这些对象对应于称为顶点的数学抽象（也称为节点或点），并且每个相关的顶点对都称为边（也称为链接或线）。通常，图形以图解形式描绘为顶点的一组点或环，并通过边的线或曲线连接。 图形是离散数学的研究对象之一。\n图的表示法 在计算机中表示图的方式由邻接矩阵，关联矩阵，邻接表。\n其他图论术语 度（Degree）：一个顶点的度是指与该顶点相关联的边的条数，顶点v的度记作d(v)。\n对任意图，度的个数之和都是偶数，也就是握手定理。\n迹：如果路径P(u,v)中的边各不相同，则该路径称为u到v的一条行迹。 路（轨道）：如果路径P(u,v)中的顶点各不相同，则该路径称为u到v的一条轨道。 闭的行迹称作回路（Circuit），闭的轨称作圈（Cycle）。\n定理1 设图G的邻接矩阵为A，A的K次幂的（i,j元素）等于在图G中由i到j长度为K的路径数  子图（Sub-Graph）：当图G'=(V',E')其中V‘包含于V，E’包含于E，则G\u0026rsquo;称作图G=(V,E)的子图。每个图都是本身的子图。\n生成子图（Spanning Sub-Graph）：指满足条件V(G') = V(G)的G的子图G'。\n导出子图（Induced Subgraph）：以图G的顶点集V的非空子集V1为顶点集，以两端点均在V1中的全体边为边集的G的子图，称为V1导出的导出子图；以图G的边集E的非空子集E1为边集，以E1中边关联的顶点的全体为顶点集的G的子图，称为E1导出的导出子图。\n补图。点不变，完全图的补线构成的图。\n几类特殊的图 树和森林 联通且不含圈的图称为树，多个不相连的树构成森林。 单个树可以看作一个比较特殊的森林。\n二部图（二分图） 二分图：顶集，且每一条边都有一个顶点在X中，而另一个顶点在Y中。 完全二分图：二分图G中若任意两个X和Y中的顶点都有边相连。若，则图G记作Km,n。 如上图，树是二部图。\n可平面图 图可以被画成边各不相交的图，称为可平面图。\n定理2：欧拉公式 不论什么形状的可平面图（凸多面体），其顶点数V、棱数E、面数F之间总有关系V+F-E=2  其他 完全图：每一对不同顶点间都有边相连的的图，记作Kn。\n正则图：如果图中所有顶点的度皆相等，则此图称为正则图\n图的度序列 定理3：通过度判断一个序列是否为可图化序列 首先把各顶点的度按降序排列形成度序列 。 去掉第一个数字k，然后把前k个数字减1，再按降序排列，循环步骤简化图。  最小生成树 什么是最小生成树 在图（包括赋权图）中，可以找到的路径长度之和最小的树。 可以解决电缆安装问题，只要达到每一个地点就行，形成连通图。\n克鲁斯卡尔算法 属于贪心算法的一种。 按找赋权的大小依次查找，让其不构成圈，最后可以产生最小生成树 。\n普里姆算法 也属于贪心算法的一种。 以某个节点开始，查找赋权小的。\n最小斯坦纳树问题 某些节点可以连（作为中继节点），也可以不连。 NP难的问题，不太可能存在高效的算法。\n最短路径问题 什么是最短路径问题 由一点到另一点所用路径的权值总和最小的问题。\n迪杰斯特拉算法 每一个节点初始化为非常大的数，路径上赋权正常的数字，赋值方式是节点的值加上路径的值。 通过查找可行路径给节点赋值，节点的值往小的地方更新。 满足条件因为使用其他路径时，必须经过点C，但AC成本大于AB成本 但也因为这个限制，权值不能为负，否则可能会出错，这一点不如福特算法 但斯拉特算法也有优点，比如他的速度要快上很多 对于单行道和双向通道值不一致时也可以非常好的解决，这是福特算法做不到的\n欧拉回路与哈密顿圈 欧拉回路 就像七桥问题，把每一个边走且只走一遍，就是欧拉回路。\n形成欧拉回路的充分必要条件是顶点的度都是偶数。\n哈密顿圈 把每一个点走且只走一遍，就是哈密顿圈 。\n是NP完全问题，不太可能存在高效算法。\n狄拉克定理 狄拉克定理：如果图是一个具有至少3个顶点的简单图G，并且图中每个顶点的度数至少为节点数的一半，那么图包含哈密顿图。\n奥尔定理\n奥尔定理是图论在1960年由挪威数学家奥斯汀·奥尔证明的结果，它为图成为哈密顿量提供了充分的条件，从本质上说，具有“足够多的边”的图必须包含哈密顿环。 具体来说，该定理考虑非相邻顶点对的度数之和：如果每个这样的对具有至少等于图中顶点总数的和，则该图为哈密顿图。如果一个总点数至少为3的简单图G满足：G的任意两个不相邻的点u和v度数之和至少为n，即d(u)+d(v)≥n，那么G必然有哈密顿回路。\n","permalink":"https://tassel234.github.io/posts/note/%E5%9B%BE%E8%AE%BA%E5%85%A5%E9%97%A8-1/","summary":"前言 使用资源 （主）程序员的数学4：图论 算法图解动画软件演示 b站视频图解 目标指向 了解图的基本知识，可以对图论模型进行数学建模和程序求解。 图的基础知识 什么是图 在数学中，图是描述于一组对象的结构，其中某些对象对在某种意义上是“相关的”。这些对象对应于称为顶点的数学抽象（也称为节点或点）","title":"图论入门-1"},{"content":"参考资源 python数学建模算法与应用\nhttps://blog.csdn.net/weixin_35757704/article/details/117808073\nhttps://blog.csdn.net/chuididehuayiren/article/details/109765279\n图表解释 第一部分左边\nDep. Variable:即dependent variable，因变量 OLS:普通最小二乘法 least squares：最小化残差平方和 No. Observations:个案数，即样本容量 df residuals：残差自由度(观测数No.Observations - (参数数目Df Model+1))，这里的1是常量参数 df model：模型中自变量（即参数）个数 Covariance Type：协方差阵的稳健性  第一部分右边\nR-squared：R方，判定系数，01间越大越吻合，计算方法为SSR/SST，残差（sse）为0. Adj . R-squared：调整后的R方，利用奥卡姆剃刀修正后的R-squared值 （奥卡姆剃刀是一种理论，认为通用的模型倾向于更简单的参数，正所谓大道至简） F-statistic：F统计量，均方误差/残差的均方误差。值越大, H 0​ 越不可能，从而回归系数显著. F检验，这个值越大越能推翻原假设，值越大说明模型是线性模型，原假设是“我们的模型不是线性模型”。f检验（F-test）， 最常用的别名叫做联合假设检验（英语：joint hypotheses test），此外也称方差比率检验、方差齐性检验。 它是一种在零假设之下，统计值服从F-分布的检验。其通常是用来分析用了超过一个参数的统计模型， 以判断该模型中的全部或一部分参数是否适合用来估计母体。 Prob（F-statistic）：当 prob(F−statistic)\u0026lt;α时，表示拒绝原假设，即认为模型是显著的， 为F-statistic的概率，值越小越能拒绝原假设。 Log likelihood ：对数似然比LLR。值越大，模型拟合得越好。 （Davidson 与MacKinnon年说：对于线性回归模型，不管它误差是不是正态分布， 都不需要过问LM，W，LLR，因为这些信息已被F检验所含有） AIC: AIC=2k−2ln(L)。其中：k是参数的数量，L是似然函数。 它衡量拟合优良性,应选择AIC最小的模型,引入了惩罚项,避免参数过多,过拟合. BIC: 贝叶斯信息准则BIC=kln(n)−2ln(L) ,BIC相比AIC在大数据量时对模型参数惩罚得更多， 导致BIC更倾向于选择参数少的简单模型。  第二部分\nintercept：常数 coef：各自变量的估计系数 std err：系数估计的标准差 t : 衡量显著性的指标，就是我们常用的t统计量，这个值越大越能拒绝原假设。 P\u0026gt;|t|，H0​（系数=0）为真的概率。统计检验中的P值，这个值越小越能拒绝原假设。 [0.025,0.975]: 95％置信区间的下限和上限值  第三部分\nOmnibus :基于峰度和偏度进行数据正态性的检验，通常与Jarque-Bera检验共同使用 属于一种统计测验,测试一组数据中已解释方差是否显著大于未解释方差, 但omnibus不显著,模型也可能存在合法的显著影响, 比如两个变量中有一个不显著, 即便另一个显著.通常用于对比 Prob(Omnibus):将上面的统计数据变成概率 Skewness: 偏度 Kurtosis:峰度 Durbin-Watson:德宾-沃森检验（检验残差自相关最常用的方法），它用于检验一阶自相关性。 自相关系数 − 1 \u0026lt; ρ \u0026lt; 1 ⇒ 0 ≤ D W ≤ 4 -1\u0026lt;ρ\u0026lt;1\\Rightarrow0≤DW≤4 −1\u0026lt;ρ\u0026lt;1⇒0≤DW≤4 并且 D W ＝ 0 ⇔ ρ ＝ １ DW＝0 \\Leftrightarrow ρ＝１ DW＝0⇔ρ＝１　即存在正自相关性 D W ＝ ４ ⇔ ρ ＝ － １ DW＝４\\Leftrightarrow ρ＝－１ DW＝４⇔ρ＝－１即存在负自相关性 D W ＝ ２ ⇔ ρ ＝ ０ DW＝２\\Leftrightarrow ρ＝０ DW＝２⇔ρ＝０　即不存在（一阶）自相关性 Jarque-Bera(JB) :同样是基于峰度和偏度进行数据正态性的检验， 通常与Omnibus检验共同使用， Jarque–Bera检验。如果统计量≫0，则表示数据不是正态分布。 Prob(JB): JB统计量的概率形式 Cond. No :条件数。用于诊断多重共线性  一元线性回归模型 import numpy as np import statsmodels.api as sm import pylab as plt def check(d): x0 = d[0]; y0 = d[1]; d ={\u0026#39;x\u0026#39;:x0, \u0026#39;y\u0026#39;:y0} re = sm.formula.ols(\u0026#39;y~x\u0026#39;, d).fit() #拟合线性回归模型 print(re.summary()) print(re.outlier_test()) #输出已知数据的野值检验 print(\u0026#39;残差的方差\u0026#39;, re.mse_resid) pre=re.get_prediction(d) df = pre.summary_frame(alpha=0.05) dfv = df.values; low, upp = dfv[:,4:].T #置信下限上限 r = (upp-low)/2 #置信半径 num = np.arange(1, len(x0)+1) plt.errorbar(num, re.resid, r, fmt=\u0026#39;o\u0026#39;) plt.show() a = np.loadtxt(\u0026#39;data10_1.txt\u0026#39;) plt.rc(\u0026#39;font\u0026#39;, size=15); plt.plot(a[0], a[1], \u0026#39;o\u0026#39;) plt.figure(); check(a) a2 = a; a2 = np.delete(a2, 8, axis=1) #删除第9列 check(a2); a3 = a2 a3 = np.delete(a3, 4, axis=1); check(a3) 注意几个比较重要的值：R方，F，P，s方（残差的方差）\n多元线性回归 一种使用公式构建，一种使用数组构建。\nplot是制图\nfit是利用极大似然估计进行估计未知参数\nppf反函数\npdf概率密度函数\nimport numpy as np import statsmodels.api as sm import pylab as plt a = np.loadtxt(\u0026#39;data10_2.txt\u0026#39;) plt.rc(\u0026#39;text\u0026#39;, usetex=True); plt.rc(\u0026#39;font\u0026#39;, size=16) plt.plot(a[0], a[2], \u0026#39;*\u0026#39;, label=\u0026#39;$x_1$\u0026#39;) plt.plot(a[1], a[2], \u0026#39;o\u0026#39;, label=\u0026#39;$x_2$\u0026#39;) plt.legend(loc=\u0026#39;upper left\u0026#39;) d = {\u0026#39;x1\u0026#39;: a[0], \u0026#39;x2\u0026#39;: a[1], \u0026#39;y\u0026#39;: a[2]} re = sm.formula.ols(\u0026#39;y~x1+x2\u0026#39;, d).fit() print(re.summary()) yh = re.predict({\u0026#39;x1\u0026#39;: [9, 10], \u0026#39;x2\u0026#39;: [10, 9]}) print(\u0026#39;残差的方差:\u0026#39;, re.mse_resid) print(\u0026#39;预测值：\u0026#39;, yh); plt.show() import numpy as np import statsmodels.api as sm import pylab as plt a = np.loadtxt(\u0026#39;data10_2.txt\u0026#39;) plt.rc(\u0026#39;text\u0026#39;, usetex=True); plt.rc(\u0026#39;font\u0026#39;, size=16) plt.plot(a[0], a[2], \u0026#39;*\u0026#39;, label=\u0026#39;$x_1$\u0026#39;) plt.plot(a[1], a[2], \u0026#39;o\u0026#39;, label=\u0026#39;$x_2$\u0026#39;) plt.legend(loc=\u0026#39;upper left\u0026#39;) X = sm.add_constant(a[:2].T) re = sm.OLS(a[2], X).fit() print(re.summary()) yh = re.predict(np.array([[1,9,10],[1,10,9]])) print(\u0026#39;残差的方差:\u0026#39;, re.mse_resid) print(\u0026#39;预测值：\u0026#39;, yh); plt.show() 多项式回归和逐步回归 看图判定几次函数拟合比较好。\n#程序文件ex10_4.py import numpy as np import statsmodels.formula.api as smf import pylab as plt a = np.loadtxt(\u0026#39;data10_4.txt\u0026#39;); x1 = a[0]; x2 = a[1]; y = a[2] plt.rc(\u0026#39;text\u0026#39;, usetex=True); plt.rc(\u0026#39;font\u0026#39;, size=16) plt.plot(x1, y, \u0026#39;*\u0026#39;, label=\u0026#39;$x_1$\u0026#39;); plt.plot(x2, y, \u0026#39;o\u0026#39;, label=\u0026#39;$x_2$\u0026#39;) d = {\u0026#39;y\u0026#39;: y, \u0026#39;x1\u0026#39;: x1, \u0026#39;x2\u0026#39;: x2} re1 = smf.ols(\u0026#39;y~x1+x2\u0026#39;, d).fit() print(\u0026#39;线性回归的残差方差：\u0026#39;, re1.mse_resid) re2 = smf.ols(\u0026#39;y~x1+x2+I(x1**2)+I(x2**2)\u0026#39;, d).fit() #这里注意写法，\u0026#39;是括起来的，最后有一个d print(\u0026#39;纯二次的残差方差：\u0026#39;, re2.mse_resid) re3 = smf.ols(\u0026#39;y~x1*x2\u0026#39;, d).fit() print(\u0026#39;交叉的残差方差：\u0026#39;, re3.mse_resid) re4 = smf.ols(\u0026#39;y~x1*x2+I(x1**2)+I(x2**2)\u0026#39;, d).fit() print(\u0026#39;完全二次的残差方差：\u0026#39;, re4.mse_resid) print(\u0026#39;预测值：\u0026#39;, re2.predict({\u0026#39;x1\u0026#39;: 170, \u0026#39;x2\u0026#39;: 160})) print(re2.summary()); plt.legend(); plt.show() re2 = smf.ols(\u0026#39;y~x1+x2+I(x1 **2) +I(x2 * *2)\u0026#39;, d).fit() 这里注意写法，\u0026lsquo;是括起来的，最后有一个d\n这个模型寻求残差最小的值。\n#程序文件ex10_5.py import numpy as np import pandas as pd from scipy.stats import t, f import statsmodels.api as sm a = pd.read_excel(\u0026#39;data10_5.xlsx\u0026#39;, header=None) b = a.values; Y=np.hstack([b[:,1],b[:-1,6]]) X = np.vstack([b[:,2:5],b[:-1,7:]]) XX = np.hstack([np.ones((25,1)),X]) cs = np.linalg.pinv(XX) @ Y #最小二乘法拟合参数 print(\u0026#39;拟合的参数为：\u0026#39;, np.round(cs,4)) yb = Y.mean() #计算y的观测值的平均值 yh = XX @ cs #计算y的估计值 q = sum((yh-Y)**2) #计算残差平方和 u = sum((yh-yb)**2) #计算回归平方和 m =3; n = len(Y) #变量个数和样本容量 F = u/m/(q/(n-m-1)) #计算F统计量的值 print(\u0026#39;F=\u0026#39;, round(F,4)) fw = f.ppf(0.95, m, n-m-1) #计算上alpha分位数 print(\u0026#39;F分布的上alpha分位数：\u0026#39;, round(fw,4)) c = np.diag(np.linalg.inv(XX.T @ XX)) ts = cs/np.sqrt(c)/np.sqrt(q/(n-m-1)) #计算t统计量的值 tw = t.ppf(0.975, n-m-1) #计算上alpha/2分位数 print(\u0026#39;t统计量值为：\u0026#39;, np.round(ts,4)) print(\u0026#39;t分布的上alpha/2分位数：\u0026#39;, round(tw,4)) XD = np.delete(XX,1,axis=1) #删除x1的观测值 cs2 = np.linalg.pinv(XD) @ Y #重新拟合参数 print(\u0026#39;x2,x3模型的参数值：\u0026#39;,np.round(cs2,4)) d = {\u0026#39;y\u0026#39;:Y,\u0026#39;x1\u0026#39;:X[:,0],\u0026#39;x2\u0026#39;:X[:,1],\u0026#39;x3\u0026#39;:X[:,2]} md = sm.formula.ols(\u0026#39;y~x1*x2+x1*x3+x2*x3+I(x1**2)+I(x2**2)+I(x3**2)\u0026#39;,d).fit() print(\u0026#39;完全二次项的系数为：\u0026#39;, md.params) 上下和左右合并矩阵的方法。\n左取右不取。\n矩阵有一行是是空的，所以切片要-1。\n#程序文件ex10_6.py import numpy as np import statsmodels.api as sm a = np.loadtxt(\u0026#39;data10_6.txt\u0026#39;) d = {\u0026#39;x1\u0026#39;:a[:,0], \u0026#39;x2\u0026#39;:a[:,1], \u0026#39;x3\u0026#39;:a[:,2], \u0026#39;x4\u0026#39;:a[:,3], \u0026#39;y\u0026#39;:a[:,4]} md1 = sm.formula.ols(\u0026#39;y~x1+x2+x3+x4\u0026#39;,d).fit() print(md1.tvalues) #下面删除变量的t值绝对值最小的 md2 = sm.formula.ols(\u0026#39;y~x1+x2+x4\u0026#39;,d).fit() print(md2.tvalues) #下面删除变量的t值绝对值最小的 md3 = sm.formula.ols(\u0026#39;y~x1+x2\u0026#39;, d).fit() print(md3.summary()) print(\u0026#39;残差方差：\u0026#39;, md3.mse_resid) 每次舍去一个。\n广义线性回归模型 分组的logistic回归模型 处理01型因变量产生的问题。回归函数改为分布在01区间。\n可以使用Yi等于1的比例来代替yi本身作为因变量（yi只可以为0或1）\n分组的适用于样本量大的数据，样本小的不宜分组。\n可以使用ols或glm\n未分组的logistic回归模型 #程序文件ex10_8_1.py import numpy as np import statsmodels.api as sm a = np.loadtxt(\u0026#39;data10_8.txt\u0026#39;) x = np.vstack([a[:, 1:4], a[:, 6:-1]]) y = np.hstack([a[:, 4], a[:, 9]]) d={\u0026#39;x1\u0026#39;: x[:,0], \u0026#39;x2\u0026#39;:x[:,1], \u0026#39;x3\u0026#39;:x[:,2], \u0026#39;y\u0026#39;:y} md = sm.formula.logit(\u0026#39;y~x1+x2+x3\u0026#39;, d).fit() print(md.summary()) md2 = sm.formula.logit(\u0026#39;y~x1+x3\u0026#39;, d).fit() print(md2.summary()) 或使用glm函数\n#程序文件ex10_8_2.py import numpy as np import statsmodels.api as sm a = np.loadtxt(\u0026#39;data10_8.txt\u0026#39;) x = np.vstack([a[:, 1:4], a[:, 6:-1]]) y = np.hstack([a[:, 4], a[:, 9]]) d={\u0026#39;x1\u0026#39;: x[:,0], \u0026#39;x2\u0026#39;:x[:,1], \u0026#39;x3\u0026#39;:x[:,2], \u0026#39;y\u0026#39;:y} md1 = sm.formula.glm(\u0026#39;y~x1+x2+x3\u0026#39;, d, family=sm.families.Binomial()).fit() print(md1.summary()) md2 = sm.formula.glm(\u0026#39;y~x1+x3\u0026#39;, d, family=sm.families.Binomial()).fit() print(md2.summary()) probit回归模型 使用到了分布函数的反函数,ppf\n#程序文件ex10_9.py import numpy as np import statsmodels.api as sm from scipy.stats import norm a = np.loadtxt(\u0026#34;data10_7_1.txt\u0026#34;) x = a[:,0]; pi = a[:,2]/a[:,1]; yi = norm.ppf(pi) X = sm.add_constant(x) md = sm.OLS(yi, X).fit() #构建并拟合模型 print(md.summary()) #输出模型的所有结果 p0= norm.cdf(md.predict([1, 9])) print(\u0026#34;所求比例p0=%.4f\u0026#34;%p0) 偏最小二乘回归 多个因变量和自变量\n 数据标准化 求得相关系数矩阵 分别提出自变量组和因变量组的成分 求回归方程 模型的解释和检验，交叉有效性检验  建议的成分个数，使均方差最小。\n#程序文件ex13_2.py import numpy as np from sklearn.cross_decomposition import PLSRegression from scipy.stats import zscore from sklearn.model_selection import cross_val_predict from sklearn.metrics import mean_squared_error d0 = np.loadtxt(\u0026#39;data13_2.txt\u0026#39;) mu = d0.mean(axis=0) #求均值 s =d0.std(axis=0, ddof=1) #求标准差 r = np.corrcoef(d0.T) #求相关系数矩阵 d = zscore(d0, ddof=1) #数据标准化 a = d[:, :7]; b = d[:, 7:] n = a.shape[1]; m = b.shape[1] #自变量和因变量个数 mse = [] #均方误差初始化 for i in range(1, n+1): #以下确定成分的个数 pls = PLSRegression(i) y_cv = cross_val_predict(pls, a, b) mse.append(mean_squared_error(b, y_cv)) nmin = np.argmin(mse); print(\u0026#39;均方误差：\\n\u0026#39;, mse) print(\u0026#39;建议的成分个数: \u0026#39;, nmin+1) md = PLSRegression(2).fit(a, b) b = md.coef_ #每一列是y对x的回归系数 print(\u0026#39;标准化数据的回归系数(列)：\\n\u0026#39;, b) b0 = np.zeros((n+1, m)) b0[0, :] = mu[n:] - mu[:n]/s[:n] @ b * s[n:] for i in range(m): b0[1:, i] = s[n+i]/s[:n] * b[:,i] print(\u0026#39;(原始数据)y关于x回归系数(列):\\n\u0026#39;, b0) ","permalink":"https://tassel234.github.io/posts/note/python%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AE%97%E6%B3%95-2%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90/","summary":"参考资源 python数学建模算法与应用 https://blog.csdn.net/weixin_35757704/article/details/117808073 https://blog.csdn.net/chuididehuayiren/article/details/109765279 图表解释 第一部分左边 Dep. Variable:即dependent variable，因变量 OLS:普通最小二乘法 least squares：最小化残差平方和 No. Observations:个案数，即样本容量 df residuals：残差自由度(观测数No.Obs","title":"Python数学建模算法-2（回归分析）"},{"content":"python数模算法-1（库的基本使用和绘图基础） 前言 使用学习资源 python数学建模算法与应用（司守奎） 比较全面的建模算法视频（编程语言是matlab）\n目标指向 只需要会看那些代码并运行实现一次代码和理解用途就可以了，需要使用的时候查阅复制粘贴就可以了。\n算法具体实现的逻辑步骤要搞清楚，锻炼一些编程思想，可以对程序进行合理的修改。\n编程环境配置 conda-python3.10.9\nlatex（可无）\n库的使用 numpy对数组 数组生成\nimport numpy as np a1 = np.array([1, 2, 3, 4]) #生成整型数组 a2 = a1.astype(float) a3 = np.array([1, 2, 3, 4], dtype=float) #浮点数 print(a1.dtype); print(a2.dtype); print(a3.dtype) b = np.array([[1, 2, 3], [4, 5, 6]]) c = np.arange(1,5) #生成数组[1, 2, 3, 4] d = np.linspace(1, 4, 4) #前面是范围，后面是分割数，生成数组[1, 2, 3, 4] e = np.logspace(1, 3, 3, base=2) #生成等比数列数组[2, 4, 8] import numpy as np a = np.ones(4, dtype=int) #输出[1, 1, 1, 1] b = np.ones((4,), dtype=int) #逗号加在前面会报错，输出同a c= np.ones((4,1)) #输出4行1列的数组 d = np.zeros(4) #输出[0, 0, 0, 0] e = np.empty(3) #生成3个元素的空数组行向量 f = np.eye(3) #生成3阶单位阵 g = np.eye(3, k=-1) #主对角线是0，生成第k对角线的元素为1，其他元素为0的3阶方阵 h = np.zeros_like(a) #生成与a同维数的全0数组 print(g) print(c) 数组元素的索引\nimport numpy as np a = np.arange(16).reshape(4,4) #生成4行4列的数组 b = a[1][2] #输出6 c = a[1, 2] #同b d = a[1:2, 2:3] #输出[[6]] x = np.array([0, 1, 2, 1]) print(a[x==1]) #输出a的第2、4行元素 print(a) numpy对矩阵 矩阵的合并 np.vstack([a, b]) #上下合并矩阵 np.hstack([a, c]) #左右合并矩阵\n矩阵的分割 b = np.vsplit(a, 2) #行分割 c = np.hsplit(a, 4) #列分割\n矩阵的乘法\n使用符号@，前面的相当于行向量\n范数计算\nimport numpy as np a = np.array([[0, 3, 4], [1, 6, 4]]) b = np.linalg.norm(a, axis=1) #求行向量2范数 c = np.linalg.norm(a, axis=0) #求列向量2范数 d = np.linalg.norm(a) #求矩阵2范数 print(\u0026#39;行向量2范数为：\u0026#39;, np.round(b, 4)) print(\u0026#39;列向量2范数为：\u0026#39;, np.round(c, 4)) print(\u0026#39;矩阵2范数为：\u0026#39;, round(d, 4)) 求线性方程的唯一解\nimport numpy as np a = np.array([[3, 1], [1, 2]]) b = np.array([9, 8]) x1 = np.linalg.inv(a) @ b #第一种解法 #上面语句中@表示矩阵乘法 x2 = np.linalg.solve(a, b) #第二种解法 print(x1); print(x2) 求超定线性方程组的唯一解\nimport numpy as np a = np.array([[3, 1], [1, 2], [1, 1]]) b = np.array([9, 8, 6]) x = np.linalg.pinv(a) @ b print(np.round(x, 4)) 特征值和特征向量\nimport numpy as np a = np.eye(4) b = np.rot90(a) #好像代表转 c, d = np.linalg.eig(b) print(\u0026#39;特征值为：\u0026#39;, c) print(\u0026#39;特征向量为：\\n\u0026#39;, d) pandas 生成二维数组\nimport pandas as pd import numpy as np dates=pd.date_range(start=\u0026#39;20191101\u0026#39;,end=\u0026#39;20191124\u0026#39;,freq=\u0026#39;D\u0026#39;) a1=pd.DataFrame(np.random.randn(24,4), index=dates, columns=list(\u0026#39;ABCD\u0026#39;)) a2=pd.DataFrame(np.random.rand(24,4)) 读写文件\nimport pandas as pd import numpy as np dates=pd.date_range(start=\u0026#39;20191101\u0026#39;, end=\u0026#39;20191124\u0026#39;, freq=\u0026#39;D\u0026#39;) a1=pd.DataFrame(np.random.randn(24,4), index=dates, columns=list(\u0026#39;ABCD\u0026#39;)) a2=pd.DataFrame(np.random.randn(24,4)) a1.to_excel(\u0026#39;data2_38_1.xlsx\u0026#39;) #可以修改此行让其不带索引 a2.to_csv(\u0026#39;data2_38_2.csv\u0026#39;) f=pd.ExcelWriter(\u0026#39;data2_38_3.xlsx\u0026#39;) #创建文件对象 a1.to_excel(f,\u0026#34;Sheet1\u0026#34;) #把a1写入Excel文件 a2.to_excel(f,\u0026#34;Sheet2\u0026#34;) #把a2写入另一个表单中 f.save() 数据预处理\nimport pandas as pd import numpy as np d=pd.DataFrame(np.random.randint(1,6,(10,4)), columns=list(\u0026#34;ABCD\u0026#34;)) d1=d[:4] #获取前4行数据 d2=d[4:] #获取第5行以后的数据 dd=pd.concat([d1,d2]) #数据行合并 s1=d.groupby(\u0026#39;A\u0026#39;).mean() #数据分组求均值 s2=d.groupby(\u0026#39;A\u0026#39;).apply(sum) #数据分组求和 import pandas as pd import numpy as np a = pd.DataFrame(np.random.randint(1,6,(5,3)), index=[\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;], columns=[\u0026#39;one\u0026#39;, \u0026#39;two\u0026#39;, \u0026#39;three\u0026#39;]) a.loc[\u0026#39;a\u0026#39;, \u0026#39;one\u0026#39;] = np.nan #修改第1行第1列的数据 b = a.iloc[1:3, 0:2].values #提取第2、3行，第1、2列数据 a[\u0026#39;four\u0026#39;] = \u0026#39;bar\u0026#39; #增加第4列数据 a2 = a.reindex([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;]) a3 = a2.dropna() #删除有不确定值的行 scipy 求解非线性方程\nfrom scipy.optimize import fsolve, root fx = lambda x: x**980-5.01*x**979+7.398*x**978\\ -3.388*x**977-x**3+5.01*x**2-7.398*x+3.388 x1 = fsolve(fx, 1.5, maxfev=4000) #函数调用4000次 x2 = root(fx, 1.5) print(x1,\u0026#39;\\n\u0026#39;,\u0026#39;-------------\u0026#39;); print(x2) 最小二乘法\nfrom scipy.optimize import least_squares import numpy as np a=np.loadtxt(\u0026#39;data2_47.txt\u0026#39;) x0=a[0]; y0=a[1]; d=a[2] fx=lambda x: np.sqrt((x0-x[0])**2+(y0-x[1])**2)-d s=least_squares(fx, np.random.rand(2)) print(s, \u0026#39;\\n\u0026#39;, \u0026#39;------------\u0026#39;, \u0026#39;\\n\u0026#39;, s.x) 求最大模特征值和对应的特征向量\nfrom scipy.sparse.linalg import eigs import numpy as np a = np.array([[1, 2, 3], [2, 1, 3], [3, 3, 6]], dtype=float) #必须加float,否则出错 b, c = np.linalg.eig(a) d, e = eigs(a, 1) print(\u0026#39;最大模特征值为：\u0026#39;, d) print(\u0026#39;对应的特征向量为：\\n\u0026#39;, e) 此外，还可以求解积分，傅里叶变换，插值，信号处理等。\nsympy 可以用计算机推导表达式，可以对符号运算。\nimport sympy as sp a, b, c, x=sp.symbols(\u0026#39;a,b,c,x\u0026#39;) x0=sp.solve(a*x**2+b*x+c, x) print(x0) import sympy as sp sp.var(\u0026#39;x1,x2\u0026#39;) s=sp.solve([x1**2+x2**2-1,x1-x2],[x1,x2]) print(s) import numpy as np import sympy as sp a = np.identity(4) #单位矩阵的另一种写法 b = np.rot90(a) c = sp.Matrix(b) print(\u0026#39;特征值为：\u0026#39;, c.eigenvals()) print(\u0026#39;特征向量为：\\n\u0026#39;, c.eigenvects()) matplotlib绘图介绍 二维绘图 绘制折线图\nimport pandas as pd import pylab as plt plt.rc(\u0026#39;font\u0026#39;,family=\u0026#39;SimHei\u0026#39;) #用来正常显示中文标签，还有一个正常显示符号的语句 plt.rc(\u0026#39;font\u0026#39;,size=16) #设置显示字体大小 a=pd.read_excel(\u0026#34;data2_52.xlsx\u0026#34;, header=None) #和py文件保存在同一级目录 b=a.values #提取其中的数据 x=b[0]; y=b[1:] plt.plot(x,y[0],\u0026#39;-*b\u0026#39;,label=\u0026#39;铂金\u0026#39;) plt.plot(x,y[1],\u0026#39;--dr\u0026#39;,label=\u0026#39;铂金\u0026#39;) plt.xlabel(\u0026#39;月份\u0026#39;); plt.ylabel(\u0026#39;每月销量\u0026#39;) plt.legend(loc=\u0026#39;upper left\u0026#39;); plt.grid(); plt.show() ()使用pandas的Dateframe绘图 绘制柱状图\nimport pandas as pd import pylab as plt plt.rc(\u0026#39;font\u0026#39;,family=\u0026#39;SimHei\u0026#39;) #用来正常显示中文标签 plt.rc(\u0026#39;font\u0026#39;,size=16) #设置显示字体大小 a=pd.read_excel(\u0026#34;data2_52.xlsx\u0026#34;,header=None) b=a.T; b.plot(kind=\u0026#39;bar\u0026#39;); plt.legend([\u0026#39;钻石\u0026#39;, \u0026#39;铂金\u0026#39;]) plt.xticks(range(6), b[0], rotation=0); plt.show() 子图\nimport pylab as plt import numpy as np plt.rc(\u0026#39;text\u0026#39;, usetex=True) #调用tex字库 y1=np.random.randint(2, 5, 6); y1=y1/sum(y1); plt.subplot(2, 2, 1); str=[\u0026#39;Apple\u0026#39;, \u0026#39;grape\u0026#39;, \u0026#39;peach\u0026#39;, \u0026#39;pear\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;pineapple\u0026#39;] plt.barh(str,y1) #水平条形图 plt.subplot(222); plt.pie(y1, labels=str) #饼图 plt.subplot(212) x2=np.linspace(0.01, 10, 100); y2=np.sin(10*x2)/x2 plt.plot(x2,y2); plt.xlabel(\u0026#39;$x$\u0026#39;) plt.ylabel(\u0026#39;$\\\\mathrm{sin}(50x)/x$\u0026#39;); plt.show()#latex表示数学公式 linspace(a,b,c)表示的是把a-b平均分成c分, 三维绘图 三维曲线\nimport pylab as plt import numpy as np ax=plt.axes(projection=\u0026#39;3d\u0026#39;) #设置三维图形模式 z=np.linspace(-50, 50, 1000) x=z**2*np.sin(z); y=z**2*np.cos(z) plt.plot(x, y, z, \u0026#39;k\u0026#39;); plt.show() 三维表面图\nimport pylab as plt import numpy as np x=np.linspace(-4,4,100); x,y=np.meshgrid(x,x) z=50*np.sin(x+y); ax=plt.axes(projection=\u0026#39;3d\u0026#39;) ax.plot_surface(x, y, z, color=\u0026#39;y\u0026#39;) plt.show() import pylab as plt import numpy as np ax=plt.axes(projection=\u0026#39;3d\u0026#39;) X = np.arange(-6, 6, 0.25) Y = np.arange(-6, 6, 0.25) X, Y = np.meshgrid(X, Y) Z = np.sin(np.sqrt(X**2 + Y**2)) surf = ax.plot_surface(X, Y, Z, cmap=\u0026#39;coolwarm\u0026#39;) plt.colorbar(surf); plt.show() 概率统计模型专题绘图 直方图 也称频数图\nimport pandas as pd import pylab as plt df = pd.read_csv(\u0026#39;data9_5.txt\u0026#39;, header=None) df = df.T #转置 plt.subplot(121); h1 = plt.hist(df[0], 5); print(h1) plt.subplot(122); plt.hist(df[1], 5) df.hist(bins=5) #另一种方法画直方图 plt.show() 箱线图\n几个点分别是最小值，1/4值，中位数，3/4点，最大值。 用来观察离散程度。\nimport pandas as pd import pylab as plt df = pd.read_csv(\u0026#39;data9_5.txt\u0026#39;, header=None).T plt.rc(\u0026#39;font\u0026#39;, family=\u0026#39;SimHei\u0026#39;); plt.rc(\u0026#39;font\u0026#39;, size=16); plt.boxplot(df, labels=[\u0026#39;甲班\u0026#39;, \u0026#39;乙班\u0026#39;]); plt.show() QQ图\n可以检验拟合优度。同时不建议直接使用库函数绘制QQ图\nimport pandas as pd import pylab as plt from scipy.stats import norm, probplot df = pd.read_csv(\u0026#39;data9_5.txt\u0026#39;, header=None) d = df.values[0] #提取甲班成绩 mu = d.mean(); s = d.std(); sd = sorted(d); n = len(d) x = (plt.arange(n)+1/2)/n; yi = norm.ppf(x, mu, s) plt.rc(\u0026#39;font\u0026#39;, size=16); plt.rc(\u0026#39;font\u0026#39;, family=\u0026#39;SimHei\u0026#39;) plt.rc(\u0026#39;axes\u0026#39;, unicode_minus=False) plt.subplot(121); plt.plot(yi, sd, \u0026#39;o\u0026#39;, label=\u0026#39;QQ图\u0026#39;) plt.plot(sd, sd, label=\u0026#39;参照直线\u0026#39;); plt.legend() plt.subplot(122); probplot(d, plot=plt); plt.show() ","permalink":"https://tassel234.github.io/posts/note/python%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AE%97%E6%B3%95-1%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%92%8C%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80/","summary":"python数模算法-1（库的基本使用和绘图基础） 前言 使用学习资源 python数学建模算法与应用（司守奎） 比较全面的建模算法视频（编程语言是matlab） 目标指向 只需要会看那些代码并运行实现一次代码和理解用途就可以了，需要使用的时候查阅复制粘贴就可以了。 算法具体实现的逻辑步骤要搞","title":"Python数学建模算法-1（库的基本使用和绘图基础）"},{"content":"github和git的基础知识（可跳过不看）  Github 代码上边的Raw、Blame是什么意思？\n  Raw：文件内容。 blame：按行显示最新提交的信息。\n Pin，该词可被译为：钉住、按住。被Pin的仓库会显示在个人主页中，类似于仓库置顶。 Watch，默认是Unwatch，如果你想关注某个仓库，当这个库有新的通知时就会提醒你。 star,表示喜爱。\nFork代表从别人的代码仓库中复制一份到自己的代码库，包含了别人库中的提交历史记录。经过fork后的代码库是完全独立的，由自己维护，可以进行任何魔改。改完之后自己可以通过Pull Request向原来的库提交合并请求。 1. Fork别人的仓库：复制别人仓库（代码、文件、提交历史记录、issue等），复制后的仓库在自己的github账号中存着。 2. Clone远程仓库：将这个复制后的远程仓库克隆到本地。 3. 在工作区对代码进行CRUD操作（增删改查） 4. 将代码的更改提交暂存区（git add .） 5. 将暂存区的文件提交到本地仓库（git commit -m \u0026lsquo;小修一下\u0026rsquo;） 6. 将本地仓库的代码推送到远程仓库（git push） 7. 给别人的仓库发送Pull Request：如果原作者认为你的修改版本不错，就会将你代码中的修改合并到自己的库中。\n可以在写编写markdown文件于github网站\nGit是一款分布式源代码管理工具(版本控制工具) ，可以对我们写的代码进行托管和版本记录（每上传一次形成一个版本，可以找回）。github和git的关系非常紧密，hub在百度翻译有如下解释：\n n. 轮毂; (某地或活动的)中心; [例句]The island\u0026rsquo;s social hub is the Cafe Sport 该岛的社交中心是“体育咖啡馆”。 可以理解为github以git为传输路径，把程序员上传过的代码集中,迭代，存放在github的仓库中，方便和其他程序员的合作或交流。\n git的进一步学习\n前言 本文介绍如何使用Github+Hugo+PaperMod主题搭建一个人博客。\n此文章也记录了我搭建博客较为详细的步骤和一些在博客搭建过程中出现的问题和解决方案。\n参考资料 23年的hugo博客搭建视频\nsulv的博客\n333rd的博客\nrosefinch-midsummer的博客\n前置工作 需要一个github账号,可以在网页打开github,推荐使用fastgithub软件，翻墙也行。\n下载hugo,推荐安装比较原始的版本，后面会解释为什么。\n下载地址\n下载和安装git，见视频\n安装github desktop，使用该软件可以从本地库克隆到github仓库，并可以完成较为方便的上传更新。\n安装fastgithub，可以获得非常快的github访问速度，而且不用翻墙。\n下载fastgithub\n搭建博客  先下载好hugo,推荐下载hugo v0.85.0版本，之前我下载了最新版本，死活不能把配置文件改成yaml格式，也就没办法直接调用别人写好的漂亮的网站结构。接下来的文字是对视频的总结，更直观的步骤请查阅hugo博客搭建视频 把下载好后把hugo.exe所在的文件夹地址放置在环境变量的系统变量中。 在cmd窗口输入hugo version查看版本和确认安装成功。  生成新站点，hugo new site \u0026lt;想要存储到的位置\u0026gt;/\u0026lt;站点名字\u0026gt; -f yml ， 实例hugo new site D:/path/to/newst -f yml ，  -f yml是把toml文件格式改成yaml格式，最新版这个指令修改不了配置文件（config）格式。\n然后就可以在文件夹找到生成的站点   在路径栏目输入cmd,打开，\n  输入hugo new posts/tech/文章名称.md生成第一篇博客文章。应该在tech目录下写一个_index.md文件用于索引。\n  安装主题，使用命令行git clone https://github.com/adityatelange/hugo-PaperMod.git\n  下载最新版本，实际上后面cmd提示hugo版本和papermod版本不完全匹配，但最后还是可以生成不错的博客页面，然后对config.yaml进行重写，赋值代码和粘贴config.yml此外写入的md文本应该在github复制最新版，旧版会报错。\n写好了开始生成静态页面，站点目录的cmd输入hugo version在本地查看\n 站点目录的cmd输入hugo生成文件夹public\n  在public的文件夹的cmd进行git 导入，输入git init,一个文件夹导入一次就够了\n  博客上传 配置FastGithub(可以跳过不看) 双击打开FastGithub.UI.exe应用程序,程序会在后台运行。\nfirefox提示连接有潜在的安全问题 设置-\u0026gt;隐私与安全-\u0026gt;证书-\u0026gt;查看证书-\u0026gt;证书颁发机构，导入cacert/fastgithub.cer，勾选“信任由此证书颁发机构来标识网站”\n安全性说明\nFastGithub为每台不同的主机生成自颁发CA证书，保存在cacert文件夹下。客户端设备需要安装和无条件信任自颁发的CA证书，请不要将证书私钥泄露给他人，以免造成损失。\n合法性说明\n《国际联网暂行规定》第六条规定：“计算机信息网络直接进行国际联网，必须使用邮电部国家公用电信网提供的国际出入口信道。任何单位和个人不得自行建立或者使用其他信道进行国际联网。” FastGithub本地代理使用的都是“公用电信网提供的国际出入口信道”，从国外Github服务器到国内用户电脑上FastGithub程序的流量，使用的是正常流量通道，其间未对流量进行任何额外加密（仅有网页原有的TLS加密，区别于VPN的流量加密），而FastGithub获取到网页数据之后发生的整个代理过程完全在国内，不再适用国际互联网相关之规定。\n通过git和github desktop将博客上传到github 输入上述两串代码，然后在github desktop进行上传，浏览器的github就可以更新了。\n上传点击fetch origin按钮.\n网页显示 在GitHub网页端，点击hugo博客代码存放库，点击settings,点击pages,修改Branch的none为master,等待一会，就可以生成网页了。\n更新 hugo -F \u0026ndash;cleanDestinationDir完成public文件夹的更新, 然后再重复上传步骤即可.\n添加图片 笔者使用的是vnote，记markdown笔记。 图片引用代码如下： ![](vx_images/ex.png =481x)\n首先应该在static文件夹下创建vx_images文件夹，再把要用的图片导入，但有两个问题。\n 不能加图片大小，也就是把 =481x去掉 前面应该加一个/  如何改进博客 创建拥有美观界面的博客 sulv大佬已经写好了一个优美的yaml配置文件,我们只需要复制粘贴到config配置文件就可以了。 但博客网页的yaml代码不能成功执行，因为sulv的博客和333rd的博客的博客都是创作于几年前，hugo和papermod的版本更新导致了各种问题，所以应该直接在github中复制，config.yml\n至于配置头像，联系方式等，也请参照上面两个博客。\n改进指南 插件\n建站\n统计部署\n为什么要写博客  通过强迫自己记笔记，对知识进行整理，对日常和灵感进行记录 可以促进知识的输出，检验自己的掌握程度，类似费曼学习法 博客本身可以促进学习，并且有助于和别人交流自己的想法  ","permalink":"https://tassel234.github.io/posts/tech/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","summary":"github和git的基础知识（可跳过不看） Github 代码上边的Raw、Blame是什么意思？ Raw：文件内容。 blame：按行显示最新提交的信息。 Pin，该词可被译为：钉住、按住。被Pin的仓库会显示在个人主页中，类似于仓库置顶。 Watch，默认是Unwatch，如果你想关注某个仓库，","title":"Hugo搭建个人博客"},{"content":"故事梗概 《外婆的道歉信》是瑞典作家弗雷德里克·巴克曼创作的一部长篇小说，讲述了一个关于爱，原谅与守护的温馨故事。这部作品以其幽默、独特的叙事风格和深入浅出的人物描绘，受到了广泛关注。\n小说以小女孩爱莎的视角，展示了一个独特、充满想象力的世界。爱莎是一个聪明、机智的小女孩，她与外婆共同生活，度过了许多难忘的时光。外婆是一个疯狂古怪，打破世俗，四处惹麻烦的存在，却是小女孩爱莎心中的英雄和唯一的朋友。为了安抚爱莎不幸的童年，给与爱莎爱的守护，外婆创作了一个又一个童话故事。然而，外婆去世后，爱莎发现自己陷入了一场冒险——把外婆的道歉信分发给曾经受到外婆恶作剧的邻居们，于是爱莎在外婆留下的一系列谜团和线索中寻找真相并逐渐理解了外婆的良苦用心。这一趟送信之旅让爱莎发现：外婆和邻居的故事，比她听过的任何童话故事都更加精彩。\n爱莎与外婆之间的深厚感情贯穿始终，让人动容。虽然外婆在故事中并不完美，但她对爱莎的关爱和付出是无法替代的。无论发生什么情况，外婆都会站在爱莎这边，为了她和世界拼命。爱莎在寻找真相的过程中，逐渐理解了外婆的期待，理解了外婆所讲故事的隐含意义，最终学会了勇气和坚强，也原谅了外婆的离去。\n文章既有童话的温馨浪漫，也有现实的残酷黑暗。爱莎从小父母离异，在学校遭受霸凌，唯一的朋友外婆也在爱莎八岁时也因为癌症死去，但爱莎并未因此消极堕落，因为童话，外婆，父母，邻居们的共同守护与治愈，爱莎得以更加坚强，温柔的成长。\n读后感 文中我最喜欢的人毫无疑问是外婆。外婆独立，不拘世俗，经常打破常规，四处惹麻烦。“要大笑，要做梦，要与众不同”是外婆的口头禅，她甚至用她的敢打敢拼赢下过一座楼。外婆也是一个温柔善良的人，是一个不怕危险，到处救死扶伤的医生（外婆那个年代学医比较打破常规），奔赴过海啸受灾城市，战场前线救人，她还把一些无家可归的人安置在自己的楼里。外婆在行医的过程中结交过很多形形色色的人，锻炼了各种各样的技能（不过狂妄大胆像是天生的）。所以在爱莎眼里，外婆是一个无所不能的超级英雄。外婆为爱莎构建了一个童话世界，这个世界可以让她克服恐惧和不安，成为内心的支柱，可以为她疲惫之时提供栖息的港湾。\n文中第二个值得讨论的角度是故事。读过全文后就可以发现，外婆创作的故事中的人物其实就是以她帮助过的人为蓝本制作的，诞生的故事进一步去安抚，帮助那些受伤的心灵（有孩子也有大人）。事实上这里可以发现外婆的故事并不是单单为了爱莎而创作，而是诞生在更早之前，为了那些流离失所的孩子而创作，故事的力量可以在爱莎的经历中窥得一斑。\n故事的力量让我想起来了人类简史(这本书是犹左作品，在构建主义上有一些争议，之后也会在读后感讨论)中提到的故事概念，简单来说，我们人类所创造的一切可以被传递和认同的思维思想造物都可以被称为故事，小至童话，寓言，大至各类主义，意识形态，人类的社会就是由无数的故事构成的，我们以相同的故事彼此认同，进而拼接成为文化，民族，国家，文明。故事的诞生之初，承担着教育启蒙的作用，后来故事开始发展为以讴歌赞颂为主，人们迫切的寻求最浪漫完美，可以被奉为涅槃的故事集。随着人们建设自己精神的力量和欲望日渐强大，也开始催生出无数亚文化。\n对那些经历过战争或自然灾害，在绝望的死土上生活的那些孩子，对那些未来无限迷茫，没有光明，希望，呆滞着的那些孩子，一把火，一段围着火堆不成章法的随情热舞，就足以让他们忘记身前身后的一切烦恼，让他们快乐于此刻，不再为生命的寂寥而担忧。如果有人愿意为他们讲上一个精彩的关于爱，勇气和希望的故事，那么他们就可以在幻想的世界里安静安宁的休息片刻，然后好好的长大。这也是故事的意义之一。和外婆的道歉信相似的故事形式，我能联想到的是东方的幻想乡和海猫的黄金乡（前者是车万越共，后者是在故事中讨论故事）。\n第三个角度是关于守护。俗话说的好：大人的职责就是保卫孩子们的健康成长，简称大保健。孩子身上承担着关于未来无限个可能性的力量，或许会引导他们去实现那缈不可及的理想世界和走向最终的故事。大人的意义就是 大保健 为孩子铺上一些路，种上一些花，留下一些种子。\n登场人物 血缘（6人）：爱莎，外婆，爱莎的妈妈，爱莎的爸爸，继父乔治，爱莎的同母异父弟弟小半\n邻居（9人2狗）：三楼 布里特.玛丽，肯特 黑裙女人\n二楼 莫纳特，莫德，莎曼萨（比熊犬） 阿尔法\n一楼 生病男孩，其母亲 怪物（狼心），呜斯（大狗）\n其他（1人）：山姆（狼心曾经的朋友）\n","permalink":"https://tassel234.github.io/posts/read/%E5%A4%96%E5%A9%86%E7%9A%84%E9%81%93%E6%AD%89%E4%BF%A1%E8%AF%BB%E5%90%8E%E6%84%9F/","summary":"故事梗概 《外婆的道歉信》是瑞典作家弗雷德里克·巴克曼创作的一部长篇小说，讲述了一个关于爱，原谅与守护的温馨故事。这部作品以其幽默、独特的叙事风格和深入浅出的人物描绘，受到了广泛关注。 小说以小女孩爱莎的视角，展示了一个独特、充满想象力的世界。爱莎是一个聪明、机智的小女孩，她与外婆共","title":"《外婆的道歉信》读后感"},{"content":"前言 使用资源 西工大网课(在慕课和b站都可以找到资源)\nBjarne Stroustrup《C++程序设计语言》\n洛谷的一些编程题\n主要以网课为主.\n引言 计算机系统由硬件和软件共同组成。硬件主体为输入输出设备，存储器，运算器，控制器。软件又分为系统软件和应用软件。应用软件就是用户下载的音乐播放器，聊天软件，浏览器的软件。而系统软件是一个计算机系统系统必备的，需要提前安装的软件，比如操作系统，数据库系统和网络系统，此外程序设计语言和语言执行程序也应该属于系统软件，其实应该说以语言编写的代码才是软件的基石。\n计算机编程语言其实和汉语，英语等我们口头表达，纸笔书写的语言没有本质的区别，编程语言其实也是把我们的想法转化为特定的词汇和语法，让我们可以和计算机交流。如果我们想书写美妙的编程诗篇，扎实的语言功底，表达力，逻辑力，想象力，创造力缺一不可。\n数据在计算机内部的样子 计算机只能够理解0和1，所以我们编写的程序最后都会转化为计算机可以理解的01代码，同样我们日常使用十进制数据也要变为二进制。\n进制之间的转化。十进制如何转化为二进制，对于整数部分是除以2取余数，对于小数部分是乘2取整数部分，是0就取0。二进制和八，十六进制的转化，整数高位补0，小数低位补0。\n对于数字类型，一般第一位代表±，以-1的次方计数，0正1负。\n二进制的计算。原码可以比较有效的对正数计算，反码指负数的负号位不变，其他位01互换，补码是在反码的基础上进行加1，利用溢出计算。\n浮点数二进制。先表示为科学计数法，对有效数字进行二进制化，分别塞上符号位，二进制的表示数，二的次方数。\n数据类型 基本数据类型。一个字节八位。\n int4,long int 4,unsigned int 4 ,第一位是符号位，而对于无符号的unsigned代表的正数范围多二倍。 char 1,也代表asc||码，为128个，‘1‘49，A65，a97。   float 4,double 8，一般小数都是double,一般计算有效数字为16位，如果是四字节的浮点数，就要在数字后加f，只可以计算7位有效数字。此外还由布尔类型，空类型。 构造数据类型。包括数组，struct,union,enum枚举,class(类)。  特殊的数据类型，有指针类型和引用类型。 int i,j; char c1,c2; c1=\u0026#39;a\u0026#39;; c2=98; i=\u0026#39;A\u0026#39;; j=66; 字符型还可以进行减法运算。cout\u0026laquo;\u0026lsquo;A\u0026rsquo;-32结果是33;\n常量和变量 字面常量  八进制，十六进制表示，0,0x 浮点型也可以用e表示，即科学计数法f e n,f可以是整数或小数，但n必须是整数。 字符串常量和字符常量  \\ooo和\\xhh称为通用转义字符，其中\\ooo表示可以用1至3位八进制数作为码值表示一个ASCII字符，hh表示可以用1至2位十六进制数作为码值表示ASCII字符。\n如:“\\1234”一“123和4”，”\\128”一\\12和8”，19\u0026quot;一”\\1和9\u0026quot;\n\\9错误，\\0xFE 错误\n由于字符型数据在内存中只占用1个字节，即使按无符号处理其最大值也仅是255(八进制为377)，因此ooo的数值范围为0~377 (八进制)，其他值使得字符型数据溢出。同理，hh的数值范围为0~FF\n字符常量 就是使用宏#define进行定义\n变量 变量需要先声明\nint d=a ，e=a+b; //错误，初值不能是变量或表达式 int m=n=z=5: //错误，不能对变量连续初始化 const int a; 一般在函数中应用比较广，避免因为误操作导致数值改变。\n运算符    int m=4，n; n = ++m; //m先增1，m为5，然后表达式使用m的值，赋值给n，n为5 n = --m; //m先减1，m为4，然后表达式使用m的值，赋值给n，n为4 n = m++; //表达式先使用m的值，赋值给n，n为4，然后m增1，m为5 n = m--;//表达式先使用m的值，赋值给n，n为5，然后m减1，m为4   C++在逻辑表达式求解时，并不一定是所有的运算都被执行，当刚开始求解或求解的中途就可以确定整个逻辑表达式的值时，其余的运算将不再进行。\nint a=1 ，b=2,c=3,d=4,m=n=1，k; k=(m=a\u0026gt;b)\u0026amp;\u0026amp;(n=c\u0026gt;d); //m的值为0，n的值为1，k的值为0 3.三目运算符   int i=3,j=5;k=i++,i+1,j++,j+1;//k为3 (i++的值)k=(i++,i+1j++,j+1); //k为7 (j+1的值) 逗号运算符是双目运算符。\n类型转换 手动类型转化\n(int)x+y //将x转换成整型 (int)(x+y) //将x+y转换成整型 (int)x%3 //x的类型和数据值不变，表达式引用转换成int后的x值 隐式类型转换 (implicit type conversion) 又称自动类型转换，它是由编译器自动进行的。\n(1)将浮点型数据赋给整型变量时，舍弃浮点数的小数部分。 如:int n=6.18;n的值为6。\n(2)将整型数据赋给浮点型变量时，数值不变，但以浮点数形式存 诸到变量中。如:double f=78;将78按78.0处理\n(3)将double型数据赋给float变量时，截取前面7位有效数字存储到float变量。将float型数据赋给double变量时，数值不变，有效数字扩展到16位。\n预处理 文件包含 #include 分为相对路径（.h）和绝对路径（C：/） 用户路径\u0026quot;\u0026quot; 系统路径\u0026lt;\u0026gt;\n条件编译 可以避免重复包含头文件，避免错误 1.\n#ifdef #else #endif   #if #elseif #else #endif 宏  #define 进行替换任意文本 但文本替换带有运算是要用（）括起来，不然可能出现错误 #x转化为字符，作用？ ##连接字符文本，ang  ","permalink":"https://tassel234.github.io/posts/note/c++%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1%E5%BC%95%E8%A8%80%E5%92%8C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","summary":"前言 使用资源 西工大网课(在慕课和b站都可以找到资源) Bjarne Stroustrup《C++程序设计语言》 洛谷的一些编程题 主要以网课为主. 引言 计算机系统由硬件和软件共同组成。硬件主体为输入输出设备，存储器，运算器，控制器。软件又分为系统软件和应用软件。应用软件就是用户下载的音乐播放器，聊天","title":"C++入门学习笔记-1（引言和基础知识）"},{"content":"正值暑假，又热又闷。\n学校的图书馆周日不开放，学习任务也没有完成。\n我今天本该在宿舍在宿舍睡觉吃饭学习，但因为前几周的经历，我意识到宿舍学习的效率是有一点惨不忍睹的。\n考虑之下，我决定去青浦图书馆学习和旅行。\n青浦图书馆坐落于青浦新城区夏阳湖上，有水上博物馆的美称，夏阳湖旁边是就是青浦博物馆。\n哈罗单车覆盖了上海的大部分地方，但是没有青浦图书馆这一片，青浦似乎是有自己的共享单车，但我骑不了。\n青浦图书馆的开放时间是周二至周日9:00-20:30(20:00以后停止入馆)\n百度地图显示青浦博物馆的夜景很好，但因为现在正值暑假，宿管阿姨关门关的早，所以很遗憾的我不能欣赏了。\n早上七点半起床，吃了一碗咖啡燕麦粥和一点苏打饼干，收拾行李，关闭电源。\n八点半出发，经过自行车，公交车，地铁，步行，加上吃午饭的时间终于在十二点抵达青浦图书馆。\n上海的地铁站有一个不成文的规定，坐阶梯式电梯时不赶时间，在电梯停留的人统一靠在电梯右侧，左边的空间留给赶时间，在电梯上走动的人。\n地铁上我看日语发音入门课程消磨时间。\n青浦图书馆不需要预约入场更不需要预约座位，上海图书馆东馆就要提前六天抢座位了。 图书馆不算大，也不算小。我能探索的就只有三层结构。\n图书馆下方有一个图咖，我看到有两个女孩在吃冰淇淋。\n图书馆内部的人真是太多了，我转了半天才在一个杂志阅览室的角落找到可以自习的地方。\n自习的人有很多，不只是考研的大学生，还有很多的工作的青年人和看书的老年人。\n书籍也有很多，宗教学，科学，欧美文学，古典文学等面面俱到，还有影像收藏。\n窗外的景色也很不错，南边的座位可以看到一条青绿色的河，北边的座位可以看到夏阳湖。\n学习时我看吴军博士写的 计算之魂，休息时我看保罗.约翰逊写的 所谓知识分子（书挺升血压的）。\n下午的时候天就阴了。\n五点多，我离开了图书馆，吃了一碗拉面。 因为博物馆那时已经闭馆了（我5点多才知道），所以我也就直接回去了。\n我沿着河畔转了一圈，看到了唱戏的大爷大妈，看到了父亲和女儿，看到男男女女，熙熙攘攘。 然后我就回去了，本来想走到地铁站，结果走一小段发现太累了，就停下来等公交。\n值得一提的是，我早上因为大意穿的是睡衣出门，走到一半才意识到，已经来不及回去换了。\n刚开始在地铁上感觉有点尴尬和不自在，但后来渐渐释怀了。\n我意识到上海是一座很大的城市，他很排外也很包容。\n上海的人都很忙，他们压根没精力去在意你，我怀疑我直接cos星野爱也没多少人在意我，更不用提一件睡衣。\n即使有人多看了你一眼，比起在内心折磨自己，不如直接微笑（恶心他人）来的从容。\n","permalink":"https://tassel234.github.io/posts/life/%E9%9D%92%E6%B5%A6%E5%9B%BE%E4%B9%A6%E9%A6%86%E6%B8%B8%E8%AE%B0/","summary":"正值暑假，又热又闷。 学校的图书馆周日不开放，学习任务也没有完成。 我今天本该在宿舍在宿舍睡觉吃饭学习，但因为前几周的经历，我意识到宿舍学习的效率是有一点惨不忍睹的。 考虑之下，我决定去青浦图书馆学习和旅行。 青浦图书馆坐落于青浦新城区夏阳湖上，有水上博物馆的美称，夏阳湖旁边是就是青浦博","title":"青浦图书馆游记"}]