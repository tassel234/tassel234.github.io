[{"content":"前言 使用资源 （主）程序员的数学4：图论 算法图解动画软件演示 计算之魂\n目标指向 了解图的基本知识，可以对图论模型进行数学建模和程序求解。\n图的基础知识 什么是图 在数学中，图是描述于一组对象的结构，其中某些对象对在某种意义上是“相关的”。这些对象对应于称为顶点的数学抽象（也称为节点或点），并且每个相关的顶点对都称为边（也称为链接或线）。通常，图形以图解形式描绘为顶点的一组点或环，并通过边的线或曲线连接。 图形是离散数学的研究对象之一。\n图的表示法 在计算机中表示图的方式由邻接矩阵，关联矩阵，邻接表。\n其他图论术语 度（Degree）：一个顶点的度是指与该顶点相关联的边的条数，顶点v的度记作d(v)。\n对任意图，度的个数之和都是偶数，也就是握手定理。\n迹：如果路径P(u,v)中的边各不相同，则该路径称为u到v的一条行迹。 路（轨道）：如果路径P(u,v)中的顶点各不相同，则该路径称为u到v的一条轨道。 闭的行迹称作回路（Circuit），闭的轨称作圈（Cycle）。\n定理1 设图G的邻接矩阵为A，A的K次幂的（i,j元素）等于在图G中由i到j长度为K的路径数  子图（Sub-Graph）：当图G'=(V',E')其中V‘包含于V，E’包含于E，则G\u0026rsquo;称作图G=(V,E)的子图。每个图都是本身的子图。\n生成子图（Spanning Sub-Graph）：指满足条件V(G') = V(G)的G的子图G'。\n导出子图（Induced Subgraph）：以图G的顶点集V的非空子集V1为顶点集，以两端点均在V1中的全体边为边集的G的子图，称为V1导出的导出子图；以图G的边集E的非空子集E1为边集，以E1中边关联的顶点的全体为顶点集的G的子图，称为E1导出的导出子图。\n补图。点不变，完全图的补线构成的图。\n几类特殊的图 树和森林 联通且不含圈的图称为树，多个不相连的树构成森林。 单个树可以看作一个比较特殊的森林。\n二部图（二分图） 二分图：顶集，且每一条边都有一个顶点在X中，而另一个顶点在Y中。 完全二分图：二分图G中若任意两个X和Y中的顶点都有边相连。若，则图G记作Km,n。 如上图，树是二部图。\n可平面图 图可以被画成边各不相交的图，称为可平面图。\n定理2：欧拉公式 不论什么形状的可平面图（凸多面体），其顶点数V、棱数E、面数F之间总有关系V+F-E=2  其他 完全图：每一对不同顶点间都有边相连的的图，记作Kn。\n正则图：如果图中所有顶点的度皆相等，则此图称为正则图\n图的度序列 定理3：通过度判断一个序列是否为可图化序列 首先把各顶点的度按降序排列形成度序列 。 去掉第一个数字k，然后把前k个数字减1，再按降序排列，循环步骤简化图。  最小生成树 什么是最小生成树 在图（包括赋权图）中，可以找到的路径长度之和最小的树。 可以解决电缆安装问题，只要达到每一个地点就行，形成连通图。\n克鲁斯卡尔算法 属于贪心算法的一种。 按找赋权的大小依次查找，让其不构成圈，最后可以产生最小生成树 。\n普里姆算法 也属于贪心算法的一种。 以某个节点开始，查找赋权小的。\n最小斯坦纳树问题 某些节点可以连（作为中继节点），也可以不连。 NP难的问题，不太可能存在高效的算法。\n最短路径问题 什么是最短路径问题 由一点到另一点所用路径的权值总和最小的问题。\n迪杰斯特拉算法 每一个节点初始化为非常大的数，路径上赋权正常的数字，赋值方式是节点的值加上路径的值。 通过查找可行路径给节点赋值，节点的值往小的地方更新。 满足条件因为使用其他路径时，必须经过点C，但AC成本大于AB成本 但也因为这个限制，权值不能为负，否则可能会出错，这一点不如福特算法 但斯拉特算法也有优点，比如他的速度要快上很多 对于单行道和双向通道值不一致时也可以非常好的解决，这是福特算法做不到的\n欧拉回路与哈密顿圈 欧拉回路 就像七桥问题，把每一个边走且只走一遍，就是欧拉回路。\n形成欧拉回路的充分必要条件是顶点的度都是偶数。\n哈密顿圈 把每一个点走且只走一遍，就是哈密顿圈 。\n是NP完全问题，不太可能存在高效算法。\n狄拉克定理 狄拉克定理：如果图是一个具有至少3个顶点的简单图G，并且图中每个顶点的度数至少为节点数的一半，那么图包含哈密顿图。\n奥尔定理\n奥尔定理是图论在1960年由挪威数学家奥斯汀·奥尔证明的结果，它为图成为哈密顿量提供了充分的条件，从本质上说，具有“足够多的边”的图必须包含哈密顿环。 具体来说，该定理考虑非相邻顶点对的度数之和：如果每个这样的对具有至少等于图中顶点总数的和，则该图为哈密顿图。如果一个总点数至少为3的简单图G满足：G的任意两个不相邻的点u和v度数之和至少为n，即d(u)+d(v)≥n，那么G必然有哈密顿回路。\n","permalink":"https://tassel234.github.io/posts/note/%E5%9B%BE%E8%AE%BA%E5%85%A5%E9%97%A8-1/","summary":"前言 使用资源 （主）程序员的数学4：图论 算法图解动画软件演示 计算之魂 目标指向 了解图的基本知识，可以对图论模型进行数学建模和程序求解。 图的基础知识 什么是图 在数学中，图是描述于一组对象的结构，其中某些对象对在某种意义上是“相关的”。这些对象对应于称为顶点的数学抽象（也称为节点或点），并","title":"图论入门-1"},{"content":"python数模算法-1（库的基本使用和绘图基础） 前言 使用学习资源 python数学建模算法与应用（司守奎） 比较全面的建模算法视频（但编程语言是matlab）\n目标指向 只需要会看那些代码并运行实现一次代码和理解用途就可以了，需要使用的时候查阅复制粘贴就可以了。\n算法具体实现的逻辑步骤要搞清楚，锻炼一些编程思想，可以对程序进行合理的修改。\n编程环境配置 conda-python3.10.9\nlatex（可无）\n库的使用 numpy对数组 数组生成\nimport numpy as np a1 = np.array([1, 2, 3, 4]) #生成整型数组 a2 = a1.astype(float) a3 = np.array([1, 2, 3, 4], dtype=float) #浮点数 print(a1.dtype); print(a2.dtype); print(a3.dtype) b = np.array([[1, 2, 3], [4, 5, 6]]) c = np.arange(1,5) #生成数组[1, 2, 3, 4] d = np.linspace(1, 4, 4) #前面是范围，后面是分割数，生成数组[1, 2, 3, 4] e = np.logspace(1, 3, 3, base=2) #生成等比数列数组[2, 4, 8] import numpy as np a = np.ones(4, dtype=int) #输出[1, 1, 1, 1] b = np.ones((4,), dtype=int) #逗号加在前面会报错，输出同a c= np.ones((4,1)) #输出4行1列的数组 d = np.zeros(4) #输出[0, 0, 0, 0] e = np.empty(3) #生成3个元素的空数组行向量 f = np.eye(3) #生成3阶单位阵 g = np.eye(3, k=-1) #主对角线是0，生成第k对角线的元素为1，其他元素为0的3阶方阵 h = np.zeros_like(a) #生成与a同维数的全0数组 print(g) print(c) 数组元素的索引\nimport numpy as np a = np.arange(16).reshape(4,4) #生成4行4列的数组 b = a[1][2] #输出6 c = a[1, 2] #同b d = a[1:2, 2:3] #输出[[6]] x = np.array([0, 1, 2, 1]) print(a[x==1]) #输出a的第2、4行元素 print(a) numpy对矩阵 矩阵的合并 np.vstack([a, b]) #上下合并矩阵 np.hstack([a, c]) #左右合并矩阵\n矩阵的分割 b = np.vsplit(a, 2) #行分割 c = np.hsplit(a, 4) #列分割\n矩阵的乘法\n使用符号@，前面的相当于行向量\n范数计算\nimport numpy as np a = np.array([[0, 3, 4], [1, 6, 4]]) b = np.linalg.norm(a, axis=1) #求行向量2范数 c = np.linalg.norm(a, axis=0) #求列向量2范数 d = np.linalg.norm(a) #求矩阵2范数 print(\u0026#39;行向量2范数为：\u0026#39;, np.round(b, 4)) print(\u0026#39;列向量2范数为：\u0026#39;, np.round(c, 4)) print(\u0026#39;矩阵2范数为：\u0026#39;, round(d, 4)) 求线性方程的唯一解\nimport numpy as np a = np.array([[3, 1], [1, 2]]) b = np.array([9, 8]) x1 = np.linalg.inv(a) @ b #第一种解法 #上面语句中@表示矩阵乘法 x2 = np.linalg.solve(a, b) #第二种解法 print(x1); print(x2) 求超定线性方程组的唯一解\nimport numpy as np a = np.array([[3, 1], [1, 2], [1, 1]]) b = np.array([9, 8, 6]) x = np.linalg.pinv(a) @ b print(np.round(x, 4)) 特征值和特征向量\nimport numpy as np a = np.eye(4) b = np.rot90(a) #好像代表转 c, d = np.linalg.eig(b) print(\u0026#39;特征值为：\u0026#39;, c) print(\u0026#39;特征向量为：\\n\u0026#39;, d) pandas 生成二维数组\nimport pandas as pd import numpy as np dates=pd.date_range(start=\u0026#39;20191101\u0026#39;,end=\u0026#39;20191124\u0026#39;,freq=\u0026#39;D\u0026#39;) a1=pd.DataFrame(np.random.randn(24,4), index=dates, columns=list(\u0026#39;ABCD\u0026#39;)) a2=pd.DataFrame(np.random.rand(24,4)) 读写文件\nimport pandas as pd import numpy as np dates=pd.date_range(start=\u0026#39;20191101\u0026#39;, end=\u0026#39;20191124\u0026#39;, freq=\u0026#39;D\u0026#39;) a1=pd.DataFrame(np.random.randn(24,4), index=dates, columns=list(\u0026#39;ABCD\u0026#39;)) a2=pd.DataFrame(np.random.randn(24,4)) a1.to_excel(\u0026#39;data2_38_1.xlsx\u0026#39;) #可以修改此行让其不带索引 a2.to_csv(\u0026#39;data2_38_2.csv\u0026#39;) f=pd.ExcelWriter(\u0026#39;data2_38_3.xlsx\u0026#39;) #创建文件对象 a1.to_excel(f,\u0026#34;Sheet1\u0026#34;) #把a1写入Excel文件 a2.to_excel(f,\u0026#34;Sheet2\u0026#34;) #把a2写入另一个表单中 f.save() 数据预处理\nimport pandas as pd import numpy as np d=pd.DataFrame(np.random.randint(1,6,(10,4)), columns=list(\u0026#34;ABCD\u0026#34;)) d1=d[:4] #获取前4行数据 d2=d[4:] #获取第5行以后的数据 dd=pd.concat([d1,d2]) #数据行合并 s1=d.groupby(\u0026#39;A\u0026#39;).mean() #数据分组求均值 s2=d.groupby(\u0026#39;A\u0026#39;).apply(sum) #数据分组求和 import pandas as pd import numpy as np a = pd.DataFrame(np.random.randint(1,6,(5,3)), index=[\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;], columns=[\u0026#39;one\u0026#39;, \u0026#39;two\u0026#39;, \u0026#39;three\u0026#39;]) a.loc[\u0026#39;a\u0026#39;, \u0026#39;one\u0026#39;] = np.nan #修改第1行第1列的数据 b = a.iloc[1:3, 0:2].values #提取第2、3行，第1、2列数据 a[\u0026#39;four\u0026#39;] = \u0026#39;bar\u0026#39; #增加第4列数据 a2 = a.reindex([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;]) a3 = a2.dropna() #删除有不确定值的行 scipy 求解非线性方程\nfrom scipy.optimize import fsolve, root fx = lambda x: x**980-5.01*x**979+7.398*x**978\\ -3.388*x**977-x**3+5.01*x**2-7.398*x+3.388 x1 = fsolve(fx, 1.5, maxfev=4000) #函数调用4000次 x2 = root(fx, 1.5) print(x1,\u0026#39;\\n\u0026#39;,\u0026#39;-------------\u0026#39;); print(x2) 最小二乘法\nfrom scipy.optimize import least_squares import numpy as np a=np.loadtxt(\u0026#39;data2_47.txt\u0026#39;) x0=a[0]; y0=a[1]; d=a[2] fx=lambda x: np.sqrt((x0-x[0])**2+(y0-x[1])**2)-d s=least_squares(fx, np.random.rand(2)) print(s, \u0026#39;\\n\u0026#39;, \u0026#39;------------\u0026#39;, \u0026#39;\\n\u0026#39;, s.x) 求最大模特征值和对应的特征向量\nfrom scipy.sparse.linalg import eigs import numpy as np a = np.array([[1, 2, 3], [2, 1, 3], [3, 3, 6]], dtype=float) #必须加float,否则出错 b, c = np.linalg.eig(a) d, e = eigs(a, 1) print(\u0026#39;最大模特征值为：\u0026#39;, d) print(\u0026#39;对应的特征向量为：\\n\u0026#39;, e) 此外，还可以求解积分，傅里叶变换，插值，信号处理等。\nsympy 可以用计算机推导表达式，可以对符号运算。\nimport sympy as sp a, b, c, x=sp.symbols(\u0026#39;a,b,c,x\u0026#39;) x0=sp.solve(a*x**2+b*x+c, x) print(x0) import sympy as sp sp.var(\u0026#39;x1,x2\u0026#39;) s=sp.solve([x1**2+x2**2-1,x1-x2],[x1,x2]) print(s) import numpy as np import sympy as sp a = np.identity(4) #单位矩阵的另一种写法 b = np.rot90(a) c = sp.Matrix(b) print(\u0026#39;特征值为：\u0026#39;, c.eigenvals()) print(\u0026#39;特征向量为：\\n\u0026#39;, c.eigenvects()) matplotlib绘图介绍 二维绘图 绘制折线图\nimport pandas as pd import pylab as plt plt.rc(\u0026#39;font\u0026#39;,family=\u0026#39;SimHei\u0026#39;) #用来正常显示中文标签，还有一个正常显示符号的语句 plt.rc(\u0026#39;font\u0026#39;,size=16) #设置显示字体大小 a=pd.read_excel(\u0026#34;data2_52.xlsx\u0026#34;, header=None) #和py文件保存在同一级目录 b=a.values #提取其中的数据 x=b[0]; y=b[1:] plt.plot(x,y[0],\u0026#39;-*b\u0026#39;,label=\u0026#39;铂金\u0026#39;) plt.plot(x,y[1],\u0026#39;--dr\u0026#39;,label=\u0026#39;铂金\u0026#39;) plt.xlabel(\u0026#39;月份\u0026#39;); plt.ylabel(\u0026#39;每月销量\u0026#39;) plt.legend(loc=\u0026#39;upper left\u0026#39;); plt.grid(); plt.show() ()使用pandas的Dateframe绘图 绘制柱状图\nimport pandas as pd import pylab as plt plt.rc(\u0026#39;font\u0026#39;,family=\u0026#39;SimHei\u0026#39;) #用来正常显示中文标签 plt.rc(\u0026#39;font\u0026#39;,size=16) #设置显示字体大小 a=pd.read_excel(\u0026#34;data2_52.xlsx\u0026#34;,header=None) b=a.T; b.plot(kind=\u0026#39;bar\u0026#39;); plt.legend([\u0026#39;钻石\u0026#39;, \u0026#39;铂金\u0026#39;]) plt.xticks(range(6), b[0], rotation=0); plt.show() 子图\nimport pylab as plt import numpy as np plt.rc(\u0026#39;text\u0026#39;, usetex=True) #调用tex字库 y1=np.random.randint(2, 5, 6); y1=y1/sum(y1); plt.subplot(2, 2, 1); str=[\u0026#39;Apple\u0026#39;, \u0026#39;grape\u0026#39;, \u0026#39;peach\u0026#39;, \u0026#39;pear\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;pineapple\u0026#39;] plt.barh(str,y1) #水平条形图 plt.subplot(222); plt.pie(y1, labels=str) #饼图 plt.subplot(212) x2=np.linspace(0.01, 10, 100); y2=np.sin(10*x2)/x2 plt.plot(x2,y2); plt.xlabel(\u0026#39;$x$\u0026#39;) plt.ylabel(\u0026#39;$\\\\mathrm{sin}(50x)/x$\u0026#39;); plt.show()#latex表示数学公式 linspace(a,b,c)表示的是把a-b平均分成c分, 三维绘图 三维曲线\nimport pylab as plt import numpy as np ax=plt.axes(projection=\u0026#39;3d\u0026#39;) #设置三维图形模式 z=np.linspace(-50, 50, 1000) x=z**2*np.sin(z); y=z**2*np.cos(z) plt.plot(x, y, z, \u0026#39;k\u0026#39;); plt.show() 三维表面图\nimport pylab as plt import numpy as np x=np.linspace(-4,4,100); x,y=np.meshgrid(x,x) z=50*np.sin(x+y); ax=plt.axes(projection=\u0026#39;3d\u0026#39;) ax.plot_surface(x, y, z, color=\u0026#39;y\u0026#39;) plt.show() import pylab as plt import numpy as np ax=plt.axes(projection=\u0026#39;3d\u0026#39;) X = np.arange(-6, 6, 0.25) Y = np.arange(-6, 6, 0.25) X, Y = np.meshgrid(X, Y) Z = np.sin(np.sqrt(X**2 + Y**2)) surf = ax.plot_surface(X, Y, Z, cmap=\u0026#39;coolwarm\u0026#39;) plt.colorbar(surf); plt.show() 概率统计模型专题绘图 直方图 也称频数图\nimport pandas as pd import pylab as plt df = pd.read_csv(\u0026#39;data9_5.txt\u0026#39;, header=None) df = df.T #转置 plt.subplot(121); h1 = plt.hist(df[0], 5); print(h1) plt.subplot(122); plt.hist(df[1], 5) df.hist(bins=5) #另一种方法画直方图 plt.show() 箱线图\n几个点分别是最小值，1/4值，中位数，3/4点，最大值。 用来观察离散程度。\nimport pandas as pd import pylab as plt df = pd.read_csv(\u0026#39;data9_5.txt\u0026#39;, header=None).T plt.rc(\u0026#39;font\u0026#39;, family=\u0026#39;SimHei\u0026#39;); plt.rc(\u0026#39;font\u0026#39;, size=16); plt.boxplot(df, labels=[\u0026#39;甲班\u0026#39;, \u0026#39;乙班\u0026#39;]); plt.show() QQ图\n可以检验拟合优度。同时不建议直接使用库函数绘制QQ图\nimport pandas as pd import pylab as plt from scipy.stats import norm, probplot df = pd.read_csv(\u0026#39;data9_5.txt\u0026#39;, header=None) d = df.values[0] #提取甲班成绩 mu = d.mean(); s = d.std(); sd = sorted(d); n = len(d) x = (plt.arange(n)+1/2)/n; yi = norm.ppf(x, mu, s) plt.rc(\u0026#39;font\u0026#39;, size=16); plt.rc(\u0026#39;font\u0026#39;, family=\u0026#39;SimHei\u0026#39;) plt.rc(\u0026#39;axes\u0026#39;, unicode_minus=False) plt.subplot(121); plt.plot(yi, sd, \u0026#39;o\u0026#39;, label=\u0026#39;QQ图\u0026#39;) plt.plot(sd, sd, label=\u0026#39;参照直线\u0026#39;); plt.legend() plt.subplot(122); probplot(d, plot=plt); plt.show() ","permalink":"https://tassel234.github.io/posts/note/python%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AE%97%E6%B3%95-1%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%92%8C%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80/","summary":"python数模算法-1（库的基本使用和绘图基础） 前言 使用学习资源 python数学建模算法与应用（司守奎） 比较全面的建模算法视频（但编程语言是matlab） 目标指向 只需要会看那些代码并运行实现一次代码和理解用途就可以了，需要使用的时候查阅复制粘贴就可以了。 算法具体实现的逻辑步骤要","title":"Python数学建模算法 1（库的基本使用和绘图基础）"},{"content":"github和git的基础知识（可跳过不看）  Github 代码上边的Raw、Blame是什么意思？\n  Raw：文件内容。 blame：按行显示最新提交的信息。\n Pin，该词可被译为：钉住、按住。被Pin的仓库会显示在个人主页中，类似于仓库置顶。 Watch，默认是Unwatch，如果你想关注某个仓库，当这个库有新的通知时就会提醒你。 star,表示喜爱。\nFork代表从别人的代码仓库中复制一份到自己的代码库，包含了别人库中的提交历史记录。经过fork后的代码库是完全独立的，由自己维护，可以进行任何魔改。改完之后自己可以通过Pull Request向原来的库提交合并请求。 1. Fork别人的仓库：复制别人仓库（代码、文件、提交历史记录、issue等），复制后的仓库在自己的github账号中存着。 2. Clone远程仓库：将这个复制后的远程仓库克隆到本地。 3. 在工作区对代码进行CRUD操作（增删改查） 4. 将代码的更改提交暂存区（git add .） 5. 将暂存区的文件提交到本地仓库（git commit -m \u0026lsquo;小修一下\u0026rsquo;） 6. 将本地仓库的代码推送到远程仓库（git push） 7. 给别人的仓库发送Pull Request：如果原作者认为你的修改版本不错，就会将你代码中的修改合并到自己的库中。\n可以在写编写markdown文件于github网站\nGit是一款分布式源代码管理工具(版本控制工具) ，可以对我们写的代码进行托管和版本记录（每上传一次形成一个版本，可以找回）。github和git的关系非常紧密，hub在百度翻译有如下解释：\n n. 轮毂; (某地或活动的)中心; [例句]The island\u0026rsquo;s social hub is the Cafe Sport 该岛的社交中心是“体育咖啡馆”。 可以理解为github以git为传输路径，把程序员上传过的代码集中,迭代，存放在github的仓库中，方便和其他程序员的合作或交流。\n git的进一步学习\n前言 本文介绍如何使用Github+Hugo+PaperMod主题搭建一个人博客。\n此文章也记录了我搭建博客较为详细的步骤和一些在博客搭建过程中出现的问题和解决方案。\n参考资料 23年的hugo博客搭建视频\nsulv的博客\n333rd的博客\nrosefinch-midsummer的博客\n前置工作 需要一个github账号,可以在网页打开github,推荐使用fastgithub软件，翻墙也行。\n下载hugo,推荐安装比较原始的版本，后面会解释为什么。\n下载地址\n下载和安装git，见视频\n安装github desktop，使用该软件可以从本地库克隆到github仓库，并可以完成较为方便的上传更新。\n安装fastgithub，可以获得非常快的github访问速度，而且不用翻墙。\n下载fastgithub\n搭建博客  先下载好hugo,推荐下载hugo v0.85.0版本，之前我下载了最新版本，死活不能把配置文件改成yaml格式，也就没办法直接调用别人写好的漂亮的网站结构。接下来的文字是对视频的总结，更直观的步骤请查阅hugo博客搭建视频 把下载好后把hugo.exe所在的文件夹地址放置在环境变量的系统变量中。 在cmd窗口输入hugo version查看版本和确认安装成功。  生成新站点，hugo new site \u0026lt;想要存储到的位置\u0026gt;/\u0026lt;站点名字\u0026gt; -f yml ， 实例hugo new site D:/path/to/newst -f yml ，  -f yml是把toml文件格式改成yaml格式，最新版这个指令修改不了配置文件（config）格式。\n然后就可以在文件夹找到生成的站点   在路径栏目输入cmd,打开，\n  输入hugo new posts/tech/文章名称.md生成第一篇博客文章。应该在tech目录下写一个_index.md文件用于索引。\n  安装主题，使用命令行git clone https://github.com/adityatelange/hugo-PaperMod.git\n  下载最新版本，实际上后面cmd提示hugo版本和papermod版本不完全匹配，但最后还是可以生成不错的博客页面，然后对config.yaml进行重写，赋值代码和粘贴config.yml此外写入的md文本应该在github复制最新版，旧版会报错。\n写好了开始生成静态页面，站点目录的cmd输入hugo version在本地查看\n 站点目录的cmd输入hugo生成文件夹public\n  在public的文件夹的cmd进行git 导入，输入git init,一个文件夹导入一次就够了\n  博客上传 配置FastGithub(可以跳过不看) 双击打开FastGithub.UI.exe应用程序,程序会在后台运行。\nfirefox提示连接有潜在的安全问题 设置-\u0026gt;隐私与安全-\u0026gt;证书-\u0026gt;查看证书-\u0026gt;证书颁发机构，导入cacert/fastgithub.cer，勾选“信任由此证书颁发机构来标识网站”\n安全性说明\nFastGithub为每台不同的主机生成自颁发CA证书，保存在cacert文件夹下。客户端设备需要安装和无条件信任自颁发的CA证书，请不要将证书私钥泄露给他人，以免造成损失。\n合法性说明\n《国际联网暂行规定》第六条规定：“计算机信息网络直接进行国际联网，必须使用邮电部国家公用电信网提供的国际出入口信道。任何单位和个人不得自行建立或者使用其他信道进行国际联网。” FastGithub本地代理使用的都是“公用电信网提供的国际出入口信道”，从国外Github服务器到国内用户电脑上FastGithub程序的流量，使用的是正常流量通道，其间未对流量进行任何额外加密（仅有网页原有的TLS加密，区别于VPN的流量加密），而FastGithub获取到网页数据之后发生的整个代理过程完全在国内，不再适用国际互联网相关之规定。\n通过git和github desktop将博客上传到github 输入上述两串代码，然后在github desktop进行上传，浏览器的github就可以更新了。\n上传点击fetch origin按钮.\n网页显示 在GitHub网页端，点击hugo博客代码存放库，点击settings,点击pages,修改Branch的none为master,等待一会，就可以生成网页了。\n更新 hugo -F \u0026ndash;cleanDestinationDir完成public文件夹的更新, 然后再重复上传步骤即可.\n添加图片 笔者使用的是vnote，记markdown笔记。 图片引用代码如下： ![](vx_images/ex.png =481x)\n首先应该在static文件夹下创建vx_images文件夹，再把要用的图片导入，但有两个问题。\n 不能加图片大小，也就是把 =481x去掉 前面应该加一个/  如何改进博客 创建拥有美观界面的博客 sulv大佬已经写好了一个优美的yaml配置文件,我们只需要复制粘贴到config配置文件就可以了。 但博客网页的yaml代码不能成功执行，因为sulv的博客和333rd的博客的博客都是创作于几年前，hugo和papermod的版本更新导致了各种问题，所以应该直接在github中复制，config.yml\n至于配置头像，联系方式等，也请参照上面两个博客。\n改进指南 插件\n建站\n统计部署\n为什么要写博客  通过强迫自己记笔记，对知识进行整理，对日常和灵感进行记录 可以促进知识的输出，检验自己的掌握程度，类似费曼学习法 博客本身可以促进学习，并且有助于和别人交流自己的想法  ","permalink":"https://tassel234.github.io/posts/tech/hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","summary":"github和git的基础知识（可跳过不看） Github 代码上边的Raw、Blame是什么意思？ Raw：文件内容。 blame：按行显示最新提交的信息。 Pin，该词可被译为：钉住、按住。被Pin的仓库会显示在个人主页中，类似于仓库置顶。 Watch，默认是Unwatch，如果你想关注某个仓库，","title":"Hugo搭建个人博客"},{"content":"故事梗概 《外婆的道歉信》是瑞典作家弗雷德里克·巴克曼创作的一部长篇小说，讲述了一个关于爱，原谅与守护的温馨故事。这部作品以其幽默、独特的叙事风格和深入浅出的人物描绘，受到了广泛关注。\n小说以小女孩爱莎的视角，展示了一个独特、充满想象力的世界。爱莎是一个聪明、机智的小女孩，她与外婆共同生活，度过了许多难忘的时光。外婆是一个疯狂古怪，打破世俗，四处惹麻烦的存在，却是小女孩爱莎心中的英雄和唯一的朋友。为了安抚爱莎不幸的童年，给与爱莎爱的守护，外婆创作了一个又一个童话故事。然而，外婆去世后，爱莎发现自己陷入了一场冒险——把外婆的道歉信分发给曾经受到外婆恶作剧的邻居们，于是爱莎在外婆留下的一系列谜团和线索中寻找真相并逐渐理解了外婆的良苦用心。这一趟送信之旅让爱莎发现：外婆和邻居的故事，比她听过的任何童话故事都更加精彩。\n爱莎与外婆之间的深厚感情贯穿始终，让人动容。虽然外婆在故事中并不完美，但她对爱莎的关爱和付出是无法替代的。无论发生什么情况，外婆都会站在爱莎这边，为了她和世界拼命。爱莎在寻找真相的过程中，逐渐理解了外婆的期待，理解了外婆所讲故事的隐含意义，最终学会了勇气和坚强，也原谅了外婆的离去。\n文章既有童话的温馨浪漫，也有现实的残酷黑暗。爱莎从小父母离异，在学校遭受霸凌，唯一的朋友外婆也在爱莎八岁时也因为癌症死去，但爱莎并未因此消极堕落，因为童话，外婆，父母，邻居们的共同守护与治愈，爱莎得以更加坚强，温柔的成长。\n读后感 文中我最喜欢的人毫无疑问是外婆。外婆独立，不拘世俗，经常打破常规，四处惹麻烦。“要大笑，要做梦，要与众不同”是外婆的口头禅，她甚至用她的敢打敢拼赢下过一座楼。外婆也是一个温柔善良的人，是一个不怕危险，到处救死扶伤的医生（外婆那个年代学医比较打破常规），奔赴过海啸受灾城市，战场前线救人，她还把一些无家可归的人安置在自己的楼里。外婆在行医的过程中结交过很多形形色色的人，锻炼了各种各样的技能（不过狂妄大胆像是天生的）。所以在爱莎眼里，外婆是一个无所不能的超级英雄。外婆为爱莎构建了一个童话世界，这个世界可以让她克服恐惧和不安，成为内心的支柱，可以为她疲惫之时提供栖息的港湾。\n文中第二个值得讨论的角度是故事。读过全文后就可以发现，外婆创作的故事中的人物其实就是以她帮助过的人为蓝本制作的，诞生的故事进一步去安抚，帮助那些受伤的心灵（有孩子也有大人）。事实上这里可以发现外婆的故事并不是单单为了爱莎而创作，而是诞生在更早之前，为了那些流离失所的孩子而创作，故事的力量可以在爱莎的经历中窥得一斑。\n故事的力量让我想起来了人类简史(这本书是犹左作品，在构建主义上有一些争议，之后也会在读后感讨论)中提到的故事概念，简单来说，我们人类所创造的一切可以被传递和认同的思维思想造物都可以被称为故事，小至童话，寓言，大至各类主义，意识形态，人类的社会就是由无数的故事构成的，我们以相同的故事彼此认同，进而拼接成为文化，民族，国家，文明。故事的诞生之初，承担着教育启蒙的作用，后来故事开始发展为以讴歌赞颂为主，人们迫切的寻求最浪漫完美，可以被奉为涅槃的故事集。随着人们建设自己精神的力量和欲望日渐强大，也开始催生出无数亚文化。\n对那些经历过战争或自然灾害，在绝望的死土上生活的那些孩子，对那些未来无限迷茫，没有光明，希望，呆滞着的那些孩子，一把火，一段围着火堆不成章法的随情热舞，就足以让他们忘记身前身后的一切烦恼，让他们快乐于此刻，不再为生命的寂寥而担忧。如果有人愿意为他们讲上一个精彩的关于爱，勇气和希望的故事，那么他们就可以在幻想的世界里安静安宁的休息片刻，然后好好的长大。这也是故事的意义之一。和外婆的道歉信相似的故事形式，我能联想到的是东方的幻想乡和海猫的黄金乡（前者是车万越共，后者是在故事中讨论故事）。\n第三个角度是关于守护。俗话说的好：大人的职责就是保卫孩子们的健康成长，简称大保健。孩子身上承担着关于未来无限个可能性的力量，或许会引导他们去实现那缈不可及的理想世界和走向最终的故事。大人的意义就是 大保健 为孩子铺上一些路，种上一些花，留下一些种子。\n登场人物 血缘（6人）：爱莎，外婆，爱莎的妈妈，爱莎的爸爸，继父乔治，爱莎的同母异父弟弟小半\n邻居（9人2狗）：三楼 布里特.玛丽，肯特 黑裙女人\n二楼 莫纳特，莫德，莎曼萨（比熊犬） 阿尔法\n一楼 生病男孩，其母亲 怪物（狼心），呜斯（大狗）\n其他（1人）：山姆（狼心曾经的朋友）\n","permalink":"https://tassel234.github.io/posts/read/%E5%A4%96%E5%A9%86%E7%9A%84%E9%81%93%E6%AD%89%E4%BF%A1%E8%AF%BB%E5%90%8E%E6%84%9F/","summary":"故事梗概 《外婆的道歉信》是瑞典作家弗雷德里克·巴克曼创作的一部长篇小说，讲述了一个关于爱，原谅与守护的温馨故事。这部作品以其幽默、独特的叙事风格和深入浅出的人物描绘，受到了广泛关注。 小说以小女孩爱莎的视角，展示了一个独特、充满想象力的世界。爱莎是一个聪明、机智的小女孩，她与外婆共","title":"《外婆的道歉信》读后感"},{"content":"引言和基础知识 前言 使用资源 西工大网课(在慕课和b站都可以找到资源)\nBjarne Stroustrup《C++程序设计语言》\n洛谷的一些编程题\n主要以网课为主.\n引言 计算机系统由硬件和软件共同组成。硬件主体为输入输出设备，存储器，运算器，控制器。软件又分为系统软件和应用软件。应用软件就是用户下载的音乐播放器，聊天软件，浏览器的软件。而系统软件是一个计算机系统系统必备的，需要提前安装的软件，比如操作系统，数据库系统和网络系统，此外程序设计语言和语言执行程序也应该属于系统软件，其实应该说以语言编写的代码才是软件的基石。\n计算机编程语言其实和汉语，英语等我们口头表达，纸笔书写的语言没有本质的区别，编程语言其实也是把我们的想法转化为特定的词汇和语法，让我们可以和计算机交流。如果我们想书写美妙的编程诗篇，扎实的语言功底，表达力，逻辑力，想象力，创造力缺一不可。\n数据在计算机内部的样子 计算机只能够理解0和1，所以我们编写的程序最后都会转化为计算机可以理解的01代码，同样我们日常使用十进制数据也要变为二进制。\n进制之间的转化。十进制如何转化为二进制，对于整数部分是除以2取余数，对于小数部分是乘2取整数部分，是0就取0。二进制和八，十六进制的转化，整数高位补0，小数低位补0。\n对于数字类型，一般第一位代表±，以-1的次方计数，0正1负。\n二进制的计算。原码可以比较有效的对正数计算，反码指负数的负号位不变，其他位01互换，补码是在反码的基础上进行加1，利用溢出计算。\n浮点数二进制。先表示为科学计数法，对有效数字进行二进制化，分别塞上符号位，二进制的表示数，二的次方数。\n数据类型 基本数据类型。一个字节八位。\n int4,long int 4,unsigned int 4 ,第一位是符号位，而对于无符号的unsigned代表的正数范围多二倍。 char 1,也代表asc||码，为128个，‘1‘49，A65，a97。   float 4,double 8，一般小数都是double,一般计算有效数字为16位，如果是四字节的浮点数，就要在数字后加f，只可以计算7位有效数字。此外还由布尔类型，空类型。 构造数据类型。包括数组，struct,union,enum枚举,class(类)。  特殊的数据类型，有指针类型和引用类型。 int i,j; char c1,c2; c1=\u0026#39;a\u0026#39;; c2=98; i=\u0026#39;A\u0026#39;; j=66; 字符型还可以进行减法运算。cout\u0026laquo;\u0026lsquo;A\u0026rsquo;-32结果是33;\n常量和变量 字面常量  八进制，十六进制表示，0,0x 浮点型也可以用e表示，即科学计数法f e n,f可以是整数或小数，但n必须是整数。 字符串常量和字符常量  \\ooo和\\xhh称为通用转义字符，其中\\ooo表示可以用1至3位八进制数作为码值表示一个ASCII字符，hh表示可以用1至2位十六进制数作为码值表示ASCII字符。\n如:“\\1234”一“123和4”，”\\128”一\\12和8”，19\u0026quot;一”\\1和9\u0026quot;\n\\9错误，\\0xFE 错误\n由于字符型数据在内存中只占用1个字节，即使按无符号处理其最大值也仅是255(八进制为377)，因此ooo的数值范围为0~377 (八进制)，其他值使得字符型数据溢出。同理，hh的数值范围为0~FF\n字符常量 就是使用宏#define进行定义\n变量 变量需要先声明\nint d=a ，e=a+b; //错误，初值不能是变量或表达式 int m=n=z=5: //错误，不能对变量连续初始化 const int a; 一般在函数中应用比较广，避免因为误操作导致数值改变。\n运算符    int m=4，n; n = ++m; //m先增1，m为5，然后表达式使用m的值，赋值给n，n为5 n = --m; //m先减1，m为4，然后表达式使用m的值，赋值给n，n为4 n = m++; //表达式先使用m的值，赋值给n，n为4，然后m增1，m为5 n = m--;//表达式先使用m的值，赋值给n，n为5，然后m减1，m为4   C++在逻辑表达式求解时，并不一定是所有的运算都被执行，当刚开始求解或求解的中途就可以确定整个逻辑表达式的值时，其余的运算将不再进行。\nint a=1 ，b=2,c=3,d=4,m=n=1，k; k=(m=a\u0026gt;b)\u0026amp;\u0026amp;(n=c\u0026gt;d); //m的值为0，n的值为1，k的值为0 3.三目运算符   int i=3,j=5;k=i++,i+1,j++,j+1;//k为3 (i++的值)k=(i++,i+1j++,j+1); //k为7 (j+1的值) 逗号运算符是双目运算符。\n类型转换 手动类型转化\n(int)x+y //将x转换成整型 (int)(x+y) //将x+y转换成整型 (int)x%3 //x的类型和数据值不变，表达式引用转换成int后的x值 隐式类型转换 (implicit type conversion) 又称自动类型转换，它是由编译器自动进行的。\n(1)将浮点型数据赋给整型变量时，舍弃浮点数的小数部分。 如:int n=6.18;n的值为6。\n(2)将整型数据赋给浮点型变量时，数值不变，但以浮点数形式存 诸到变量中。如:double f=78;将78按78.0处理\n(3)将double型数据赋给float变量时，截取前面7位有效数字存储到float变量。将float型数据赋给double变量时，数值不变，有效数字扩展到16位。\n","permalink":"https://tassel234.github.io/posts/note/c++%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/","summary":"引言和基础知识 前言 使用资源 西工大网课(在慕课和b站都可以找到资源) Bjarne Stroustrup《C++程序设计语言》 洛谷的一些编程题 主要以网课为主. 引言 计算机系统由硬件和软件共同组成。硬件主体为输入输出设备，存储器，运算器，控制器。软件又分为系统软件和应用软件。应用软件就是用户下载的音","title":"C++入门学习笔记(1)"},{"content":"正值暑假，又热又闷。\n学校的图书馆周日不开放，学习任务也没有完成。\n我今天本该在宿舍在宿舍睡觉吃饭学习，但因为前几周的经历，我意识到宿舍学习的效率是有一点惨不忍睹的。\n考虑之下，我决定去青浦图书馆学习和旅行。\n青浦图书馆坐落于青浦新城区夏阳湖上，有水上博物馆的美称，夏阳湖旁边是就是青浦博物馆。\n哈罗单车覆盖了上海的大部分地方，但是没有青浦图书馆这一片，青浦似乎是有自己的共享单车，但我骑不了。\n青浦图书馆的开放时间是周二至周日9:00-20:30(20:00以后停止入馆)\n百度地图显示青浦博物馆的夜景很好，但因为现在正值暑假，宿管阿姨关门关的早，所以很遗憾的我不能欣赏了。\n早上七点半起床，吃了一碗咖啡燕麦粥和一点苏打饼干，收拾行李，关闭电源。\n八点半出发，经过自行车，公交车，地铁，步行，加上吃午饭的时间终于在十二点抵达青浦图书馆。\n上海的地铁站有一个不成文的规定，坐阶梯式电梯时不赶时间，在电梯停留的人统一靠在电梯右侧，左边的空间留给赶时间，在电梯上走动的人。\n地铁上我看日语发音入门课程消磨时间。\n青浦图书馆不需要预约入场更不需要预约座位，上海图书馆东馆就要提前六天抢座位了。 图书馆不算大，也不算小。我能探索的就只有三层结构。\n图书馆下方有一个图咖，我看到有两个女孩在吃冰淇淋。\n图书馆内部的人真是太多了，我转了半天才在一个杂志阅览室的角落找到可以自习的地方。\n自习的人有很多，不只是考研的大学生，还有很多的工作的青年人和看书的老年人。\n书籍也有很多，宗教学，科学，欧美文学，古典文学等面面俱到，还有影像收藏。\n窗外的景色也很不错，南边的座位可以看到一条青绿色的河，北边的座位可以看到夏阳湖。\n学习时我看吴军博士写的 计算之魂，休息时我看保罗.约翰逊写的 所谓知识分子（书挺升血压的）。\n下午的时候天就阴了。\n五点多，我离开了图书馆，吃了一碗拉面。 因为博物馆那时已经闭馆了（我5点多才知道），所以我也就直接回去了。\n我沿着河畔转了一圈，看到了唱戏的大爷大妈，看到了父亲和女儿，看到男男女女，熙熙攘攘。 然后我就回去了，本来想走到地铁站，结果走一小段发现太累了，就停下来等公交。\n值得一提的是，我早上因为大意穿的是睡衣出门，走到一半才意识到，已经来不及回去换了。\n刚开始在地铁上感觉有点尴尬和不自在，但后来渐渐释怀了。\n我意识到上海是一座很大的城市，他很排外也很包容。\n上海的人都很忙，他们压根没精力去在意你，我怀疑我直接cos星野爱也没多少人在意我，更不用提一件睡衣。\n即使有人多看了你一眼，比起在内心折磨自己，不如直接微笑（恶心他人）来的从容。\n","permalink":"https://tassel234.github.io/posts/life/%E9%9D%92%E6%B5%A6%E5%9B%BE%E4%B9%A6%E9%A6%86%E6%B8%B8%E8%AE%B0/","summary":"正值暑假，又热又闷。 学校的图书馆周日不开放，学习任务也没有完成。 我今天本该在宿舍在宿舍睡觉吃饭学习，但因为前几周的经历，我意识到宿舍学习的效率是有一点惨不忍睹的。 考虑之下，我决定去青浦图书馆学习和旅行。 青浦图书馆坐落于青浦新城区夏阳湖上，有水上博物馆的美称，夏阳湖旁边是就是青浦博","title":"青浦图书馆游记"}]