<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>C&#43;&#43;入门学习笔记-2(数组，指针，结构体) | hrkr&#39;s Blog</title>
<meta name="keywords" content="">
<meta name="description" content="数组的定义和使用 （1）一维数组的定义、初始化、引用 使用数组，可以方便地定义一个名字（数组名）来表示大批量数据，并能够通过循环批处理大量数据。 一维数组是由元素类型、数组名和长度组成的构造类型。例如： int A[10], B[20]; // 元素是整型 常量表达式表示数组中元素的个数，称为数组长度。常量表达式的值必须为">
<meta name="author" content="hrkr">
<link rel="canonical" href="https://tassel234.github.io/posts/note/%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.js" onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://tassel234.github.io/img/">
<link rel="icon" type="image/png" sizes="16x16" href="https://tassel234.github.io/img/">
<link rel="icon" type="image/png" sizes="32x32" href="https://tassel234.github.io/img/">
<link rel="apple-touch-icon" href="https://tassel234.github.io/img/Q.jpg">
<link rel="mask-icon" href="https://tassel234.github.io/img/Q.jpg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="C&#43;&#43;入门学习笔记-2(数组，指针，结构体)" />
<meta property="og:description" content="数组的定义和使用 （1）一维数组的定义、初始化、引用 使用数组，可以方便地定义一个名字（数组名）来表示大批量数据，并能够通过循环批处理大量数据。 一维数组是由元素类型、数组名和长度组成的构造类型。例如： int A[10], B[20]; // 元素是整型 常量表达式表示数组中元素的个数，称为数组长度。常量表达式的值必须为" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://tassel234.github.io/posts/note/%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-27T23:39:05+08:00" />
<meta property="article:modified_time" content="2023-08-27T23:39:05+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="C&#43;&#43;入门学习笔记-2(数组，指针，结构体)"/>
<meta name="twitter:description" content="数组的定义和使用 （1）一维数组的定义、初始化、引用 使用数组，可以方便地定义一个名字（数组名）来表示大批量数据，并能够通过循环批处理大量数据。 一维数组是由元素类型、数组名和长度组成的构造类型。例如： int A[10], B[20]; // 元素是整型 常量表达式表示数组中元素的个数，称为数组长度。常量表达式的值必须为"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://tassel234.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "学习记录\u0026笔记",
      "item": "https://tassel234.github.io/posts/note/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "C++入门学习笔记-2(数组，指针，结构体)",
      "item": "https://tassel234.github.io/posts/note/%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "C++入门学习笔记-2(数组，指针，结构体)",
  "name": "C\u002b\u002b入门学习笔记-2(数组，指针，结构体)",
  "description": "数组的定义和使用 （1）一维数组的定义、初始化、引用 使用数组，可以方便地定义一个名字（数组名）来表示大批量数据，并能够通过循环批处理大量数据。 一维数组是由元素类型、数组名和长度组成的构造类型。例如： int A[10], B[20]; // 元素是整型 常量表达式表示数组中元素的个数，称为数组长度。常量表达式的值必须为",
  "keywords": [
    
  ],
  "articleBody": "数组的定义和使用 （1）一维数组的定义、初始化、引用 使用数组，可以方便地定义一个名字（数组名）来表示大批量数据，并能够通过循环批处理大量数据。\n一维数组是由元素类型、数组名和长度组成的构造类型。例如：\nint A[10], B[20]; // 元素是整型 常量表达式表示数组中元素的个数，称为数组长度。常量表达式的值必须为正整数且大于等于1。数组一经定义，数组长度就始终不变。定义中数组的值不能是变量。\n初值列表提供的元素个数不能超过数组长度，但可以小于数组长度。如果初值个数小于数组长度，则只初始化前面的数组元素，剩余元素初始化为0。\n可以用下面的表达式计算出数组A的长度：\nint A[]={1,8,9}; sizeof(A) / sizeof(int) 下标表达式可以是常量、变量、表达式，但必须是正整数，不允许为负。下标由0开始。整个数组不允许进行赋值运算、算术运算等操作，只有元素才可以。\n（2）二维数组的定义、初始化、引用 本质上，C++的多维数组都是一维数组。\nint A[2][3]={ {1,2,3},{4,5,6}};//初值按二维形式 int A[2][3]={ 1,2,3,4,5,6 };//初值按一维形式 初值列表提供的元素个数不能超过数组长度，但可以小于数组长度。如果初值个数小于数组长度，则只初始化前面的数组元素；剩余元素初始化为0。这个规则两种初始化形式都适用。\nint A[3][4]={{1},{1,2},{1,2,3}}; int A[3][4]={1,2,3,4,5}; 多维数组定义时可以不用指定第1维的数组长度，但其余维的长度必须指定，编译器会根据列出的元素个数自动确定第1维的长度。\nint A[][2][3]={1,2,3,4,5,6,7,8,9,10,11,12};//正确 int B[2][][3]={1,2,3,4,5,6,7,8,9,10,11,12};//错误，只能省略第1维 数组与函数 （1）数组作为函数的参数 x=max(c,-10); //使用变量或常数作为函数实参 x=max(A[2],-10); //使用数组元素作为函数实参 a[5]的a就是数组的首地址，可以作为参数传递到数组。如果实参使用数组名调用，本质上是将这个数组的首地址传递到形参中。这就造成了数组即使形式参数又是实际参数，（内存中 两个对象所处位置相同，则它们实为同一个对象）不像变量是生成副本，无法在函数体内修改它的值。\nvoid fun(int A[5],int n) { A[1]=100; //A[1]实质就是实参a[1] n=10; //赋值给形参n，不影响实参x } void caller() { int a[5]={1,2,3,4,5},x=5; fun(a,x); cout数组的定义中可以不写长度，写长或者写短都可以。而且名字可以不同，只有是数组就可以。（对一维数组而言）\n（2）数组参数的传递机制 既然形参数组就是实参数组，所以函数调用时不会为形参数组分配存储空间。\n多维数组作为函数的参数，形参数组第1维可以与实参相同，也可以不相同；可以是任意长度，也可以不写长度；但其他维的长度需要相同。\nvoid f(int A[5][10]); //正确 void f(int A[2][10]); //正确 void f(int A[][10]); //正确 void f(int A[][]); //错误，第2维长度必须给出 void f(int A[5][5]); //错误，第2维长度必须相同 void f(int A[50]); //错误，必须是二维数组 字符串的处理 （1）字符数组 char s[20]; //定义字符数组 char s[4]={'J','a','v','a'}; //字符数组初始化 C++语言规定字符串是以'\\0'（ASCII值为0）字符作为结束符的字符数组。C++总是在编译时为字符串常量自动在其后增加一个空字符。以定义字符数组时数组的长度至少为字符串长度加1（空字符也要占位）。\nchar c; char s[10]=“hello.”; c=‘a’; //正确 c=“a”; //错误 //因为使用\"\"会造成自动带一个空字符，数组的长度至少为2 （1）使用标准输入输出流，将整个字符串一次输入或输出\nchar str[80];//数组应该比较大 cin  str; //输入字符串 cout （2）使用字符串输入输出函数\nchar str[80]; gets(str); //输入字符串 char str[80]=\"Programming\"; puts(str); //输出字符串 （2）字符串处理函数 C++标准库提供了兼容C语言的字符串处理函数，其头文件为string.h。\n►（1）字符串复制函数strcpy char str1[10],str2[]=\"Computer\"; strcpy(str1,str2); //复制str2到str1 ►（2）字符串复制函数strncpy char str1[10], str2[]=\"Computer\"; strncpy(str1,str2,4);//复制str2的前4个字符到str1 ►（3）字符串连接函数strcat char str1[10]=\"ABC\", str2[]=\"123\"; strcat(str1,str2);//在str1后面连接str2,str2未变化 ►（4）字符串连接函数strncat char str1[10]=\"ABC\",str2[]=\"123456\"; strncat(str1,str2,4);//将str2前4个字符连接到str1后面 ►（5）字符串比较函数strcmp if (strcmp(str1,str2)==0)...... //比较字符串相等 if (strcmp(str1,str2)0)......//比较str1大于str2 ►（6）计算字符串长度函数 n=strlen(\"Language\"); //n=8 char str[20]=\"Visual Basic\"; n=strlen(str); //n=12 ►（7）字符串转换成数值函数 f=atof(\"123.456\"); //f=123.456 i=atoi(\"-456\"); //i=-456 （3）字符串对象 C++特有，使用string类型，比使用C风格字符串更方便、更安全。这样和python非常类似了。\n#include  //不能写为string.h char S2[20]=\"Java\"; //C风格字符串初始化 string str2=\"Java\"; //string对象复制初始化 string str3(\"C++\"); //string对象直接初始化 输入输出和上个章节类似。\nstr1=\"Java\"; //C风格字符串可以直接赋给string str1.c_str(); //string转换为C风格字符串，返回char指针 str1.copy(S1,n,pos); //把str1中从pos开始的n个字符复制到S1字符数组 （4）字符串对象的操作 string对象允许使用运算符进行操作，实现类似C风格字符串的处理。如复制（strcpy）、连接（strcat）、比较（strcmp）等。下面的这些运算和python非常类似了。\n字符串连接运算\nstr1=\"12\" , str2=\"AB\" , str3=\"CD\"; str1 = str2 + str3; //str1结果为ABCD str1 = str1 + \"PHP\"; //str1结果为12PHP str1 += str3; //str1结果为12CD 字符串关系运算\nstr1=\"ABC\" , str1=\"XYZ\"; str1  str2; //结果为假 str1 == str2; //结果为假 str1 == \"ABC\"; //结果为真 其他\nstr1=\"ABCDEFGHIJK\"; //获取字符串的长度 n = str1.size(); //n为11 n = str1.length(); //n为11 //检查字符串是否为空字符串 b = str1.empty(); //b为假 //得到子字符串 str2 = str1.substr(2,4); //从下标2开始的4个字符，str2为CDEF //查找子字符串 n = str1.find(\"DEF\",pos); //从pos开始查找字符串\"DEF\"在str1中的位置，n为3 //删除字符 str1.erase(3,5); //从下标3开始往后删5个字符，str1变为ABCIJK //增加字符 str1.append(\"12345\",1,3); //在str1末尾增加\"12345\"下标从1开始的3个字符，即\"234\" //字符串替换和插入操作 str1.replace(p0,n0,S1,n); //删除从p0开始的n0个字符，然后在p0处插入字符串S1前n个字符 str1.replace(p0,n0,str2,pos,n); //删除从p0开始的n0个字符，然后在p0处插入字符串str2中pos开始的前n个字符 str1.insert(p0,S1,n); //在p0位置插入字符串S1前n个字符 str1.insert(p0,str2,pos,n); //在p0位置插入字符串str2中pos开始的前n个字符 字符串对象数组\nstring SY[5]={\"123\",\"12\",\"1234\",\"1\",\"12345\"}; //长度 3,2,4,1,5 数组的应用 （1）用数组解决排序问题 冒泡排序 冒泡排序法（bubble sort）的基本思想是通过相邻两个记录之间的比较和交换，使关键码较小的记录逐渐从底部移向顶部。\n#include  using namespace std; #define N 10 //数组元素个数 int main() { int A[N], i, j, t; //注意数组下标从0开始 for (i=0; iA[i]; //输入N个数 for(j=0 ; jA[i+1]) //A[i]与A[i+1]比较 降序 t=A[i], A[i]=A[i+1], A[i+1]=t; //交换 for (i=0; i选择排序法 选择排序法（selection sort）的基本思想是第i趟选择排序通过n-i次关键码的比较，从n-i+1个记录中选出关键码最小的记录，并和第i个记录进行交换。\n#include  #include  using namespace std; void SelectionSort(int A[],int n) //选择排序 n为数组元素个数 { int i,j,k,t; for(i=0; i降序 if(i!=k) t=A[i], A[i]=A[k], A[k]=t; } } #define N 10 int main() { int A[N],i; srand((unsigned int)time(0)); //设置随机数种子 for(i=0; i（2）用数组解决查找问题 顺序查找法 就是这个比较，返回数组下标。\n#include  using namespace std; int Search(int A[],int n,int find) { //顺序查找 n=序列元素个数 find=欲查找数据 int i; for (i=0; ifind; i=Search(A,N,find); if(i=0) cout二分查找法 先排序，后查找\n#include  using namespace std; int BinarySearch(int A[],int n,int find) { //二分查找 n=序列元素个数 find=欲查找数据 int low,upper,mid; low=0 , upper=n-1; //左右两部分 while(lowfind) upper = mid - 1; //左半部分 else return mid; //找到 } return -1; //未找到 } #define N 10 int main() { int A[N]={8,24,30,47,62,68,83,90,92,95},i,find; cinfind; i=BinarySearch(A,N,find); if(i = 0) cout指针的定义与使用 （1）指针的定义 return语句只能返回一个值，即使有多个return也只还回第一个。加上数组也是只针对多个相同类型的数据，如果使用指针就可以想返回多少就返回多少。指针是两个函数进行数据交换必不可少的工具。\n 指针记录某一变量的地址，指针本身也有地址，存于特定的区域 int *pa=pb的写法正确，* 是间接寻址符或者叫取值符,可以理解为从pa指针取出的值是整形。但如果在声明中赋值也是可以的，因为pa在声明中也确实是指针，可以理解为把 *分配给了int，可以理解定义了一个指向int的指针，所以应该使用地址赋值，而不是数值赋值。 *pa单独出现代表了从pa指向的地址中取出来的值，前面要是加上int,char等声明，* pa就只是代表pa指针了。 int *pa;pa=\u0026a这样声明也可以 \u0026 是取地址运算符  由于指针数据的特殊性，其初始化和赋值运算是有约束条件的，只能使用以下四种值： （1）0值常量表达式\np1=null; //正确，指针允许0值常量表达式 p1=0; //正确，指针允许0值常量表达式 （2）相同指向类型的对象的地址。 （3）相同指向类型的另一个有效指针。例如：\nint x, *px=\u0026x; //正确 int *py=px; //正确，相同指向类型的另一个指针 （4）对象存储空间后面下一个有效地址，如数组下一个元素的地址。\nint a[10], *px=\u0026a[2]; //正确 int *py=\u0026a[++i]; //正确，相同指向类型的另一个指针 （2）指针的有效性和运算 无效的情况 如果指针的值为0，称为0值指针，又称空指针（null pointer），空指针是无效的。\n如果指针未经初始化，或者没有赋值，或者指针运算后指向未知对象，那么该指针是无效的。\n一个指针曾经指向一个已知对象，在对象的内存空间释放后，虽然该指针仍是原来的内存地址，但指针所指已是未知对象，称为“迷途指针”\n如果指针的位置停留在未知的位置，那么修改指针的值有可能造成重要的数据被修改。\n指针的运算 （1）指针加减整数运算\nint x[10], n=3 , *p=\u0026x[5]; p+1 //指向存储空间中x[5]后面的第1个int型存储单元 p+n //指向存储空间中x[5]后面的第n(3)个int型存储单元 p-1 //指向存储空间中x[5]前面的第1个int型存储单元 p-n //指向存储空间中x[5]前面的第n(3)个int型存储单元 （2）指针变量自增自减运算\nint x[10], *p=\u0026x[5]; p++ //p指向x[5]后面的第1个int型内存单元 ++p //p指向x[5]后面的第1个int型内存单元 p-- //p指向x[5]前面的第1个int型内存单元 --p //p指向x[5]前面的第1个int型内存单元 （3）两个指针相减运算\nint x[5], *p1=\u0026x[0], *p2=\u0026x[4]; int n; n=p2-p1;//n的值为4 （4）指针的关系运算 即比较地址数据的大小，位置的前后。\nconst的三种 主要应用领域是让实参于函数中不可修改 单const\nconst int *p//代表不可以改变变量的值，但是可以改变指针指向， //实际编程中，指向const的指针常用作函数的形参，以此确保传递给函数的实参对象在函数中不被修改。 int *const pc=\u0026a//代表地址不可以改了，但数值可以改 双const\nconst int *const cpc=\u0026b\n指针与数组 一维数组与指针 数组名既代表数组本身，又代表整个数组的地址，还是是数组首元素的地址值.\nint a[10], b[10], c[10]; a=b; //错误，a是常量不能出现在左值的位置 c=a+b; //错误，a、b是地址值，不允许加法运算 a++; //错误，a是常量不能使用++运算 int a[]; int *p p=a//数组的名称就代表了地址 pb=\u0026a[0]//a[0]就是变量了，要用取地址运算符 *(a+i) *(p+i) 上述代码都是成立的\n区别  指针并不能被赋予常量的值int *p,p=2//是错的 指针所存储的是变量的地址值，指针可以进行数加减，自增，自减；相减时值得注意，间隔几个元素取决他的类型。也可以进行关系运算 数组的数组名不可以进行这些操作  （1）使用下标法访问数组元素，程序写法比较直观，能直接知道访问的是第几个元素。\n（2）而使用指针引用法，指针变量直接指向元素，不必每次都重新计算地址，能提高运行效率。\n（3）将自增和自减运算用于指针变量十分有效，可以使指针变量自动向前或向后指向数组的下一个或前一个元素。\n指针写起来更简捷一些\n（2）指针与字符串 char *p=\"C Language\"; //或者 char *p; p=\"C Language\"; 访问\nchar str[]=\"C Language\", *p=str; //p指向字符串的指针 cout遍历\nchar str[]=\"C Language\" , *p=str; //p指向字符串的指针 while (*p!='\\0') cout指针与函数 （1）指针作为函数的参数 指针是函数参数传递的重要工具。比如swap交换函数要使用指针，直接使用变量会生成副本。通过将指针作为函数参数的方法，既可以返回多个运算结果，又避免了使用全局变量。\n（2）数组作为函数的参数 数组同样是直接使用地址，不使用副本，直接修改原数组数据。将一个字符串传递到函数中，传递的是地址，则函数形参既可以用字符数组，又可以用指针变量，两种形式完全等价。在子函数中可以修改字符串的内容，主调函数得到的是变化后的字符串。\n（3）引用 引用类型是结合了数组和指针的优点，不在C语言中，而属于C++的一个特性。\n 引用类型自带const限定，引用一旦被初始化，就不能改变引用关系，不能再作为其他对象的引用。 初始化是必定要绑定赋值，不能为空 写法是int x;\u0026r=x  int x, \u0026r=x; //定义整型变量x,y int *p1=\u0026x; //p1指向x int *p2=\u0026r; //p2指向r，本质上指向x //程序① 传递对象本身 #include  using namespace std; //对象作为函数形参 void swap(int a,int b) { int t; t=a, a=b, b=t; } int main() { int x=10, y=20; swap(x,y); 12 coutusing namespace std; //指针作为函数形参 void swap(int *a,int *b) { int t; t=*a, *a=*b, *b=t; } int main() { int x=10, y=20; swap(\u0026x,\u0026y); coutusing namespace std; //引用作为函数形参 void swap(int \u0026a,int \u0026b) { int t; t=a, a=b, b=t; } int main() { int x=10, y=20; swap(x,y); cout（4）指向函数的指针 函数代码在内存中也要占据一段存储空间（代码区内），这段存储空间的起始地址称为函数入口地址。C++规定函数入口地址为函数的指针，即函数名既代表函数，又是函数的指针（或地址）。\nC++允许定义指向函数的指针变量，定义形式为：\nint (*p)(int a, int b); //定义函数指针变量 int max(int a, int b); //max函数原型 int min(int a, int b); //min函数原型 int (*p)(int a, int b); //定义函数指针变量 p=max; c=p(a,b); //等价于c=max(a,b); 变为动态方式调用。熟练掌握函数指针的应用，有利于程序的模块化设计，提高程序的可扩展性。\n动态分配内存 （1）new与delete运算符 数据类型* 指针名称 = new 数据类型 int* p = new int delete p; 可以拓展到结构体或类\n动态分配是根据程序的需要适时分配，且分配的大小就是程序要求的大小。分配的空间可以根据程序的需要扩大或缩小；\nnew 动态分配\nnew [] 动态分配数组\ndelete 释放空间\ndelete [] 释放数组空间\n（2）动态内存的应用 ►（1）静态内存管理由编译器进行，而动态内存管理按程序员人为的指令进行。\n►（2）动态内存分配和释放必须对应，即有分配就必须有释放，后果是随着程序运行多次，可以使用的内存空间越来越少.\n► （3）动态分配内存的生命期由程序员决定，即从分配时开始，至释放时结束。特别地，动态分配内存的生命期允许跨多个函数。\n►（4）避免释放内存后出现“迷途指针”，应及时设置为空指针。\n#include  using namespace std; int *f1(int n) //分配n个整型内存，返回首地址 { int *p, i; p = new int[n]; //分配 for (i=0; i0) coutint *f1(int n)返回指针的函数\n（3）动态分配数组 #include  using namespace std; double AVE(double *A,int N) //计算N*N二维数组元素的平均值 { int i,j,sum=0; for(i=0;in; double *A=new double[n*n]; //分配“数组”A[n][n] for (i=0;i*(A+i*n+j); //输入数据到A[i][j] cout（4）动态分配字符串 char *p=new char[1000]; //分配字符串空间 cinp; //输入字符串 cout结构体 基本知识 #include using namespace std; int main() { cout 结构体声明一般放在开头，也可以放在main的外面。大概等价于数据类型的定义和声明，也不会在声明中分配存储空间，实例化才会分配存储空间，空间是连续按顺序的。 可以放在函数内部，但此时这个声明是局部的，而不是全局的。 结构体对象可以赋值，但不可以算数和比较运算。  结构体和指针的关系 #include using namespace std; int main() { coutsexpbirthday-year=2008; p-sex='w'; cout结构体和数组的关系 如同声明int,char数组，可以用结构体进行声明。用这个方法可以表示几何的点。\n#include using namespace std; struct staff{ int no; char name[21]; double salary; }a[3],t; int main() { couta[i].name a[i].no a[i].salary; for (i=0;i结构体和函数的关系 就像传int类型等，直接传递进去，在函数内部进行各种操作。 对结构体数组进行传递，是对首地址进行传入。\n共用体  对于实体对象，分配的存储空间是成员内存的最大值。 定义和结构体的定义和引用相似。使用union定义，   修改一个成员的值会让其他值都改变 成员的首地址相同，所有成员的值相同，不同成员所用到的内存长度有差异  枚举类型(enum)  定义都是相似的 必须是指定值 枚举常量是右值不是左值  没有给定值时从0往后排\nenum COLORS {RED=10,GREEN=8,BLUE,BLACK,WHITE}; //RED为10、GREEN为8、BLUE为9、BLACK为10、WHITE为11。 RED=10; //错误，RED不是左值，不能被赋值 GREEN++; //错误，GREEN不是左值，不能自增自减 enum DIRECTION {LEFT,UP,RIGHT,DOWN,BEFORE,BACK} dir=LEFT; typedef 就是把一个结构的名字进行更改\n自定义数据类型的应用——链表 基础知识 链表主要用于两个目的：一是建立不定长度的数组。二是链表可以 在不重新安排整个存储结构的情况下，方便且迅速地插入和删除数 据元素。\nstruct NODE { //结点数据类型 ElemType data; //数据域 NODE *link; //指针域 }; 首先设计一种称为结点（node）的数据类型： 这个结构体类型中，data成员表示数据域，代表结点的数据信息。\nElemType可以是简单的内置数据类型，也可以是复杂的数据类型， 如\ntypedef struct tagElemType { //复杂的数据元素类型 ...... //任意数目、任意组合、任意类型的数据成员 } ElemType; 数据域是链表中的信息对象（元素），实际应用中结合具体要求设 计其数据类型。为方便介绍，将ElemType简单设定为int型，即\ntypedef int ElemType; //简单的数据元素类型 link成员表示指针域，存放另一个结点的地址，是链表中的组织者。 假定有一个NODE类型的对象指针L，将一个新结点的地址赋给L的 link成员，则L可以通过它的link成员“链接”到新结点上，重复这 个过程可以得到链表结构。\n链表的类型 struct LNode { //单链表结点类型 ElemType data; //数据域\nLNode *next; //指针域：指向直接后继结点 }; typedef LNode* LinkList; //LNode为单链表结构体类型， LinkList为单链表指针类型\n此外还有双链表和循环链表\n创建单链表 创建链表常用两种方法：头插法和尾插法。\n头插法 #include  using namespace std; typedef int ElemType; //简单的数据元素类型 struct LNode { //单链表结点类型 ElemType data; //数据域 LNode *next; //指针域：指向直接后继结点 }; typedef LNode* LinkList; //LNode为单链表结构体类型，LinkList为单链表指针类型 void input(ElemType *ep) //实现数据域元素输入的定制函数 { //在函数中可以写更加复杂、任意形式、任意数目的输入 cin*ep; } void CreateLinkF(LinkList *L,int n,void(*input)(ElemType*)) { //头插法创建单链表，调用input输入函数输入数据 LinkList s; *L=new LNode;//创建头结点 (*L)-next=NULL; //初始时为空表 for (; n0; n--) { //创建n个结点链表 s=new LNode; //创建新结点 input(\u0026s-data); //调用input输入数据域 s-next=(*L)-next; //将s增加到开始结点之前 (*L)-next=s; //头结点之后 } } int main() { LinkList L; int n; cinn; CreateLinkF(\u0026L,n,input); } 尾插法 #include  using namespace std; typedef int ElemType; //简单的数据元素类型 struct LNode { //单链表结点类型 ElemType data; //数据域 LNode *next; //指针域：指向直接后继结点 }; typedef LNode* LinkList; //LNode为单链表结构体类型，LinkList为单链表指针类型 void input(ElemType *ep) //实现数据域元素输入的定制函数 { //在函数中可以写更加复杂、任意形式、任意数目的输入 cin*ep; } void CreateLinkR(LinkList *L,int n,void(*input)(ElemType*)) { //尾插法创建单链表，调用input输入函数输入数据 LinkList p,s; p=*L=new LNode; //创建头结点 for (; n0; n--) { //创建n个结点链表 s=new LNode; //创建新结点 input(\u0026s-data); //调用input输入数据域 p-next=s, p=s; //将s插入到当前链表末尾 } p-next=NULL; //尾结点 } int main() { LinkList L; int n; cinn; CreateLinkR(\u0026L,n,input); } 链表的撤销 void DestroyList(LinkList *L) //销毁单链表L { LinkList q,p=*L; //p指向头结点 while(p!=NULL) { //若不是链尾继续 q=p-next; //指向直接后继结点 delete p; //释放结点存储空间 p=q; //直接后继结点 } *L=NULL; //置为空表 链表的运算 链表的遍历 即p=p-next\n查找节点 int compare(ElemType *ep1,ElemType *ep2) //实现两个数据元素关系比较的定制函数 {//在函数中对数据元素进行定制的关系比较，如相等，大于或小于 if (*ep1==*ep2) return 1; //满足相等关系返回真（1） return 0; //不满足关系返回假（0） int LocateElem(LinkList L,ElemType e, int(*compare)(ElemType*,ElemType*)) {//返回L中第1个与e满足关系compare()的元素的位序 int i=0; LinkList p=L-next; //p指向开始结点 while(p!=NULL) { //若不是链尾继续 i++; //记录结点的位序 if(compare(\u0026(p-data),\u0026e)) return i; p=p-next; //指向直接后继结点 } return 0; //关系不存在返回0 插入节点 int ListInsert(LinkList *L,int i,ElemType e) { //在第i个位置之前插入元素e LinkList s,p=*L; //p指向头结点 while(p!=NULL \u0026\u0026 i1) { //寻找第i-1个结点 p=p-next; //p指向直接后继结点 i--; } if(p==NULL||idata=e; //插入L中 s-next=p-next, p-next=s; //结点插入算法 return 1; //操作成功返回真（1） 删除节点 int ListDelete(LinkList *L,int i,ElemType *ep) { //删除第i个结点,并由*ep返回其值 LinkList p=NULL,q=*L; //q指向头结点 while(q!=NULL \u0026\u0026 i=1) { //直到第i个结点 p=q; //p是q的前驱 q=q-next; //q指向直接后继结点 i--; } if(p==NULL||q==NULL) return 0;//i值不合法返回假（0） p-next=q-next; //结点删除算法 if(ep!=NULL) *ep=q-data; //删除结点由*ep返回其值 delete q; //释放结点 return 1; //操作成功返回真（1） ",
  "wordCount" : "8933",
  "inLanguage": "en",
  "datePublished": "2023-08-27T23:39:05+08:00",
  "dateModified": "2023-08-27T23:39:05+08:00",
  "author":{
    "@type": "Person",
    "name": "hrkr"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://tassel234.github.io/posts/note/%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "hrkr's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://tassel234.github.io/img/"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://tassel234.github.io/" accesskey="h" title="hrkr&#39;s Blog (Alt + H)">
                <img src="https://tassel234.github.io/img/Q.jpg" alt="" aria-label="logo"
                    height="35">hrkr&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://tassel234.github.io/search" title="🔍 搜索 (Alt &#43; /)" accesskey=/>
                    <span>🔍 搜索</span>
                </a>
            </li>
            <li>
                <a href="https://tassel234.github.io/" title="🏠 主页">
                    <span>🏠 主页</span>
                </a>
            </li>
            <li>
                <a href="https://tassel234.github.io/posts" title="📚 文章">
                    <span>📚 文章</span>
                </a>
            </li>
            <li>
                <a href="https://tassel234.github.io/tags" title="🧩 标签">
                    <span>🧩 标签</span>
                </a>
            </li>
            <li>
                <a href="https://tassel234.github.io/archives/" title="⏱️ 时间轴">
                    <span>⏱️ 时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://tassel234.github.io/about" title="🙋🏻‍♂️ 关于">
                    <span>🙋🏻‍♂️ 关于</span>
                </a>
            </li>
            <li>
                <a href="https://tassel234.github.io/links" title="🤝 友链">
                    <span>🤝 友链</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://tassel234.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://tassel234.github.io/posts/">Posts</a>&nbsp;»&nbsp;<a href="https://tassel234.github.io/posts/note/">学习记录&amp;笔记</a></div>
    <h1 class="post-title">
      C&#43;&#43;入门学习笔记-2(数组，指针，结构体)
    </h1>
    <div class="post-meta"><span title='2023-08-27 23:39:05 +0800 CST'>2023-08-27</span>&nbsp;·&nbsp;18 min&nbsp;·&nbsp;hrkr

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e6%95%b0%e7%bb%84%e7%9a%84%e5%ae%9a%e4%b9%89%e5%92%8c%e4%bd%bf%e7%94%a8" aria-label="数组的定义和使用">数组的定义和使用</a><ul>
                        
                <li>
                    <a href="#1%e4%b8%80%e7%bb%b4%e6%95%b0%e7%bb%84%e7%9a%84%e5%ae%9a%e4%b9%89%e5%88%9d%e5%a7%8b%e5%8c%96%e5%bc%95%e7%94%a8" aria-label="（1）一维数组的定义、初始化、引用">（1）一维数组的定义、初始化、引用</a></li>
                <li>
                    <a href="#2%e4%ba%8c%e7%bb%b4%e6%95%b0%e7%bb%84%e7%9a%84%e5%ae%9a%e4%b9%89%e5%88%9d%e5%a7%8b%e5%8c%96%e5%bc%95%e7%94%a8" aria-label="（2）二维数组的定义、初始化、引用">（2）二维数组的定义、初始化、引用</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%95%b0%e7%bb%84%e4%b8%8e%e5%87%bd%e6%95%b0" aria-label="数组与函数">数组与函数</a><ul>
                        
                <li>
                    <a href="#1%e6%95%b0%e7%bb%84%e4%bd%9c%e4%b8%ba%e5%87%bd%e6%95%b0%e7%9a%84%e5%8f%82%e6%95%b0" aria-label="（1）数组作为函数的参数">（1）数组作为函数的参数</a></li>
                <li>
                    <a href="#2%e6%95%b0%e7%bb%84%e5%8f%82%e6%95%b0%e7%9a%84%e4%bc%a0%e9%80%92%e6%9c%ba%e5%88%b6" aria-label="（2）数组参数的传递机制">（2）数组参数的传递机制</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%ad%97%e7%ac%a6%e4%b8%b2%e7%9a%84%e5%a4%84%e7%90%86" aria-label="字符串的处理">字符串的处理</a><ul>
                        
                <li>
                    <a href="#1%e5%ad%97%e7%ac%a6%e6%95%b0%e7%bb%84" aria-label="（1）字符数组">（1）字符数组</a></li>
                <li>
                    <a href="#2%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%a4%84%e7%90%86%e5%87%bd%e6%95%b0" aria-label="（2）字符串处理函数">（2）字符串处理函数</a></li>
                <li>
                    <a href="#3%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%af%b9%e8%b1%a1" aria-label="（3）字符串对象">（3）字符串对象</a></li>
                <li>
                    <a href="#4%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%af%b9%e8%b1%a1%e7%9a%84%e6%93%8d%e4%bd%9c" aria-label="（4）字符串对象的操作">（4）字符串对象的操作</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%95%b0%e7%bb%84%e7%9a%84%e5%ba%94%e7%94%a8" aria-label="数组的应用">数组的应用</a><ul>
                        
                <li>
                    <a href="#1%e7%94%a8%e6%95%b0%e7%bb%84%e8%a7%a3%e5%86%b3%e6%8e%92%e5%ba%8f%e9%97%ae%e9%a2%98" aria-label="（1）用数组解决排序问题">（1）用数组解决排序问题</a><ul>
                        
                <li>
                    <a href="#%e5%86%92%e6%b3%a1%e6%8e%92%e5%ba%8f" aria-label="冒泡排序">冒泡排序</a></li>
                <li>
                    <a href="#%e9%80%89%e6%8b%a9%e6%8e%92%e5%ba%8f%e6%b3%95" aria-label="选择排序法">选择排序法</a></li></ul>
                </li>
                <li>
                    <a href="#2%e7%94%a8%e6%95%b0%e7%bb%84%e8%a7%a3%e5%86%b3%e6%9f%a5%e6%89%be%e9%97%ae%e9%a2%98" aria-label="（2）用数组解决查找问题">（2）用数组解决查找问题</a><ul>
                        
                <li>
                    <a href="#%e9%a1%ba%e5%ba%8f%e6%9f%a5%e6%89%be%e6%b3%95" aria-label="顺序查找法">顺序查找法</a></li>
                <li>
                    <a href="#%e4%ba%8c%e5%88%86%e6%9f%a5%e6%89%be%e6%b3%95" aria-label="二分查找法">二分查找法</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e6%8c%87%e9%92%88%e7%9a%84%e5%ae%9a%e4%b9%89%e4%b8%8e%e4%bd%bf%e7%94%a8" aria-label="指针的定义与使用">指针的定义与使用</a><ul>
                        
                <li>
                    <a href="#1%e6%8c%87%e9%92%88%e7%9a%84%e5%ae%9a%e4%b9%89" aria-label="（1）指针的定义">（1）指针的定义</a></li>
                <li>
                    <a href="#2%e6%8c%87%e9%92%88%e7%9a%84%e6%9c%89%e6%95%88%e6%80%a7%e5%92%8c%e8%bf%90%e7%ae%97" aria-label="（2）指针的有效性和运算">（2）指针的有效性和运算</a><ul>
                        
                <li>
                    <a href="#%e6%97%a0%e6%95%88%e7%9a%84%e6%83%85%e5%86%b5" aria-label="无效的情况">无效的情况</a></li>
                <li>
                    <a href="#%e6%8c%87%e9%92%88%e7%9a%84%e8%bf%90%e7%ae%97" aria-label="指针的运算">指针的运算</a></li>
                <li>
                    <a href="#const%e7%9a%84%e4%b8%89%e7%a7%8d" aria-label="const的三种">const的三种</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e6%8c%87%e9%92%88%e4%b8%8e%e6%95%b0%e7%bb%84" aria-label="指针与数组">指针与数组</a><ul>
                        
                <li>
                    <a href="#%e4%b8%80%e7%bb%b4%e6%95%b0%e7%bb%84%e4%b8%8e%e6%8c%87%e9%92%88" aria-label="一维数组与指针">一维数组与指针</a></li>
                <li>
                    <a href="#%e5%8c%ba%e5%88%ab" aria-label="区别">区别</a></li>
                <li>
                    <a href="#2%e6%8c%87%e9%92%88%e4%b8%8e%e5%ad%97%e7%ac%a6%e4%b8%b2" aria-label="（2）指针与字符串">（2）指针与字符串</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%8c%87%e9%92%88%e4%b8%8e%e5%87%bd%e6%95%b0" aria-label="指针与函数">指针与函数</a><ul>
                        
                <li>
                    <a href="#1%e6%8c%87%e9%92%88%e4%bd%9c%e4%b8%ba%e5%87%bd%e6%95%b0%e7%9a%84%e5%8f%82%e6%95%b0" aria-label="（1）指针作为函数的参数">（1）指针作为函数的参数</a></li>
                <li>
                    <a href="#2%e6%95%b0%e7%bb%84%e4%bd%9c%e4%b8%ba%e5%87%bd%e6%95%b0%e7%9a%84%e5%8f%82%e6%95%b0" aria-label="（2）数组作为函数的参数">（2）数组作为函数的参数</a></li>
                <li>
                    <a href="#3%e5%bc%95%e7%94%a8" aria-label="（3）引用">（3）引用</a></li>
                <li>
                    <a href="#4%e6%8c%87%e5%90%91%e5%87%bd%e6%95%b0%e7%9a%84%e6%8c%87%e9%92%88" aria-label="（4）指向函数的指针">（4）指向函数的指针</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%8a%a8%e6%80%81%e5%88%86%e9%85%8d%e5%86%85%e5%ad%98" aria-label="动态分配内存">动态分配内存</a><ul>
                        
                <li>
                    <a href="#1new%e4%b8%8edelete%e8%bf%90%e7%ae%97%e7%ac%a6" aria-label="（1）new与delete运算符">（1）new与delete运算符</a></li>
                <li>
                    <a href="#2%e5%8a%a8%e6%80%81%e5%86%85%e5%ad%98%e7%9a%84%e5%ba%94%e7%94%a8" aria-label="（2）动态内存的应用">（2）动态内存的应用</a></li>
                <li>
                    <a href="#3%e5%8a%a8%e6%80%81%e5%88%86%e9%85%8d%e6%95%b0%e7%bb%84" aria-label="（3）动态分配数组">（3）动态分配数组</a></li>
                <li>
                    <a href="#4%e5%8a%a8%e6%80%81%e5%88%86%e9%85%8d%e5%ad%97%e7%ac%a6%e4%b8%b2" aria-label="（4）动态分配字符串">（4）动态分配字符串</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%bb%93%e6%9e%84%e4%bd%93" aria-label="结构体">结构体</a><ul>
                        
                <li>
                    <a href="#%e5%9f%ba%e6%9c%ac%e7%9f%a5%e8%af%86" aria-label="基本知识">基本知识</a></li>
                <li>
                    <a href="#%e7%bb%93%e6%9e%84%e4%bd%93%e5%92%8c%e6%8c%87%e9%92%88%e7%9a%84%e5%85%b3%e7%b3%bb" aria-label="结构体和指针的关系">结构体和指针的关系</a></li>
                <li>
                    <a href="#%e7%bb%93%e6%9e%84%e4%bd%93%e5%92%8c%e6%95%b0%e7%bb%84%e7%9a%84%e5%85%b3%e7%b3%bb" aria-label="结构体和数组的关系">结构体和数组的关系</a></li>
                <li>
                    <a href="#%e7%bb%93%e6%9e%84%e4%bd%93%e5%92%8c%e5%87%bd%e6%95%b0%e7%9a%84%e5%85%b3%e7%b3%bb" aria-label="结构体和函数的关系">结构体和函数的关系</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%85%b1%e7%94%a8%e4%bd%93" aria-label="共用体">共用体</a></li>
                <li>
                    <a href="#%e6%9e%9a%e4%b8%be%e7%b1%bb%e5%9e%8benum" aria-label="枚举类型(enum)">枚举类型(enum)</a></li>
                <li>
                    <a href="#typedef" aria-label="typedef">typedef</a></li>
                <li>
                    <a href="#%e8%87%aa%e5%ae%9a%e4%b9%89%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b%e7%9a%84%e5%ba%94%e7%94%a8%e9%93%be%e8%a1%a8" aria-label="自定义数据类型的应用——链表">自定义数据类型的应用——链表</a><ul>
                        
                <li>
                    <a href="#%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86" aria-label="基础知识">基础知识</a></li>
                <li>
                    <a href="#%e9%93%be%e8%a1%a8%e7%9a%84%e7%b1%bb%e5%9e%8b" aria-label="链表的类型">链表的类型</a></li>
                <li>
                    <a href="#%e5%88%9b%e5%bb%ba%e5%8d%95%e9%93%be%e8%a1%a8" aria-label="创建单链表">创建单链表</a><ul>
                        
                <li>
                    <a href="#%e5%a4%b4%e6%8f%92%e6%b3%95" aria-label="头插法">头插法</a></li>
                <li>
                    <a href="#%e5%b0%be%e6%8f%92%e6%b3%95" aria-label="尾插法">尾插法</a></li>
                <li>
                    <a href="#%e9%93%be%e8%a1%a8%e7%9a%84%e6%92%a4%e9%94%80" aria-label="链表的撤销">链表的撤销</a></li></ul>
                </li>
                <li>
                    <a href="#%e9%93%be%e8%a1%a8%e7%9a%84%e8%bf%90%e7%ae%97" aria-label="链表的运算">链表的运算</a><ul>
                        
                <li>
                    <a href="#%e9%93%be%e8%a1%a8%e7%9a%84%e9%81%8d%e5%8e%86" aria-label="链表的遍历">链表的遍历</a></li>
                <li>
                    <a href="#%e6%9f%a5%e6%89%be%e8%8a%82%e7%82%b9" aria-label="查找节点">查找节点</a></li>
                <li>
                    <a href="#%e6%8f%92%e5%85%a5%e8%8a%82%e7%82%b9" aria-label="插入节点">插入节点</a></li>
                <li>
                    <a href="#%e5%88%a0%e9%99%a4%e8%8a%82%e7%82%b9" aria-label="删除节点">删除节点</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="数组的定义和使用">数组的定义和使用<a hidden class="anchor" aria-hidden="true" href="#数组的定义和使用">#</a></h2>
<h3 id="1一维数组的定义初始化引用">（1）一维数组的定义、初始化、引用<a hidden class="anchor" aria-hidden="true" href="#1一维数组的定义初始化引用">#</a></h3>
<p>使用数组，可以方便地定义一个名字（数组名）来表示大批量数据，并能够通过循环批处理大量数据。</p>
<p>一维数组是由元素类型、数组名和长度组成的构造类型。例如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">int A[10], B[20]; // 元素是整型
</code></pre></div><p>常量表达式表示数组中元素的个数，称为数组长度。常量表达式的值必须为正整数且大于等于1。数组一经定义，数组长度就始终不变。定义中数组的值不能是变量。</p>
<p>初值列表提供的元素个数不能超过数组长度，但可以小于数组长度。如果初值个数小于数组长度，则只初始化前面的数组元素，剩余元素初始化为0。</p>
<p>可以用下面的表达式计算出数组A的长度：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">int A[]={1,8,9};
sizeof(A) / sizeof(int)
</code></pre></div><p>下标表达式可以是常量、变量、表达式，但必须是正整数，不允许为负。下标由0开始。整个数组不允许进行赋值运算、算术运算等操作，只有元素才可以。</p>
<h3 id="2二维数组的定义初始化引用">（2）二维数组的定义、初始化、引用<a hidden class="anchor" aria-hidden="true" href="#2二维数组的定义初始化引用">#</a></h3>
<p>本质上，C++的多维数组都是一维数组。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">int A[2][3]={ {1,2,3},{4,5,6}};//初值按二维形式
int A[2][3]={ 1,2,3,4,5,6 };//初值按一维形式

</code></pre></div><p>初值列表提供的元素个数不能超过数组长度，但可以小于数组长度。如果初值个数小于数组长度，则只初始化前面的数组元素；剩余元素初始化为0。这个规则两种初始化形式都适用。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">int A[3][4]={{1},{1,2},{1,2,3}};
int A[3][4]={1,2,3,4,5};
</code></pre></div><p>多维数组定义时可以不用指定第1维的数组长度，但其余维的长度必须指定，编译器会根据列出的元素个数自动确定第1维的长度。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">int A[][2][3]={1,2,3,4,5,6,7,8,9,10,11,12};//正确
int B[2][][3]={1,2,3,4,5,6,7,8,9,10,11,12};//错误，只能省略第1维
</code></pre></div><h2 id="数组与函数">数组与函数<a hidden class="anchor" aria-hidden="true" href="#数组与函数">#</a></h2>
<h3 id="1数组作为函数的参数">（1）数组作为函数的参数<a hidden class="anchor" aria-hidden="true" href="#1数组作为函数的参数">#</a></h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">x=max(c,-10); //使用变量或常数作为函数实参
x=max(A[2],-10); //使用数组元素作为函数实参
</code></pre></div><p>a[5]的a就是数组的首地址，可以作为参数传递到数组。如果实参使用数组名调用，本质上是将这个数组的首地址传递到形参中。这就造成了数组即使形式参数又是实际参数，（内存中
两个对象所处位置相同，则它们实为同一个对象）不像变量是生成副本，无法在函数体内修改它的值。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">void fun(int A[5],int n)
{
 A[1]=100; //A[1]实质就是实参a[1]
 n=10; //赋值给形参n，不影响实参x
}
void caller()
{
 int a[5]={1,2,3,4,5},x=5;
 fun(a,x);
 cout&lt;&lt;a[1]&lt;&lt;“,“&lt;&lt;x&lt;&lt;endl; //a[1]=100,x=5
}

</code></pre></div><p>数组的定义中可以不写长度，写长或者写短都可以。而且名字可以不同，只有是数组就可以。（对一维数组而言）</p>
<h3 id="2数组参数的传递机制">（2）数组参数的传递机制<a hidden class="anchor" aria-hidden="true" href="#2数组参数的传递机制">#</a></h3>
<p>既然形参数组就是实参数组，所以函数调用时不会为形参数组分配存储空间。</p>
<p>多维数组作为函数的参数，形参数组第1维可以与实参相同，也可以不相同；可以是任意长度，也可以不写长度；但其他维的长度需要相同。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">void f(int A[5][10]); //正确
void f(int A[2][10]); //正确
void f(int A[][10]); //正确
void f(int A[][]); //错误，第2维长度必须给出
void f(int A[5][5]); //错误，第2维长度必须相同
void f(int A[50]); //错误，必须是二维数组

</code></pre></div><h2 id="字符串的处理">字符串的处理<a hidden class="anchor" aria-hidden="true" href="#字符串的处理">#</a></h2>
<h3 id="1字符数组">（1）字符数组<a hidden class="anchor" aria-hidden="true" href="#1字符数组">#</a></h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">char s[20]; //定义字符数组
char s[4]={&#39;J&#39;,&#39;a&#39;,&#39;v&#39;,&#39;a&#39;}; //字符数组初始化
</code></pre></div><p>C++语言规定字符串是以'\0'（ASCII值为0）字符作为结束符的字符数组。C++总是在编译时为字符串常量自动在其后增加一个空字符。以定义字符数组时数组的长度至少为字符串长度加1（空字符也要占位）。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">char c; char s[10]=“hello.”;
c=‘a’; //正确 c=“a”; //错误
//因为使用&#34;&#34;会造成自动带一个空字符，数组的长度至少为2
</code></pre></div><p>（1）使用标准输入输出流，将整个字符串一次输入或输出</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">char str[80];//数组应该比较大
cin &gt;&gt; str; //输入字符串
cout &lt;&lt; str; //输出字符串
</code></pre></div><p>（2）使用字符串输入输出函数</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">char str[80];
gets(str); //输入字符串
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">char str[80]=&#34;Programming&#34;;
puts(str); //输出字符串
</code></pre></div><h3 id="2字符串处理函数">（2）字符串处理函数<a hidden class="anchor" aria-hidden="true" href="#2字符串处理函数">#</a></h3>
<p>C++标准库提供了兼容C语言的字符串处理函数，其头文件为string.h。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">►（1）字符串复制函数strcpy
char str1[10],str2[]=&#34;Computer&#34;;
strcpy(str1,str2); //复制str2到str1
►（2）字符串复制函数strncpy
char str1[10], str2[]=&#34;Computer&#34;;
strncpy(str1,str2,4);//复制str2的前4个字符到str1
►（3）字符串连接函数strcat
char str1[10]=&#34;ABC&#34;, str2[]=&#34;123&#34;;
strcat(str1,str2);//在str1后面连接str2,str2未变化
►（4）字符串连接函数strncat
char str1[10]=&#34;ABC&#34;,str2[]=&#34;123456&#34;;
strncat(str1,str2,4);//将str2前4个字符连接到str1后面
►（5）字符串比较函数strcmp
if (strcmp(str1,str2)==0)...... //比较字符串相等
if (strcmp(str1,str2)&gt;0)......//比较str1大于str2
►（6）计算字符串长度函数
n=strlen(&#34;Language&#34;); //n=8
char str[20]=&#34;Visual Basic&#34;;
n=strlen(str); //n=12
►（7）字符串转换成数值函数
f=atof(&#34;123.456&#34;); //f=123.456
i=atoi(&#34;-456&#34;); //i=-456
</code></pre></div><h3 id="3字符串对象">（3）字符串对象<a hidden class="anchor" aria-hidden="true" href="#3字符串对象">#</a></h3>
<p>C++特有，使用string类型，比使用C风格字符串更方便、更安全。这样和python非常类似了。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">#include &lt;string&gt; //不能写为string.h
char S2[20]=&#34;Java&#34;; //C风格字符串初始化
string str2=&#34;Java&#34;; //string对象复制初始化
string str3(&#34;C++&#34;); //string对象直接初始化

</code></pre></div><p>输入输出和上个章节类似。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">str1=&#34;Java&#34;; 
//C风格字符串可以直接赋给string
str1.c_str();
//string转换为C风格字符串，返回char指针
str1.copy(S1,n,pos);
//把str1中从pos开始的n个字符复制到S1字符数组

</code></pre></div><h3 id="4字符串对象的操作">（4）字符串对象的操作<a hidden class="anchor" aria-hidden="true" href="#4字符串对象的操作">#</a></h3>
<p>string对象允许使用运算符进行操作，实现类似C风格字符串的处理。如复制（strcpy）、连接（strcat）、比较（strcmp）等。下面的这些运算和python非常类似了。</p>
<p><strong>字符串连接运算</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">str1=&#34;12&#34; , str2=&#34;AB&#34; , str3=&#34;CD&#34;;
str1 = str2 + str3; //str1结果为ABCD
str1 = str1 + &#34;PHP&#34;; //str1结果为12PHP
str1 += str3; //str1结果为12CD
</code></pre></div><p><strong>字符串关系运算</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">str1=&#34;ABC&#34; , str1=&#34;XYZ&#34;;
str1 &gt; str2; //结果为假
str1 == str2; //结果为假
str1 == &#34;ABC&#34;; //结果为真
</code></pre></div><p><strong>其他</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">str1=&#34;ABCDEFGHIJK&#34;;
//获取字符串的长度
n = str1.size(); //n为11
n = str1.length(); //n为11
//检查字符串是否为空字符串
b = str1.empty(); //b为假 
//得到子字符串
str2 = str1.substr(2,4); //从下标2开始的4个字符，str2为CDEF
//查找子字符串
n = str1.find(&#34;DEF&#34;,pos); //从pos开始查找字符串&#34;DEF&#34;在str1中的位置，n为3
//删除字符
str1.erase(3,5); //从下标3开始往后删5个字符，str1变为ABCIJK
//增加字符
str1.append(&#34;12345&#34;,1,3); //在str1末尾增加&#34;12345&#34;下标从1开始的3个字符，即&#34;234&#34;
//字符串替换和插入操作
str1.replace(p0,n0,S1,n); //删除从p0开始的n0个字符，然后在p0处插入字符串S1前n个字符
str1.replace(p0,n0,str2,pos,n); //删除从p0开始的n0个字符，然后在p0处插入字符串str2中pos开始的前n个字符
str1.insert(p0,S1,n); //在p0位置插入字符串S1前n个字符
str1.insert(p0,str2,pos,n); //在p0位置插入字符串str2中pos开始的前n个字符

</code></pre></div><p>字符串对象数组</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">string SY[5]={&#34;123&#34;,&#34;12&#34;,&#34;1234&#34;,&#34;1&#34;,&#34;12345&#34;};
//长度 3,2,4,1,5

</code></pre></div><h2 id="数组的应用">数组的应用<a hidden class="anchor" aria-hidden="true" href="#数组的应用">#</a></h2>
<h3 id="1用数组解决排序问题">（1）用数组解决排序问题<a hidden class="anchor" aria-hidden="true" href="#1用数组解决排序问题">#</a></h3>
<h4 id="冒泡排序">冒泡排序<a hidden class="anchor" aria-hidden="true" href="#冒泡排序">#</a></h4>
<p>冒泡排序法（bubble sort）的基本思想是通过相邻两个记录之间的比较和交换，使关键码较小的记录逐渐从底部移向顶部。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">#include &lt;iostream&gt;
  using namespace std;
  #define N 10 //数组元素个数
  int main()
  {
 int A[N], i, j, t; //注意数组下标从0开始
  for (i=0; i&lt;N; i++) cin&gt;&gt;A[i]; //输入N个数
  for(j=0 ; j&lt;N-1 ; j++) //冒泡排序法
  for(i=0 ; i&lt;N-1-j; i++) //一趟冒泡排序
  if(A[i] &gt; A[i+1]) //A[i]与A[i+1]比较 &lt;升序 &gt;降序
  t=A[i], A[i]=A[i+1], A[i+1]=t; //交换
  for (i=0; i&lt;N; i++) cout&lt;&lt;A[i]&lt;&lt;&#34; &#34;; //输出排序结果
  return 0;
  }
</code></pre></div><h4 id="选择排序法">选择排序法<a hidden class="anchor" aria-hidden="true" href="#选择排序法">#</a></h4>
<p>选择排序法（selection sort）的基本思想是第i趟选择排序通过n-i次关键码的比较，从n-i+1个记录中选出关键码最小的记录，并和第i个记录进行交换。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">#include &lt;iostream&gt;
 #include &lt;ctime&gt;
 using namespace std;
 void SelectionSort(int A[],int n) //选择排序 n为数组元素个数
 {
 int i,j,k,t;
 for(i=0; i&lt;n-1; i++) { //选择排序法
 k=i;
 for(j=i+1; j&lt;n; j++) //一趟选择排序
 if (A[j] &lt; A[k]) k=j; //&lt;升序 &gt;降序
 if(i!=k) t=A[i], A[i]=A[k], A[k]=t;
 }
}

 #define N 10
 int main()
 {
 int A[N],i;
 srand((unsigned int)time(0)); //设置随机数种子
 for(i=0; i&lt;N; i++) { //随机产生N个数
 A[i] = rand()%100;
 cout&lt;&lt;A[i]&lt;&lt;&#34; &#34;;
 }
 cout&lt;&lt;endl;
 SelectionSort(A,N);
 for(i=0; i&lt;N; i++) cout&lt;&lt;A[i]&lt;&lt;&#34; &#34;; //输出排序结果
 return 0;
 
</code></pre></div><h3 id="2用数组解决查找问题">（2）用数组解决查找问题<a hidden class="anchor" aria-hidden="true" href="#2用数组解决查找问题">#</a></h3>
<h4 id="顺序查找法">顺序查找法<a hidden class="anchor" aria-hidden="true" href="#顺序查找法">#</a></h4>
<p>就是这个比较，返回数组下标。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">#include &lt;iostream&gt; 
 using namespace std; 
 int Search(int A[],int n,int find) 
 { //顺序查找 n=序列元素个数 find=欲查找数据 
 int i; 
 for (i=0; i&lt;n ; i++) if (A[i]==find) return i; 
 return -1; //未找到 
 } 
 #define N 10 
  int main() 
 { 
 int A[N]={18,-3,-12,34,101,211,12,90,77,45}, i,find; 
 cin&gt;&gt;find; 
 i=Search(A,N,find); 
 if(i&gt;=0) cout&lt;&lt;&#34;A[&#34;&lt;&lt;i&lt;&lt;&#34;]=&#34;&lt;&lt;find&lt;&lt;endl; 
 else cout&lt;&lt;&#34;not found&#34;&lt;&lt;endl; 
 return 0; 
 }

</code></pre></div><h4 id="二分查找法">二分查找法<a hidden class="anchor" aria-hidden="true" href="#二分查找法">#</a></h4>
<p>先排序，后查找</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">#include &lt;iostream&gt;
 using namespace std;
 int BinarySearch(int A[],int n,int find)
 { //二分查找 n=序列元素个数 find=欲查找数据
 int low,upper,mid;
 low=0 , upper=n-1; //左右两部分
 while(low&lt;=upper) {
 mid = low + (upper-low)/2;
//不用(upper+low)/2，避免upper+low溢出
 if( A[mid] &lt; find) low = mid+1; //右半部分
 else if (A[mid] &gt; find) upper = mid - 1; //左半部分
 else return mid; //找到
 }
 return -1; //未找到
 }

 #define N 10
 int main()
 {
 int A[N]={8,24,30,47,62,68,83,90,92,95},i,find;
 cin&gt;&gt;find;
 i=BinarySearch(A,N,find);
 if(i &gt;= 0) cout&lt;&lt;&#34;A[&#34;&lt;&lt;i&lt;&lt;&#34;]=&#34;&lt;&lt;find&lt;&lt;endl;
 else cout&lt;&lt;&#34;not found&#34;&lt;&lt;endl;
 return 0;
 }

</code></pre></div><h2 id="指针的定义与使用">指针的定义与使用<a hidden class="anchor" aria-hidden="true" href="#指针的定义与使用">#</a></h2>
<h3 id="1指针的定义">（1）指针的定义<a hidden class="anchor" aria-hidden="true" href="#1指针的定义">#</a></h3>
<p>return语句只能返回一个值，即使有多个return也只还回第一个。加上数组也是只针对多个相同类型的数据，如果使用指针就可以想返回多少就返回多少。指针是两个函数进行数据交换必不可少的工具。</p>
<ul>
<li>指针记录某一变量的地址，指针本身也有地址，存于特定的区域</li>
<li><code>int *pa=pb</code>的写法正确，* 是间接寻址符或者叫取值符,可以理解为从pa指针取出的值是整形。但如果在声明中赋值也是可以的，因为pa在声明中也确实是指针，可以理解为把 *分配给了int，可以理解定义了一个指向int的指针，所以应该使用地址赋值，而不是数值赋值。</li>
<li>*pa单独出现代表了从pa指向的地址中取出来的值，前面要是加上int,char等声明，<code>*  pa</code>就只是代表pa指针了。</li>
<li><code>int *pa;pa=&amp;a</code>这样声明也可以</li>
<li>&amp; 是取地址运算符</li>
</ul>
<p>由于指针数据的特殊性，其初始化和赋值运算是有约束条件的，只能使用以下四种值：
（1）0值常量表达式</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">p1=null; //正确，指针允许0值常量表达式
p1=0; //正确，指针允许0值常量表达式
</code></pre></div><p>（2）相同指向类型的对象的地址。
（3）相同指向类型的另一个有效指针。例如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">int x, *px=&amp;x; //正确
int *py=px; //正确，相同指向类型的另一个指针
</code></pre></div><p>（4）对象存储空间后面下一个有效地址，如数组下一个元素的地址。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">int a[10], *px=&amp;a[2]; //正确
int *py=&amp;a[++i]; //正确，相同指向类型的另一个指针

</code></pre></div><h3 id="2指针的有效性和运算">（2）指针的有效性和运算<a hidden class="anchor" aria-hidden="true" href="#2指针的有效性和运算">#</a></h3>
<h4 id="无效的情况">无效的情况<a hidden class="anchor" aria-hidden="true" href="#无效的情况">#</a></h4>
<p>如果指针的值为0，称为0值指针，又称空指针（null pointer），空指针是无效的。</p>
<p>如果指针未经初始化，或者没有赋值，或者指针运算后指向未知对象，那么该指针是无效的。</p>
<p>一个指针曾经指向一个已知对象，在对象的内存空间释放后，虽然该指针仍是原来的内存地址，但指针所指已是未知对象，称为“迷途指针”</p>
<p>如果指针的位置停留在未知的位置，那么修改指针的值有可能造成重要的数据被修改。</p>
<h4 id="指针的运算">指针的运算<a hidden class="anchor" aria-hidden="true" href="#指针的运算">#</a></h4>
<p>（1）指针加减整数运算</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">int x[10], n=3 , *p=&amp;x[5];
p+1 //指向存储空间中x[5]后面的第1个int型存储单元
p+n //指向存储空间中x[5]后面的第n(3)个int型存储单元
p-1 //指向存储空间中x[5]前面的第1个int型存储单元
p-n //指向存储空间中x[5]前面的第n(3)个int型存储单元
</code></pre></div><p>（2）指针变量自增自减运算</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">int x[10], *p=&amp;x[5];
p++ //p指向x[5]后面的第1个int型内存单元
++p //p指向x[5]后面的第1个int型内存单元
p-- //p指向x[5]前面的第1个int型内存单元
--p //p指向x[5]前面的第1个int型内存单元

</code></pre></div><p>（3）两个指针相减运算</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">int x[5], *p1=&amp;x[0],
*p2=&amp;x[4];
int n;
n=p2-p1;//n的值为4

</code></pre></div><p>（4）指针的关系运算
即比较地址数据的大小，位置的前后。</p>
<h4 id="const的三种">const的三种<a hidden class="anchor" aria-hidden="true" href="#const的三种">#</a></h4>
<p>主要应用领域是让实参于函数中不可修改
<strong>单const</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">const int *p//代表不可以改变变量的值，但是可以改变指针指向，
//实际编程中，指向const的指针常用作函数的形参，以此确保传递给函数的实参对象在函数中不被修改。
int *const pc=&amp;a//代表地址不可以改了，但数值可以改
</code></pre></div><p><strong>双const</strong></p>
<p><code>const int *const cpc=&amp;b</code></p>
<h2 id="指针与数组">指针与数组<a hidden class="anchor" aria-hidden="true" href="#指针与数组">#</a></h2>
<h3 id="一维数组与指针">一维数组与指针<a hidden class="anchor" aria-hidden="true" href="#一维数组与指针">#</a></h3>
<p>数组名既代表数组本身，又代表整个数组的地址，还是是数组首元素的地址值.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">int a[10], b[10], c[10];
a=b; //错误，a是常量不能出现在左值的位置
c=a+b; //错误，a、b是地址值，不允许加法运算
a++; //错误，a是常量不能使用++运算
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">int a[];
int *p
p=a//数组的名称就代表了地址
pb=&amp;a[0]//a[0]就是变量了，要用取地址运算符
*(a+i)
*(p+i)

</code></pre></div><p>上述代码都是成立的</p>
<h3 id="区别">区别<a hidden class="anchor" aria-hidden="true" href="#区别">#</a></h3>
<ul>
<li>指针并不能被赋予常量的值<code>int *p,p=2//是错的</code></li>
<li>指针所存储的是变量的地址值，指针可以进行数加减，自增，自减；相减时值得注意，间隔几个元素取决他的类型。也可以进行关系运算</li>
<li>数组的数组名不可以进行这些操作</li>
</ul>
<p>（1）使用下标法访问数组元素，程序写法比较直观，能直接知道访问的是第几个元素。</p>
<p>（2）而使用指针引用法，指针变量直接指向元素，不必每次都重新计算地址，能提高运行效率。</p>
<p>（3）将自增和自减运算用于指针变量十分有效，可以使指针变量自动向前或向后指向数组的下一个或前一个元素。</p>
<p>指针写起来更简捷一些</p>
<h3 id="2指针与字符串">（2）指针与字符串<a hidden class="anchor" aria-hidden="true" href="#2指针与字符串">#</a></h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">char *p=&#34;C Language&#34;;
//或者
char *p;
p=&#34;C Language&#34;; 
</code></pre></div><p>访问</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">char str[]=&#34;C Language&#34;, *p=str; //p指向字符串的指针
cout&lt;&lt;p&lt;&lt;endl; //输出：C Language
cout&lt;&lt;p+2&lt;&lt;endl; //输出：Language
cout&lt;&lt;&amp;str[7]&lt;&lt;endl; //输出：age
</code></pre></div><p>遍历</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">char str[]=&#34;C Language&#34;
, *p=str; //p指向字符串的指针
while (*p!=&#39;\0&#39;) cout&lt;&lt;*p++;
</code></pre></div><h2 id="指针与函数">指针与函数<a hidden class="anchor" aria-hidden="true" href="#指针与函数">#</a></h2>
<h3 id="1指针作为函数的参数">（1）指针作为函数的参数<a hidden class="anchor" aria-hidden="true" href="#1指针作为函数的参数">#</a></h3>
<p>指针是函数参数传递的重要工具。比如swap交换函数要使用指针，直接使用变量会生成副本。通过将指针作为函数参数的方法，既可以返回多个运算结果，又避免了使用全局变量。</p>
<h3 id="2数组作为函数的参数">（2）数组作为函数的参数<a hidden class="anchor" aria-hidden="true" href="#2数组作为函数的参数">#</a></h3>
<p>数组同样是直接使用地址，不使用副本，直接修改原数组数据。将一个字符串传递到函数中，传递的是地址，则函数形参既可以用字符数组，又可以用指针变量，两种形式完全等价。在子函数中可以修改字符串的内容，主调函数得到的是变化后的字符串。</p>
<h3 id="3引用">（3）引用<a hidden class="anchor" aria-hidden="true" href="#3引用">#</a></h3>
<p>引用类型是结合了数组和指针的优点，不在C语言中，而属于C++的一个特性。</p>
<ul>
<li>引用类型自带const限定，引用一旦被初始化，就不能改变引用关系，不能再作为其他对象的引用。</li>
<li>初始化是必定要绑定赋值，不能为空</li>
<li>写法是<code>int x;&amp;r=x</code></li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">int x, &amp;r=x; //定义整型变量x,y
int *p1=&amp;x; //p1指向x
int *p2=&amp;r; //p2指向r，本质上指向x

</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback"> //程序① 传递对象本身 
 #include &lt;iostream&gt; 
 using namespace std; 
 //对象作为函数形参 
 void swap(int a,int b) 
 { int t; 
 t=a, a=b, b=t; 
 } 
 int main() 
 { int x=10, y=20; 
 swap(x,y); 12 cout&lt;&lt;x&lt;&lt;&#34;,&#34;&lt;&lt;y; 13 return 0; 14 }


//程序② 传递对象的指针 
 #include &lt;iostream&gt; 
 using namespace std; 
 //指针作为函数形参 
 void swap(int *a,int *b) 
 { int t; 
 t=*a, *a=*b, *b=t; 
 } 
 int main() 
 { int x=10, y=20; 
 swap(&amp;x,&amp;y); 
 cout&lt;&lt;x&lt;&lt;&#34;,&#34;&lt;&lt;y; 
 return 0; 
 }

 //程序③ 传递对象的引用 
 #include &lt;iostream&gt; 
 using namespace std; 
 //引用作为函数形参 
 void swap(int &amp;a,int &amp;b) 
 { int t; 
 t=a, a=b, b=t; 
 } 
 int main() 
 { int x=10, y=20; 
 swap(x,y); 
 cout&lt;&lt;x&lt;&lt;&#34;,&#34;&lt;&lt;y; 
 return 0; 
 
</code></pre></div><h3 id="4指向函数的指针">（4）指向函数的指针<a hidden class="anchor" aria-hidden="true" href="#4指向函数的指针">#</a></h3>
<p>函数代码在内存中也要占据一段存储空间（代码区内），这段存储空间的起始地址称为函数入口地址。C++规定函数入口地址为函数的指针，即函数名既代表函数，又是函数的指针（或地址）。</p>
<p>C++允许定义指向函数的指针变量，定义形式为：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">int (*p)(int a, int b); //定义函数指针变量

</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">int max(int a, int b); //max函数原型
int min(int a, int b); //min函数原型
int (*p)(int a, int b); //定义函数指针变量
p=max;
c=p(a,b); //等价于c=max(a,b);

</code></pre></div><p>变为动态方式调用。熟练掌握函数指针的应用，有利于程序的模块化设计，提高程序的可扩展性。</p>
<h2 id="动态分配内存">动态分配内存<a hidden class="anchor" aria-hidden="true" href="#动态分配内存">#</a></h2>
<h3 id="1new与delete运算符">（1）new与delete运算符<a hidden class="anchor" aria-hidden="true" href="#1new与delete运算符">#</a></h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">数据类型* 指针名称 = new 数据类型
int* p = new int
delete p;
</code></pre></div><p>可以拓展到结构体或类</p>
<p>动态分配是根据程序的需要适时分配，且分配的大小就是程序要求的大小。分配的空间可以根据程序的需要扩大或缩小；</p>
<p>new 动态分配</p>
<p>new [] 动态分配数组</p>
<p>delete 释放空间</p>
<p>delete [] 释放数组空间</p>
<h3 id="2动态内存的应用">（2）动态内存的应用<a hidden class="anchor" aria-hidden="true" href="#2动态内存的应用">#</a></h3>
<p>►（1）静态内存管理由编译器进行，而动态内存管理按程序员人为的指令进行。</p>
<p>►（2）动态内存分配和释放必须对应，即有分配就必须有释放，后果是随着程序运行多次，可以使用的内存空间越来越少.</p>
<p>► （3）动态分配内存的生命期由程序员决定，即从分配时开始，<strong>至释放时结束。特别地，动态分配内存的生命期允许跨多个函数。</strong></p>
<p>►（4）避免释放内存后出现“迷途指针”，应及时设置为空指针。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">#include &lt;iostream&gt;
 using namespace std;
 int *f1(int n) //分配n个整型内存，返回首地址
 { int *p, i;
 p = new int[n]; //分配
 for (i=0; i&lt;n; i++) p[i]=i; //赋初始值
 return p; //动态分配的指针返回是有意义的
 }
 void f2(int *p,int n) //输出动态内存中的n个数据
 { while (n--&gt;0) cout&lt;&lt;*p++&lt;&lt;&#34; &#34;; }
 void f3(int *p)
 { delete [] p; } //释放内存

 int main() 
  { 
  int *pi; 
  pi=f1(5); //分配 
  f2(pi,5); //输出 
  f3(pi); //释放 
  return 0; 
 } 
</code></pre></div><p>int *f1(int n)返回指针的函数</p>
<h3 id="3动态分配数组">（3）动态分配数组<a hidden class="anchor" aria-hidden="true" href="#3动态分配数组">#</a></h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">#include &lt;iostream&gt;
 using namespace std;
 double AVE(double *A,int N) //计算N*N二维数组元素的平均值
 { int i,j,sum=0;
 for(i=0;i&lt;N;i++)
 for(j=0;j&lt;N;j++) sum=sum+*(A+i*N+j);
 return sum/(N*N);
 }
  int main()
 { int i,j,n=4; cin&gt;&gt;n;
 double *A=new double[n*n]; //分配“数组”A[n][n]
 for (i=0;i&lt;n;i++)
 for (j=0;j&lt;n;j++) cin&gt;&gt;*(A+i*n+j); //输入数据到A[i][j]
 cout&lt;&lt;&#34;detA=&#34;&lt;&lt;AVE(A,n)&lt;&lt;endl;
 delete [] A; //释放“数组”
 return 0;
 }

</code></pre></div><h3 id="4动态分配字符串">（4）动态分配字符串<a hidden class="anchor" aria-hidden="true" href="#4动态分配字符串">#</a></h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">char *p=new char[1000]; //分配字符串空间
cin&gt;&gt;p; //输入字符串
cout&lt;&lt;p; //输出字符串
delete [] p; //释放字符串空间

</code></pre></div><h2 id="结构体">结构体<a hidden class="anchor" aria-hidden="true" href="#结构体">#</a></h2>
<h3 id="基本知识">基本知识<a hidden class="anchor" aria-hidden="true" href="#基本知识">#</a></h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">#include&lt;iostream&gt;
using namespace std;
int main() 
{
	
 cout&lt;&lt;&#34;hello\n&#34;;
 struct DATA{
 	int year;
 	int mouth;
 	int day;
 };
 struct staff{
 	int no;
 	char name[21];
 	char sex;
 	DATA birthday;
 	double salary;
 	
 };
 
staff s1={1001,&#34;archer&#34;,&#39;m&#39;,{1980,1,1},2900.0};//s1是一个结构体对象，
cout&lt;&lt;s1.birthday.year;//成员引用使用.
//成员只可以逐个输入和输出
		
}
</code></pre></div><ul>
<li>结构体声明一般放在开头，也可以放在main的外面。大概等价于数据类型的定义和声明，也不会在声明中分配存储空间，实例化才会分配存储空间，空间是连续按顺序的。</li>
<li>可以放在函数内部，但此时这个声明是局部的，而不是全局的。</li>
<li>结构体对象可以赋值，但不可以算数和比较运算。</li>
</ul>
<h3 id="结构体和指针的关系">结构体和指针的关系<a hidden class="anchor" aria-hidden="true" href="#结构体和指针的关系">#</a></h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">
#include&lt;iostream&gt;
using namespace std;
int main() 
{
	
 cout&lt;&lt;&#34;hello\n&#34;;
 struct DATA{
 	int year;
 	int mouth;
 	int day;
 };
 DATA d={1980,1,1};//一个奇怪的devc++规则，即用即声明，但反正也不麻烦
 //更新，可以在结构体后声明成员，但前提是要把结构体的创建写到main函数外部
 struct staff{
 	int no;
 	char name[21];
 	char sex;
 	DATA *pbirthday;
 	double salary;
 	
 };
 staff *p;//指针可以提前声明然后赋值，这里声明s1会报错

 
staff s1={1001,&#34;archer&#34;,&#39;m&#39;,&amp;d,2900.0};

p=&amp;s1;//赋地址值，没有*，下方编译成功
cout&lt;&lt;p-&gt;sex&lt;&lt;endl;//这是字母l不是一数字1，/用于除法和注释 
p-&gt;pbirthday-&gt;year=2008;
p-&gt;sex=&#39;w&#39;;
cout&lt;&lt;s1.sex&lt;&lt;endl;
	
}
</code></pre></div><h3 id="结构体和数组的关系">结构体和数组的关系<a hidden class="anchor" aria-hidden="true" href="#结构体和数组的关系">#</a></h3>
<p>如同声明int,char数组，可以用结构体进行声明。用这个方法可以表示几何的点。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">
#include&lt;iostream&gt;
using namespace std;

 struct staff{
 	int no;
 	char name[21];
 	double salary; 
 }a[3],t;
int main() 
{
 cout&lt;&lt;&#34;hello\n&#34;;
int i,j;

for (i=0;i&lt;3;i++)
	cin&gt;&gt;a[i].name &gt;&gt;a[i].no &gt;&gt;a[i].salary;
for (i=0;i&lt;3;i++)
	cout&lt;&lt;a[i].name &lt;&lt;a[i].no &lt;&lt;a[i].salary&lt;&lt;endl;
 };
</code></pre></div><h3 id="结构体和函数的关系">结构体和函数的关系<a hidden class="anchor" aria-hidden="true" href="#结构体和函数的关系">#</a></h3>
<p>就像传int类型等，直接传递进去，在函数内部进行各种操作。
对结构体数组进行传递，是对首地址进行传入。</p>
<h2 id="共用体">共用体<a hidden class="anchor" aria-hidden="true" href="#共用体">#</a></h2>
<ul>
<li>对于实体对象，分配的存储空间是成员内存的最大值。</li>
<li>定义和结构体的定义和引用相似。使用union定义，</li>
</ul>
<ol>
<li>修改一个成员的值会让其他值都改变</li>
<li>成员的首地址相同，所有成员的值相同，不同成员所用到的内存长度有差异</li>
</ol>
<h2 id="枚举类型enum">枚举类型(enum)<a hidden class="anchor" aria-hidden="true" href="#枚举类型enum">#</a></h2>
<ul>
<li>定义都是相似的</li>
<li>必须是指定值</li>
<li>枚举常量是右值不是左值</li>
</ul>
<p>没有给定值时从0往后排</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">enum COLORS {RED=10,GREEN=8,BLUE,BLACK,WHITE};
//RED为10、GREEN为8、BLUE为9、BLACK为10、WHITE为11。
RED=10; //错误，RED不是左值，不能被赋值
GREEN++; //错误，GREEN不是左值，不能自增自减
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">enum DIRECTION {LEFT,UP,RIGHT,DOWN,BEFORE,BACK} dir=LEFT;
</code></pre></div><h2 id="typedef">typedef<a hidden class="anchor" aria-hidden="true" href="#typedef">#</a></h2>
<p>就是把一个结构的名字进行更改</p>
<h2 id="自定义数据类型的应用链表">自定义数据类型的应用——链表<a hidden class="anchor" aria-hidden="true" href="#自定义数据类型的应用链表">#</a></h2>
<h3 id="基础知识">基础知识<a hidden class="anchor" aria-hidden="true" href="#基础知识">#</a></h3>
<p>链表主要用于两个目的：一是建立不定长度的数组。二是链表可以
在不重新安排整个存储结构的情况下，方便且迅速地插入和删除数
据元素。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">
struct NODE { //结点数据类型
 ElemType data; //数据域
 NODE *link; //指针域
};

</code></pre></div><p>首先设计一种称为结点（node）的数据类型：
这个结构体类型中，data成员表示数据域，代表结点的数据信息。</p>
<p>ElemType可以是简单的内置数据类型，也可以是复杂的数据类型，
如</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">typedef struct tagElemType { //复杂的数据元素类型
 ...... //任意数目、任意组合、任意类型的数据成员
} ElemType;
</code></pre></div><p>数据域是链表中的信息对象（元素），实际应用中结合具体要求设
计其数据类型。为方便介绍，将ElemType简单设定为int型，即</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">typedef int ElemType; //简单的数据元素类型
</code></pre></div><p>link成员表示指针域，存放另一个结点的地址，是链表中的组织者。
假定有一个NODE类型的对象指针L，将一个新结点的地址赋给L的
link成员，则L可以通过它的link成员“链接”到新结点上，重复这
个过程可以得到链表结构。</p>
<h3 id="链表的类型">链表的类型<a hidden class="anchor" aria-hidden="true" href="#链表的类型">#</a></h3>
<p>struct LNode { //单链表结点类型
ElemType data; //数据域</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">LNode *next; //指针域：指向直接后继结点
};

typedef LNode*   LinkList; //LNode为单链表结构体类型，
</code></pre></div><p>LinkList为单链表指针类型</p>
<p>此外还有双链表和循环链表</p>
<h3 id="创建单链表">创建单链表<a hidden class="anchor" aria-hidden="true" href="#创建单链表">#</a></h3>
<p>创建链表常用两种方法：头插法和尾插法。</p>
<h4 id="头插法">头插法<a hidden class="anchor" aria-hidden="true" href="#头插法">#</a></h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">#include &lt;iostream&gt;
 using namespace std;
 typedef int ElemType; //简单的数据元素类型
 struct LNode { //单链表结点类型
 ElemType data; //数据域
  LNode *next; //指针域：指向直接后继结点
 };
 typedef LNode* LinkList; //LNode为单链表结构体类型，LinkList为单链表指针类型
 void input(ElemType *ep) //实现数据域元素输入的定制函数
 { //在函数中可以写更加复杂、任意形式、任意数目的输入
 cin&gt;&gt;*ep;
 }
 void CreateLinkF(LinkList *L,int n,void(*input)(ElemType*))
 { //头插法创建单链表，调用input输入函数输入数据
 LinkList s;
 *L=new LNode;//创建头结点
 (*L)-&gt;next=NULL; //初始时为空表
 for (; n&gt;0; n--) { //创建n个结点链表
 s=new LNode; //创建新结点
 input(&amp;s-&gt;data); //调用input输入数据域
 s-&gt;next=(*L)-&gt;next; //将s增加到开始结点之前
 (*L)-&gt;next=s; //头结点之后
 }
 }
 int main()
 {
 LinkList L; int n; cin&gt;&gt;n;
 CreateLinkF(&amp;L,n,input);
}


</code></pre></div><h4 id="尾插法">尾插法<a hidden class="anchor" aria-hidden="true" href="#尾插法">#</a></h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">#include &lt;iostream&gt;
 using namespace std;
 typedef int ElemType; //简单的数据元素类型
 struct LNode { //单链表结点类型
 ElemType data; //数据域
 LNode *next; //指针域：指向直接后继结点
 };
 typedef LNode* LinkList; //LNode为单链表结构体类型，LinkList为单链表指针类型
 void input(ElemType *ep) //实现数据域元素输入的定制函数
 { //在函数中可以写更加复杂、任意形式、任意数目的输入
 cin&gt;&gt;*ep;
 }

 void CreateLinkR(LinkList *L,int n,void(*input)(ElemType*))
 { //尾插法创建单链表，调用input输入函数输入数据
 LinkList p,s;
 p=*L=new LNode; //创建头结点
 for (; n&gt;0; n--) { //创建n个结点链表
 s=new LNode; //创建新结点
 input(&amp;s-&gt;data); //调用input输入数据域
 p-&gt;next=s, p=s; //将s插入到当前链表末尾
 }
 p-&gt;next=NULL; //尾结点
 }
 int main()
 {
 LinkList L; int n; cin&gt;&gt;n;
 CreateLinkR(&amp;L,n,input);
 }

</code></pre></div><h4 id="链表的撤销">链表的撤销<a hidden class="anchor" aria-hidden="true" href="#链表的撤销">#</a></h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">void DestroyList(LinkList *L) //销毁单链表L
 {
 
 LinkList q,p=*L; //p指向头结点
 while(p!=NULL) { //若不是链尾继续
 q=p-&gt;next; //指向直接后继结点
 delete p; //释放结点存储空间
 p=q; //直接后继结点
 }
 
 *L=NULL; //置为空表 
</code></pre></div><h3 id="链表的运算">链表的运算<a hidden class="anchor" aria-hidden="true" href="#链表的运算">#</a></h3>
<h4 id="链表的遍历">链表的遍历<a hidden class="anchor" aria-hidden="true" href="#链表的遍历">#</a></h4>
<p>即p=p-&gt;next</p>
<h4 id="查找节点">查找节点<a hidden class="anchor" aria-hidden="true" href="#查找节点">#</a></h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">int compare(ElemType *ep1,ElemType *ep2)
 //实现两个数据元素关系比较的定制函数
 {//在函数中对数据元素进行定制的关系比较，如相等，大于或小于
 if (*ep1==*ep2) return 1; //满足相等关系返回真（1）
  return 0; //不满足关系返回假（0）

int LocateElem(LinkList L,ElemType e,
 int(*compare)(ElemType*,ElemType*))
 {//返回L中第1个与e满足关系compare()的元素的位序
 int i=0;
 LinkList p=L-&gt;next; //p指向开始结点
 while(p!=NULL) { //若不是链尾继续
 i++; //记录结点的位序
 if(compare(&amp;(p-&gt;data),&amp;e)) return i;
 p=p-&gt;next; //指向直接后继结点
 }
 return 0; //关系不存在返回0
</code></pre></div><h4 id="插入节点">插入节点<a hidden class="anchor" aria-hidden="true" href="#插入节点">#</a></h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">int ListInsert(LinkList *L,int i,ElemType e)
 { //在第i个位置之前插入元素e
 LinkList s,p=*L; //p指向头结点
 while(p!=NULL &amp;&amp; i&gt;1) { //寻找第i-1个结点
 p=p-&gt;next; //p指向直接后继结点
 i--;
 }
 if(p==NULL||i&lt;1) return 0; //i值不合法返回假（0）
 s=new LNode; //创建新结点
 s-&gt;data=e; //插入L中
 s-&gt;next=p-&gt;next, p-&gt;next=s; //结点插入算法
 return 1; //操作成功返回真（1）
 
</code></pre></div><h4 id="删除节点">删除节点<a hidden class="anchor" aria-hidden="true" href="#删除节点">#</a></h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">int ListDelete(LinkList *L,int i,ElemType *ep)
 { //删除第i个结点,并由*ep返回其值
 LinkList p=NULL,q=*L; //q指向头结点
 while(q!=NULL &amp;&amp; i&gt;=1) { //直到第i个结点
 p=q; //p是q的前驱
 q=q-&gt;next; //q指向直接后继结点
 i--;
  }
 if(p==NULL||q==NULL) return 0;//i值不合法返回假（0）
 p-&gt;next=q-&gt;next; //结点删除算法
 if(ep!=NULL) *ep=q-&gt;data; //删除结点由*ep返回其值
 delete q; //释放结点
 return 1; //操作成功返回真（1）
 
</code></pre></div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="next" href="https://tassel234.github.io/posts/note/%E5%9B%BE%E8%AE%BA%E5%85%A5%E9%97%A8_2/">
    <span class="title">Next »</span>
    <br>
    <span>图论入门_2</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share C&#43;&#43;入门学习笔记-2(数组，指针，结构体) on twitter"
        href="https://twitter.com/intent/tweet/?text=C%2b%2b%e5%85%a5%e9%97%a8%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0-2%28%e6%95%b0%e7%bb%84%ef%bc%8c%e6%8c%87%e9%92%88%ef%bc%8c%e7%bb%93%e6%9e%84%e4%bd%93%29&amp;url=https%3a%2f%2ftassel234.github.io%2fposts%2fnote%2f%25E6%2595%25B0%25E7%25BB%2584%25E6%258C%2587%25E9%2592%2588%25E7%25BB%2593%25E6%259E%2584%25E4%25BD%2593%2f&amp;hashtags=">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share C&#43;&#43;入门学习笔记-2(数组，指针，结构体) on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2ftassel234.github.io%2fposts%2fnote%2f%25E6%2595%25B0%25E7%25BB%2584%25E6%258C%2587%25E9%2592%2588%25E7%25BB%2593%25E6%259E%2584%25E4%25BD%2593%2f&amp;title=C%2b%2b%e5%85%a5%e9%97%a8%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0-2%28%e6%95%b0%e7%bb%84%ef%bc%8c%e6%8c%87%e9%92%88%ef%bc%8c%e7%bb%93%e6%9e%84%e4%bd%93%29&amp;summary=C%2b%2b%e5%85%a5%e9%97%a8%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0-2%28%e6%95%b0%e7%bb%84%ef%bc%8c%e6%8c%87%e9%92%88%ef%bc%8c%e7%bb%93%e6%9e%84%e4%bd%93%29&amp;source=https%3a%2f%2ftassel234.github.io%2fposts%2fnote%2f%25E6%2595%25B0%25E7%25BB%2584%25E6%258C%2587%25E9%2592%2588%25E7%25BB%2593%25E6%259E%2584%25E4%25BD%2593%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share C&#43;&#43;入门学习笔记-2(数组，指针，结构体) on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2ftassel234.github.io%2fposts%2fnote%2f%25E6%2595%25B0%25E7%25BB%2584%25E6%258C%2587%25E9%2592%2588%25E7%25BB%2593%25E6%259E%2584%25E4%25BD%2593%2f&title=C%2b%2b%e5%85%a5%e9%97%a8%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0-2%28%e6%95%b0%e7%bb%84%ef%bc%8c%e6%8c%87%e9%92%88%ef%bc%8c%e7%bb%93%e6%9e%84%e4%bd%93%29">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share C&#43;&#43;入门学习笔记-2(数组，指针，结构体) on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2ftassel234.github.io%2fposts%2fnote%2f%25E6%2595%25B0%25E7%25BB%2584%25E6%258C%2587%25E9%2592%2588%25E7%25BB%2593%25E6%259E%2584%25E4%25BD%2593%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share C&#43;&#43;入门学习笔记-2(数组，指针，结构体) on whatsapp"
        href="https://api.whatsapp.com/send?text=C%2b%2b%e5%85%a5%e9%97%a8%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0-2%28%e6%95%b0%e7%bb%84%ef%bc%8c%e6%8c%87%e9%92%88%ef%bc%8c%e7%bb%93%e6%9e%84%e4%bd%93%29%20-%20https%3a%2f%2ftassel234.github.io%2fposts%2fnote%2f%25E6%2595%25B0%25E7%25BB%2584%25E6%258C%2587%25E9%2592%2588%25E7%25BB%2593%25E6%259E%2584%25E4%25BD%2593%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share C&#43;&#43;入门学习笔记-2(数组，指针，结构体) on telegram"
        href="https://telegram.me/share/url?text=C%2b%2b%e5%85%a5%e9%97%a8%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0-2%28%e6%95%b0%e7%bb%84%ef%bc%8c%e6%8c%87%e9%92%88%ef%bc%8c%e7%bb%93%e6%9e%84%e4%bd%93%29&amp;url=https%3a%2f%2ftassel234.github.io%2fposts%2fnote%2f%25E6%2595%25B0%25E7%25BB%2584%25E6%258C%2587%25E9%2592%2588%25E7%25BB%2593%25E6%259E%2584%25E4%25BD%2593%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://tassel234.github.io/">hrkr&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
